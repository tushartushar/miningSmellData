Implementation smell,Namespace,Class,File,Method,Description
Long Method,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The method has 173 lines of code.
Long Method,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The method has 283 lines of code.
Long Method,Substrate.Core,BlockFluid,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,TileOutflow,The method has 107 lines of code.
Long Method,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateFast,The method has 101 lines of code.
Long Method,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateSlow,The method has 127 lines of code.
Long Method,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The method has 155 lines of code.
Long Method,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The method has 448 lines of code.
Long Method,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The method has 307 lines of code.
Long Method,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The method has 206 lines of code.
Long Method,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The method has 159 lines of code.
Long Method,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The method has 212 lines of code.
Long Method,Ionic.Zlib,ParallelDeflateOutputStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ParallelDeflateOutputStream.cs,_PerpetualWriterMethod,The method has 140 lines of code.
Complex Method,Substrate,AlphaChunk,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaChunk.cs,SetLocation,Cyclomatic complexity of the method is 11
Complex Method,Substrate,AnvilChunk,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilChunk.cs,SetLocation,Cyclomatic complexity of the method is 11
Complex Method,Substrate,AnvilChunk,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilChunk.cs,LoadTree,Cyclomatic complexity of the method is 13
Complex Method,Substrate,AlphaBlockCollection,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaBlockCollection.cs,SetID,Cyclomatic complexity of the method is 14
Complex Method,Substrate,Level,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Level.cs,LoadTree,Cyclomatic complexity of the method is 19
Complex Method,Substrate,Level,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Level.cs,BuildTree,Cyclomatic complexity of the method is 18
Complex Method,Substrate,Player,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Player.cs,LoadTree,Cyclomatic complexity of the method is 21
Complex Method,Substrate,Player,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Player.cs,BuildTree,Cyclomatic complexity of the method is 13
Complex Method,Substrate,RegionChunkManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\RegionChunkManager.cs,RelightDirtyChunks,Cyclomatic complexity of the method is 9
Complex Method,Substrate.Core,BlockFluid,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,TileOutflow,Cyclomatic complexity of the method is 20
Complex Method,Substrate.Core,BlockFluid,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,TileInflow,Cyclomatic complexity of the method is 10
Complex Method,Substrate.Core,BlockFluid,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoWater,Cyclomatic complexity of the method is 15
Complex Method,Substrate.Core,BlockFluid,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoLava,Cyclomatic complexity of the method is 14
Complex Method,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockLight,Cyclomatic complexity of the method is 13
Complex Method,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockSkyLight,Cyclomatic complexity of the method is 13
Complex Method,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,UpdateBlockSkyLight,Cyclomatic complexity of the method is 8
Complex Method,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,SpreadBlockLight,Cyclomatic complexity of the method is 11
Complex Method,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,SpreadSkyLight,Cyclomatic complexity of the method is 23
Complex Method,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalChunk,Cyclomatic complexity of the method is 10
Complex Method,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,ReadFile,Cyclomatic complexity of the method is 16
Complex Method,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,GetChunkDataInputStream,Cyclomatic complexity of the method is 9
Complex Method,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Write,Cyclomatic complexity of the method is 14
Complex Method,Substrate.ImportExport,Schematic,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ImportExport\Schematic.cs,Import,Cyclomatic complexity of the method is 9
Complex Method,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadValue,Cyclomatic complexity of the method is 14
Complex Method,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteValue,Cyclomatic complexity of the method is 14
Complex Method,Substrate.Nbt,NbtVerifier,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtVerifier.cs,Verify,Cyclomatic complexity of the method is 10
Complex Method,Substrate.Nbt,NbtVerifier,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtVerifier.cs,VerifyList,Cyclomatic complexity of the method is 9
Complex Method,Substrate.Nbt,NbtVerifier,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtVerifier.cs,VerifyCompound,Cyclomatic complexity of the method is 8
Complex Method,Substrate.Nbt,JSONSerializer,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\JSONSerializer.cs,SerializeCompound,Cyclomatic complexity of the method is 8
Complex Method,Substrate.Nbt,JSONSerializer,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\JSONSerializer.cs,SerializeList,Cyclomatic complexity of the method is 9
Complex Method,Substrate.Nbt,JSONSerializer,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\JSONSerializer.cs,SerializeScaler,Cyclomatic complexity of the method is 8
Complex Method,Substrate.TileEntities,TileEntityMobSpawner,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\TileEntities\TileEntityMobSpawner.cs,LoadTree,Cyclomatic complexity of the method is 14
Complex Method,Substrate.TileEntities,TileEntityMobSpawner,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\TileEntities\TileEntityMobSpawner.cs,BuildTree,Cyclomatic complexity of the method is 13
Complex Method,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,Cyclomatic complexity of the method is 10
Complex Method,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,Cyclomatic complexity of the method is 10
Complex Method,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateNone,Cyclomatic complexity of the method is 11
Complex Method,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateFast,Cyclomatic complexity of the method is 14
Complex Method,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateSlow,Cyclomatic complexity of the method is 18
Complex Method,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,Cyclomatic complexity of the method is 22
Complex Method,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,Cyclomatic complexity of the method is 52
Complex Method,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Flush,Cyclomatic complexity of the method is 10
Complex Method,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,Cyclomatic complexity of the method is 43
Complex Method,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,Cyclomatic complexity of the method is 35
Complex Method,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,Cyclomatic complexity of the method is 26
Complex Method,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_dynamic,Cyclomatic complexity of the method is 8
Complex Method,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,Cyclomatic complexity of the method is 12
Complex Method,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,finish,Cyclomatic complexity of the method is 13
Complex Method,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,Cyclomatic complexity of the method is 9
Complex Method,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,Read,Cyclomatic complexity of the method is 18
Long Parameter List,Substrate,AlphaBlockCollection,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaBlockCollection.cs,AlphaBlockCollection,The method has 6 parameters. Parameters: blocks' data' blockLight' skyLight' heightMap' tileEntities
Long Parameter List,Substrate,AlphaBlockCollection,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaBlockCollection.cs,AlphaBlockCollection,The method has 7 parameters. Parameters: blocks' data' blockLight' skyLight' heightMap' tileEntities' tileTicks
Long Parameter List,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,SpreadSkyLight,The method has 5 parameters. Parameters: chunkMap' heightMap' lx' ly' lz
Long Parameter List,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,TestBlockLight,The method has 7 parameters. Parameters: chunk' x1' y1' z1' x2' y2' z2
Long Parameter List,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,TestSkyLight,The method has 7 parameters. Parameters: chunk' x1' y1' z1' x2' y2' z2
Long Parameter List,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Debug,The method has 5 parameters. Parameters: mode' x' z' count' str
Long Parameter List,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Write,The method has 5 parameters. Parameters: x' z' data' length' timestamp
Long Parameter List,Substrate.Nbt,SchemaNodeList,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\SchemaNodeList.cs,SchemaNodeList,The method has 5 parameters. Parameters: name' type' length' subschema' options
Long Parameter List,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Initialize,The method has 5 parameters. Parameters: codec' level' windowBits' memLevel' strategy
Long Parameter List,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The method has 5 parameters. Parameters: goodLength' maxLazy' niceLength' maxChainLength' flavor
Long Parameter List,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Init,The method has 6 parameters. Parameters: bl' bd' tl' tl_index' td' td_index
Long Parameter List,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The method has 8 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' s' z
Long Parameter List,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The method has 11 parameters. Parameters: b' bindex' n' s' d' e' t' m' hp' hn' v
Long Parameter List,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_bits,The method has 5 parameters. Parameters: c' bb' tb' hp' z
Long Parameter List,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_dynamic,The method has 9 parameters. Parameters: nl' nd' c' bl' bd' tl' td' hp' z
Long Parameter List,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_fixed,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,Ionic.Zlib,StaticTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Zlib.cs,StaticTree,The method has 5 parameters. Parameters: treeCodes' extraBits' extraBase' elems' maxLength
Long Parameter List,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,ZlibBaseStream,The method has 5 parameters. Parameters: stream' compressionMode' level' flavor' leaveOpen
Long Statement,Substrate,AlphaChunk,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaChunk.cs,LoadTree,The length of the statement  "            _blockManager = new AlphaBlockCollection(_blocks' _data' _blockLight' _skyLight' _heightMap' _tileEntities' _tileTicks); " is 120.
Long Statement,Substrate,AnvilChunk,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilChunk.cs,LoadTree,The length of the statement  "            _blockManager = new AlphaBlockCollection(_blocks' _data' _blockLight' _skyLight' _heightMap' _tileEntities' _tileTicks); " is 120.
Long Statement,Substrate,AlphaBlock,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaBlock.cs,CreateTileEntity,The length of the statement  "                throw new UnknownTileEntityException("The TileEntity type '" + info.TileEntityName + "' has not been registered with the TileEntityFactory."); " is 142.
Long Statement,Substrate,AlphaBlockCollection,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaBlockCollection.cs,SetID,The length of the statement  "                if (info1.Luminance != info2.Luminance || info1.Opacity != info2.Opacity || info1.TransmitsLight != info2.TransmitsLight) { " is 123.
Long Statement,Substrate.Core,BlockTileEntities,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockTileEntities.cs,CreateTileEntity,The length of the statement  "                throw new UnknownTileEntityException("The TileEntity type '" + info.TileEntityName + "' has not been registered with the TileEntityFactory."); " is 142.
Long Statement,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,BlockToColorIndex,The length of the statement  "                throw new ArgumentOutOfRangeException("level"' level' "Argument 'level' must be in range [0' " + (_groupSize - 1) + "]"); " is 121.
Long Statement,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,GroupToColorIndex,The length of the statement  "                throw new ArgumentOutOfRangeException("level"' level' "Argument 'level' must be in range [0' " + (_groupSize - 1) + "]"); " is 121.
Long Statement,Substrate.Nbt,VerifierLogger,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\VerifierLogger.cs,InvalidTagTypeHandler,The length of the statement  "            Console.WriteLine("Invalid Tag Type Error: '{0}' has type '{1}'' expected '{2}'"' e.TagName' e.Tag.GetTagType()' e.Schema.ToString()); " is 134.
Long Statement,Substrate.Nbt,VerifierLogger,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\VerifierLogger.cs,InvalidTagValueHandler,The length of the statement  "            Console.WriteLine("Invalid Tag Value Error: '{0}' of type '{1}' is set to invalid value '{2}'"' e.TagName' e.Tag.GetTagType()' e.Tag.ToString()); " is 145.
Long Statement,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,finish,The length of the statement  "                            throw new ZlibException(String.Format("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected)); " is 133.
Long Statement,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,finish,The length of the statement  "                            throw new ZlibException(String.Format("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected)); " is 126.
Complex Conditional,Substrate.Core,CompositeDataArray3,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\CompositeDataArray.cs,CompositeDataArray3,The conditional expression  "sections[i].Length != sections[0].Length                      || sections[i].XDim != sections[0].XDim                      || sections[i].YDim != sections[0].YDim                      || sections[i].ZDim != sections[0].ZDim"  is complex.
Complex Conditional,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,QueueRelight,The conditional expression  "key.x < -15 || key.x >= 31 || key.z < -15 || key.z >= 31"  is complex.
Complex Conditional,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateSlow,The conditional expression  "match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered ||                                                (match_length == MIN_MATCH && strstart - match_start > 4096))"  is complex.
Complex Conditional,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,longest_match,The conditional expression  "window[match + best_len] != scan_end ||                      window[match + best_len - 1] != scan_end1 ||                      window[match] != window[scan] ||                      window[++match] != window[scan + 1]"  is complex.
Complex Conditional,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The conditional expression  "_codec.OutputBuffer == null ||                  (_codec.InputBuffer == null && _codec.AvailableBytesIn != 0) ||                  (status == FINISH_STATE && flush != FlushType.Finish)"  is complex.
Complex Conditional,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The conditional expression  "_codec.AvailableBytesIn != 0 || lookahead != 0 || (flush != FlushType.None && status != FINISH_STATE)"  is complex.
Complex Conditional,Ionic.Zlib,ZlibCodec,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibCodec.cs,flush_pending,The conditional expression  "dstate.pending.Length <= dstate.nextPending ||                  OutputBuffer.Length <= NextOut ||                  dstate.pending.Length < (dstate.nextPending + len) ||                  OutputBuffer.Length < (NextOut + len)"  is complex.
Virtual Method Call from Constructor,Substrate,AlphaBlock,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaBlock.cs,AlphaBlock,The constructor "AlphaBlock" calls a virtual method "Copy".
Virtual Method Call from Constructor,Substrate,Level,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Level.cs,Level,The constructor "Level" calls a virtual method "Copy".
Virtual Method Call from Constructor,Substrate.Core,Region,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Region.cs,Region,The constructor "Region" calls a virtual method "GetFilePath".
Virtual Method Call from Constructor,Substrate.Core,Region,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Region.cs,Region,The constructor "Region" calls a virtual method "ParseFileNameCore".
Virtual Method Call from Constructor,Substrate.Core,Enumerator,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionManager.cs,Enumerator,The constructor "Enumerator" calls a virtual method "GetRegion".
Magic Number,Substrate,AlphaChunk,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaChunk.cs,Timestamp,The following statement contains a magic number: DateTime epoch = new DateTime(1970' 1' 1' 0' 0' 0' 0);
Magic Number,Substrate,AlphaChunk,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaChunk.cs,Timestamp,The following statement contains a magic number: return (int)((DateTime.UtcNow - epoch).Ticks / (10000L * 1000L));
Magic Number,Substrate,AlphaChunk,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaChunk.cs,Timestamp,The following statement contains a magic number: return (int)((DateTime.UtcNow - epoch).Ticks / (10000L * 1000L));
Magic Number,Substrate,AnvilChunk,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilChunk.cs,AnvilChunk,The following statement contains a magic number: _sections = new AnvilSection[16];
Magic Number,Substrate,AnvilChunk,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilChunk.cs,BuildNBTTree,The following statement contains a magic number: _sections = new AnvilSection[16];
Magic Number,Substrate,AnvilChunk,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilChunk.cs,Timestamp,The following statement contains a magic number: DateTime epoch = new DateTime(1970' 1' 1' 0' 0' 0' 0);
Magic Number,Substrate,AnvilChunk,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilChunk.cs,Timestamp,The following statement contains a magic number: return (int)((DateTime.UtcNow - epoch).Ticks / (10000L * 1000L));
Magic Number,Substrate,AnvilChunk,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilChunk.cs,Timestamp,The following statement contains a magic number: return (int)((DateTime.UtcNow - epoch).Ticks / (10000L * 1000L));
Magic Number,Substrate,AnvilRegion,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilRegion.cs,ParseFileName,The following statement contains a magic number: z = Convert.ToInt32(match.Groups[2].Value);
Magic Number,Substrate,AnvilSection,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilSection.cs,LoadTree,The following statement contains a magic number: ctree["Add"] = new TagNodeByteArray(new byte[2048]);
Magic Number,Substrate,AnvilWorld,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilWorld.cs,OnResolveOpen,The following statement contains a magic number: world.Level.Version < 19133
Magic Number,Substrate,BetaRegion,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BetaRegion.cs,ParseFileName,The following statement contains a magic number: z = Convert.ToInt32(match.Groups[2].Value);
Magic Number,Substrate,BetaWorld,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BetaWorld.cs,CreateWorld,The following statement contains a magic number: _level.Version = 19132;
Magic Number,Substrate,BetaWorld,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BetaWorld.cs,OnResolveOpen,The following statement contains a magic number: world.Level.Version != 19132
Magic Number,Substrate,EnchantmentInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Protection = new EnchantmentInfo(EnchantmentType.PROTECTION' "Protection").SetMaxLevel(4);
Magic Number,Substrate,EnchantmentInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: FireProtection = new EnchantmentInfo(EnchantmentType.FIRE_PROTECTION' "Fire Protection").SetMaxLevel(4);
Magic Number,Substrate,EnchantmentInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: FeatherFalling = new EnchantmentInfo(EnchantmentType.FEATHER_FALLING' "Feather Falling").SetMaxLevel(4);
Magic Number,Substrate,EnchantmentInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: BlastProtection = new EnchantmentInfo(EnchantmentType.BLAST_PROTECTION' "Blast Protection").SetMaxLevel(4);
Magic Number,Substrate,EnchantmentInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: ProjectileProtection = new EnchantmentInfo(EnchantmentType.PROJECTILE_PROTECTION' "Projectile Protection").SetMaxLevel(4);
Magic Number,Substrate,EnchantmentInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Respiration = new EnchantmentInfo(EnchantmentType.RESPIRATION' "Respiration").SetMaxLevel(3);
Magic Number,Substrate,EnchantmentInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Thorns = new EnchantmentInfo(EnchantmentType.THORNS' "Thorns").SetMaxLevel(3);
Magic Number,Substrate,EnchantmentInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Sharpness = new EnchantmentInfo(EnchantmentType.SHARPNESS' "Sharpness").SetMaxLevel(5);
Magic Number,Substrate,EnchantmentInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Smite = new EnchantmentInfo(EnchantmentType.SMITE' "Smite").SetMaxLevel(5);
Magic Number,Substrate,EnchantmentInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: BaneOfArthropods = new EnchantmentInfo(EnchantmentType.BANE_OF_ARTHROPODS' "Bane of Arthropods").SetMaxLevel(5);
Magic Number,Substrate,EnchantmentInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Knockback = new EnchantmentInfo(EnchantmentType.KNOCKBACK' "Knockback").SetMaxLevel(2);
Magic Number,Substrate,EnchantmentInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: FireAspect = new EnchantmentInfo(EnchantmentType.FIRE_ASPECT' "Fire Aspect").SetMaxLevel(2);
Magic Number,Substrate,EnchantmentInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Looting = new EnchantmentInfo(EnchantmentType.LOOTING' "Looting").SetMaxLevel(3);
Magic Number,Substrate,EnchantmentInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Efficiency = new EnchantmentInfo(EnchantmentType.EFFICIENCY' "Efficiency").SetMaxLevel(5);
Magic Number,Substrate,EnchantmentInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Unbreaking = new EnchantmentInfo(EnchantmentType.UNBREAKING' "Unbreaking").SetMaxLevel(3);
Magic Number,Substrate,EnchantmentInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Fortune = new EnchantmentInfo(EnchantmentType.FORTUNE' "Fortune").SetMaxLevel(3);
Magic Number,Substrate,EnchantmentInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Power = new EnchantmentInfo(EnchantmentType.POWER' "Power").SetMaxLevel(5);
Magic Number,Substrate,EnchantmentInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Punch = new EnchantmentInfo(EnchantmentType.PUNCH' "Punch").SetMaxLevel(2);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronShovel = new ItemInfo(256' "Iron Shovel");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronPickaxe = new ItemInfo(257' "Iron Pickaxe");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronAxe = new ItemInfo(258' "Iron Axe");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FlintAndSteel = new ItemInfo(259' "Flint and Steel");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Apple = new ItemInfo(260' "Apple").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Apple = new ItemInfo(260' "Apple").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Bow = new ItemInfo(261' "Bow");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Arrow = new ItemInfo(262' "Arrow").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Arrow = new ItemInfo(262' "Arrow").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Coal = new ItemInfo(263' "Coal").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Coal = new ItemInfo(263' "Coal").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Diamond = new ItemInfo(264' "Diamond").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Diamond = new ItemInfo(264' "Diamond").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronIngot = new ItemInfo(265' "Iron Ingot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronIngot = new ItemInfo(265' "Iron Ingot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldIngot = new ItemInfo(266' "Gold Ingot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldIngot = new ItemInfo(266' "Gold Ingot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronSword = new ItemInfo(267' "Iron Sword");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: WoodenSword = new ItemInfo(268' "Wooden Sword");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: WoodenShovel = new ItemInfo(269' "Wooden Shovel");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: WoodenPickaxe = new ItemInfo(270' "Wooden Pickaxe");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: WoodenAxe = new ItemInfo(271' "Wooden Axe");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: StoneSword = new ItemInfo(272' "Stone Sword");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: StoneShovel = new ItemInfo(273' "Stone Shovel");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: StonePickaxe = new ItemInfo(274' "Stone Pickaxe");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: StoneAxe = new ItemInfo(275' "Stone Axe");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondSword = new ItemInfo(276' "Diamond Sword");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondShovel = new ItemInfo(277' "Diamond Shovel");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondPickaxe = new ItemInfo(278' "Diamond Pickaxe");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondAxe = new ItemInfo(279' "Diamond Axe");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Stick = new ItemInfo(280' "Stick").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Stick = new ItemInfo(280' "Stick").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Bowl = new ItemInfo(281' "Bowl").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Bowl = new ItemInfo(281' "Bowl").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MushroomSoup = new ItemInfo(282' "Mushroom Soup");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldSword = new ItemInfo(283' "Gold Sword");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldShovel = new ItemInfo(284' "Gold Shovel");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldPickaxe = new ItemInfo(285' "Gold Pickaxe");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldAxe = new ItemInfo(286' "Gold Axe");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: String = new ItemInfo(287' "String").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: String = new ItemInfo(287' "String").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Feather = new ItemInfo(288' "Feather").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Feather = new ItemInfo(288' "Feather").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Gunpowder = new ItemInfo(289' "Gunpowder").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Gunpowder = new ItemInfo(289' "Gunpowder").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: WoodenHoe = new ItemInfo(290' "Wooden Hoe");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: StoneHoe = new ItemInfo(291' "Stone Hoe");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronHoe = new ItemInfo(292' "Iron Hoe");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondHoe = new ItemInfo(293' "Diamond Hoe");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldHoe = new ItemInfo(294' "Gold Hoe");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Seeds = new ItemInfo(295' "Seeds").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Seeds = new ItemInfo(295' "Seeds").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Wheat = new ItemInfo(296' "Wheat").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Wheat = new ItemInfo(296' "Wheat").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Bread = new ItemInfo(297' "Bread").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Bread = new ItemInfo(297' "Bread").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: LeatherCap = new ItemInfo(298' "Leather Cap");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: LeatherTunic = new ItemInfo(299' "Leather Tunic");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: LeatherPants = new ItemInfo(300' "Leather Pants");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: LeatherBoots = new ItemInfo(301' "Leather Boots");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: ChainHelmet = new ItemInfo(302' "Chain Helmet");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: ChainChestplate = new ItemInfo(303' "Chain Chestplate");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: ChainLeggings = new ItemInfo(304' "Chain Leggings");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: ChainBoots = new ItemInfo(305' "Chain Boots");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronHelmet = new ItemInfo(306' "Iron Helmet");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronChestplate = new ItemInfo(307' "Iron Chestplate");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronLeggings = new ItemInfo(308' "Iron Leggings");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronBoots = new ItemInfo(309' "Iron Boots");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondHelmet = new ItemInfo(310' "Diamond Helmet");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondChestplate = new ItemInfo(311' "Diamond Chestplate");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondLeggings = new ItemInfo(312' "Diamond Leggings");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondBoots = new ItemInfo(313' "Diamond Boots");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldHelmet = new ItemInfo(314' "Gold Helmet");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldChestplate = new ItemInfo(315' "Gold Chestplate");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldLeggings = new ItemInfo(316' "Gold Leggings");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldBoots = new ItemInfo(317' "Gold Boots");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Flint = new ItemInfo(318' "Flint").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Flint = new ItemInfo(318' "Flint").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RawPorkchop = new ItemInfo(319' "Raw Porkchop").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RawPorkchop = new ItemInfo(319' "Raw Porkchop").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: CookedPorkchop = new ItemInfo(320' "Cooked Porkchop").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: CookedPorkchop = new ItemInfo(320' "Cooked Porkchop").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Painting = new ItemInfo(321' "Painting").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Painting = new ItemInfo(321' "Painting").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldenApple = new ItemInfo(322' "Golden Apple").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldenApple = new ItemInfo(322' "Golden Apple").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Sign = new ItemInfo(323' "Sign");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: WoodenDoor = new ItemInfo(324' "Door");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Bucket = new ItemInfo(325' "Bucket");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: WaterBucket = new ItemInfo(326' "Water Bucket");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: LavaBucket = new ItemInfo(327' "Lava Bucket");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Minecart = new ItemInfo(328' "Minecart");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Saddle = new ItemInfo(329' "Saddle");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronDoor = new ItemInfo(330' "Iron Door");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RedstoneDust = new ItemInfo(331' "Redstone Dust").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RedstoneDust = new ItemInfo(331' "Redstone Dust").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Snowball = new ItemInfo(332' "Snowball").SetStackSize(16);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Snowball = new ItemInfo(332' "Snowball").SetStackSize(16);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Boat = new ItemInfo(333' "Boat");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Leather = new ItemInfo(334' "Leather").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Leather = new ItemInfo(334' "Leather").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Milk = new ItemInfo(335' "Milk");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: ClayBrick = new ItemInfo(336' "Clay Brick").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: ClayBrick = new ItemInfo(336' "Clay Brick").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Clay = new ItemInfo(337' "Clay").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Clay = new ItemInfo(337' "Clay").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: SugarCane = new ItemInfo(338' "Sugar Cane").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: SugarCane = new ItemInfo(338' "Sugar Cane").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Paper = new ItemInfo(339' "Paper").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Paper = new ItemInfo(339' "Paper").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Book = new ItemInfo(340' "Book").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Book = new ItemInfo(340' "Book").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Slimeball = new ItemInfo(341' "Slimeball").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Slimeball = new ItemInfo(341' "Slimeball").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: StorageMinecart = new ItemInfo(342' "Storage Minecart");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: PoweredMinecart = new ItemInfo(343' "Powered Minecart");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Egg = new ItemInfo(344' "Egg").SetStackSize(16);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Egg = new ItemInfo(344' "Egg").SetStackSize(16);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Compass = new ItemInfo(345' "Compass");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FishingRod = new ItemInfo(346' "Fishing Rod");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Clock = new ItemInfo(347' "Clock");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GlowstoneDust = new ItemInfo(348' "Glowstone Dust").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GlowstoneDust = new ItemInfo(348' "Glowstone Dust").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RawFish = new ItemInfo(349' "Raw Fish").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RawFish = new ItemInfo(349' "Raw Fish").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: CookedFish = new ItemInfo(350' "Cooked Fish").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: CookedFish = new ItemInfo(350' "Cooked Fish").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Dye = new ItemInfo(351' "Dye").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Dye = new ItemInfo(351' "Dye").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Bone = new ItemInfo(352' "Bone").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Bone = new ItemInfo(352' "Bone").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Sugar = new ItemInfo(353' "Sugar").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Sugar = new ItemInfo(353' "Sugar").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Cake = new ItemInfo(354' "Cake");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Bed = new ItemInfo(355' "Bed");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RedstoneRepeater = new ItemInfo(356' "Redstone Repeater").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RedstoneRepeater = new ItemInfo(356' "Redstone Repeater").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Cookie = new ItemInfo(357' "Cookie").SetStackSize(8);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Cookie = new ItemInfo(357' "Cookie").SetStackSize(8);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Map = new ItemInfo(358' "Map");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Shears = new ItemInfo(359' "Shears");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MelonSlice = new ItemInfo(360' "Melon Slice").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MelonSlice = new ItemInfo(360' "Melon Slice").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: PumpkinSeeds = new ItemInfo(361' "Pumpkin Seeds").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: PumpkinSeeds = new ItemInfo(361' "Pumpkin Seeds").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MelonSeeds = new ItemInfo(362' "Melon Seeds").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MelonSeeds = new ItemInfo(362' "Melon Seeds").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RawBeef = new ItemInfo(363' "Raw Beef").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RawBeef = new ItemInfo(363' "Raw Beef").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Steak = new ItemInfo(364' "Steak").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Steak = new ItemInfo(364' "Steak").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RawChicken = new ItemInfo(365' "Raw Chicken").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RawChicken = new ItemInfo(365' "Raw Chicken").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: CookedChicken = new ItemInfo(366' "Cooked Chicken").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: CookedChicken = new ItemInfo(366' "Cooked Chicken").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RottenFlesh = new ItemInfo(367' "Rotten Flesh").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RottenFlesh = new ItemInfo(367' "Rotten Flesh").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: EnderPearl = new ItemInfo(368' "Ender Pearl").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: EnderPearl = new ItemInfo(368' "Ender Pearl").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BlazeRod = new ItemInfo(369' "Blaze Rod").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BlazeRod = new ItemInfo(369' "Blaze Rod").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GhastTear = new ItemInfo(370' "Ghast Tear").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GhastTear = new ItemInfo(370' "Ghast Tear").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldNugget = new ItemInfo(371' "Gold Nugget").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldNugget = new ItemInfo(371' "Gold Nugget").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NetherWart = new ItemInfo(372' "Nether Wart").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NetherWart = new ItemInfo(372' "Nether Wart").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Potion = new ItemInfo(373' "Potion");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GlassBottle = new ItemInfo(374' "Glass Bottle").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GlassBottle = new ItemInfo(374' "Glass Bottle").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: SpiderEye = new ItemInfo(375' "Spider Eye").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: SpiderEye = new ItemInfo(375' "Spider Eye").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FermentedSpiderEye = new ItemInfo(376' "Fermented Spider Eye").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FermentedSpiderEye = new ItemInfo(376' "Fermented Spider Eye").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BlazePowder = new ItemInfo(377' "Blaze Powder").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BlazePowder = new ItemInfo(377' "Blaze Powder").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MagmaCream = new ItemInfo(378' "Magma Cream").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MagmaCream = new ItemInfo(378' "Magma Cream").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BrewingStand = new ItemInfo(379' "Brewing Stand").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BrewingStand = new ItemInfo(379' "Brewing Stand").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Cauldron = new ItemInfo(380' "Cauldron");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: EyeOfEnder = new ItemInfo(381' "Eye of Ender").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: EyeOfEnder = new ItemInfo(381' "Eye of Ender").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GlisteringMelon = new ItemInfo(382' "Glistering Melon").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GlisteringMelon = new ItemInfo(382' "Glistering Melon").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: SpawnEgg = new ItemInfo(383' "Spawn Egg").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: SpawnEgg = new ItemInfo(383' "Spawn Egg").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BottleOEnchanting = new ItemInfo(384' "Bottle O' Enchanting").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BottleOEnchanting = new ItemInfo(384' "Bottle O' Enchanting").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FireCharge = new ItemInfo(385' "Fire Charge").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FireCharge = new ItemInfo(385' "Fire Charge").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BookAndQuill = new ItemInfo(386' "Book and Quill");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: WrittenBook = new ItemInfo(387' "Written Book");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Emerald = new ItemInfo(388' "Emerald").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Emerald = new ItemInfo(388' "Emerald").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: ItemFrame = new ItemInfo(389' "Item Frame").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: ItemFrame = new ItemInfo(389' "Item Frame").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FlowerPot = new ItemInfo(390' "Flower Pot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FlowerPot = new ItemInfo(390' "Flower Pot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Carrot = new ItemInfo(391' "Carrot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Carrot = new ItemInfo(391' "Carrot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Potato = new ItemInfo(392' "Potato").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Potato = new ItemInfo(392' "Potato").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BakedPotato = new ItemInfo(393' "Baked Potato").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BakedPotato = new ItemInfo(393' "Baked Potato").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: PoisonPotato = new ItemInfo(394' "Poisonous Potato").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: PoisonPotato = new ItemInfo(394' "Poisonous Potato").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: EmptyMap = new ItemInfo(395' "Empty Map").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: EmptyMap = new ItemInfo(395' "Empty Map").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldenCarrot = new ItemInfo(396' "Golden Carrot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldenCarrot = new ItemInfo(396' "Golden Carrot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MobHead = new ItemInfo(397' "Mob Head").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MobHead = new ItemInfo(397' "Mob Head").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: CarrotOnStick = new ItemInfo(398' "Carrot on a Stick");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NetherStar = new ItemInfo(399' "Nether Star").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NetherStar = new ItemInfo(399' "Nether Star").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: PumpkinPie = new ItemInfo(400' "Pumpkin Pie").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: PumpkinPie = new ItemInfo(400' "Pumpkin Pie").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FireworkRocket = new ItemInfo(401' "Firework Rocket");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FireworkStar = new ItemInfo(402' "Firework Star").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FireworkStar = new ItemInfo(402' "Firework Star").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: EnchantedBook = new ItemInfo(403' "Enchanted Book");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RedstoneComparator = new ItemInfo(404' "Redstone Comparator").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RedstoneComparator = new ItemInfo(404' "Redstone Comparator").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NetherBrick = new ItemInfo(405' "Nether Brick").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NetherBrick = new ItemInfo(405' "Nether Brick").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NetherQuartz = new ItemInfo(406' "Nether Quartz").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NetherQuartz = new ItemInfo(406' "Nether Quartz").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: TntMinecart = new ItemInfo(407' "Minecart with TNT");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: HopperMinecart = new ItemInfo(408' "Minecart with Hopper");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronHorseArmor = new ItemInfo(417' "Iron Horse Armor");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldHorseArmor = new ItemInfo(418' "Gold Horse Armor");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondHorseArmor = new ItemInfo(419' "Diamond Horse Armor");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Lead = new ItemInfo(420' "Lead").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Lead = new ItemInfo(420' "Lead").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NameTag = new ItemInfo(421' "Name Tag").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NameTag = new ItemInfo(421' "Name Tag").SetStackSize(64);
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDisc13 = new ItemInfo(2256' "13 Disc");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDiscCat = new ItemInfo(2257' "Cat Disc");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDiscBlocks = new ItemInfo(2258' "Blocks Disc");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDiscChirp = new ItemInfo(2259' "Chirp Disc");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDiscFar = new ItemInfo(2260' "Far Disc");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDiscMall = new ItemInfo(2261' "Mall Disc");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDiscMellohi = new ItemInfo(2262' "Mellohi Disc");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDiscStal = new ItemInfo(2263' "Stal Disc");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDiscStrad = new ItemInfo(2264' "Strad Disc");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDiscWard = new ItemInfo(2265' "Ward Disc");
Magic Number,Substrate,ItemInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDisc11 = new ItemInfo(2266' "11 Disc");
Magic Number,Substrate,Enumerator,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EntityCollection.cs,ParseFileName,The following statement contains a magic number: z = (int)Base36.Decode(match.Groups[2].Value);
Magic Number,Substrate,Level,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Level.cs,Level,The following statement contains a magic number: _spawnY = 64;
Magic Number,Substrate,Level,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Level.cs,Level,The following statement contains a magic number: _version = 19133;
Magic Number,Substrate,Level,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Level.cs,SetDefaultPlayer,The following statement contains a magic number: _player.Position.Y = _spawnY + 1.7;
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Grass = new BlockInfo(2' "Grass").SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Grass = new BlockInfo(2' "Grass").SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Dirt = new BlockInfo(3' "Dirt");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Cobblestone = new BlockInfo(4' "Cobblestone");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodPlank = new BlockInfo(5' "Wooden Plank");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Sapling = new BlockInfo(6' "Sapling").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Sapling = new BlockInfo(6' "Sapling").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Bedrock = new BlockInfo(7' "Bedrock");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Water = new BlockInfo(8' "Water").SetOpacity(3).SetState(BlockState.FLUID).SetTick(5);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Water = new BlockInfo(8' "Water").SetOpacity(3).SetState(BlockState.FLUID).SetTick(5);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Water = new BlockInfo(8' "Water").SetOpacity(3).SetState(BlockState.FLUID).SetTick(5);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StationaryWater = new BlockInfo(9' "Stationary Water").SetOpacity(3).SetState(BlockState.FLUID);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StationaryWater = new BlockInfo(9' "Stationary Water").SetOpacity(3).SetState(BlockState.FLUID);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Lava = new BlockInfo(10' "Lava").SetOpacity(0).SetLuminance(MAX_LUMINANCE).SetState(BlockState.FLUID).SetTick(30);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Lava = new BlockInfo(10' "Lava").SetOpacity(0).SetLuminance(MAX_LUMINANCE).SetState(BlockState.FLUID).SetTick(30);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StationaryLava = new BlockInfo(11' "Stationary Lava").SetOpacity(0).SetLuminance(MAX_LUMINANCE).SetState(BlockState.FLUID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StationaryLava = new BlockInfo(11' "Stationary Lava").SetOpacity(0).SetLuminance(MAX_LUMINANCE).SetState(BlockState.FLUID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Sand = new BlockInfo(12' "Sand").SetTick(3);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Sand = new BlockInfo(12' "Sand").SetTick(3);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Gravel = new BlockInfo(13' "Gravel").SetTick(3);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Gravel = new BlockInfo(13' "Gravel").SetTick(3);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: GoldOre = new BlockInfo(14' "Gold Ore");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: IronOre = new BlockInfo(15' "Iron Ore");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CoalOre = new BlockInfo(16' "Coal Ore");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Wood = new BlockInfo(17' "Wood");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Leaves = new BlockInfo(18' "Leaves").SetOpacity(1).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Leaves = new BlockInfo(18' "Leaves").SetOpacity(1).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Sponge = new BlockInfo(19' "Sponge");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Glass = new BlockInfo(20' "Glass").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: LapisOre = new BlockInfo(21' "Lapis Lazuli Ore");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: LapisBlock = new BlockInfo(22' "Lapis Lazuli Block");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Dispenser = (BlockInfoEx)new BlockInfoEx(23' "Dispenser").SetTick(4);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Dispenser = (BlockInfoEx)new BlockInfoEx(23' "Dispenser").SetTick(4);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Sandstone = new BlockInfo(24' "Sandstone");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: NoteBlock = new BlockInfoEx(25' "Note Block");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Bed = new BlockInfo(26' "Bed").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: PoweredRail = new BlockInfo(27' "Powered Rail").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DetectorRail = new BlockInfo(28' "Detector Rail").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DetectorRail = new BlockInfo(28' "Detector Rail").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StickyPiston = new BlockInfo(29' "Sticky Piston").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Cobweb = new BlockInfo(30' "Cobweb").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: TallGrass = new BlockInfo(31' "Tall Grass").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DeadShrub = new BlockInfo(32' "Dead Shrub").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Piston = new BlockInfo(33' "Piston").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: PistonHead = new BlockInfo(34' "Piston Head").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Wool = new BlockInfo(35' "Wool");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: PistonMoving = (BlockInfoEx)new BlockInfoEx(36' "Piston Moving").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: YellowFlower = new BlockInfo(37' "Yellow Flower").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: YellowFlower = new BlockInfo(37' "Yellow Flower").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedRose = new BlockInfo(38' "Red Rose").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedRose = new BlockInfo(38' "Red Rose").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BrownMushroom = new BlockInfo(39' "Brown Mushroom").SetOpacity(0).SetLuminance(1).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BrownMushroom = new BlockInfo(39' "Brown Mushroom").SetOpacity(0).SetLuminance(1).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedMushroom = new BlockInfo(40' "Red Mushroom").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedMushroom = new BlockInfo(40' "Red Mushroom").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: GoldBlock = new BlockInfo(41' "Gold Block");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: IronBlock = new BlockInfo(42' "Iron Block");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DoubleStoneSlab = new BlockInfo(43' "Double Slab");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StoneSlab = new BlockInfo(44' "Slab").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BrickBlock = new BlockInfo(45' "Brick Block");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: TNT = new BlockInfo(46' "TNT");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Bookshelf = new BlockInfo(47' "Bookshelf");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: MossStone = new BlockInfo(48' "Moss Stone");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Obsidian = new BlockInfo(49' "Obsidian");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Torch = new BlockInfo(50' "Torch").SetOpacity(0).SetLuminance(MAX_LUMINANCE - 1).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Torch = new BlockInfo(50' "Torch").SetOpacity(0).SetLuminance(MAX_LUMINANCE - 1).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Fire = new BlockInfo(51' "Fire").SetOpacity(0).SetLuminance(MAX_LUMINANCE).SetState(BlockState.NONSOLID).SetTick(40);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Fire = new BlockInfo(51' "Fire").SetOpacity(0).SetLuminance(MAX_LUMINANCE).SetState(BlockState.NONSOLID).SetTick(40);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: MonsterSpawner = (BlockInfoEx)new BlockInfoEx(52' "Monster Spawner").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodStairs = new BlockInfo(53' "Wooden Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Chest = (BlockInfoEx)new BlockInfoEx(54' "Chest").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneWire = new BlockInfo(55' "Redstone Wire").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DiamondOre = new BlockInfo(56' "Diamond Ore");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DiamondBlock = new BlockInfo(57' "Diamond Block");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CraftTable = new BlockInfo(58' "Crafting Table");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Crops = new BlockInfo(59' "Crops").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Crops = new BlockInfo(59' "Crops").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Farmland = new BlockInfo(60' "Farmland").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Farmland = new BlockInfo(60' "Farmland").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Furnace = new BlockInfoEx(61' "Furnace");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BurningFurnace = (BlockInfoEx)new BlockInfoEx(62' "Burning Furnace").SetLuminance(MAX_LUMINANCE - 1);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SignPost = (BlockInfoEx)new BlockInfoEx(63' "Sign Post").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodDoor = new BlockInfo(64' "Wooden Door").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Ladder = new BlockInfo(65' "Ladder").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Rails = new BlockInfo(66' "Rails").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CobbleStairs = new BlockInfo(67' "Cobblestone Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WallSign = (BlockInfoEx)new BlockInfoEx(68' "Wall Sign").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Lever = new BlockInfo(69' "Lever").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StonePlate = new BlockInfo(70' "Stone Pressure Plate").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StonePlate = new BlockInfo(70' "Stone Pressure Plate").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: IronDoor = new BlockInfo(71' "Iron Door").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodPlate = new BlockInfo(72' "Wooden Pressure Plate").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodPlate = new BlockInfo(72' "Wooden Pressure Plate").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneOre = new BlockInfo(73' "Redstone Ore").SetTick(30);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneOre = new BlockInfo(73' "Redstone Ore").SetTick(30);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: GlowRedstoneOre = new BlockInfo(74' "Glowing Redstone Ore").SetLuminance(9).SetTick(30);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: GlowRedstoneOre = new BlockInfo(74' "Glowing Redstone Ore").SetLuminance(9).SetTick(30);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: GlowRedstoneOre = new BlockInfo(74' "Glowing Redstone Ore").SetLuminance(9).SetTick(30);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneTorch = new BlockInfo(75' "Redstone Torch (Off)").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(2);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneTorch = new BlockInfo(75' "Redstone Torch (Off)").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(2);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneTorchOn = new BlockInfo(76' "Redstone Torch (On)").SetOpacity(0).SetLuminance(7).SetState(BlockState.NONSOLID).SetTick(2);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneTorchOn = new BlockInfo(76' "Redstone Torch (On)").SetOpacity(0).SetLuminance(7).SetState(BlockState.NONSOLID).SetTick(2);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneTorchOn = new BlockInfo(76' "Redstone Torch (On)").SetOpacity(0).SetLuminance(7).SetState(BlockState.NONSOLID).SetTick(2);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StoneButton = new BlockInfo(77' "Stone Button").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Snow = new BlockInfo(78' "Snow").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Snow = new BlockInfo(78' "Snow").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Ice = new BlockInfo(79' "Ice").SetOpacity(3).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Ice = new BlockInfo(79' "Ice").SetOpacity(3).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Ice = new BlockInfo(79' "Ice").SetOpacity(3).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SnowBlock = new BlockInfo(80' "Snow Block").SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SnowBlock = new BlockInfo(80' "Snow Block").SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Cactus = new BlockInfo(81' "Cactus").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Cactus = new BlockInfo(81' "Cactus").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: ClayBlock = new BlockInfo(82' "Clay Block");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SugarCane = new BlockInfo(83' "Sugar Cane").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SugarCane = new BlockInfo(83' "Sugar Cane").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Jukebox = new BlockInfo(84' "Jukebox");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Fence = new BlockInfo(85' "Fence").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Pumpkin = new BlockInfo(86' "Pumpkin");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Netherrack = new BlockInfo(87' "Netherrack");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SoulSand = new BlockInfo(88' "Soul Sand");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Glowstone = new BlockInfo(89' "Glowstone Block").SetLuminance(MAX_LUMINANCE);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Portal = new BlockInfo(90' "Portal").SetOpacity(0).SetLuminance(11).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Portal = new BlockInfo(90' "Portal").SetOpacity(0).SetLuminance(11).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: JackOLantern = new BlockInfo(91' "Jack-O-Lantern").SetLuminance(MAX_LUMINANCE);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CakeBlock = new BlockInfo(92' "Cake Block").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneRepeater = new BlockInfo(93' "Redstone Repeater (Off)").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneRepeater = new BlockInfo(93' "Redstone Repeater (Off)").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneRepeaterOn = new BlockInfo(94' "Redstone Repeater (On)").SetOpacity(0).SetLuminance(7).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneRepeaterOn = new BlockInfo(94' "Redstone Repeater (On)").SetOpacity(0).SetLuminance(7).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneRepeaterOn = new BlockInfo(94' "Redstone Repeater (On)").SetOpacity(0).SetLuminance(7).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: LockedChest = (BlockInfoEx)new BlockInfoEx(95' "Locked Chest").SetLuminance(MAX_LUMINANCE).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: LockedChest = (BlockInfoEx)new BlockInfoEx(95' "Locked Chest").SetLuminance(MAX_LUMINANCE).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StainedGlass = new BlockInfo(95' "Stained Glass").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Trapdoor = new BlockInfo(96' "Trapdoor").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SilverfishStone = new BlockInfo(97' "Stone with Silverfish");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StoneBrick = new BlockInfo(98' "Stone Brick");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: HugeRedMushroom = new BlockInfo(99' "Huge Red Mushroom");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: HugeBrownMushroom = new BlockInfo(100' "Huge Brown Mushroom");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: IronBars = new BlockInfo(101' "Iron Bars").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: GlassPane = new BlockInfo(102' "Glass Pane").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Melon = new BlockInfo(103' "Melon");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: PumpkinStem = new BlockInfo(104' "Pumpkin Stem").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: PumpkinStem = new BlockInfo(104' "Pumpkin Stem").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: MelonStem = new BlockInfo(105' "Melon Stem").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: MelonStem = new BlockInfo(105' "Melon Stem").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Vines = new BlockInfo(106' "Vines").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Vines = new BlockInfo(106' "Vines").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: FenceGate = new BlockInfo(107' "Fence Gate").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BrickStairs = new BlockInfo(108' "Brick Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StoneBrickStairs = new BlockInfo(109' "Stone Brick Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Mycelium = new BlockInfo(110' "Mycelium").SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Mycelium = new BlockInfo(110' "Mycelium").SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: LillyPad = new BlockInfo(111' "Lilly Pad").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: NetherBrick = new BlockInfo(112' "Nether Brick");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: NetherBrickFence = new BlockInfo(113' "Nether Brick Fence").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: NetherBrickStairs = new BlockInfo(114' "Nether Brick Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: NetherWart = new BlockInfo(115' "Nether Wart").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: NetherWart = new BlockInfo(115' "Nether Wart").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: EnchantmentTable = (BlockInfoEx)new BlockInfoEx(116' "Enchantment Table").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BrewingStand = (BlockInfoEx)new BlockInfoEx(117' "Brewing Stand").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Cauldron = new BlockInfo(118' "Cauldron").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: EndPortal = (BlockInfoEx)new BlockInfoEx(119' "End Portal").SetOpacity(0).SetLuminance(MAX_LUMINANCE).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: EndPortalFrame = new BlockInfo(120' "End Portal Frame").SetLuminance(MAX_LUMINANCE);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: EndStone = new BlockInfo(121' "End Stone");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DragonEgg = new BlockInfo(122' "Dragon Egg").SetOpacity(0).SetLuminance(1).SetTick(3);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DragonEgg = new BlockInfo(122' "Dragon Egg").SetOpacity(0).SetLuminance(1).SetTick(3);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneLampOff = new BlockInfo(123' "Redstone Lamp (Off)").SetTick(2);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneLampOff = new BlockInfo(123' "Redstone Lamp (Off)").SetTick(2);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneLampOn = new BlockInfo(124' "Redstone Lamp (On)").SetLuminance(15).SetTick(2);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneLampOn = new BlockInfo(124' "Redstone Lamp (On)").SetLuminance(15).SetTick(2);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneLampOn = new BlockInfo(124' "Redstone Lamp (On)").SetLuminance(15).SetTick(2);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DoubleWoodSlab = new BlockInfo(125' "Double Wood Slab");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodSlab = new BlockInfo(126' "Wood Slab");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CocoaPlant = new BlockInfo(127' "Cocoa Plant").SetLuminance(2).SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CocoaPlant = new BlockInfo(127' "Cocoa Plant").SetLuminance(2).SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SandstoneStairs = new BlockInfo(128' "Sandstone Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: EmeraldOre = new BlockInfo(129' "Emerald Ore");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: EnderChest = (BlockInfoEx)new BlockInfoEx(130' "Ender Chest").SetLuminance(7).SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: EnderChest = (BlockInfoEx)new BlockInfoEx(130' "Ender Chest").SetLuminance(7).SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: TripwireHook = new BlockInfo(131' "Tripwire Hook").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Tripwire = new BlockInfo(132' "Tripwire").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: EmeraldBlock = new BlockInfo(133' "Emerald Block");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SpruceWoodStairs = new BlockInfo(134' "Sprice Wood Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BirchWoodStairs = new BlockInfo(135' "Birch Wood Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: JungleWoodStairs = new BlockInfo(136' "Jungle Wood Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CommandBlock = (BlockInfoEx)new BlockInfoEx(137' "Command Block");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BeaconBlock = (BlockInfoEx)new BlockInfoEx(138' "Beacon Block").SetOpacity(0).SetLuminance(MAX_LUMINANCE);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CobblestoneWall = new BlockInfo(139' "Cobblestone Wall").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: FlowerPot = new BlockInfo(140' "Flower Pot").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Carrots = new BlockInfo(141' "Carrots").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Carrots = new BlockInfo(141' "Carrots").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Potatoes = new BlockInfo(142' "Potatoes").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Potatoes = new BlockInfo(142' "Potatoes").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodButton = new BlockInfo(143' "Wooden Button").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Heads = new BlockInfo(144' "Heads").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Anvil = new BlockInfo(145' "Anvil").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: TrappedChest = (BlockInfoEx)new BlockInfoEx(146' "Trapped Chest").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: TrappedChest = (BlockInfoEx)new BlockInfoEx(146' "Trapped Chest").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WeightedPressurePlateLight = new BlockInfo(147' "Weighted Pressure Plate (Light)").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WeightedPressurePlateLight = new BlockInfo(147' "Weighted Pressure Plate (Light)").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WeightedPressurePlateHeavy = new BlockInfo(148' "Weighted Pressure Plate (Heavy)").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WeightedPressurePlateHeavy = new BlockInfo(148' "Weighted Pressure Plate (Heavy)").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneComparatorInactive = new BlockInfo(149' "Redstone Comparator (Inactive)").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneComparatorInactive = new BlockInfo(149' "Redstone Comparator (Inactive)").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneComparatorActive = new BlockInfo(150' "Redstone Comparator (Active)").SetOpacity(0).SetLuminance(9).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneComparatorActive = new BlockInfo(150' "Redstone Comparator (Active)").SetOpacity(0).SetLuminance(9).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneComparatorActive = new BlockInfo(150' "Redstone Comparator (Active)").SetOpacity(0).SetLuminance(9).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DaylightSensor = new BlockInfo(151' "Daylight Sensor").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DaylightSensor = new BlockInfo(151' "Daylight Sensor").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneBlock = new BlockInfo(152' "Block of Redstone").SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneBlock = new BlockInfo(152' "Block of Redstone").SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: NetherQuartzOre = new BlockInfo(153' "Neither Quartz Ore");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Hopper = (BlockInfoEx)new BlockInfoEx(154' "Hopper").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Hopper = (BlockInfoEx)new BlockInfoEx(154' "Hopper").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: QuartzBlock = new BlockInfo(155' "Block of Quartz");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: QuartzStairs = new BlockInfo(156' "Quartz Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: ActivatorRail = new BlockInfo(157' "Activator Rail").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: ActivatorRail = new BlockInfo(157' "Activator Rail").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Dropper = (BlockInfoEx)new BlockInfoEx(158' "Dropper").SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Dropper = (BlockInfoEx)new BlockInfoEx(158' "Dropper").SetTick(10);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StainedClay = new BlockInfo(159' "Stained Clay");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StainedGlassPane = new BlockInfo(160' "Stained Glass Pane").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: HayBlock = new BlockInfo(170' "Hay Block");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Carpet = new BlockInfo(171' "Carpet").SetOpacity(0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: HardenedClay = new BlockInfo(172' "Hardened Clay");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CoalBlock = new BlockInfo(173' "Block of Coal");
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Wood.SetDataLimits(0' 2' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Leaves.SetDataLimits(0' 2' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Jukebox.SetDataLimits(0' 2' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Sapling.SetDataLimits(0' 15' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Cactus.SetDataLimits(0' 15' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SugarCane.SetDataLimits(0' 15' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Water.SetDataLimits(0' 7' 0x8);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Lava.SetDataLimits(0' 7' 0x8);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: TallGrass.SetDataLimits(0' 2' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Crops.SetDataLimits(0' 7' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: PoweredRail.SetDataLimits(0' 5' 0x8);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DetectorRail.SetDataLimits(0' 5' 0x8);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StickyPiston.SetDataLimits(1' 5' 0x8);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Piston.SetDataLimits(1' 5' 0x8);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: PistonHead.SetDataLimits(1' 5' 0x8);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Wool.SetDataLimits(0' 15' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Torch.SetDataLimits(1' 5' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneTorch.SetDataLimits(0' 5' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneTorchOn.SetDataLimits(0' 5' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Rails.SetDataLimits(0' 9' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Ladder.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Ladder.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodStairs.SetDataLimits(0' 3' 0x4);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CobbleStairs.SetDataLimits(0' 3' 0x4);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Lever.SetDataLimits(0' 6' 0x8);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodDoor.SetDataLimits(0' 3' 0xC);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: IronDoor.SetDataLimits(0' 3' 0xC);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StoneButton.SetDataLimits(1' 4' 0x8);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Snow.SetDataLimits(0' 7' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SignPost.SetDataLimits(0' 15' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WallSign.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WallSign.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Furnace.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Furnace.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BurningFurnace.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BurningFurnace.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Dispenser.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Dispenser.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Pumpkin.SetDataLimits(0' 3' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: JackOLantern.SetDataLimits(0' 3' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StoneSlab.SetDataLimits(0' 5' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DoubleStoneSlab.SetDataLimits(0' 5' 0x8);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Cactus.SetDataLimits(0' 5' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Bed.SetDataLimits(0' 3' 0x8);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Trapdoor.SetDataLimits(0' 3' 0x4);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StoneBrick.SetDataLimits(0' 2' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: HugeRedMushroom.SetDataLimits(0' 10' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: HugeBrownMushroom.SetDataLimits(0' 10' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: FenceGate.SetDataLimits(0' 3' 0x4);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SilverfishStone.SetDataLimits(0' 2' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Cauldron.SetDataLimits(0' 3' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodSlab.SetDataLimits(0' 5' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DoubleWoodSlab.SetDataLimits(0' 5' 0x8);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: TripwireHook.SetDataLimits(0' 3' 0xC);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: QuartzBlock.SetDataLimits(0' 4' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: QuartzStairs.SetDataLimits(0' 3' 0x4);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Carpet.SetDataLimits(0' 15' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Dropper.SetDataLimits(0' 5' 0);
Magic Number,Substrate,BlockInfo,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Hopper.SetDataLimits(0' 5' 0);
Magic Number,Substrate,AlphaChunkManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaChunkManager.cs,AlphaChunkManager,The following statement contains a magic number: _cache = new LRUCache<ChunkKey' ChunkRef>(256);
Magic Number,Substrate,Entity,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Entity.cs,LoadTree,The following statement contains a magic number: _pos.Z = pos[2].ToTagDouble();
Magic Number,Substrate,Entity,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Entity.cs,LoadTree,The following statement contains a magic number: _motion.Z = motion[2].ToTagDouble();
Magic Number,Substrate,Player,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Player.cs,Player,The following statement contains a magic number: Air = 300;
Magic Number,Substrate,Player,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Player.cs,Player,The following statement contains a magic number: Health = 20.0f;
Magic Number,Substrate,Player,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Player.cs,Player,The following statement contains a magic number: Fire = -20;
Magic Number,Substrate,SpawnPoint,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\SpawnPoint.cs,GetHashCode,The following statement contains a magic number: int hash = 23;
Magic Number,Substrate,SpawnPoint,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\SpawnPoint.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + _x;
Magic Number,Substrate,SpawnPoint,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\SpawnPoint.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + _y;
Magic Number,Substrate,SpawnPoint,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\SpawnPoint.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + _z;
Magic Number,Substrate.Core,Region,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Region.cs,ForeignX,The following statement contains a magic number: return (lcx + XDIM * 10000) & XMASK;
Magic Number,Substrate.Core,Region,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Region.cs,ForeignZ,The following statement contains a magic number: return (lcz + ZDIM * 10000) & ZMASK;
Magic Number,Substrate.Core,BlockFluid,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,GetChunk,The following statement contains a magic number: int cx = x / _xdim + (x >> 31);
Magic Number,Substrate.Core,BlockFluid,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,GetChunk,The following statement contains a magic number: int cz = z / _zdim + (z >> 31);
Magic Number,Substrate.Core,BlockFluid,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,TileOutflow,The following statement contains a magic number: i < 4
Magic Number,Substrate.Core,BlockFluid,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,TileOutflow,The following statement contains a magic number: i < 4
Magic Number,Substrate.Core,BlockFluid,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,TileInflow,The following statement contains a magic number: int minFlow = 16;
Magic Number,Substrate.Core,BlockFluid,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,TileInflow,The following statement contains a magic number: i < 4
Magic Number,Substrate.Core,BlockFluid,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoWater,The following statement contains a magic number: int curflow = 16;
Magic Number,Substrate.Core,BlockFluid,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoWater,The following statement contains a magic number: newflow < 16 && curflow == 16
Magic Number,Substrate.Core,BlockFluid,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoWater,The following statement contains a magic number: newflow < 16 && curflow == 16
Magic Number,Substrate.Core,BlockFluid,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoLava,The following statement contains a magic number: int curflow = 16;
Magic Number,Substrate.Core,BlockFluid,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoLava,The following statement contains a magic number: newflow < 16 && curflow == 16
Magic Number,Substrate.Core,BlockFluid,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoLava,The following statement contains a magic number: newflow < 16 && curflow == 16
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,BlockLight,The following statement contains a magic number: _lightbit = new BitArray(_blockset.XDim * 3 * _blockset.ZDim * 3 * _blockset.YDim);
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,BlockLight,The following statement contains a magic number: _lightbit = new BitArray(_blockset.XDim * 3 * _blockset.ZDim * 3 * _blockset.YDim);
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,BlockLight,The following statement contains a magic number: _lightbit = new BitArray(_blockset.XDim * 3 * _blockset.ZDim * 3 * _blockset.YDim);
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,BlockLight,The following statement contains a magic number: _lightbit = new BitArray(_blockset.XDim * 3 * _blockset.ZDim * 3 * _blockset.YDim);
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockLight,The following statement contains a magic number: StitchBlockLight(map[1' 2]' BlockCollectionEdge.WEST);
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockLight,The following statement contains a magic number: map[1' 2] != null
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockLight,The following statement contains a magic number: StitchBlockLight(map[2' 1]' BlockCollectionEdge.SOUTH);
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockLight,The following statement contains a magic number: map[2' 1] != null
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockSkyLight,The following statement contains a magic number: StitchBlockSkyLight(map[1' 2]' BlockCollectionEdge.WEST);
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockSkyLight,The following statement contains a magic number: map[1' 2] != null
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockSkyLight,The following statement contains a magic number: StitchBlockSkyLight(map[2' 1]' BlockCollectionEdge.SOUTH);
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockSkyLight,The following statement contains a magic number: map[2' 1] != null
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LightBitmapIndex,The following statement contains a magic number: int xstride = _zdim * 3 * zstride;
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,QueueRelight,The following statement contains a magic number: key.x < -15 || key.x >= 31 || key.z < -15 || key.z >= 31
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,QueueRelight,The following statement contains a magic number: key.x < -15 || key.x >= 31 || key.z < -15 || key.z >= 31
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,QueueRelight,The following statement contains a magic number: key.x < -15 || key.x >= 31 || key.z < -15 || key.z >= 31
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,QueueRelight,The following statement contains a magic number: key.x < -15 || key.x >= 31 || key.z < -15 || key.z >= 31
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,NeighborHeight,The following statement contains a magic number: x = (x + _xdim * 2) % _xdim;
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,NeighborHeight,The following statement contains a magic number: z = (z + _zdim * 2) % _zdim;
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalBlockLightMap,The following statement contains a magic number: IBoundedLitBlockCollection['] map = new IBoundedLitBlockCollection[3' 3];
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalBlockLightMap,The following statement contains a magic number: IBoundedLitBlockCollection['] map = new IBoundedLitBlockCollection[3' 3];
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalBlockLightMap,The following statement contains a magic number: map[0' 2] = OnResolveNeighbor(-1' 0' 1);
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalBlockLightMap,The following statement contains a magic number: map[1' 2] = OnResolveNeighbor(0' 0' 1);
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalBlockLightMap,The following statement contains a magic number: map[2' 0] = OnResolveNeighbor(1' 0' -1);
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalBlockLightMap,The following statement contains a magic number: map[2' 1] = OnResolveNeighbor(1' 0' 0);
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalBlockLightMap,The following statement contains a magic number: map[2' 2] = OnResolveNeighbor(1' 0' 1);
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalBlockLightMap,The following statement contains a magic number: map[2' 2] = OnResolveNeighbor(1' 0' 1);
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalHeightMap,The following statement contains a magic number: int['] map = new int[3 * xdim' 3 * zdim];
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalHeightMap,The following statement contains a magic number: int['] map = new int[3 * xdim' 3 * zdim];
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalHeightMap,The following statement contains a magic number: zi < 3
Magic Number,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalHeightMap,The following statement contains a magic number: xi < 3
Magic Number,Substrate.Core,PlayerFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\PlayerFile.cs,NameFromFilename,The following statement contains a magic number: return filename.Remove(filename.Length - 4);
Magic Number,Substrate.Core,BlockKey,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockKey.cs,GetHashCode,The following statement contains a magic number: int hash = 23;
Magic Number,Substrate.Core,BlockKey,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockKey.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + x;
Magic Number,Substrate.Core,BlockKey,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockKey.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + y;
Magic Number,Substrate.Core,BlockKey,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockKey.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + z;
Magic Number,Substrate.Core,ChunkFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\ChunkFile.cs,ChunkFile,The following statement contains a magic number: cx += (64 * 64);
Magic Number,Substrate.Core,ChunkFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\ChunkFile.cs,ChunkFile,The following statement contains a magic number: cx += (64 * 64);
Magic Number,Substrate.Core,ChunkFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\ChunkFile.cs,ChunkFile,The following statement contains a magic number: cz += (64 * 64);
Magic Number,Substrate.Core,ChunkFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\ChunkFile.cs,ChunkFile,The following statement contains a magic number: cz += (64 * 64);
Magic Number,Substrate.Core,ChunkFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\ChunkFile.cs,ChunkFile,The following statement contains a magic number: string dir1 = Base36.Encode(cx % 64);
Magic Number,Substrate.Core,ChunkFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\ChunkFile.cs,ChunkFile,The following statement contains a magic number: string dir2 = Base36.Encode(cz % 64);
Magic Number,Substrate.Core,ChunkKey,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\ChunkKey.cs,GetHashCode,The following statement contains a magic number: int hash = 23;
Magic Number,Substrate.Core,ChunkKey,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\ChunkKey.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + cx;
Magic Number,Substrate.Core,ChunkKey,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\ChunkKey.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + cz;
Magic Number,Substrate.Core,NBTFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\NBTFile.cs,Timestamp,The following statement contains a magic number: DateTime epoch = new DateTime(1970' 1' 1' 0' 0' 0' 0);
Magic Number,Substrate.Core,NBTFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\NBTFile.cs,Timestamp,The following statement contains a magic number: return (int)((time - epoch).Ticks / (10000L * 1000L));
Magic Number,Substrate.Core,NBTFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\NBTFile.cs,Timestamp,The following statement contains a magic number: return (int)((time - epoch).Ticks / (10000L * 1000L));
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,ReadFile,The following statement contains a magic number: file.Write(int0' 0' 4);
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,ReadFile,The following statement contains a magic number: file.Write(int0' 0' 4);
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,ReadFile,The following statement contains a magic number: sizeDelta += SectorBytes * 2;
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,ReadFile,The following statement contains a magic number: byte[] offsetBytes = new byte[4];
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,ReadFile,The following statement contains a magic number: file.Read(offsetBytes' 0' 4);
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,ReadFile,The following statement contains a magic number: sectorFree[(offset >> 8) + sectorNum] = false;
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,ReadFile,The following statement contains a magic number: offset != 0 && (offset >> 8) + (offset & 0xFF) <= sectorFree.Count
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,ReadFile,The following statement contains a magic number: byte[] modBytes = new byte[4];
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,ReadFile,The following statement contains a magic number: file.Read(modBytes' 0' 4);
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,GetChunkDataInputStream,The following statement contains a magic number: int sectorNumber = offset >> 8;
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,GetChunkDataInputStream,The following statement contains a magic number: byte[] lengthBytes = new byte[4];
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,GetChunkDataInputStream,The following statement contains a magic number: file.Read(lengthBytes' 0' 4);
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Write,The following statement contains a magic number: int sectorNumber = offset >> 8;
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Write,The following statement contains a magic number: sectorsNeeded >= 256
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Write,The following statement contains a magic number: file.Write(bytes' 0' 4);
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,DeleteChunk,The following statement contains a magic number: int sectorNumber = offset >> 8;
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,OutOfBounds,The following statement contains a magic number: return x < 0 || x >= 32 || z < 0 || z >= 32;
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,OutOfBounds,The following statement contains a magic number: return x < 0 || x >= 32 || z < 0 || z >= 32;
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,GetOffset,The following statement contains a magic number: return offsets[x + z * 32];
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,SetOffset,The following statement contains a magic number: offsets[x + z * 32] = offset;
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,SetOffset,The following statement contains a magic number: file.Seek((x + z * 32) * 4' SeekOrigin.Begin);
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,SetOffset,The following statement contains a magic number: file.Seek((x + z * 32) * 4' SeekOrigin.Begin);
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,SetOffset,The following statement contains a magic number: file.Write(bytes' 0' 4);
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Timestamp,The following statement contains a magic number: DateTime epoch = new DateTime(1970' 1' 1' 0' 0' 0' 0);
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Timestamp,The following statement contains a magic number: return (int)((DateTime.UtcNow - epoch).Ticks / (10000L * 1000L));
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Timestamp,The following statement contains a magic number: return (int)((DateTime.UtcNow - epoch).Ticks / (10000L * 1000L));
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Timestamp,The following statement contains a magic number: DateTime epoch = new DateTime(1970' 1' 1' 0' 0' 0' 0);
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Timestamp,The following statement contains a magic number: return (int)((time - epoch).Ticks / (10000L * 1000L));
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Timestamp,The following statement contains a magic number: return (int)((time - epoch).Ticks / (10000L * 1000L));
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,GetTimestamp,The following statement contains a magic number: return chunkTimestamps[x + z * 32];
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,SetTimestamp,The following statement contains a magic number: chunkTimestamps[x + z * 32] = value;
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,SetTimestamp,The following statement contains a magic number: file.Seek(SectorBytes + (x + z * 32) * 4' SeekOrigin.Begin);
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,SetTimestamp,The following statement contains a magic number: file.Seek(SectorBytes + (x + z * 32) * 4' SeekOrigin.Begin);
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,SetTimestamp,The following statement contains a magic number: file.Write(bytes' 0' 4);
Magic Number,Substrate.Core,RegionFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,parseCoordinatesFromName,The following statement contains a magic number: z = Convert.ToInt32(match.Groups[2].Value);
Magic Number,Substrate.Core,RegionKey,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionKey.cs,GetHashCode,The following statement contains a magic number: int hash = 23;
Magic Number,Substrate.Core,RegionKey,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionKey.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + rx;
Magic Number,Substrate.Core,RegionKey,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionKey.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + rz;
Magic Number,Substrate.Core,Base36,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Base.cs,Encode,The following statement contains a magic number: result.Push(_alphabet[(int)(input % 36)]);
Magic Number,Substrate.Core,Base36,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Base.cs,Encode,The following statement contains a magic number: input /= 36;
Magic Number,Substrate.Core,Base36,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Base.cs,Decode,The following statement contains a magic number: result += _alphabet.IndexOf(input[i]) * (long)Math.Pow(36' pos);
Magic Number,Substrate.Core,Base16,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Base.cs,Encode,The following statement contains a magic number: int hi = (input[i] >> 4) & 0xF;
Magic Number,Substrate.Core,Base16,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Base.cs,Encode,The following statement contains a magic number: stride > 0 && (((i + 1) * 2 - 1) % stride) == 0
Magic Number,Substrate.Core,Base16,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Base.cs,Encode,The following statement contains a magic number: stride > 0 && (((i + 1) * 2) % stride) == 0
Magic Number,Substrate.Core,NibbleArray,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\NibbleArray.cs,NibbleArray,The following statement contains a magic number: _data = new byte[(int)Math.Ceiling(length / 2.0)];
Magic Number,Substrate.Core,XZYNibbleArray,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\NibbleArray.cs,XZYNibbleArray,The following statement contains a magic number: xdim * ydim * zdim != data.Length * 2
Magic Number,Substrate.Core,YZXNibbleArray,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\NibbleArray.cs,YZXNibbleArray,The following statement contains a magic number: xdim * ydim * zdim != data.Length * 2
Magic Number,Substrate.Data,MapFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapFile.cs,IdFromFilename,The following statement contains a magic number: return Convert.ToInt32(filename.Substring(4).Remove(filename.Length - 4));
Magic Number,Substrate.Data,MapFile,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapFile.cs,IdFromFilename,The following statement contains a magic number: return Convert.ToInt32(filename.Substring(4).Remove(filename.Length - 4));
Magic Number,Substrate.Data,Map,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\Map.cs,Map,The following statement contains a magic number: _scale = 3;
Magic Number,Substrate.Data,Map,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\Map.cs,Map,The following statement contains a magic number: _height = 128;
Magic Number,Substrate.Data,Map,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\Map.cs,Map,The following statement contains a magic number: _width = 128;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _colorIndex = new Color[256];
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _labIndex = new Vector3[256];
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _blockIndex = new ColorGroup[4096];
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,BlockToColorIndex,The following statement contains a magic number: blockId < 0 || blockId >= 4096
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,BlockToColor,The following statement contains a magic number: ci < 0 || ci >= 256
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,GroupToColor,The following statement contains a magic number: ci < 0 || ci >= 256
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: double r = color.R / 255.0;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: double g = color.G / 255.0;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: double b = color.B / 255.0;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: r = (r > 0.04045)                  ? Math.Pow((r + 0.055) / 1.055' 2.4)                  : r / 12.92;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: r = (r > 0.04045)                  ? Math.Pow((r + 0.055) / 1.055' 2.4)                  : r / 12.92;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: r = (r > 0.04045)                  ? Math.Pow((r + 0.055) / 1.055' 2.4)                  : r / 12.92;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: r = (r > 0.04045)                  ? Math.Pow((r + 0.055) / 1.055' 2.4)                  : r / 12.92;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: r = (r > 0.04045)                  ? Math.Pow((r + 0.055) / 1.055' 2.4)                  : r / 12.92;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: g = (g > 0.04045)                  ? Math.Pow((g + 0.055) / 1.055' 2.4)                  : g / 12.92;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: g = (g > 0.04045)                  ? Math.Pow((g + 0.055) / 1.055' 2.4)                  : g / 12.92;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: g = (g > 0.04045)                  ? Math.Pow((g + 0.055) / 1.055' 2.4)                  : g / 12.92;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: g = (g > 0.04045)                  ? Math.Pow((g + 0.055) / 1.055' 2.4)                  : g / 12.92;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: g = (g > 0.04045)                  ? Math.Pow((g + 0.055) / 1.055' 2.4)                  : g / 12.92;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: b = (b > 0.04045)                  ? Math.Pow((b + 0.055) / 1.055' 2.4)                  : b / 12.92;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: b = (b > 0.04045)                  ? Math.Pow((b + 0.055) / 1.055' 2.4)                  : b / 12.92;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: b = (b > 0.04045)                  ? Math.Pow((b + 0.055) / 1.055' 2.4)                  : b / 12.92;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: b = (b > 0.04045)                  ? Math.Pow((b + 0.055) / 1.055' 2.4)                  : b / 12.92;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: b = (b > 0.04045)                  ? Math.Pow((b + 0.055) / 1.055' 2.4)                  : b / 12.92;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: r *= 100;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: g *= 100;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: b *= 100;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: xyz.X = r * 0.4124 + g * 0.3576 + b * 0.1805;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: xyz.X = r * 0.4124 + g * 0.3576 + b * 0.1805;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: xyz.X = r * 0.4124 + g * 0.3576 + b * 0.1805;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: xyz.Y = r * 0.2126 + g * 0.7152 + b * 0.0722;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: xyz.Y = r * 0.2126 + g * 0.7152 + b * 0.0722;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: xyz.Y = r * 0.2126 + g * 0.7152 + b * 0.0722;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: xyz.Z = r * 0.0193 + g * 0.1192 + b * 0.9505;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: xyz.Z = r * 0.0193 + g * 0.1192 + b * 0.9505;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: xyz.Z = r * 0.0193 + g * 0.1192 + b * 0.9505;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: double x = xyz.X / 95.047;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: double y = xyz.Y / 100.0;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: double z = xyz.Z / 108.883;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: x = (x > 0.008856)                  ? Math.Pow(x' 1.0 / 3.0)                  : (7.787 * x) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: x = (x > 0.008856)                  ? Math.Pow(x' 1.0 / 3.0)                  : (7.787 * x) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: x = (x > 0.008856)                  ? Math.Pow(x' 1.0 / 3.0)                  : (7.787 * x) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: x = (x > 0.008856)                  ? Math.Pow(x' 1.0 / 3.0)                  : (7.787 * x) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: x = (x > 0.008856)                  ? Math.Pow(x' 1.0 / 3.0)                  : (7.787 * x) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: y = (y > 0.008856)                  ? Math.Pow(y' 1.0 / 3.0)                  : (7.787 * y) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: y = (y > 0.008856)                  ? Math.Pow(y' 1.0 / 3.0)                  : (7.787 * y) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: y = (y > 0.008856)                  ? Math.Pow(y' 1.0 / 3.0)                  : (7.787 * y) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: y = (y > 0.008856)                  ? Math.Pow(y' 1.0 / 3.0)                  : (7.787 * y) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: y = (y > 0.008856)                  ? Math.Pow(y' 1.0 / 3.0)                  : (7.787 * y) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: z = (z > 0.008856)                  ? Math.Pow(z' 1.0 / 3.0)                  : (7.787 * z) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: z = (z > 0.008856)                  ? Math.Pow(z' 1.0 / 3.0)                  : (7.787 * z) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: z = (z > 0.008856)                  ? Math.Pow(z' 1.0 / 3.0)                  : (7.787 * z) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: z = (z > 0.008856)                  ? Math.Pow(z' 1.0 / 3.0)                  : (7.787 * z) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: z = (z > 0.008856)                  ? Math.Pow(z' 1.0 / 3.0)                  : (7.787 * z) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: lab.X = (116 * y) - 16;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: lab.X = (116 * y) - 16;
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: lab.Y = 500 * (x - y);
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: lab.Z = 200 * (y - z);
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadShort,The following statement contains a magic number: byte[] gzBytes = new byte[2];
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadShort,The following statement contains a magic number: _stream.Read(gzBytes' 0' 2);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadInt,The following statement contains a magic number: byte[] gzBytes = new byte[4];
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadInt,The following statement contains a magic number: _stream.Read(gzBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadLong,The following statement contains a magic number: byte[] gzBytes = new byte[8];
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadLong,The following statement contains a magic number: _stream.Read(gzBytes' 0' 8);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadFloat,The following statement contains a magic number: byte[] gzBytes = new byte[4];
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadFloat,The following statement contains a magic number: _stream.Read(gzBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadDouble,The following statement contains a magic number: byte[] gzBytes = new byte[8];
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadDouble,The following statement contains a magic number: _stream.Read(gzBytes' 0' 8);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadByteArray,The following statement contains a magic number: byte[] lenBytes = new byte[4];
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadByteArray,The following statement contains a magic number: _stream.Read(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadString,The following statement contains a magic number: byte[] lenBytes = new byte[2];
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadString,The following statement contains a magic number: _stream.Read(lenBytes' 0' 2);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadList,The following statement contains a magic number: byte[] lenBytes = new byte[4];
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadList,The following statement contains a magic number: _stream.Read(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadIntArray,The following statement contains a magic number: byte[] lenBytes = new byte[4];
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadIntArray,The following statement contains a magic number: _stream.Read(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadIntArray,The following statement contains a magic number: byte[] buffer = new byte[4];
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadIntArray,The following statement contains a magic number: _stream.Read(buffer' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadLongArray,The following statement contains a magic number: byte[] lenBytes = new byte[4];
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadLongArray,The following statement contains a magic number: _stream.Read(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadLongArray,The following statement contains a magic number: byte[] buffer = new byte[8];
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadLongArray,The following statement contains a magic number: _stream.Read(buffer' 0' 8);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadShortArray,The following statement contains a magic number: byte[] lenBytes = new byte[4];
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadShortArray,The following statement contains a magic number: _stream.Read(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadShortArray,The following statement contains a magic number: byte[] buffer = new byte[2];
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadShortArray,The following statement contains a magic number: _stream.Read(buffer' 0' 2);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteShort,The following statement contains a magic number: _stream.Write(gzBytes' 0' 2);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteInt,The following statement contains a magic number: _stream.Write(gzBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteLong,The following statement contains a magic number: _stream.Write(gzBytes' 0' 8);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteFloat,The following statement contains a magic number: _stream.Write(gzBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteDouble,The following statement contains a magic number: _stream.Write(gzBytes' 0' 8);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteByteArray,The following statement contains a magic number: _stream.Write(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteString,The following statement contains a magic number: _stream.Write(lenBytes' 0' 2);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteList,The following statement contains a magic number: _stream.Write(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteIntArray,The following statement contains a magic number: _stream.Write(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteIntArray,The following statement contains a magic number: byte[] data = new byte[val.Length * 4];
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteIntArray,The following statement contains a magic number: Array.Copy(buffer' 0' data' i * 4' 4);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteIntArray,The following statement contains a magic number: Array.Copy(buffer' 0' data' i * 4' 4);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteLongArray,The following statement contains a magic number: _stream.Write(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteLongArray,The following statement contains a magic number: byte[] data = new byte[val.Length * 8];
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteLongArray,The following statement contains a magic number: Array.Copy(buffer' 0' data' i * 8' 8);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteLongArray,The following statement contains a magic number: Array.Copy(buffer' 0' data' i * 8' 8);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteShortArray,The following statement contains a magic number: _stream.Write(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteShortArray,The following statement contains a magic number: byte[] data = new byte[val.Length * 2];
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteShortArray,The following statement contains a magic number: Array.Copy(buffer' 0' data' i * 2' 2);
Magic Number,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteShortArray,The following statement contains a magic number: Array.Copy(buffer' 0' data' i * 2' 2);
Magic Number,Ionic.Zlib,CRC32,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Crc32.cs,_InternalComputeCrc32,The following statement contains a magic number: return (Int32)(crc32Table[(W ^ B) & 0xFF] ^ (W >> 8));
Magic Number,Ionic.Zlib,CRC32,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Crc32.cs,SlurpBlock,The following statement contains a magic number: _RunningCrc32Result = ((_RunningCrc32Result) >> 8) ^ crc32Table[(block[x]) ^ ((_RunningCrc32Result) & 0x000000FF)];
Magic Number,Ionic.Zlib,CRC32,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Crc32.cs,CRC32,The following statement contains a magic number: crc32Table = new UInt32[256];
Magic Number,Ionic.Zlib,CRC32,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Crc32.cs,CRC32,The following statement contains a magic number: i < 256
Magic Number,Ionic.Zlib,CRC32,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Crc32.cs,gf2_matrix_square,The following statement contains a magic number: i < 32
Magic Number,Ionic.Zlib,CRC32,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Crc32.cs,Combine,The following statement contains a magic number: uint[] even = new uint[32];
Magic Number,Ionic.Zlib,CRC32,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Crc32.cs,Combine,The following statement contains a magic number: uint[] odd = new uint[32];
Magic Number,Ionic.Zlib,CRC32,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Crc32.cs,Combine,The following statement contains a magic number: i < 32
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateManager,The following statement contains a magic number: dyn_ltree = new short[HEAP_SIZE * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateManager,The following statement contains a magic number: dyn_dtree = new short[(2 * InternalConstants.D_CODES + 1) * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateManager,The following statement contains a magic number: dyn_dtree = new short[(2 * InternalConstants.D_CODES + 1) * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateManager,The following statement contains a magic number: bl_tree = new short[(2 * InternalConstants.BL_CODES + 1) * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateManager,The following statement contains a magic number: bl_tree = new short[(2 * InternalConstants.BL_CODES + 1) * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_InitializeLazyMatch,The following statement contains a magic number: window_size = 2 * w_size;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_InitializeTreeData,The following statement contains a magic number: last_eob_len = 8;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: dyn_ltree[i * 2] = 0;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: dyn_dtree[i * 2] = 0;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: bl_tree[i * 2] = 0;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: dyn_ltree[END_BLOCK * 2] = 1;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_IsSmaller,The following statement contains a magic number: short tn2 = tree[n * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_IsSmaller,The following statement contains a magic number: short tm2 = tree[m * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int nextlen = (int)tree[0 * 2 + 1];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 138;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: tree[(max_code + 1) * 2 + 1] = (short)0x7fff;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: nextlen = (int)tree[(n + 1) * 2 + 1];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 138;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: max_blindex >= 3
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(dcodes - 1' 5);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: int nextlen   = tree[0 * 2 + 1];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 138;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: nextlen = tree[(n + 1) * 2 + 1];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 138;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_code,The following statement contains a magic number: int c2 = c * 2;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_bits,The following statement contains a magic number: pending[pendingCount++] = (byte)(bi_buf >> 8);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits(STATIC_TREES << 1' 3);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits(STATIC_TREES << 1' 3);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: 1 + last_eob_len + 10 - bi_valid < 9
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: 1 + last_eob_len + 10 - bi_valid < 9
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: last_eob_len = 7;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending[_distanceOffset + last_lit * 2] = unchecked((byte) ( (uint)dist >> 8 ) );
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending[_distanceOffset + last_lit * 2] = unchecked((byte) ( (uint)dist >> 8 ) );
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending[_distanceOffset + last_lit * 2 + 1] = unchecked((byte)dist);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: dyn_ltree[lc * 2]++;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: int out_length = last_lit << 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.ExtraDistanceBits[dcode]));
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.ExtraDistanceBits[dcode]));
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length >>= 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: (matches < (last_lit / 2)) && out_length < in_length / 2
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: (matches < (last_lit / 2)) && out_length < in_length / 2
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: (last_lit & 0x1fff) == 0 && (int)compressionLevel > 2
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_compressed_block,The following statement contains a magic number: int ix = _distanceOffset + lx * 2;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_compressed_block,The following statement contains a magic number: distance = ((pending[ix] << 8) & 0xff00) |                          (pending[ix + 1] & 0xff);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_compressed_block,The following statement contains a magic number: last_eob_len = ltree[END_BLOCK * 2 + 1];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: bin_freq += dyn_ltree[n * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: n < 7
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: ascii_freq += dyn_ltree[n * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: n < 128
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: bin_freq += dyn_ltree[n * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: data_type = (sbyte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: pending[pendingCount++] = (byte)(bi_buf >> 8);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: bi_valid == 16
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,bi_windup,The following statement contains a magic number: pending[pendingCount++] = (byte)(bi_buf >> 8);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,bi_windup,The following statement contains a magic number: bi_valid > 8
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,copy_block,The following statement contains a magic number: last_eob_len = 8;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,copy_block,The following statement contains a magic number: unchecked                  {                      //put_short((short)len);                      pending[pendingCount++] = (byte)len;                      pending[pendingCount++] = (byte)(len >> 8);                       //put_short((short)~len);                      pending[pendingCount++] = (byte)~len;                      pending[pendingCount++] = (byte)(~len >> 8);                  }
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,copy_block,The following statement contains a magic number: unchecked                  {                      //put_short((short)len);                      pending[pendingCount++] = (byte)len;                      pending[pendingCount++] = (byte)(len >> 8);                       //put_short((short)~len);                      pending[pendingCount++] = (byte)~len;                      pending[pendingCount++] = (byte)(~len >> 8);                  }
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateNone,The following statement contains a magic number: max_block_size = pending.Length - 5;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateNone,The following statement contains a magic number: max_block_size > pending.Length - 5
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_stored_block,The following statement contains a magic number: send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0)' 3);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (opt_len + 3 + 7) >> 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (opt_len + 3 + 7) >> 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (opt_len + 3 + 7) >> 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (static_len + 3 + 7) >> 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (static_len + 3 + 7) >> 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (static_len + 3 + 7) >> 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: stored_len + 4 <= opt_lenb && buf != -1
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateSlow,The following statement contains a magic number: match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered ||                                                (match_length == MIN_MATCH && strstart - match_start > 4096))
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateSlow,The following statement contains a magic number: match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered ||                                                (match_length == MIN_MATCH && strstart - match_start > 4096))
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateSlow,The following statement contains a magic number: prev_length -= 2;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,longest_match,The following statement contains a magic number: chain_length >>= 2;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,longest_match,The following statement contains a magic number: scan += 2;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: windowBits < 9 || windowBits > 15
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: windowBits < 9 || windowBits > 15
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: hash_bits = memLevel + 7;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: window = new byte[w_size * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: lit_bufsize = 1 << (memLevel + 6);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: pending = new byte[lit_bufsize * 4];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: _lengthOffset = (1 + 2) * lit_bufsize;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: level_flags = 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: level_flags > 3
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: header |= (level_flags << 6);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)(header >> 8);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,GZipStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\GZipStream.cs,EmitHeader,The following statement contains a magic number: int bufferLength = 10 + cbLength + fnLength;
Magic Number,Ionic.Zlib,GZipStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\GZipStream.cs,EmitHeader,The following statement contains a magic number: header[i++] = 8;
Magic Number,Ionic.Zlib,GZipStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\GZipStream.cs,EmitHeader,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(timet)' 0' header' i' 4);
Magic Number,Ionic.Zlib,GZipStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\GZipStream.cs,EmitHeader,The following statement contains a magic number: i += 4;
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateBlocks,The following statement contains a magic number: hufts = new int[MANY * 3];
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Flush,The following statement contains a magic number: pass < 2
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: k += 8;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: k < (20)
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: tp_index_t_3 = (tp_index + t) * 3;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: s.window[q++] = (byte)tp[tp_index_t_3 + 2];
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: e &= 15;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: k += 8;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: k < 15
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: tp_index_t_3 = (tp_index + t) * 3;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: e &= 15;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: k += 8;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: c -= 2;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: q - r > 0 && 2 > (q - r)
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: (e & 16) != 0
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: (e & 16) != 0
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: t += tp[tp_index_t_3 + 2];
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: tp_index_t_3 = (tp_index + t) * 3;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: s.window[q++] = (byte)tp[tp_index_t_3 + 2];
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: (e & 64) == 0
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: k -= (c << 3);
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Initialize,The following statement contains a magic number: w < 8 || w > 15
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Initialize,The following statement contains a magic number: w < 8 || w > 15
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Sync,The following statement contains a magic number: n != 0 && m < 4
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Sync,The following statement contains a magic number: m != 4
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: xp = 2;
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: r[2] = (int) (q - u[h - 1] - j);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: r[0] = 128 + 64;
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: r[0] = 128 + 64;
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (q + j) * 3' 3);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (q + j) * 3' 3);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: initWorkArea(19);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: result = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: result = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: initWorkArea(288);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: result = huft_build(c' 0' nl' 257' cplens' cplext' tl' bl' hp' hn' v);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: initWorkArea(288);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: result != Z_OK || (bd[0] == 0 && nl > 257)
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,initWorkArea,The following statement contains a magic number: r = new int[3];
Magic Number,Ionic.Zlib,WorkItem,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ParallelDeflateOutputStream.cs,WorkItem,The following statement contains a magic number: int n = size + ((size / 32768)+1) * 5 * 2;
Magic Number,Ionic.Zlib,WorkItem,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ParallelDeflateOutputStream.cs,WorkItem,The following statement contains a magic number: int n = size + ((size / 32768)+1) * 5 * 2;
Magic Number,Ionic.Zlib,WorkItem,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ParallelDeflateOutputStream.cs,WorkItem,The following statement contains a magic number: int n = size + ((size / 32768)+1) * 5 * 2;
Magic Number,Ionic.Zlib,ParallelDeflateOutputStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ParallelDeflateOutputStream.cs,ParallelDeflateOutputStream,The following statement contains a magic number: BuffersPerCore = 4;
Magic Number,Ionic.Zlib,ParallelDeflateOutputStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ParallelDeflateOutputStream.cs,_PerpetualWriterMethod,The following statement contains a magic number: byte[] buffer = new byte[128];
Magic Number,Ionic.Zlib,ParallelDeflateOutputStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ParallelDeflateOutputStream.cs,TraceOutput,The following statement contains a magic number: Console.ForegroundColor = (ConsoleColor) (tid % 8 + 8);
Magic Number,Ionic.Zlib,ParallelDeflateOutputStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ParallelDeflateOutputStream.cs,TraceOutput,The following statement contains a magic number: Console.ForegroundColor = (ConsoleColor) (tid % 8 + 8);
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,DistanceCode,The following statement contains a magic number: return (dist < 256)                  ? _dist_code[dist]                  : _dist_code[256 + SharedUtils.URShift(dist' 7)];
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,DistanceCode,The following statement contains a magic number: return (dist < 256)                  ? _dist_code[dist]                  : _dist_code[256 + SharedUtils.URShift(dist' 7)];
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,DistanceCode,The following statement contains a magic number: return (dist < 256)                  ? _dist_code[dist]                  : _dist_code[256 + SharedUtils.URShift(dist' 7)];
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[s.heap[s.heap_max] * 2 + 1] = 0;
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[n * 2 + 1] = (short) bits;
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: f = tree[n * 2];
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.static_len += f * (stree[n * 2 + 1] + xbits);
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.bl_count[bits + 1] = (short) (s.bl_count[bits + 1] + 2);
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: overflow -= 2;
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[m * 2 + 1] = (short) bits;
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[m * 2 + 1] != bits
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[n * 2] != 0
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: node = s.heap[++s.heap_len] = (max_code < 2?++max_code:0);
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = 1;
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: s.static_len -= stree[node * 2 + 1];
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: s.heap_len < 2
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_codes,The following statement contains a magic number: int len = tree[n * 2 + 1];
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_codes,The following statement contains a magic number: tree[n * 2] =  unchecked((short) (bi_reverse(next_code[len]++' len)));
Magic Number,Ionic.Zlib,Adler,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Zlib.cs,Adler32,The following statement contains a magic number: uint s2 = (uint) ((adler >> 16) & 0xffff);
Magic Number,Ionic.Zlib,Adler,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Zlib.cs,Adler32,The following statement contains a magic number: k -= 16;
Magic Number,Ionic.Zlib,Adler,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Zlib.cs,Adler32,The following statement contains a magic number: k >= 16
Magic Number,Ionic.Zlib,Adler,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Zlib.cs,Adler32,The following statement contains a magic number: return (uint)((s2 << 16) | s1);
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,Write,The following statement contains a magic number: done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: _stream.Write(BitConverter.GetBytes(c1)' 0' 4);
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: _stream.Write(BitConverter.GetBytes(c2)' 0' 4);
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: byte[] header = new byte[10];
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: n != 10
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: header[0] != 0x1F || header[1] != 0x8B || header[2] != 8
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: header[0] != 0x1F || header[1] != 0x8B || header[2] != 8
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: Int32 timet = BitConverter.ToInt32(header' 4);
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: n = _stream.Read(header' 0' 2);
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: Int16 extraLength = (Int16)(header[0] + header[1] * 256);
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: (header[3] & 0x04) == 0x04
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: (header[3] & 0x08) == 0x08
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: (header[3] & 0x10) == 0x010
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: (header[3] & 0x02) == 0x02
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,UncompressString,The following statement contains a magic number: byte[] working = new byte[1024];
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,UncompressBuffer,The following statement contains a magic number: byte[] working = new byte[1024];
Duplicate Code,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The method contains a code clone-set at the following line numbers (starting from the method definition): ((28' 47)' (245' 264)' (186' 205)' (246' 265))
Duplicate Code,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The method contains a code clone-set at the following line numbers (starting from the method definition): ((186' 205)' (313' 332)' (348' 367)' (246' 265))
Missing Default,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockLight,The following switch statement is missing a default case: switch (edge) {                  case BlockCollectionEdge.EAST:                      for (int x = 0; x < xdim; x++) {                          for (int y = 0; y < ydim; y++) {                              TestBlockLight(chunk' x' y' 0' x' y' zdim - 1);                          }                      }                      break;                    case BlockCollectionEdge.NORTH:                      for (int z = 0; z < zdim; z++) {                          for (int y = 0; y < ydim; y++) {                              TestBlockLight(chunk' 0' y' z' xdim - 1' y' z);                          }                      }                      break;                    case BlockCollectionEdge.WEST:                      for (int x = 0; x < xdim; x++) {                          for (int y = 0; y < ydim; y++) {                              TestBlockLight(chunk' x' y' zdim - 1' x' y' 0);                          }                      }                      break;                    case BlockCollectionEdge.SOUTH:                      for (int z = 0; z < zdim; z++) {                          for (int y = 0; y < ydim; y++) {                              TestBlockLight(chunk' xdim - 1' y' z' 0' y' z);                          }                      }                      break;              }
Missing Default,Substrate.Core,BlockLight,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockSkyLight,The following switch statement is missing a default case: switch (edge) {                  case BlockCollectionEdge.EAST:                      for (int x = 0; x < xdim; x++) {                          for (int y = 0; y < ydim; y++) {                              TestSkyLight(chunk' x' y' 0' x' y' zdim - 1);                          }                      }                      break;                    case BlockCollectionEdge.NORTH:                      for (int z = 0; z < zdim; z++) {                          for (int y = 0; y < ydim; y++) {                              TestSkyLight(chunk' 0' y' z' xdim - 1' y' z);                          }                      }                      break;                    case BlockCollectionEdge.WEST:                      for (int x = 0; x < xdim; x++) {                          for (int y = 0; y < ydim; y++) {                              TestSkyLight(chunk' x' y' zdim - 1' x' y' 0);                          }                      }                      break;                    case BlockCollectionEdge.SOUTH:                      for (int z = 0; z < zdim; z++) {                          for (int y = 0; y < ydim; y++) {                              TestSkyLight(chunk' xdim - 1' y' z' 0' y' z);                          }                      }                      break;              }
Missing Default,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadValue,The following switch statement is missing a default case: switch (type) {                  case TagType.TAG_END:                      return null;                    case TagType.TAG_BYTE:                      return ReadByte();                    case TagType.TAG_SHORT:                      return ReadShort();                    case TagType.TAG_INT:                      return ReadInt();                    case TagType.TAG_LONG:                      return ReadLong();                    case TagType.TAG_FLOAT:                      return ReadFloat();                    case TagType.TAG_DOUBLE:                      return ReadDouble();                    case TagType.TAG_BYTE_ARRAY:                      return ReadByteArray();                    case TagType.TAG_STRING:                      return ReadString();                    case TagType.TAG_LIST:                      return ReadList();                    case TagType.TAG_COMPOUND:                      return ReadCompound();                    case TagType.TAG_INT_ARRAY:                      return ReadIntArray();                                        case TagType.TAG_LONG_ARRAY:                      return ReadLongArray();                    case TagType.TAG_SHORT_ARRAY:                      return ReadShortArray();              }
Missing Default,Substrate.Nbt,NbtTree,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteValue,The following switch statement is missing a default case: switch (val.GetTagType()) {                  case TagType.TAG_END:                      break;                    case TagType.TAG_BYTE:                      WriteByte(val.ToTagByte());                      break;                    case TagType.TAG_SHORT:                      WriteShort(val.ToTagShort());                      break;                    case TagType.TAG_INT:                      WriteInt(val.ToTagInt());                      break;                    case TagType.TAG_LONG:                      WriteLong(val.ToTagLong());                      break;                    case TagType.TAG_FLOAT:                      WriteFloat(val.ToTagFloat());                      break;                    case TagType.TAG_DOUBLE:                      WriteDouble(val.ToTagDouble());                      break;                    case TagType.TAG_BYTE_ARRAY:                      WriteByteArray(val.ToTagByteArray());                      break;                    case TagType.TAG_STRING:                      WriteString(val.ToTagString());                      break;                    case TagType.TAG_LIST:                      WriteList(val.ToTagList());                      break;                    case TagType.TAG_COMPOUND:                      WriteCompound(val.ToTagCompound());                      break;                    case TagType.TAG_INT_ARRAY:                      WriteIntArray(val.ToTagIntArray());                      break;                    case TagType.TAG_LONG_ARRAY:                      WriteLongArray(val.ToTagLongArray());                      break;                    case TagType.TAG_SHORT_ARRAY:                      WriteShortArray(val.ToTagShortArray());                      break;              }
Missing Default,Substrate.Nbt,NbtVerifier,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtVerifier.cs,OnMissingTag,The following switch statement is missing a default case: switch (code) {                          case TagEventCode.FAIL:                              return false;                          case TagEventCode.PASS:                              return true;                      }
Missing Default,Substrate.Nbt,NbtVerifier,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtVerifier.cs,OnInvalidTagType,The following switch statement is missing a default case: switch (code) {                          case TagEventCode.FAIL:                              return false;                          case TagEventCode.PASS:                              return true;                      }
Missing Default,Substrate.Nbt,NbtVerifier,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtVerifier.cs,OnInvalidTagValue,The following switch statement is missing a default case: switch (code) {                          case TagEventCode.FAIL:                              return false;                          case TagEventCode.PASS:                              return true;                      }
Missing Default,Substrate.Nbt,SchemaNodeScaler,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\SchemaNodeScaler.cs,BuildDefaultTree,The following switch statement is missing a default case: switch (_type) {                  case TagType.TAG_STRING:                      return new TagNodeString();                    case TagType.TAG_BYTE:                      return new TagNodeByte();                    case TagType.TAG_SHORT:                      return new TagNodeShort();                    case TagType.TAG_INT:                      return new TagNodeInt();                    case TagType.TAG_LONG:                      return new TagNodeLong();                    case TagType.TAG_FLOAT:                      return new TagNodeFloat();                    case TagType.TAG_DOUBLE:                      return new TagNodeDouble();              }
Missing Default,Substrate.Nbt,JSONSerializer,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\JSONSerializer.cs,SerializeScaler,The following switch statement is missing a default case: switch (tag.GetTagType()) {                  case TagType.TAG_STRING:                      str.Append("\"" + Escape(tag.ToTagString().Data) + "\"");                      break;                    case TagType.TAG_BYTE:                      str.Append(tag.ToTagByte().Data);                      break;                    case TagType.TAG_SHORT:                      str.Append(tag.ToTagShort().Data);                      break;                    case TagType.TAG_INT:                      str.Append(tag.ToTagInt().Data);                      break;                    case TagType.TAG_LONG:                      str.Append(tag.ToTagLong().Data);                      break;                    case TagType.TAG_FLOAT:                      str.Append(tag.ToTagFloat().Data);                      break;                    case TagType.TAG_DOUBLE:                      str.Append(tag.ToTagDouble().Data);                      break;                    case TagType.TAG_BYTE_ARRAY:                      str.Append(Convert.ToBase64String(tag.ToTagByteArray().Data));                      /*if (tag.ToTagByteArray().Length == (16 * 16 * 128 / 2)) {                          str.Append(Base16.Encode(tag.ToTagByteArray().Data' 1));                      }                      else {                          str.Append(Base16.Encode(tag.ToTagByteArray().Data' 2));                      }*/                      break;              }
Missing Default,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,SetDeflater,The following switch statement is missing a default case: switch (config.Flavor)              {                  case DeflateFlavor.Store:                      DeflateFunction = DeflateNone;                      break;                  case DeflateFlavor.Fast:                      DeflateFunction = DeflateFast;                      break;                  case DeflateFlavor.Slow:                      DeflateFunction = DeflateSlow;                      break;              }
Missing Default,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following switch statement is missing a default case: switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }
