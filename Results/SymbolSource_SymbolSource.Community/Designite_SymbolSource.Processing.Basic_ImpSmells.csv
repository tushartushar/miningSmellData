Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,SymbolSource.Processing.Basic,StreamDecorator,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\StreamExtensions.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,SymbolSource.Processing.Basic,StreamDecorator,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\StreamExtensions.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Statement,SymbolSource.Processing.Basic,BinaryStoreManager,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\BinaryStoreManager.cs,ReadBinaryHash,The length of the statement  "            return reader.FileHeader.TimeDateStamp.ToString("X") + (reader.Is32BitHeader ? reader.OptionalHeader32.SizeOfImage : reader.OptionalHeader64.SizeOfImage).ToString("X"); " is 168.
Long Statement,SymbolSource.Processing.Basic,ManagedSourceExtractor,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\ManagedSourceExtractor.cs,IsTemporaryCompilerFile,The length of the statement  "            return sourceFileName.EndsWith("17d14f5c-a337-4978-8281-53493378c1071.vb"' StringComparison.InvariantCultureIgnoreCase); " is 120.
Long Statement,SymbolSource.Processing.Basic,PdbStoreManager,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\PdbStoreManager.cs,ReadSrcSrv,The length of the statement  "            using (var pdbstrProcess = processFactory.Create(PdbStrPath()' "-r"' string.Format(@"-p:""{0}"""' pdbFilePath)' "-s:srcsrv")) " is 125.
Long Statement,SymbolSource.Processing.Basic,PdbStoreManager,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\PdbStoreManager.cs,WriteSrcSrv,The length of the statement  "                using (var pdbstrProcess = processFactory.Create(PdbStrPath()' "-w"' string.Format(@"-p:""{0}"""' pdbFilePath)' string.Format(@"-i:""{0}"""' tempFile)' "-s:srcsrv")) " is 165.
Long Statement,Internal,BinaryStoreManager,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\BinaryStoreManager.cs,ReadBinaryHash,The length of the statement  "            return reader.FileHeader.TimeDateStamp.ToString("X") + (reader.Is32BitHeader ? reader.OptionalHeader32.SizeOfImage : reader.OptionalHeader64.SizeOfImage).ToString("X"); " is 168.
Long Statement,SymbolSource.Processing.Basic.Projects,AddInfoBuilder,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\Projects\AddInfoBuilder.cs,BuildBinaryInfo,The length of the statement  "                symbolInfo.SourceInfos = sourceDiscover.FindSources(fileInfos' binaryInfo' symbolInfo).OrderBy(s => s.KeyPath).ToArray(); " is 121.
Long Statement,SymbolSource.Processing.Basic.Projects,SourceDiscover,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\Projects\SourceDiscover.cs,FindSources,The length of the statement  "                string maxCommonOriginalPath = GetMaxCommonPath(originalPaths.Select(o => o.Replace('\\'' Path.DirectorySeparatorChar).Replace('/'' Path.DirectorySeparatorChar))); " is 163.
Long Statement,SymbolSource.Processing.Basic.Projects,SourceDiscover,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\Projects\SourceDiscover.cs,FindSources,The length of the statement  "                fileInfos = fileInfos.Where(f => originalPathsExtensions.Any(o => string.Equals(Path.GetExtension(f.FullPath)' o' StringComparison.OrdinalIgnoreCase))).ToArray(); " is 162.
Long Statement,SymbolSource.Processing.Basic.Projects,SourceDiscover,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\Projects\SourceDiscover.cs,FindSources,The length of the statement  "                string maxCommonFileInfosPath = GetMaxCommonPath(fileInfos.Select(o => o.FullPath.Replace('\\'' Path.DirectorySeparatorChar).Replace('/'' Path.DirectorySeparatorChar))); " is 169.
Long Statement,SymbolSource.Processing.Basic.Projects,SourceDiscover,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\Projects\SourceDiscover.cs,FindSources,The length of the statement  "                    var actualPath = GetActualPaths(fileInfos' originalPath.Replace('\\'' Path.DirectorySeparatorChar).Replace('/'' Path.DirectorySeparatorChar)' maxCommonOriginalPath' maxCommonFileInfosPath); " is 189.
Long Statement,SymbolSource.Processing.Basic.Projects,SourceDiscover,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\Projects\SourceDiscover.cs,FindSources,The length of the statement  "                        log.DebugFormat("Found '{0}' -> '{1}' ('{2}') "' originalPath' actualPath!=null ? actualPath.FullPath : "NOT FOUND"' keyPath); " is 126.
Long Statement,SymbolSource.Processing.Basic.Projects,SourceDiscover,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\Projects\SourceDiscover.cs,CheckCandidate,The length of the statement  "            string[] fileNameSplitted = fileName.Replace('\\'' Path.DirectorySeparatorChar).Replace('/'' Path.DirectorySeparatorChar).Split(Path.DirectorySeparatorChar); " is 157.
Long Statement,SymbolSource.Processing.Basic.Projects,SourceDiscover,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\Projects\SourceDiscover.cs,CheckCandidate,The length of the statement  "            string[] fullPathSplitted = fullPath.Replace('\\'' Path.DirectorySeparatorChar).Replace('/'' Path.DirectorySeparatorChar).Split(Path.DirectorySeparatorChar); " is 157.
Complex Conditional,SymbolSource.Processing.Basic,SourceConverter,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\SourceConverter.cs,DetectEncoding,The conditional expression  "data.Length >= 3 && data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF"  is complex.
Magic Number,SymbolSource.Processing.Basic,BinaryStoreManager,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\BinaryStoreManager.cs,ReadPdbHash,The following statement contains a magic number: if (debugDirectory.PointerToRawData > 0)              {                  using (var fileStream = File.Open(binaryFilePath' FileMode.Open))                  using (var codeViewReader = new BinaryReader(fileStream))                  {                      fileStream.Position = debugDirectory.PointerToRawData;                      uint codeViewVersion = codeViewReader.ReadUInt32();                      if (codeViewVersion == 0x53445352) //RSRS                      {                          var pdbSignature = new Guid(codeViewReader.ReadBytes(16));                          uint pdbAge = codeViewReader.ReadUInt32();                          string pdbFilePath = ReadZeroTerminatedString(codeViewReader);                          return (pdbSignature.ToString("N") + pdbAge.ToString("x")).ToUpper();                      }                  }              }
Magic Number,SymbolSource.Processing.Basic,SourceConverter,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\SourceConverter.cs,DetectEncoding,The following statement contains a magic number: if (data.Length >= 3 && data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF)                  return Encoding.UTF8;
Magic Number,SymbolSource.Processing.Basic,SourceConverter,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\SourceConverter.cs,DetectEncoding,The following statement contains a magic number: if (data.Length >= 3 && data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF)                  return Encoding.UTF8;
Magic Number,SymbolSource.Processing.Basic,SourceConverter,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\SourceConverter.cs,DetectEncoding,The following statement contains a magic number: if (data.Length >= 2 && data[0] == 0xFF && data[1] == 0xFE)                  return Encoding.Unicode;
Magic Number,SymbolSource.Processing.Basic,SourceConverter,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\SourceConverter.cs,DetectEncoding,The following statement contains a magic number: if (data.Length >= 2 && data[0] == 0xFE && data[1] == 0xFF)                  return Encoding.BigEndianUnicode;
Magic Number,SymbolSource.Processing.Basic,PdbRwInternal,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\SymbolStoreManager.cs,ReadHash,The following statement contains a magic number: using (var read = File.Open(pdbFileHash' FileMode.Open))                  {                      PdbFileHeader head = new PdbFileHeader(read' bits);                      PdbReader reader = new PdbReader(read' head.pageSize);                      MsfDirectory dir = new MsfDirectory(reader' head' bits);                        bits.MinCapacity(28);                      reader.Seek(dir.streams[1].pages[0]' 0);                      reader.Read(bits.Buffer' 0' 28);                        int ver;                      int sig;                      int age;                      Guid guid;                      bits.ReadInt32(out ver); //  0..3  Version                      bits.ReadInt32(out sig); //  4..7  Signature                      bits.ReadInt32(out age); //  8..11 Age                      bits.ReadGuid(out guid); // 12..27 GUID                      return (guid.ToString("N") + age.ToString("x")).ToUpper();                  }
Magic Number,SymbolSource.Processing.Basic,PdbRwInternal,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\SymbolStoreManager.cs,ReadHash,The following statement contains a magic number: using (var read = File.Open(pdbFileHash' FileMode.Open))                  {                      PdbFileHeader head = new PdbFileHeader(read' bits);                      PdbReader reader = new PdbReader(read' head.pageSize);                      MsfDirectory dir = new MsfDirectory(reader' head' bits);                        bits.MinCapacity(28);                      reader.Seek(dir.streams[1].pages[0]' 0);                      reader.Read(bits.Buffer' 0' 28);                        int ver;                      int sig;                      int age;                      Guid guid;                      bits.ReadInt32(out ver); //  0..3  Version                      bits.ReadInt32(out sig); //  4..7  Signature                      bits.ReadInt32(out age); //  8..11 Age                      bits.ReadGuid(out guid); // 12..27 GUID                      return (guid.ToString("N") + age.ToString("x")).ToUpper();                  }
Magic Number,SymbolSource.Processing.Basic,PdbRwInternal,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\SymbolStoreManager.cs,WriteHash,The following statement contains a magic number: Guid guid = new Guid(hash.Remove(32));
Magic Number,SymbolSource.Processing.Basic,PdbRwInternal,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\SymbolStoreManager.cs,WriteHash,The following statement contains a magic number: int age = int.Parse(hash.Substring(32)' NumberStyles.HexNumber);
Magic Number,SymbolSource.Processing.Basic,PdbRwInternal,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\SymbolStoreManager.cs,WriteHash,The following statement contains a magic number: using (var read = File.Open(pdbFileHash' FileMode.Open))                  {                      PdbFileHeader head = new PdbFileHeader(read' bits);                      PdbReader reader = new PdbReader(read' head.pageSize);                      MsfDirectory dir = new MsfDirectory(reader' head' bits);                        reader.Seek(dir.streams[1].pages[0]' 8); //bo przeskakujemy 8 znakσw na ver i sig                        using (BinaryWriter writer = new BinaryWriter(read))                      {                          writer.Write(age);                          writer.Write(guid.ToByteArray());                      }                  }
Magic Number,Internal,BinaryStoreManager,C:\repos\SymbolSource_SymbolSource.Community\Sources\SymbolSource.Processing.Basic\BinaryStoreManager.cs,ReadPdbHash,The following statement contains a magic number: if (debugDirectory.PointerToRawData > 0)              {                  using (var fileStream = File.Open(binaryFilePath' FileMode.Open))                  using (var codeViewReader = new BinaryReader(fileStream))                  {                      fileStream.Position = debugDirectory.PointerToRawData;                      uint codeViewVersion = codeViewReader.ReadUInt32();                      if (codeViewVersion == 0x53445352) //RSRS                      {                          var pdbSignature = new Guid(codeViewReader.ReadBytes(16));                          uint pdbAge = codeViewReader.ReadUInt32();                          string pdbFilePath = ReadZeroTerminatedString(codeViewReader);                          return (pdbSignature.ToString("N") + pdbAge.ToString("x")).ToUpper();                      }                  }              }
