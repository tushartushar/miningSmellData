Implementation smell,Namespace,Class,File,Method,Description
Long Method,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,CheckForIntersect,The method has 146 lines of code.
Long Method,Xbim.Tessellator,XbimTessellator,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTessellator.cs,MeshPolyhedronBinary,The method has 154 lines of code.
Long Method,Xbim.Tessellator,XbimTriangulatedMesh,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTriangulatedMesh.cs,BalanceNormals,The method has 106 lines of code.
Complex Method,Xbim.Tessellator,Geom,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Geom.cs,EdgeIntersect,Cyclomatic complexity of the method is 15
Complex Method,Xbim.Tessellator,Mesh,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Mesh.cs,MergeConvexFaces,Cyclomatic complexity of the method is 8
Complex Method,Xbim.Tessellator,PriorityQueue<TValue>,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\PriorityQueue.cs,Init,Cyclomatic complexity of the method is 8
Complex Method,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,CheckForIntersect,Cyclomatic complexity of the method is 15
Complex Method,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,WalkDirtyRegions,Cyclomatic complexity of the method is 13
Complex Method,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,ComputeNormal,Cyclomatic complexity of the method is 14
Complex Method,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,ProjectPolygon,Cyclomatic complexity of the method is 10
Complex Method,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,TessellateMonoRegion,Cyclomatic complexity of the method is 8
Complex Method,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,OutputPolymesh,Cyclomatic complexity of the method is 14
Complex Method,Xbim.Tessellator,XbimTessellator,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTessellator.cs,MeshPolyhedronBinary,Cyclomatic complexity of the method is 20
Complex Method,Xbim.Tessellator,XbimTessellator,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTessellator.cs,MeshPolyhedronText,Cyclomatic complexity of the method is 11
Complex Method,Xbim.Tessellator,XbimTessellator,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTessellator.cs,MeshPolyhedronBinary,Cyclomatic complexity of the method is 14
Complex Method,Xbim.Tessellator,XbimTessellator,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTessellator.cs,TriangulateFaces,Cyclomatic complexity of the method is 14
Complex Method,Xbim.Tessellator,XbimTriangulatedMesh,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTriangulatedMesh.cs,BalanceNormals,Cyclomatic complexity of the method is 10
Long Parameter List,Xbim.Tessellator,Geom,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Geom.cs,EdgeIntersect,The method has 5 parameters. Parameters: o1' d1' o2' d2' v
Long Parameter List,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,AddRightEdges,The method has 5 parameters. Parameters: regUp' eFirst' eLast' eTopLeft' cleanUp
Long Parameter List,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,VertexWeights,The method has 5 parameters. Parameters: isect' org' dst' w0' w1
Long Parameter List,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,GetIntersectData,The method has 5 parameters. Parameters: isect' orgUp' dstUp' orgLo' dstLo
Long Statement,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,AddContour,The length of the statement  "                reverse = (forceOrientation == ContourOrientation.Clockwise && area < 0.0f) || (forceOrientation == ContourOrientation.CounterClockwise && area > 0.0f); " is 152.
Long Statement,Xbim.Tessellator,XbimTessellator,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTessellator.cs,Mesh,The length of the statement  "            return Mesh(shellBasedModel.SbsmBoundary' shellBasedModel.EntityLabel' (float)shellBasedModel.Model.ModelFactors.Precision); " is 124.
Long Statement,Xbim.Tessellator,XbimTessellator,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTessellator.cs,MeshPolyhedronBinary,The length of the statement  "                                var item = new List<IfcPositiveInteger>() { triangulation.PnIndex[i]' triangulation.PnIndex[i + 1]' triangulation.PnIndex[i + 2] }; " is 131.
Long Statement,Xbim.Tessellator,XbimTessellator,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTessellator.cs,MeshPolyhedronBinary,The length of the statement  "                        triangulation.Coordinates.CoordList.Select(c => c.AsTriplet()).Select(t => new XbimTriplet<IfcLengthMeasure> { A = t.A - origin.A' B = t.B - origin.B' C = t.C - origin.C }) : " is 174.
Long Statement,Xbim.Tessellator,XbimTessellator,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTessellator.cs,MeshPolyhedronBinary,The length of the statement  "                        shapeGeometry.BoundingBox = new XbimRect3D(bb.X - origin.X' bb.Y - origin.Y' bb.Z - origin.Z' bb.SizeX' bb.SizeY' bb.SizeZ); " is 124.
Long Statement,Xbim.Tessellator,XbimTessellator,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTessellator.cs,MeshPolyhedronBinary,The length of the statement  "                        var planar = (ushort.MaxValue != faceGroup.Key); //we have a mesh of faces that all have the same normals at their vertices " is 123.
Long Statement,Xbim.Tessellator,XbimTessellator,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTessellator.cs,MeshPolyhedronBinary,The length of the statement  "                    shapeGeometry.BoundingBox = new XbimRect3D(bb.X - origin.X' bb.Y - origin.Y' bb.Z - origin.Z' bb.SizeX' bb.SizeY' bb.SizeZ); " is 124.
Long Statement,Xbim.Tessellator,XbimTriangulatedMesh,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTriangulatedMesh.cs,UnifyFaceOrientation,The length of the statement  "                triangles = new List<XbimTriangleEdge[]> { new[] { xbimEdges[0]' xbimEdges[0].NextEdge' xbimEdges[0].NextEdge.NextEdge } }; " is 123.
Long Statement,Xbim.Tessellator,XbimTriangulatedMesh,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTriangulatedMesh.cs,FindExtremeTriangle,The length of the statement  "                            && !Vec3.Colinear(_vertices[edge.StartVertexIndex].Position' _vertices[edge.NextEdge.StartVertexIndex].Position' _vertices[edge.NextEdge.NextEdge.StartVertexIndex].Position)) " is 174.
Long Statement,Xbim.Tessellator,XbimTriangulatedMesh,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTriangulatedMesh.cs,BalanceNormals,The length of the statement  "            var edgesAtVertex = _faces.Values.SelectMany(el => el).SelectMany(e => e).Where(e => e != null).GroupBy(k => k.StartVertexIndex); " is 129.
Long Statement,Xbim.Tessellator,XbimTriangulatedMesh,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTriangulatedMesh.cs,BalanceNormals,The length of the statement  "                //they are all connected to each other so find the first sharp edge or the any one if none sharp' this stops a face being split " is 127.
Long Statement,Xbim.Tessellator,XbimTriangulatedMesh,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTriangulatedMesh.cs,BalanceNormals,The length of the statement  "                        while (nextConnectedEdgeCandidate != null && !visited.Contains(nextConnectedEdgeCandidate.EdgeId) && !nextConnectedEdgeCandidate.Normal.IsValid) //skip colinear triangles " is 170.
Long Statement,Xbim.Tessellator,XbimTriangulatedMesh,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTriangulatedMesh.cs,BalanceNormals,The length of the statement  "            _faces = _faces.Values.SelectMany(v => v).GroupBy(t=>ComputeTrianglePackedNormalInt(t)).ToDictionary(k=>k.Key'v=>v.ToList()); " is 125.
Complex Conditional,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,CheckForIntersect,The conditional expression  "(! Geom.VertEq(dstUp' _event)                  && Geom.EdgeSign(dstUp' _event' isect) >= 0.0f)                  || (! Geom.VertEq(dstLo' _event)                  && Geom.EdgeSign(dstLo' _event' isect) <= 0.0f )"  is complex.
Complex Conditional,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,WalkDirtyRegions,The conditional expression  "eUp.Dst != eLo.Dst                          && ! regUp.FixUpperEdge && ! regLo.FixUpperEdge                          && (eUp.Dst == _event || eLo.Dst == _event)"  is complex.
Magic Number,Xbim.Tessellator,Geom,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Geom.cs,IsWindingInside,The following statement contains a magic number: switch (rule)              {                  case WindingRule.EvenOdd:                      return (n & 1) == 1;                  case WindingRule.NonZero:                      return n != 0;                  case WindingRule.Positive:                      return n > 0;                  case WindingRule.Negative:                      return n < 0;                  case WindingRule.AbsGeqTwo:                      return n >= 2 || n <= -2;              }
Magic Number,Xbim.Tessellator,Geom,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Geom.cs,IsWindingInside,The following statement contains a magic number: switch (rule)              {                  case WindingRule.EvenOdd:                      return (n & 1) == 1;                  case WindingRule.NonZero:                      return n != 0;                  case WindingRule.Positive:                      return n > 0;                  case WindingRule.Negative:                      return n < 0;                  case WindingRule.AbsGeqTwo:                      return n >= 2 || n <= -2;              }
Magic Number,Xbim.Tessellator,Geom,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Geom.cs,Interpolate,The following statement contains a magic number: return ((a <= b) ? ((b == 0.0f) ? ((x+y) / 2.0f)  // ReSharper restore CompareOfFloatsByEqualityOperator                      : (x + (y-x) * (a/(a+b))))                      : (y + (x-y) * (b/(a+b))));
Magic Number,Xbim.Tessellator,Geom,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Geom.cs,EdgeIntersect,The following statement contains a magic number: v._s = (o2._s + d1._s) / 2.0f;
Magic Number,Xbim.Tessellator,Geom,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Geom.cs,EdgeIntersect,The following statement contains a magic number: v._t = (o2._t + d1._t) / 2.0f;
Magic Number,Xbim.Tessellator,Mesh,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Mesh.cs,MergeConvexFaces,The following statement contains a magic number: (curNv + symNv - 2) <= maxVertsPerFace
Magic Number,Xbim.Tessellator,Vec3EqualityComparer,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\MeshUtils.cs,Vec3EqualityComparer,The following statement contains a magic number: _gridDim = precision*10;
Magic Number,Xbim.Tessellator,Vec3EqualityComparer,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\MeshUtils.cs,GetHashCode,The following statement contains a magic number: var hash = (int)2166136261;
Magic Number,Xbim.Tessellator,Vec3EqualityComparer,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\MeshUtils.cs,GetHashCode,The following statement contains a magic number: hash = hash * 16777619 ^ xs.GetHashCode();
Magic Number,Xbim.Tessellator,Vec3EqualityComparer,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\MeshUtils.cs,GetHashCode,The following statement contains a magic number: hash = hash * 16777619 ^ ys.GetHashCode();
Magic Number,Xbim.Tessellator,Vec3EqualityComparer,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\MeshUtils.cs,GetHashCode,The following statement contains a magic number: hash = hash * 16777619 ^ zs.GetHashCode();
Magic Number,Xbim.Tessellator,Vec3,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\MeshUtils.cs,Angle,The following statement contains a magic number: cosinus > -0.70710678118655 && cosinus < 0.70710678118655
Magic Number,Xbim.Tessellator,Vec3,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\MeshUtils.cs,Angle,The following statement contains a magic number: cosinus > -0.70710678118655 && cosinus < 0.70710678118655
Magic Number,Xbim.Tessellator,Vec3,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\MeshUtils.cs,LongAxis,The following statement contains a magic number: i = 2;
Magic Number,Xbim.Tessellator,PriorityHeap<TValue>,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\PriorityHeap.cs,Insert,The following statement contains a magic number: (curr * 2) > _max
Magic Number,Xbim.Tessellator,PriorityQueue<TValue>,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\PriorityQueue.cs,Init,The following statement contains a magic number: uint seed = 2016473283;
Magic Number,Xbim.Tessellator,PriorityQueue<TValue>,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\PriorityQueue.cs,Init,The following statement contains a magic number: seed = seed * 1539415821 + 1;
Magic Number,Xbim.Tessellator,PriorityQueue<TValue>,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\PriorityQueue.cs,Init,The following statement contains a magic number: r > p + 10
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,VertexWeights,The following statement contains a magic number: w0 = 0.5f * t2 / (t1 + t2);
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,VertexWeights,The following statement contains a magic number: w1 = 0.5f * t1 / (t1 + t2);
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,InitPriorityQ,The following statement contains a magic number: vertexCount += 8;
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,ComputeNormal,The following statement contains a magic number: minVal[2] = v._coords.Z;
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,ComputeNormal,The following statement contains a magic number: minVert[2] = v;
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,ComputeNormal,The following statement contains a magic number: v._coords.Z < minVal[2]
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,ComputeNormal,The following statement contains a magic number: maxVal[2] = v._coords.Z;
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,ComputeNormal,The following statement contains a magic number: maxVert[2] = v;
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,ComputeNormal,The following statement contains a magic number: v._coords.Z > maxVal[2]
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,ComputeNormal,The following statement contains a magic number: i = 2;
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,ComputeNormal,The following statement contains a magic number: maxVal[2] - minVal[2] > maxVal[i] - minVal[i]
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,ComputeNormal,The following statement contains a magic number: maxVal[2] - minVal[2] > maxVal[i] - minVal[i]
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,ProjectPolygon,The following statement contains a magic number: _sUnit[(i + 1) % 3] = SUnitX;
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,ProjectPolygon,The following statement contains a magic number: _sUnit[(i + 2) % 3] = SUnitY;
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,ProjectPolygon,The following statement contains a magic number: _sUnit[(i + 2) % 3] = SUnitY;
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,ProjectPolygon,The following statement contains a magic number: _tUnit[(i + 1) % 3] = norm[i] > 0.0 ? -SUnitY : SUnitY;
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,ProjectPolygon,The following statement contains a magic number: _tUnit[(i + 2) % 3] = norm[i] > 0.0 ? SUnitX : -SUnitX;
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,ProjectPolygon,The following statement contains a magic number: _tUnit[(i + 2) % 3] = norm[i] > 0.0 ? SUnitX : -SUnitX;
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,OutputPolymesh,The following statement contains a magic number: polySize = 3;
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,OutputPolymesh,The following statement contains a magic number: polySize < 3
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,OutputPolymesh,The following statement contains a magic number: polySize > 3
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,OutputPolymesh,The following statement contains a magic number: maxFaceCount *= 2;
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,OutputContours,The following statement contains a magic number: _elements = new int[_elementCount * 2];
Magic Number,Xbim.Tessellator,Tess,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Sweep.cs,SignedArea,The following statement contains a magic number: return area * 0.5f;
Magic Number,Xbim.Tessellator,XbimCartesianPoint3dList,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimPolygonalFace.cs,XbimCartesianPoint3dList,The following statement contains a magic number: points.Add(new XbimCartesianPoint3D(pnt[0]' pnt[1]' pnt[2]));
Magic Number,Xbim.Tessellator,XbimTessellator,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTessellator.cs,IsLarge,The following statement contains a magic number: return coordinate > _model.ModelFactors.OneMilliMeter * 999999;
Magic Number,Xbim.Tessellator,XbimTessellator,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTessellator.cs,MeshPolyhedronText,The following statement contains a magic number: textWriter.WriteLine("P {0} {1} {2} {3} {4}"' 2' verticesCount' facesCount' triangleCount' 0);
Magic Number,Xbim.Tessellator,XbimTessellator,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTessellator.cs,TriangulateFaces,The following statement contains a magic number: polygon.Count < 3
Magic Number,Xbim.Tessellator,XbimTessellator,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTessellator.cs,TriangulateFaces,The following statement contains a magic number: var is3D = (polygon[0].Dim == 3);
Magic Number,Xbim.Tessellator,XbimTessellator,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTessellator.cs,TriangulateFaces,The following statement contains a magic number: triangulatedMesh.AddTriangle(contours[0][0].Data' contours[0][1].Data' contours[0][2].Data' faceId);
Magic Number,Xbim.Tessellator,XbimTessellator,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTessellator.cs,TriangulateFaces,The following statement contains a magic number: contours.Count == 1 && contours[0].Length == 3
Magic Number,Xbim.Tessellator,XbimTriangulatedMesh,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTriangulatedMesh.cs,XbimTriangulatedMesh,The following statement contains a magic number: var edgeCount = (int)(faceCount * 1.5);
Magic Number,Xbim.Tessellator,XbimTriangulatedMesh,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTriangulatedMesh.cs,AddEdge,The following statement contains a magic number: var arr = new XbimTriangleEdge[2];
Magic Number,Xbim.Tessellator,XbimTriangulatedMesh,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTriangulatedMesh.cs,FindExtremeTriangle,The following statement contains a magic number: isMax = p => Math.Abs(p.Position.X - _maxX) < 1e-9;
Magic Number,Xbim.Tessellator,XbimTriangulatedMesh,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTriangulatedMesh.cs,BalanceNormals,The following statement contains a magic number: const double minAngle = Math.PI / 5;
Magic Number,Xbim.Tessellator,XbimTriangulatedMesh,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTriangulatedMesh.cs,ComputeTrianglePackedNormalInt,The following statement contains a magic number: var pn2 = edges[2].PackedNormal.ToUnit16();
Magic Number,Xbim.Tessellator,XbimTriangulatedMesh,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTriangulatedMesh.cs,ComputeTriangleNormal,The following statement contains a magic number: edges[2].Normal = v;
Magic Number,Xbim.Tessellator,XbimTriangulatedMesh,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTriangulatedMesh.cs,IsFacingOutward,The following statement contains a magic number: var centroid = new XbimPoint3D((p1.X + p2.X + p3.X) / 3' (p1.Y + p2.Y + p3.Y) / 3' (p1.Z + p2.Z + p3.Z) / 3);
Magic Number,Xbim.Tessellator,XbimTriangulatedMesh,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTriangulatedMesh.cs,IsFacingOutward,The following statement contains a magic number: var centroid = new XbimPoint3D((p1.X + p2.X + p3.X) / 3' (p1.Y + p2.Y + p3.Y) / 3' (p1.Z + p2.Z + p3.Z) / 3);
Magic Number,Xbim.Tessellator,XbimTriangulatedMesh,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\XbimTriangulatedMesh.cs,IsFacingOutward,The following statement contains a magic number: var centroid = new XbimPoint3D((p1.X + p2.X + p3.X) / 3' (p1.Y + p2.Y + p3.Y) / 3' (p1.Z + p2.Z + p3.Z) / 3);
Missing Default,Xbim.Tessellator,Geom,D:\research\architectureSmells\repos\xBimTeam_XbimEssentials\Xbim.Tessellator\Geom.cs,IsWindingInside,The following switch statement is missing a default case: switch (rule)              {                  case WindingRule.EvenOdd:                      return (n & 1) == 1;                  case WindingRule.NonZero:                      return n != 0;                  case WindingRule.Positive:                      return n > 0;                  case WindingRule.Negative:                      return n < 0;                  case WindingRule.AbsGeqTwo:                      return n >= 2 || n <= -2;              }
