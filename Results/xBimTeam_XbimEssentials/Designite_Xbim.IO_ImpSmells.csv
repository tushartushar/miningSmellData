Implementation smell,Namespace,Class,File,Method,Description
Long Method,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,ImportStepZip,The method has 114 lines of code.
Long Method,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,InsertCopy,The method has 105 lines of code.
Long Method,Xbim.IO,ModelHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\ModelHelper.cs,InsertCopy,The method has 107 lines of code.
Long Method,Xbim.IO,PersistEntityExtensions,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\IPersistEntityExtensions.cs,WriteEntity,The method has 100 lines of code.
Long Method,Xbim.IO,PersistEntityExtensions,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\IPersistEntityExtensions.cs,WriteProperty,The method has 117 lines of code.
Long Method,Xbim.IO.Step21,Part21Writer,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Part21Writer.cs,WriteProperty,The method has 113 lines of code.
Long Method,Xbim.IO.Xml,XbimXmlReader4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlReader4.cs,SetPropertyFromElement,The method has 162 lines of code.
Long Method,Xbim.IO.Xml,IfcXmlReader,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,StartElement,The method has 152 lines of code.
Long Method,Xbim.IO.Xml,IfcXmlReader,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,EndElement,The method has 189 lines of code.
Long Method,Xbim.IO.Xml,IfcXmlReader,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,Read,The method has 146 lines of code.
Long Method,Xbim.IO.Xml,XbimXmlWriter4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlWriter4.cs,WriteProperty,The method has 150 lines of code.
Long Method,Xbim.IO.Xml,IfcXmlWriter3,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlWriter3.cs,WriteProperty,The method has 204 lines of code.
Long Method,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The method has 226 lines of code.
Long Method,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The method has 161 lines of code.
Long Method,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The method has 162 lines of code.
Complex Method,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,Validate,Cyclomatic complexity of the method is 11
Complex Method,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,GetSchemaError,Cyclomatic complexity of the method is 10
Complex Method,Xbim.IO,ModelHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\ModelHelper.cs,ReplaceReferences,Cyclomatic complexity of the method is 17
Complex Method,Xbim.IO,StringExtensions,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\StringExtensions.cs,StorageType,Cyclomatic complexity of the method is 9
Complex Method,Xbim.IO,FileReferenceResolver,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\FileReferenceResolver.cs,EvaluateRelativePath,Cyclomatic complexity of the method is 8
Complex Method,Xbim.IO.Xml,XbimXmlReader4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlReader4.cs,ReadEntity,Cyclomatic complexity of the method is 12
Complex Method,Xbim.IO.Xml,XbimXmlReader4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlReader4.cs,SetPropertyFromElement,Cyclomatic complexity of the method is 34
Complex Method,Xbim.IO.Xml,XbimXmlReader4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlReader4.cs,SetPropertyFromString,Cyclomatic complexity of the method is 16
Complex Method,Xbim.IO.Xml,XbimXmlReader4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlReader4.cs,ReadSchemaVersion,Cyclomatic complexity of the method is 8
Complex Method,Xbim.IO.Xml,XmlMetaProperty,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XmlMetaProperty.cs,SetAttributeValueHandler,Cyclomatic complexity of the method is 8
Complex Method,Xbim.IO.Xml,IfcXmlReader,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,EndElement,Cyclomatic complexity of the method is 9
Complex Method,Xbim.IO.Xml,XbimXmlWriter4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlWriter4.cs,WriteHeader,Cyclomatic complexity of the method is 9
Complex Method,Xbim.IO.Xml,XbimXmlWriter4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlWriter4.cs,WriteProperty,Cyclomatic complexity of the method is 20
Complex Method,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,Cyclomatic complexity of the method is 8
Long Parameter List,Xbim.IO.Esent,XbimGeometryHandle,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryHandle.cs,XbimGeometryHandle,The method has 6 parameters. Parameters: geometryLabel' geometryType' productLabel' expressTypeId' surfaceStyleLabel' geometryHashCode
Long Parameter List,Xbim.IO.Esent,XbimGeometryHandle,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryHandle.cs,XbimGeometryHandle,The method has 5 parameters. Parameters: geometryLabel' geometryType' productLabel' expressTypeId' surfaceStyleLabel
Long Parameter List,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,ImportIfcXml,The method has 5 parameters. Parameters: xbimDbName' xmlFilename' progressHandler' keepOpen' cacheEntities
Long Parameter List,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,ImportIfcXml,The method has 5 parameters. Parameters: xbimDbName' inputStream' progressHandler' keepOpen' cacheEntities
Long Parameter List,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,ImportStep,The method has 6 parameters. Parameters: xbimDbName' toImportIfcFilename' progressHandler' keepOpen' cacheEntities' codePageOverride
Long Parameter List,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,ImportStep,The method has 7 parameters. Parameters: xbimDbName' stream' streamSize' progressHandler' keepOpen' cacheEntities' codePageOverride
Long Parameter List,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,ImportStepZip,The method has 6 parameters. Parameters: xbimDbName' toImportFilename' progressHandler' keepOpen' cacheEntities' codePageOverride
Long Parameter List,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,ImportStepZip,The method has 6 parameters. Parameters: xbimDbName' fileStream' progressHandler' keepOpen' cacheEntities' codePageOverride
Long Parameter List,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,InsertCopy,The method has 6 parameters. Parameters: toCopy' mappings' txn' includeInverses' propTransform' keepLabels
Long Parameter List,Xbim.IO.Esent,P21ToIndexParser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimP21Indexer.cs,P21ToIndexParser,The method has 5 parameters. Parameters: inputP21' streamSize' table' cache' codePageOverride
Long Parameter List,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,UpdateEntity,The method has 5 parameters. Parameters: currentLabel' typeId' indexKeys' data' indexed
Long Parameter List,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,AddEntity,The method has 6 parameters. Parameters: currentLabel' typeId' indexKeys' data' indexed' trans
Long Parameter List,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,AddGeometry,The method has 8 parameters. Parameters: prodLabel' type' expressType' transform' shapeData' subPart' styleLabel' geometryHash
Long Parameter List,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,AddMapGeometry,The method has 5 parameters. Parameters: geomId' prodLabel' expressType' transform' styleLabel
Long Parameter List,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,CreateFrom,The method has 6 parameters. Parameters: importFrom' xbimDbName' progDelegate' keepOpen' cacheEntities' storageType
Long Parameter List,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,CreateFrom,The method has 7 parameters. Parameters: inputStream' streamSize' streamType' xbimDbName' progDelegate' keepOpen' cacheEntities
Long Parameter List,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,InsertCopy,The method has 5 parameters. Parameters: toCopy' mappings' txn' propTransform' includeInverses
Long Parameter List,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,InsertCopy,The method has 5 parameters. Parameters: toCopy' mappings' propTransform' includeInverses' keepLabels
Long Parameter List,Xbim.IO.Esent,XbimReadTransaction,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimReadTransaction.cs,DoReversibleAction,The method has 5 parameters. Parameters: doAction' undoAction' entity' changeType' property
Long Parameter List,Xbim.IO.Esent,XbimReadWriteTransaction,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimReadWriteTransaction.cs,DoReversibleAction,The method has 5 parameters. Parameters: doAction' undoAction' entity' changeType' property
Long Parameter List,Xbim.IO.Esent,EsentShapeInstanceCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeInstanceCursor.cs,AddInstance,The method has 7 parameters. Parameters: ctxtId' shapeLabel' styleLabel' typeId' productLabel' repType' transform
Long Parameter List,Xbim.IO,ModelHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\ModelHelper.cs,InsertCopy,The method has 7 parameters. Parameters: model' toCopy' mappings' propTransform' includeInverses' keepLabels' getLabeledEntity
Long Parameter List,Xbim.IO,PersistEntityExtensions,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\IPersistEntityExtensions.cs,ReadEntityProperties,The method has 5 parameters. Parameters: entity' cache' br' unCached' fromCache
Long Parameter List,Xbim.IO.Memory,MemoryModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Memory\MemoryModel.cs,SaveAsXml,The method has 5 parameters. Parameters: stream' xmlSettings' xbimSettings' configuration' progress
Long Parameter List,Xbim.IO.Memory,MemoryModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Memory\MemoryModel.cs,SaveAsXMLZip,The method has 5 parameters. Parameters: stream' xmlSettings' xbimSettings' configuration' progress
Long Parameter List,Xbim.IO.Memory,MemoryModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Memory\MemoryModel.cs,InsertCopy,The method has 5 parameters. Parameters: toCopy' mappings' propTransform' includeInverses' keepLabels
Long Parameter List,Xbim.IO.Memory,MemoryModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Memory\MemoryModel.cs,InsertCopy,The method has 6 parameters. Parameters: toCopy' mappings' propTransform' includeInverses' keepLabels' noTransaction
Long Parameter List,Xbim.IO.Memory,Transaction,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Memory\Transaction.cs,DoReversibleAction,The method has 5 parameters. Parameters: doAction' undoAction' entity' changeType' propertyOrder
Long Parameter List,Xbim.IO.Step21,Part21Writer,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Part21Writer.cs,WriteProperty,The method has 5 parameters. Parameters: propType' propVal' output' map' metadata
Long Parameter List,Xbim.IO.Xml,XbimXmlReader4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlReader4.cs,SetPropertyFromElement,The method has 5 parameters. Parameters: property' entity' input' pos' valueType
Long Parameter List,Xbim.IO.Xml,XbimXmlReader4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlReader4.cs,SetPropertyFromString,The method has 5 parameters. Parameters: property' entity' value' pos' valueType
Long Parameter List,Xbim.IO.Xml,XbimXmlWriter4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlWriter4.cs,WriteEntity,The method has 5 parameters. Parameters: entity' output' onlyOnce' pos' name
Long Parameter List,Xbim.IO.Xml,XbimXmlWriter4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlWriter4.cs,WriteProperty,The method has 7 parameters. Parameters: propName' propType' propVal' output' pos' attr' wrap
Long Parameter List,Xbim.IO.Xml,IfcXmlWriter3,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlWriter3.cs,WriteProperty,The method has 7 parameters. Parameters: propName' propType' propVal' entity' output' pos' attr
Long Identifier,Xbim.IO.Xml.BsConf,attribute,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\BsConf\cnf.designer.cs,,The length of the parameter aggregatecontentFieldSpecified is 30.
Long Identifier,Xbim.IO.Xml.BsConf,schema,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\BsConf\cnf.designer.cs,,The length of the parameter elementFormDefaultFieldSpecified is 32.
Long Identifier,Xbim.IO.Xml.BsConf,schema,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\BsConf\cnf.designer.cs,,The length of the parameter attributeFormDefaultFieldSpecified is 34.
Long Statement,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,AttachedDatabase,The length of the statement  "                                Api.JetAttachDatabase(_session' _databaseName' openMode == OpenDatabaseGrbit.ReadOnly ? AttachDatabaseGrbit.ReadOnly : AttachDatabaseGrbit.None); " is 145.
Long Statement,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,Close,The length of the statement  "                refCount = OpenInstances.Count(c => string.Compare(c.DatabaseName' DatabaseName' StringComparison.OrdinalIgnoreCase) == 0); " is 123.
Long Statement,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,GetXbimTempDirectory,The length of the statement  "                        throw new XbimException("Unable to initialise the Xbim database engine' no write access. Please set a location for the XbimTempDirectory in the config file"); " is 158.
Long Statement,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,GetOrCreateInstanceFromCache,The length of the statement  "                EsentModel.Logger.ErrorFormat("Illegal Entity in the model #{0}' Type {1} is defined as Abstract and cannot be created"' label' type.Name); " is 139.
Long Statement,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,GetInstanceFromStore,The length of the statement  "                        if (currentIfcTypeId == 0) // this should never happen (there's a test for it' but old xbim files might be incorrectly identified) " is 130.
Long Statement,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,Dispose,The length of the statement  "                            //TODO: MC: Check this with Steve. System path was obtained from private field before and was deleted even if the instance wasn't terminated. That didn't seem to be right. " is 171.
Long Statement,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,Where,The length of the statement  "                expressTypes = implementations.Where(implementation => !implementations.Any(i => i != implementation && i.NonAbstractSubTypes.Contains(implementation))).ToList(); " is 162.
Long Statement,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,InsertCopy,The length of the statement  "                    prop.PropertyInfo.SetValue(theCopy' InsertCopy((IPersistEntity)value' mappings' txn' includeInverses' propTransform' keepLabels)' null); " is 136.
Long Statement,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,InsertCopy,The length of the statement  "                            if (getAt == null) throw new Exception(string.Format("GetAt Method not found on ({0}) found"' copyColl.GetType().Name)); " is 120.
Long Statement,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,AddModified,The length of the statement  "            //        throw new XbimException("An attempt to edit a duplicate reference for #" + entity.EntityLabel + " error has occurred"); " is 129.
Long Statement,Xbim.IO.Esent,P21ToIndexParser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimP21Indexer.cs,EndEntity,The length of the statement  "                _toStore.Add(new Tuple<int' short' List<int>' byte[]' bool>(_currentLabel' type.TypeId' keys' bytes' type.IndexedClass)); " is 121.
Long Statement,Xbim.IO.Esent,P21ToIndexParser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimP21Indexer.cs,SetObjectValue,The length of the statement  "            if (_indexKeys != null && _indexKeys.Contains(_currentInstance.CurrentParamIndex + 1)) //current param index is 0 based and ifcKey is 1 based " is 141.
Long Statement,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,CreateTable,The length of the statement  "                Api.JetCreateIndex(sesid' tableid' entityTableLabelIndex' CreateIndexGrbit.IndexPrimary' labelIndexDef' labelIndexDef.Length' 100); " is 131.
Long Statement,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,CreateTable,The length of the statement  "                Api.JetCreateIndex(sesid' tableid' entityTableLabelIndex' CreateIndexGrbit.IndexPrimary' labelIndexDef' labelIndexDef.Length' 100); " is 131.
Long Statement,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,UpdateEntity,The length of the statement  "            UpdateEntity(toWrite.EntityLabel' expressType.TypeId' expressType.GetIndexedValues(toWrite)' ms.ToArray()' expressType.IndexedClass); " is 133.
Long Statement,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,UpdateEntity,The length of the statement  "                if (!TrySeekEntityLabel(currentLabel)) throw new XbimException("Attempt to update an entity that does not exist in the model"); " is 127.
Long Statement,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,UpdateEntity,The length of the statement  "                //TODO delete any existing keys' not strictly necessary as the search engine checks the compliance of every entity with the search criteria after retrieval " is 155.
Long Statement,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,AddEntity,The length of the statement  "            AddEntity(toWrite.EntityLabel' expressType.TypeId' expressType.GetIndexedValues(toWrite)' ms.ToArray()' expressType.IndexedClass); " is 130.
Long Statement,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,TrySeekEntityType,The length of the statement  "                    ih = new XbimInstanceHandle(Model' Api.RetrieveColumnAsInt32(Sesid' _indexTable' _colIdIdxEntityLabel' RetrieveColumnGrbit.RetrieveFromIndex)' Api.RetrieveColumnAsInt16(Sesid' _indexTable' _colIdIdxIfcType' RetrieveColumnGrbit.RetrieveFromIndex)); " is 247.
Long Statement,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,TrySeekEntityType,The length of the statement  "                return Api.TrySetIndexRange(Sesid' _indexTable' SetIndexRangeGrbit.RangeUpperLimit | SetIndexRangeGrbit.RangeInclusive); " is 120.
Long Statement,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,TryMoveNextEntityType,The length of the statement  "                ih = new XbimInstanceHandle(Model' Api.RetrieveColumnAsInt32(Sesid' _indexTable' _colIdIdxEntityLabel' RetrieveColumnGrbit.RetrieveFromIndex)' Api.RetrieveColumnAsInt16(Sesid' _indexTable' _colIdIdxIfcType' RetrieveColumnGrbit.RetrieveFromIndex)); " is 247.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,CreateTable,The length of the statement  "                Api.JetCreateIndex(sesid' tableid' GeometryTablePrimaryIndex' CreateIndexGrbit.IndexPrimary' indexDef' indexDef.Length' 100); " is 125.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,CreateTable,The length of the statement  "                Api.JetCreateIndex(sesid' tableid' GeometryTableHashIndex' CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100); " is 127.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,CreateTable,The length of the statement  "                indexDef = string.Format("+{0}\0{1}\0{2}\0{3}\0{4}\0\0"' ColNameGeomType' ColNameProductIfcTypeId' ColNameProductLabel' ColNameSubPart' ColNameStyleLabel); " is 155.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,CreateTable,The length of the statement  "                Api.JetCreateIndex(sesid' tableid' GeometryTableGeomTypeIndex' CreateIndexGrbit.IndexUnique' indexDef' indexDef.Length' 100); " is 125.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,CreateTable,The length of the statement  "                indexDef = string.Format("+{0}\0{1}\0{2}\0{3}\0{4}\0\0"' ColNameGeomType' ColNameStyleLabel' ColNameProductIfcTypeId' ColNameProductLabel' ColNameGeometryLabel); " is 161.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,InitColumns,The length of the statement  "            _colValues = new ColumnValue[] { _colValGeomType' _colValProductLabel' _colValProductIfcTypeId' _colValSubPart' _colValTransformMatrix' _colValShapeData' _colValGeometryHash ' _colValStyleLabel}; " is 195.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,AddGeometry,The length of the statement  "                //     _colValStyleLabel.Value = -expressType; //use the negative type id as a style for object that have no render material " is 124.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,AddMapGeometry,The length of the statement  "                        Api.SetColumn(Sesid' Table' _colIdStyleLabel' -expressType); //use the negative type id as a style for object that have no render material " is 138.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,AddMapGeometry,The length of the statement  "                    geomType = (XbimGeometryType)Api.RetrieveColumnAsByte(Sesid' Table' _colIdGeomType' RetrieveColumnGrbit.RetrieveCopy).Value; " is 124.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,AddMapGeometry,The length of the statement  "                                Api.SetColumn(sesid' table' _colIdStyleLabel' -expressType); //use the negative type id as a style for object that have no render material " is 138.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,GeometryData,The length of the statement  "                        yield return new XbimGeometryData(_colValGeometryLabel.Value.Value' productLabel' (XbimGeometryType)_colValGeomType.Value' _colValProductIfcTypeId.Value.Value' _colValShapeData.Value' _colValTransformMatrix.Value' _colValGeometryHash.Value.Value' _colValStyleLabel.Value.HasValue ? _colValStyleLabel.Value.Value : 0' _colValSubPart.Value.HasValue ? _colValSubPart.Value.Value : 0); " is 381.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,GetGeometryData,The length of the statement  "                        yield return new XbimGeometryData(_colValGeometryLabel.Value.Value' _colValProductLabel.Value.Value' (XbimGeometryType)_colValGeomType.Value' _colValProductIfcTypeId.Value.Value' _colValShapeData.Value' _colValTransformMatrix.Value' _colValGeometryHash.Value.Value' _colValStyleLabel.Value.HasValue ? _colValStyleLabel.Value.Value : 0' _colValSubPart.Value.HasValue ? _colValSubPart.Value.Value : 0); " is 400.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,GetGeometryHandlesById,The length of the statement  "                        result.Add(new XbimGeometryHandle(geomId.Value' geomType' product.Value' expressType.Value' style.Value' hashId.Value)); " is 120.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,GetGeometryHandlesByIfcType,The length of the statement  "                        var expressType = Api.RetrieveColumnAsInt16(Sesid' Table' _colIdProductIfcTypeId' RetrieveColumnGrbit.RetrieveFromIndex); " is 121.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,GetGeometryHandlesByIfcType,The length of the statement  "                        result.Add(new XbimGeometryHandle(geomId.Value' geomType' product.Value' expressType.Value' style.Value' geomId.Value)); " is 120.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,GetGeometryHandlesBySurfaceStyle,The length of the statement  "                        var expressType = Api.RetrieveColumnAsInt16(Sesid' Table' _colIdProductIfcTypeId' RetrieveColumnGrbit.RetrieveFromIndex); " is 121.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,GetGeometryHandle,The length of the statement  "                return new XbimGeometryHandle(geometryLabel' (XbimGeometryType)geomType.Value' product.Value' expressType.Value' style.Value' geomHash.Value); " is 142.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,GetGeometryData,The length of the statement  "                return new XbimGeometryData(_colValGeometryLabel.Value.Value' _colValProductLabel.Value.Value' (XbimGeometryType)_colValGeomType.Value' _colValProductIfcTypeId.Value.Value' _colValShapeData.Value' _colValTransformMatrix.Value' _colValGeometryHash.Value.Value' _colValStyleLabel.Value.HasValue ? _colValStyleLabel.Value.Value : 0' _colValSubPart.Value.HasValue ? _colValSubPart.Value.Value : 0); " is 394.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,GetGeometryData,The length of the statement  "                    yield return new XbimGeometryData(_colValGeometryLabel.Value.Value' _colValProductLabel.Value.Value' (XbimGeometryType)_colValGeomType.Value' _colValProductIfcTypeId.Value.Value' _colValShapeData.Value' _colValTransformMatrix.Value' _colValGeometryHash.Value.Value' _colValStyleLabel.Value.HasValue ? _colValStyleLabel.Value.Value : 0' _colValSubPart.Value.HasValue ? _colValSubPart.Value.Value : 0); " is 400.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,GetGeometryData,The length of the statement  "                return new XbimGeometryData(geomLabel' _colValProductLabel.Value.Value' (XbimGeometryType)_colValGeomType.Value' _colValProductIfcTypeId.Value.Value' _colValShapeData.Value' _colValTransformMatrix.Value' _colValGeometryHash.Value.Value' _colValStyleLabel.Value.HasValue ? _colValStyleLabel.Value.Value : 0' _colValSubPart.Value.HasValue ? _colValSubPart.Value.Value : 0); " is 371.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,UpdateReferenceCount,The length of the statement  "                    Api.SetColumn(Sesid' Table' _colIdSubPart' count); //change the order variable to hold the number of references to this object " is 126.
Long Statement,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,GeometryData,The length of the statement  "                        yield return new XbimGeometryData(_colValGeometryLabel.Value.Value' _colValProductLabel.Value.Value' (XbimGeometryType)_colValGeomType.Value' _colValProductIfcTypeId.Value.Value' _colValShapeData.Value' _colValTransformMatrix.Value' _colValGeometryHash.Value.Value' _colValStyleLabel.Value.HasValue ? _colValStyleLabel.Value.Value : 0' _colValSubPart.Value.HasValue ? _colValSubPart.Value.Value : 0); " is 400.
Long Statement,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,Activate,The length of the statement  "                throw new XbimInitializationFailedException(string.Format("Failed to activate #{0}={1}"' entity.EntityLabel' entity.ExpressType.ExpressNameUpper)' e); " is 150.
Long Statement,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,CreateFrom,The length of the statement  "                    InstanceCache.ImportStepZip(xbimDbName' importFrom' progDelegate' keepOpen' cacheEntities' _codePageOverrideForStepFiles); " is 122.
Long Statement,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,CreateFrom,The length of the statement  "                Cache.ImportStep(xbimDbName' inputStream' streamSize' progDelegate' keepOpen' cacheEntities' _codePageOverrideForStepFiles); " is 124.
Long Statement,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,CreateModel,The length of the statement  "                model.Header = new StepFileHeader(StepFileHeader.HeaderCreationMode.InitWithXbimDefaults) { FileName = { Name = dbFileName } }; " is 127.
Long Statement,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,GetGeometryData,The length of the statement  "            // identity needs instead to be tested at the model level of children first' then call this function on the matching child. " is 123.
Long Statement,Xbim.IO.Esent,EsentShapeGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeGeometryCursor.cs,InitColumns,The length of the statement  "            _colValues = new ColumnValue[] { _colValIfcShapeLabel' _colValGeometryHash' _colValCost' _colValReferenceCount' _colValLOD' _colValFormat'_colValBoundingBox'_colValShapeData }; " is 176.
Long Statement,Xbim.IO.Esent,EsentShapeGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeGeometryCursor.cs,CreateTable,The length of the statement  "                Api.JetCreateIndex(sesid' tableid' geometryTablePrimaryIndex' CreateIndexGrbit.IndexPrimary|CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100); " is 160.
Long Statement,Xbim.IO.Esent,EsentShapeGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeGeometryCursor.cs,UpdateReferenceCount,The length of the statement  "                    Api.SetColumn(Sesid' Table' _colIdReferenceCount' refCount); //change the order variable to hold the number of references to this object " is 136.
Long Statement,Xbim.IO.Esent,EsentShapeGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeGeometryCursor.cs,GetReferenceCount,The length of the statement  "                var refCount = Api.RetrieveColumnAsInt32(Sesid' Table' _colIdReferenceCount'RetrieveColumnGrbit.RetrieveFromIndex).Value; " is 121.
Long Statement,Xbim.IO.Esent,EsentShapeInstanceCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeInstanceCursor.cs,InitColumns,The length of the statement  "            _colValues = new ColumnValue[] { _colValIfcTypeId' _colValIfcProductLabel' _colValStyleLabel' _colValShapeLabel' _colValRepresentationContext' _colValRepType' _colValTransformation'_colValBoundingBox' }; " is 203.
Long Statement,Xbim.IO.Esent,EsentShapeInstanceCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeInstanceCursor.cs,CreateTable,The length of the statement  "                Api.JetCreateIndex(sesid' tableid' geometryShapeIndex' CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100); " is 123.
Long Statement,Xbim.IO.Esent,EsentShapeInstanceCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeInstanceCursor.cs,CreateTable,The length of the statement  "                Api.JetCreateIndex(sesid' tableid' productTypeIndex' CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100); " is 121.
Long Statement,Xbim.IO.Esent,EsentShapeInstanceCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeInstanceCursor.cs,CreateTable,The length of the statement  "                indexDef = string.Format("+{0}\0{1}\0{2}\0{3}\0\0"' colNameRepresentationContext' colNameStyleLabel' colNameIfcTypeId'  colNameInstanceLabel); " is 142.
Long Statement,Xbim.IO.Esent,EsentShapeInstanceCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeInstanceCursor.cs,CreateTable,The length of the statement  "                Api.JetCreateIndex(sesid' tableid' instanceTablePrimaryIndex' CreateIndexGrbit.IndexPrimary' indexDef' indexDef.Length' 100); " is 125.
Long Statement,Xbim.IO,ModelHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\ModelHelper.cs,Replace,The length of the statement  "                throw new XbimException("It isn't possible to replace entities from different models. Insert copy of the entity first."); " is 121.
Long Statement,Xbim.IO,ModelHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\ModelHelper.cs,GetReferingTypes,The length of the statement  "                referingTypes.Add(new ReferingType { Type = type' SingleReferences = singleReferences' ListReferences = listReferences }); " is 122.
Long Statement,Xbim.IO,ModelHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\ModelHelper.cs,InsertCopy,The length of the statement  "                            InsertCopy(model' (IPersistEntity)value' mappings' propTransform' includeInverses' keepLabels' getLabeledEntity)' null); " is 120.
Long Statement,Xbim.IO,ModelHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\ModelHelper.cs,InsertCopy,The length of the statement  "                                if (getAt == null) throw new Exception(string.Format("GetAt Method not found on ({0}) found"' copyColl.GetType().Name)); " is 120.
Long Statement,Xbim.IO,PersistEntityExtensions,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\IPersistEntityExtensions.cs,ReadEntityProperties,The length of the statement  "                            if (!parserState.InList && cache.Read.TryGetValue(label' out refEntity)) //if we are in a list then make a forward reference anyway to make sure we maintain list order " is 167.
Long Statement,Xbim.IO,PersistEntityExtensions,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\IPersistEntityExtensions.cs,ReadEntityProperties,The length of the statement  "                                cache.AddForwardReference(new StepForwardReference(label' parserState.CurrentPropertyId' entity'parserState.NestedIndex)); " is 122.
Long Statement,Xbim.IO,PersistEntityExtensions,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\IPersistEntityExtensions.cs,ReadEntityProperties,The length of the statement  "                            if (!parserState.InList && cache.Read.TryGetValue(label' out refEntity)) //if we are in a list then make a forward reference anyway to make sure we maintain list order " is 167.
Long Statement,Xbim.IO,PersistEntityExtensions,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\IPersistEntityExtensions.cs,ReadEntityProperties,The length of the statement  "                                cache.AddForwardReference(new StepForwardReference(label' parserState.CurrentPropertyId' entity' parserState.NestedIndex)); " is 123.
Long Statement,Xbim.IO.Memory,InMemoryGeometryStore,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Memory\InMemoryGeometryStore.cs,EndInit,The length of the statement  "            _entityStyleLookup = ShapeInstances.GroupBy(s => s.Value.StyleLabel>0?s.Value.StyleLabel:-s.Value.IfcTypeId).ToDictionary(s => s.Key' v => " is 138.
Long Statement,Xbim.IO.Memory,MemoryModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Memory\MemoryModel.cs,LoadStep21,The length of the statement  "                        var sid = _instances.Factory.SchemasIds.FirstOrDefault(s => string.Equals(s' id' StringComparison.InvariantCultureIgnoreCase)); " is 127.
Long Statement,Xbim.IO.Step21.Parser,StepForwardReference,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\StepForwardReference.cs,Resolve,The length of the statement  "                    EsentModel.Logger.ErrorFormat("Data Error. Cannot set the property = {0} of entity #{1} = {2} to entity #{3}' schema violation. Ignored"'  " is 137.
Long Statement,Xbim.IO.Step21,StepText,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepTextHelper.cs,ToPart21,The length of the statement  "                    // boundaries according to specs from http://www.buildingsmart-tech.org/downloads/accompanying-documents/guidelines/IFC2x%20Model%20Implementation%20Guide%20V2-0b.pdf " is 166.
Long Statement,Xbim.IO.Step21,Part21Writer,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Part21Writer.cs,Write,The length of the statement  "                    var eft = instance.GetType().Assembly.GetTypes().Where(t => typeof(IEntityFactory).IsAssignableFrom(t)).FirstOrDefault(); " is 121.
Long Statement,Xbim.IO.Step21,Part21Writer,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Part21Writer.cs,WriteHeader,The length of the statement  "            output.Write(@"'{0}'"' (header.FileName != null && header.FileName.Name != null) ? header.FileName.Name.ToPart21() : ""); " is 121.
Long Statement,Xbim.IO.Step21,Part21Writer,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Part21Writer.cs,WriteHeader,The length of the statement  "                output.Write(@")' '{0}'' '{1}'' '{2}');"' header.FileName.PreprocessorVersion.ToPart21()' header.FileName.OriginatingSystem.ToPart21()' " is 135.
Long Statement,Xbim.IO.Step21,Part21Writer,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Part21Writer.cs,WriteEntity,The length of the statement  "            if (map != null && map.Keys.Contains(entity.EntityLabel)) return; //if the entity is replaced in the map do not write it " is 120.
Long Statement,Xbim.IO.Xml.BsConf,configuration,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\BsConf\cnf.custom.cs,GetEntity,The length of the statement  "                        .OfType<entity>().FirstOrDefault(e => string.Compare(e.EntityName' name' StringComparison.InvariantCultureIgnoreCase) == 0); " is 124.
Long Statement,Xbim.IO.Xml,XbimXmlReader4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlReader4.cs,Read,The length of the statement  "          //   using (var xmlInStream = new StreamReader(inputStream' Encoding.GetEncoding("ISO-8859-9"))) //this is a work around to ensure Latin character sets are read " is 160.
Long Statement,Xbim.IO.Xml,XbimXmlReader4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlReader4.cs,ReadSchemaInHeader,The length of the statement  "                    if (input.Value == "http://www.buildingsmart-tech.org/ifcXML/MVD4/IFC4" || input.Value == "http://www.buildingsmart-tech.org/ifcXML/IFC4/Add1") " is 143.
Long Statement,Xbim.IO.Xml,XbimXmlReader4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlReader4.cs,ReadSchemaVersion,The length of the statement  "                    if (string.Equals(input.Value' "http://www.buildingsmart-tech.org/ifcXML/MVD4/IFC"' StringComparison.OrdinalIgnoreCase) || " is 122.
Long Statement,Xbim.IO.Xml,XbimXmlReader4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlReader4.cs,ReadSchemaVersion,The length of the statement  "                    if (string.Equals(input.Value' "http://www.buildingsmart-tech.org/ifcXML/IFC4/final"' StringComparison.OrdinalIgnoreCase)) " is 122.
Long Statement,Xbim.IO.Xml,XmlMetaProperty,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XmlMetaProperty.cs,IsStringCompatible,The length of the statement  "            var defTypeAttr = type.GetCustomAttributes(typeof(DefinedTypeAttribute)' false).FirstOrDefault() as DefinedTypeAttribute; " is 121.
Long Statement,Xbim.IO.Xml,IfcXmlReader,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,StartElement,The length of the statement  "                //if we have a completely empty element that is not a ref we need to make sure it is written to the database as EndElement will not be called " is 141.
Long Statement,Xbim.IO.Xml,IfcXmlReader,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,StartElement,The length of the statement  "                    //if (!(_currentNode is XmlUosCollection) && _currentNode is XmlCollectionProperty && !(_currentNode.Parent is XmlUosCollection)) " is 129.
Long Statement,Xbim.IO.Xml,IfcXmlReader,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,StartElement,The length of the statement  "                else if (!(_currentNode is XmlUosCollection) && _currentNode is XmlCollectionProperty && !(_currentNode.Parent is XmlUosCollection)) " is 132.
Long Statement,Xbim.IO.Xml,IfcXmlReader,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,IsIfcType,The length of the statement  "                if (elementName.Contains("-wrapper") && elementName.StartsWith(_expressNamespace) == false) // we have an inline type definition " is 128.
Long Statement,Xbim.IO.Xml,IfcXmlReader,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,GetId,The length of the statement  "            else if (IsIfcEntity(input.LocalName' out expressType) && !typeof(IExpressValueType).IsAssignableFrom(expressType.Type)) //its a type with no identity' make one " is 160.
Long Statement,Xbim.IO.Xml,IfcXmlReader,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,EndElement,The length of the statement  "                        //if the generic type of the collection is different from the actualEntityType then we need to create an entity and call Ifc Parse " is 130.
Long Statement,Xbim.IO.Xml,IfcXmlReader,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,SetValue,The length of the statement  "                                    if(String.Compare(input.Value' "unknown"' StringComparison.OrdinalIgnoreCase) != 0) //do nothing with IfcLogicals that are undefined " is 132.
Long Statement,Xbim.IO.Xml,IfcXmlReader,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,Read,The length of the statement  "            //   using (var xmlInStream = new StreamReader(inputStream' Encoding.GetEncoding("ISO-8859-9"))) //this is a work around to ensure latin character sets are read " is 160.
Long Statement,Xbim.IO.Xml,IfcXmlReader,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,Read,The length of the statement  "                //IFC2x3 was the first IFC mapped to XML so IFC version wasn't explicit. So we need to put it in to keep the data complete " is 122.
Long Statement,Xbim.IO.Xml,XmlProperty,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,SetValue,The length of the statement  "                if (parserType == StepParserType.Boolean && String.Compare(val' "unknown"' StringComparison.OrdinalIgnoreCase) == 0) //do nothing with IfcLogicals that are undefined " is 165.
Long Statement,Xbim.IO.Xml,IfcXmlWriter3,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlWriter3.cs,WriteProperty,The length of the statement  "            //    throw new Exception(string.Format("Entity of type {0} has illegal property {1} of type {2}"' entity.GetType().ToString()' propType.Name' propType.Name)); " is 159.
Complex Conditional,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,ImportStepZip,The conditional expression  "entry.IsFile &&                                  (                                      string.Compare(ext' ".ifc"' StringComparison.OrdinalIgnoreCase) == 0 ||                                      string.Compare(ext' ".step21"' StringComparison.OrdinalIgnoreCase) == 0 ||                                      string.Compare(ext' ".stp"' StringComparison.OrdinalIgnoreCase) == 0                                  )"  is complex.
Complex Conditional,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,GetSchemaError,The conditional expression  "entAttr.EntityType != EntityAttributeType.Set && entAttr.EntityType != EntityAttributeType.List &&                  entAttr.EntityType != EntityAttributeType.ListUnique && entAttr.EntityType != EntityAttributeType.Array &&                  entAttr.EntityType != EntityAttributeType.ArrayUnique && entAttr.EntityType != EntityAttributeType.Bag"  is complex.
Complex Conditional,Xbim.IO.Xml,IfcXmlReader,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,EndElement,The conditional expression  "prevInputType == XmlNodeType.Element && prevInputName == input.LocalName &&                           _currentNode is XmlProperty && _currentNode.Parent is XmlEntity"  is complex.
Empty Catch Block,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Xbim.IO.Esent,P21ToIndexParser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimP21Indexer.cs,BeginParse,The method has an empty catch block.
Empty Catch Block,Xbim.IO.Esent,P21ToIndexParser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimP21Indexer.cs,BeginParse,The method has an empty catch block.
Empty Catch Block,Xbim.IO.Esent,EsentCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentCursor.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,Close,The method has an empty catch block.
Empty Catch Block,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Xbim.IO,FileReferenceResolver,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\FileReferenceResolver.cs,ResourceAlternatives,The method has an empty catch block.
Magic Number,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,PersistedEntityInstanceCache,The following statement contains a magic number: SystemParameters.DatabasePageSize = 4096;
Magic Number,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,PersistedEntityInstanceCache,The following statement contains a magic number: SystemParameters.MaxInstances = 128;
Magic Number,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,AttachedDatabase,The following statement contains a magic number: if (_session == null)              {                  lock (OpenInstances) //if a db is opened twice we use the same instance                  {                      foreach (var cache in OpenInstances)                      {                            if (String.Compare(cache.DatabaseName' _databaseName' StringComparison.OrdinalIgnoreCase) == 0)                          {                              _jetInstance.Term();                              _jetInstance = cache.JetInstance;                              break;                          }                      }                      _session = new Session(_jetInstance);                      try                      {                          if(!string.IsNullOrWhiteSpace(_databaseName))                              Api.JetAttachDatabase(_session' _databaseName' AttachDatabaseGrbit.None);                      }                      catch (EsentDatabaseDirtyShutdownException)                      {                            // try and fix the problem with the badly shutdown database                          var startInfo = new ProcessStartInfo("EsentUtl.exe")                          {                              WindowStyle = ProcessWindowStyle.Hidden'                              UseShellExecute = false'                              CreateNoWindow = true'                              Arguments = String.Format("/p \"{0}\" /o "' _databaseName)                          };                          using (var proc = Process.Start(startInfo))                          {                              if (proc != null && proc.WaitForExit(60000) == false) //give in if it takes more than a minute                              {                                  // timed out.                                  if (!proc.HasExited)                                  {                                      proc.Kill();                                      // Give the process time to die' as we'll likely be reading files it has open next.                                      Thread.Sleep(500);                                  }                                  EsentModel.Logger.WarnFormat("Repair failed {0} after dirty shutdown' time out"' _databaseName);                              }                              else                              {                                  EsentModel.Logger.WarnFormat("Repair success {0} after dirty shutdown"' _databaseName);                                  if (proc != null) proc.Close();                                  //try again                                  Api.JetAttachDatabase(_session' _databaseName' openMode == OpenDatabaseGrbit.ReadOnly ? AttachDatabaseGrbit.ReadOnly : AttachDatabaseGrbit.None);                              }                          }                          }                      OpenInstances.Add(this);                      Api.JetOpenDatabase(_session' _databaseName' String.Empty' out _databaseId' openMode);                  }              }
Magic Number,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,AttachedDatabase,The following statement contains a magic number: if (_session == null)              {                  lock (OpenInstances) //if a db is opened twice we use the same instance                  {                      foreach (var cache in OpenInstances)                      {                            if (String.Compare(cache.DatabaseName' _databaseName' StringComparison.OrdinalIgnoreCase) == 0)                          {                              _jetInstance.Term();                              _jetInstance = cache.JetInstance;                              break;                          }                      }                      _session = new Session(_jetInstance);                      try                      {                          if(!string.IsNullOrWhiteSpace(_databaseName))                              Api.JetAttachDatabase(_session' _databaseName' AttachDatabaseGrbit.None);                      }                      catch (EsentDatabaseDirtyShutdownException)                      {                            // try and fix the problem with the badly shutdown database                          var startInfo = new ProcessStartInfo("EsentUtl.exe")                          {                              WindowStyle = ProcessWindowStyle.Hidden'                              UseShellExecute = false'                              CreateNoWindow = true'                              Arguments = String.Format("/p \"{0}\" /o "' _databaseName)                          };                          using (var proc = Process.Start(startInfo))                          {                              if (proc != null && proc.WaitForExit(60000) == false) //give in if it takes more than a minute                              {                                  // timed out.                                  if (!proc.HasExited)                                  {                                      proc.Kill();                                      // Give the process time to die' as we'll likely be reading files it has open next.                                      Thread.Sleep(500);                                  }                                  EsentModel.Logger.WarnFormat("Repair failed {0} after dirty shutdown' time out"' _databaseName);                              }                              else                              {                                  EsentModel.Logger.WarnFormat("Repair success {0} after dirty shutdown"' _databaseName);                                  if (proc != null) proc.Close();                                  //try again                                  Api.JetAttachDatabase(_session' _databaseName' openMode == OpenDatabaseGrbit.ReadOnly ? AttachDatabaseGrbit.ReadOnly : AttachDatabaseGrbit.None);                              }                          }                          }                      OpenInstances.Add(this);                      Api.JetOpenDatabase(_session' _databaseName' String.Empty' out _databaseId' openMode);                  }              }
Magic Number,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,CreateInstance,The following statement contains a magic number: jetInstance.Parameters.LogFileSize = 1024;
Magic Number,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,CreateInstance,The following statement contains a magic number: jetInstance.Parameters.LogBuffers = 1024;
Magic Number,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,CreateInstance,The following statement contains a magic number: jetInstance.Parameters.MaxVerPages = 4096*2;
Magic Number,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,CreateInstance,The following statement contains a magic number: jetInstance.Parameters.MaxVerPages = 4096*2;
Magic Number,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,CreateInstance,The following statement contains a magic number: jetInstance.Parameters.MaxSessions = 512;
Magic Number,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,CreateInstance,The following statement contains a magic number: jetInstance.Parameters.MaxOpenTables = 256;
Magic Number,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,SaveAsIfcZip,The following statement contains a magic number: try              {                  fs = new FileStream(storageFileName' FileMode.Create' FileAccess.Write);                  zipStream = new ZipOutputStream(fs);                  zipStream.SetLevel(3); //0-9' 9 being the highest level of compression                  var newEntry = new ZipEntry(fileBody) { DateTime = DateTime.Now };                  zipStream.PutNextEntry(newEntry);                  using (entityTable.BeginReadOnlyTransaction())                  {                      using (TextWriter tw = new StreamWriter(zipStream))                      {                          Part21Writer.Write(_model' tw' Model.Metadata);                          tw.Flush();                      }                  }              }              catch (Exception e)              {                  throw new XbimException("Failed to write IfcZip file " + storageFileName' e);              }              finally              {                  if (fs != null) fs.Close();                  if (zipStream != null) zipStream.Close();                  FreeTable(entityTable);              }
Magic Number,Xbim.IO.Esent,P21ToIndexParser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimP21Indexer.cs,BeginParse,The following statement contains a magic number: _toStore = new BlockingCollection<Tuple<int' short' List<int>' byte[]' bool>>(512);
Magic Number,Xbim.IO.Esent,P21ToIndexParser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimP21Indexer.cs,BeginList,The following statement contains a magic number: if (_listNestLevel < 2) return;
Magic Number,Xbim.IO.Esent,P21ToIndexParser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimP21Indexer.cs,BeginList,The following statement contains a magic number: if (_listNestLevel - 1 > _nestedIndex.Count)                  _nestedIndex.Add(0);              else                  _nestedIndex[_listNestLevel - 2]++;
Magic Number,Xbim.IO.Esent,P21ToIndexParser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimP21Indexer.cs,NewEntity,The following statement contains a magic number: var newPercentage = Convert.ToInt32(pos / _streamSize * 100.0);
Magic Number,Xbim.IO.Esent,P21ToIndexParser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimP21Indexer.cs,SetHexValue,The following statement contains a magic number: if (InHeader)              {                  _propertyValue.Init(value' StepParserType.HexaDecimal);                  if (_currentInstance.Entity != null)                      _currentInstance.ParameterSetter(_currentInstance.CurrentParamIndex' _propertyValue' NestedIndex);                }              else              {                  _binaryWriter.Write((byte)P21ParseAction.SetHexValue);                  _binaryWriter.Write(Convert.ToInt64(value' 16));                }
Magic Number,Xbim.IO.Esent,P21ToIndexParser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimP21Indexer.cs,SetStringValue,The following statement contains a magic number: if (InHeader)              {                  _propertyValue.Init(value' StepParserType.String);                  if (_currentInstance.Entity != null)                      _currentInstance.ParameterSetter(_currentInstance.CurrentParamIndex' _propertyValue' NestedIndex);                }              else              {                  _binaryWriter.Write((byte)P21ParseAction.SetStringValue);                  var ret = value.Substring(1' value.Length - 2); //remove the quotes                  if (ret.Contains("\\") || ret.Contains("'")) //"''" added to remove extra ' added in IfcText Escape() method                  {                      var d = new XbimP21StringDecoder();                      ret = d.Unescape(ret' _codePageOverride);                  }                  _binaryWriter.Write(ret);              }
Magic Number,Xbim.IO.Esent,EsentCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentCursor.cs,CreateGlobalsTable,The following statement contains a magic number: using (var transaction = new Transaction(sesid))             {                 JET_TABLEID tableid;                 Api.JetCreateTable(sesid' dbid' GlobalsTableName' 1' 100' out tableid);                 JET_COLUMNID versionColumnid;                 Api.JetAddColumn(                     sesid'                     tableid'                     VersionColumnName'                     new JET_COLUMNDEF { coltyp = JET_coltyp.LongText }'                     null'                     0'                     out versionColumnid);                  var defaultValue = BitConverter.GetBytes(0);                  JET_COLUMNID countColumnid;                 Api.JetAddColumn(                     sesid'                     tableid'                     EntityCountColumnName'                     new JET_COLUMNDEF { coltyp = JET_coltyp.Long' grbit = ColumndefGrbit.ColumnEscrowUpdate }'                     defaultValue'                     defaultValue.Length'                     out countColumnid);                  Api.JetAddColumn(                     sesid'                     tableid'                     GeometryCountColumnName'                     new JET_COLUMNDEF { coltyp = JET_coltyp.Long' grbit = ColumndefGrbit.ColumnEscrowUpdate }'                     defaultValue'                     defaultValue.Length'                     out countColumnid);                  Api.JetAddColumn(                     sesid'                     tableid'                     FlushColumnName'                     new JET_COLUMNDEF { coltyp = JET_coltyp.Long' grbit = ColumndefGrbit.ColumnEscrowUpdate }'                     defaultValue'                     defaultValue.Length'                     out countColumnid);                  Api.JetAddColumn(                    sesid'                    tableid'                    ifcHeaderColumnName'                    new JET_COLUMNDEF { coltyp = JET_coltyp.LongBinary }'                    null'                    0'                    out countColumnid);                  using (var update = new Update(sesid' tableid' JET_prep.Insert))                 {                     Api.SetColumn(sesid' tableid' versionColumnid' Version' Encoding.Unicode);                     update.Save();                 }                  Api.JetCloseTable(sesid' tableid);                 transaction.Commit(CommitTransactionGrbit.LazyFlush);             }
Magic Number,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,CreateTable,The following statement contains a magic number: using (var transaction = new Transaction(sesid))              {                  Api.JetCreateTable(sesid' dbid' ifcEntityTableName' 8' 100' out tableid);                    JET_COLUMNID columnid;                  //Add the primary key' Entity Label                  var columndef = new JET_COLUMNDEF { coltyp = JET_coltyp.Long' grbit = ColumndefGrbit.ColumnNotNULL };                  Api.JetAddColumn(sesid' tableid' colNameEntityLabel' columndef' null' 0' out columnid);                    // Identity of the type of the object : 16-bit integer looked up in IfcType Table                  columndef = new JET_COLUMNDEF { coltyp = JET_coltyp.Short' grbit = ColumndefGrbit.ColumnMaybeNull };                  Api.JetAddColumn(sesid' tableid' colNameIfcType' columndef' null' 0' out columnid);                      //The properties of the entity                  columndef = new JET_COLUMNDEF { coltyp = JET_coltyp.LongBinary' grbit = ColumndefGrbit.ColumnMaybeNull };                  //if(EsentVersion.SupportsWindows7Features) columndef.grbit |= Windows7Grbits.ColumnCompressed;                  Api.JetAddColumn(sesid' tableid' colNameEntityData' columndef' null' 0' out columnid);                    //Flag to say if this class is to be indexed by type                  columndef = new JET_COLUMNDEF { coltyp = JET_coltyp.Bit' grbit = ColumndefGrbit.None };                  Api.JetAddColumn(sesid' tableid' colNameIsIndexedClass' columndef' null' 0' out columnid);                    //Primary Key index                  var labelIndexDef = string.Format("+{0}\0\0"' colNameEntityLabel);                  Api.JetCreateIndex(sesid' tableid' entityTableLabelIndex' CreateIndexGrbit.IndexPrimary' labelIndexDef' labelIndexDef.Length' 100);                  Api.JetCloseTable(sesid' tableid);                  transaction.Commit(CommitTransactionGrbit.LazyFlush);              }
Magic Number,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,CreateTable,The following statement contains a magic number: using (var transaction = new Transaction(sesid))              {                  Api.JetCreateTable(sesid' dbid' ifcEntityTableName' 8' 100' out tableid);                    JET_COLUMNID columnid;                  //Add the primary key' Entity Label                  var columndef = new JET_COLUMNDEF { coltyp = JET_coltyp.Long' grbit = ColumndefGrbit.ColumnNotNULL };                  Api.JetAddColumn(sesid' tableid' colNameEntityLabel' columndef' null' 0' out columnid);                    // Identity of the type of the object : 16-bit integer looked up in IfcType Table                  columndef = new JET_COLUMNDEF { coltyp = JET_coltyp.Short' grbit = ColumndefGrbit.ColumnMaybeNull };                  Api.JetAddColumn(sesid' tableid' colNameIfcType' columndef' null' 0' out columnid);                      //The properties of the entity                  columndef = new JET_COLUMNDEF { coltyp = JET_coltyp.LongBinary' grbit = ColumndefGrbit.ColumnMaybeNull };                  //if(EsentVersion.SupportsWindows7Features) columndef.grbit |= Windows7Grbits.ColumnCompressed;                  Api.JetAddColumn(sesid' tableid' colNameEntityData' columndef' null' 0' out columnid);                    //Flag to say if this class is to be indexed by type                  columndef = new JET_COLUMNDEF { coltyp = JET_coltyp.Bit' grbit = ColumndefGrbit.None };                  Api.JetAddColumn(sesid' tableid' colNameIsIndexedClass' columndef' null' 0' out columnid);                    //Primary Key index                  var labelIndexDef = string.Format("+{0}\0\0"' colNameEntityLabel);                  Api.JetCreateIndex(sesid' tableid' entityTableLabelIndex' CreateIndexGrbit.IndexPrimary' labelIndexDef' labelIndexDef.Length' 100);                  Api.JetCloseTable(sesid' tableid);                  transaction.Commit(CommitTransactionGrbit.LazyFlush);              }
Magic Number,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,CreateTable,The following statement contains a magic number: using (var transaction = new Transaction(sesid))              {                  Api.JetCreateTable(sesid' dbid' ifcEntityTableName' 8' 100' out tableid);                    JET_COLUMNID columnid;                  //Add the primary key' Entity Label                  var columndef = new JET_COLUMNDEF { coltyp = JET_coltyp.Long' grbit = ColumndefGrbit.ColumnNotNULL };                  Api.JetAddColumn(sesid' tableid' colNameEntityLabel' columndef' null' 0' out columnid);                    // Identity of the type of the object : 16-bit integer looked up in IfcType Table                  columndef = new JET_COLUMNDEF { coltyp = JET_coltyp.Short' grbit = ColumndefGrbit.ColumnMaybeNull };                  Api.JetAddColumn(sesid' tableid' colNameIfcType' columndef' null' 0' out columnid);                      //The properties of the entity                  columndef = new JET_COLUMNDEF { coltyp = JET_coltyp.LongBinary' grbit = ColumndefGrbit.ColumnMaybeNull };                  //if(EsentVersion.SupportsWindows7Features) columndef.grbit |= Windows7Grbits.ColumnCompressed;                  Api.JetAddColumn(sesid' tableid' colNameEntityData' columndef' null' 0' out columnid);                    //Flag to say if this class is to be indexed by type                  columndef = new JET_COLUMNDEF { coltyp = JET_coltyp.Bit' grbit = ColumndefGrbit.None };                  Api.JetAddColumn(sesid' tableid' colNameIsIndexedClass' columndef' null' 0' out columnid);                    //Primary Key index                  var labelIndexDef = string.Format("+{0}\0\0"' colNameEntityLabel);                  Api.JetCreateIndex(sesid' tableid' entityTableLabelIndex' CreateIndexGrbit.IndexPrimary' labelIndexDef' labelIndexDef.Length' 100);                  Api.JetCloseTable(sesid' tableid);                  transaction.Commit(CommitTransactionGrbit.LazyFlush);              }
Magic Number,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,CreateTable,The following statement contains a magic number: using (var transaction = new Transaction(sesid))              {                  Api.JetCreateTable(sesid' dbid' ifcEntityIndexTableName' 8' 100' out tableid);                  JET_COLUMNID columnid;                  // Identity of the type of the object : 16-bit integer looked up in IfcType Table                  var columndef = new JET_COLUMNDEF { coltyp = JET_coltyp.Short' grbit = ColumndefGrbit.ColumnNotNULL };                  Api.JetAddColumn(sesid' tableid' colNameIfcType' columndef' null' 0' out columnid);                  // Name of the secondary key : for lookup by a property value of the object that is a foreign object                  columndef = new JET_COLUMNDEF { coltyp = JET_coltyp.Long' grbit = ColumndefGrbit.ColumnNotNULL };                  Api.JetAddColumn(sesid' tableid' colNameSecondaryKey' columndef' null' 0' out columnid);                  //Add the entity Label                  Api.JetAddColumn(sesid' tableid' colNameEntityLabel' columndef' null' 0' out columnid);                    //Add the primary key' Entity Type' Index label and Entity Label                   var labelIndexDef = string.Format("+{0}\0{1}\0{2}\0\0"' colNameIfcType' colNameSecondaryKey' colNameEntityLabel);                  Api.JetCreateIndex(sesid' tableid' entityTableLabelIndex' CreateIndexGrbit.IndexPrimary' labelIndexDef' labelIndexDef.Length' 100);                  Api.JetCloseTable(sesid' tableid);                  transaction.Commit(CommitTransactionGrbit.LazyFlush);              }
Magic Number,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,CreateTable,The following statement contains a magic number: using (var transaction = new Transaction(sesid))              {                  Api.JetCreateTable(sesid' dbid' ifcEntityIndexTableName' 8' 100' out tableid);                  JET_COLUMNID columnid;                  // Identity of the type of the object : 16-bit integer looked up in IfcType Table                  var columndef = new JET_COLUMNDEF { coltyp = JET_coltyp.Short' grbit = ColumndefGrbit.ColumnNotNULL };                  Api.JetAddColumn(sesid' tableid' colNameIfcType' columndef' null' 0' out columnid);                  // Name of the secondary key : for lookup by a property value of the object that is a foreign object                  columndef = new JET_COLUMNDEF { coltyp = JET_coltyp.Long' grbit = ColumndefGrbit.ColumnNotNULL };                  Api.JetAddColumn(sesid' tableid' colNameSecondaryKey' columndef' null' 0' out columnid);                  //Add the entity Label                  Api.JetAddColumn(sesid' tableid' colNameEntityLabel' columndef' null' 0' out columnid);                    //Add the primary key' Entity Type' Index label and Entity Label                   var labelIndexDef = string.Format("+{0}\0{1}\0{2}\0\0"' colNameIfcType' colNameSecondaryKey' colNameEntityLabel);                  Api.JetCreateIndex(sesid' tableid' entityTableLabelIndex' CreateIndexGrbit.IndexPrimary' labelIndexDef' labelIndexDef.Length' 100);                  Api.JetCloseTable(sesid' tableid);                  transaction.Commit(CommitTransactionGrbit.LazyFlush);              }
Magic Number,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,CreateTable,The following statement contains a magic number: using (var transaction = new Transaction(sesid))              {                  Api.JetCreateTable(sesid' dbid' ifcEntityIndexTableName' 8' 100' out tableid);                  JET_COLUMNID columnid;                  // Identity of the type of the object : 16-bit integer looked up in IfcType Table                  var columndef = new JET_COLUMNDEF { coltyp = JET_coltyp.Short' grbit = ColumndefGrbit.ColumnNotNULL };                  Api.JetAddColumn(sesid' tableid' colNameIfcType' columndef' null' 0' out columnid);                  // Name of the secondary key : for lookup by a property value of the object that is a foreign object                  columndef = new JET_COLUMNDEF { coltyp = JET_coltyp.Long' grbit = ColumndefGrbit.ColumnNotNULL };                  Api.JetAddColumn(sesid' tableid' colNameSecondaryKey' columndef' null' 0' out columnid);                  //Add the entity Label                  Api.JetAddColumn(sesid' tableid' colNameEntityLabel' columndef' null' 0' out columnid);                    //Add the primary key' Entity Type' Index label and Entity Label                   var labelIndexDef = string.Format("+{0}\0{1}\0{2}\0\0"' colNameIfcType' colNameSecondaryKey' colNameEntityLabel);                  Api.JetCreateIndex(sesid' tableid' entityTableLabelIndex' CreateIndexGrbit.IndexPrimary' labelIndexDef' labelIndexDef.Length' 100);                  Api.JetCloseTable(sesid' tableid);                  transaction.Commit(CommitTransactionGrbit.LazyFlush);              }
Magic Number,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,WriteHeader,The following statement contains a magic number: var ms = new MemoryStream(4096);
Magic Number,Xbim.IO.Esent,EsentEntityCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentEntityCursor.cs,AddEntity,The following statement contains a magic number: try              {                  if (indexed.HasValue && indexed.Value == false) indexed = null;                  using (var update = new Update(Sesid' Table' JET_prep.Insert))                  {                      //first put a record in with a null type key                      SetEntityRowValues(currentLabel' typeId' data' indexed);                      Api.SetColumns(Sesid' Table' _colValues);                      update.Save();                      UpdateCount(1);                  }                  //set the main variables of label and type just ones                  SetEntityIndexRowValues(typeId' -1' currentLabel);                  //add -1 record to allow retrieval by type id alone                  if (indexed.HasValue && indexed.Value == true)                  {                      using (var update = new Update(Sesid' _indexTable' JET_prep.Insert))                      {                          Api.SetColumns(Sesid' _indexTable' _colIdxValues);                          update.Save();                      }                  }                    //now add in any extra index keys                  if (indexKeys == null) return;                    var transactionCounter = 0;                  //SRL need to upgrade store to uint                  foreach (var key in indexKeys.Distinct())                  {                      using (var update = new Update(Sesid' _indexTable' JET_prep.Insert))                      {                          _colValIdxKey.Value = key;                          Api.SetColumns(Sesid' _indexTable' _colIdxValues);                          update.Save();                          transactionCounter++;                          if (!trans.HasValue || transactionCounter % 100 != 0) continue;                            trans.Value.Commit();                          trans.Value.Begin();                      }                  }              }              catch (Exception e)              {                    throw new XbimException("Failed to add entity to the database"' e);              }
Magic Number,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,CreateTable,The following statement contains a magic number: Api.JetCreateTable(sesid' dbid' GeometryTableName' 8' 80' out tableid);
Magic Number,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,CreateTable,The following statement contains a magic number: Api.JetCreateTable(sesid' dbid' GeometryTableName' 8' 80' out tableid);
Magic Number,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,CreateTable,The following statement contains a magic number: using (var transaction = new Transaction(sesid))              {                  JET_COLUMNID columnid;                    var columndef = new JET_COLUMNDEF                  {                      coltyp = JET_coltyp.Long'                      grbit = ColumndefGrbit.ColumnAutoincrement                  };                    Api.JetAddColumn(sesid' tableid' ColNameGeometryLabel' columndef' null' 0' out columnid);                    columndef.grbit = ColumndefGrbit.ColumnNotNULL;                    Api.JetAddColumn(sesid' tableid' ColNameProductLabel' columndef' null' 0' out columnid);                    columndef.coltyp = JET_coltyp.UnsignedByte;                  Api.JetAddColumn(sesid' tableid' ColNameGeomType' columndef' null' 0' out columnid);                                    columndef.coltyp = JET_coltyp.Short;                  Api.JetAddColumn(sesid' tableid' ColNameProductIfcTypeId' columndef' null' 0' out columnid);                  Api.JetAddColumn(sesid' tableid' ColNameSubPart' columndef' null' 0' out columnid);                                     columndef.coltyp = JET_coltyp.Binary;                  columndef.grbit = ColumndefGrbit.ColumnMaybeNull;                  Api.JetAddColumn(sesid' tableid' ColNameTransformMatrix' columndef' null' 0' out columnid);                                   columndef.coltyp = JET_coltyp.LongBinary;                  //if (EsentVersion.SupportsWindows7Features)                  //    columndef.grbit |= Windows7Grbits.ColumnCompressed;                  Api.JetAddColumn(sesid' tableid' ColNameShapeData' columndef' null' 0' out columnid);                    columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' ColNameGeometryHash' columndef' null' 0' out columnid);                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' ColNameStyleLabel' columndef' null' 0' out columnid);                  // The primary index is the type and the entity label.                  var indexDef = string.Format("+{0}\0\0"' ColNameGeometryLabel);                  Api.JetCreateIndex(sesid' tableid' GeometryTablePrimaryIndex' CreateIndexGrbit.IndexPrimary' indexDef' indexDef.Length' 100);                  //create index by geometry hashes                      indexDef = string.Format("+{0}\0\0"' ColNameGeometryHash);                  Api.JetCreateIndex(sesid' tableid' GeometryTableHashIndex' CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100);                  //Create index by product                  indexDef = string.Format("+{0}\0{1}\0{2}\0{3}\0{4}\0\0"' ColNameGeomType' ColNameProductIfcTypeId' ColNameProductLabel' ColNameSubPart' ColNameStyleLabel);                  Api.JetCreateIndex(sesid' tableid' GeometryTableGeomTypeIndex' CreateIndexGrbit.IndexUnique' indexDef' indexDef.Length' 100);                  //create index by style                  indexDef = string.Format("+{0}\0{1}\0{2}\0{3}\0{4}\0\0"' ColNameGeomType' ColNameStyleLabel' ColNameProductIfcTypeId' ColNameProductLabel' ColNameGeometryLabel);                  Api.JetCreateIndex(sesid' tableid' GeometryTableStyleIndex' CreateIndexGrbit.None' indexDef' indexDef.Length' 100);                  Api.JetCloseTable(sesid' tableid);                  transaction.Commit(CommitTransactionGrbit.LazyFlush);              }
Magic Number,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,CreateTable,The following statement contains a magic number: using (var transaction = new Transaction(sesid))              {                  JET_COLUMNID columnid;                    var columndef = new JET_COLUMNDEF                  {                      coltyp = JET_coltyp.Long'                      grbit = ColumndefGrbit.ColumnAutoincrement                  };                    Api.JetAddColumn(sesid' tableid' ColNameGeometryLabel' columndef' null' 0' out columnid);                    columndef.grbit = ColumndefGrbit.ColumnNotNULL;                    Api.JetAddColumn(sesid' tableid' ColNameProductLabel' columndef' null' 0' out columnid);                    columndef.coltyp = JET_coltyp.UnsignedByte;                  Api.JetAddColumn(sesid' tableid' ColNameGeomType' columndef' null' 0' out columnid);                                    columndef.coltyp = JET_coltyp.Short;                  Api.JetAddColumn(sesid' tableid' ColNameProductIfcTypeId' columndef' null' 0' out columnid);                  Api.JetAddColumn(sesid' tableid' ColNameSubPart' columndef' null' 0' out columnid);                                     columndef.coltyp = JET_coltyp.Binary;                  columndef.grbit = ColumndefGrbit.ColumnMaybeNull;                  Api.JetAddColumn(sesid' tableid' ColNameTransformMatrix' columndef' null' 0' out columnid);                                   columndef.coltyp = JET_coltyp.LongBinary;                  //if (EsentVersion.SupportsWindows7Features)                  //    columndef.grbit |= Windows7Grbits.ColumnCompressed;                  Api.JetAddColumn(sesid' tableid' ColNameShapeData' columndef' null' 0' out columnid);                    columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' ColNameGeometryHash' columndef' null' 0' out columnid);                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' ColNameStyleLabel' columndef' null' 0' out columnid);                  // The primary index is the type and the entity label.                  var indexDef = string.Format("+{0}\0\0"' ColNameGeometryLabel);                  Api.JetCreateIndex(sesid' tableid' GeometryTablePrimaryIndex' CreateIndexGrbit.IndexPrimary' indexDef' indexDef.Length' 100);                  //create index by geometry hashes                      indexDef = string.Format("+{0}\0\0"' ColNameGeometryHash);                  Api.JetCreateIndex(sesid' tableid' GeometryTableHashIndex' CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100);                  //Create index by product                  indexDef = string.Format("+{0}\0{1}\0{2}\0{3}\0{4}\0\0"' ColNameGeomType' ColNameProductIfcTypeId' ColNameProductLabel' ColNameSubPart' ColNameStyleLabel);                  Api.JetCreateIndex(sesid' tableid' GeometryTableGeomTypeIndex' CreateIndexGrbit.IndexUnique' indexDef' indexDef.Length' 100);                  //create index by style                  indexDef = string.Format("+{0}\0{1}\0{2}\0{3}\0{4}\0\0"' ColNameGeomType' ColNameStyleLabel' ColNameProductIfcTypeId' ColNameProductLabel' ColNameGeometryLabel);                  Api.JetCreateIndex(sesid' tableid' GeometryTableStyleIndex' CreateIndexGrbit.None' indexDef' indexDef.Length' 100);                  Api.JetCloseTable(sesid' tableid);                  transaction.Commit(CommitTransactionGrbit.LazyFlush);              }
Magic Number,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,CreateTable,The following statement contains a magic number: using (var transaction = new Transaction(sesid))              {                  JET_COLUMNID columnid;                    var columndef = new JET_COLUMNDEF                  {                      coltyp = JET_coltyp.Long'                      grbit = ColumndefGrbit.ColumnAutoincrement                  };                    Api.JetAddColumn(sesid' tableid' ColNameGeometryLabel' columndef' null' 0' out columnid);                    columndef.grbit = ColumndefGrbit.ColumnNotNULL;                    Api.JetAddColumn(sesid' tableid' ColNameProductLabel' columndef' null' 0' out columnid);                    columndef.coltyp = JET_coltyp.UnsignedByte;                  Api.JetAddColumn(sesid' tableid' ColNameGeomType' columndef' null' 0' out columnid);                                    columndef.coltyp = JET_coltyp.Short;                  Api.JetAddColumn(sesid' tableid' ColNameProductIfcTypeId' columndef' null' 0' out columnid);                  Api.JetAddColumn(sesid' tableid' ColNameSubPart' columndef' null' 0' out columnid);                                     columndef.coltyp = JET_coltyp.Binary;                  columndef.grbit = ColumndefGrbit.ColumnMaybeNull;                  Api.JetAddColumn(sesid' tableid' ColNameTransformMatrix' columndef' null' 0' out columnid);                                   columndef.coltyp = JET_coltyp.LongBinary;                  //if (EsentVersion.SupportsWindows7Features)                  //    columndef.grbit |= Windows7Grbits.ColumnCompressed;                  Api.JetAddColumn(sesid' tableid' ColNameShapeData' columndef' null' 0' out columnid);                    columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' ColNameGeometryHash' columndef' null' 0' out columnid);                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' ColNameStyleLabel' columndef' null' 0' out columnid);                  // The primary index is the type and the entity label.                  var indexDef = string.Format("+{0}\0\0"' ColNameGeometryLabel);                  Api.JetCreateIndex(sesid' tableid' GeometryTablePrimaryIndex' CreateIndexGrbit.IndexPrimary' indexDef' indexDef.Length' 100);                  //create index by geometry hashes                      indexDef = string.Format("+{0}\0\0"' ColNameGeometryHash);                  Api.JetCreateIndex(sesid' tableid' GeometryTableHashIndex' CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100);                  //Create index by product                  indexDef = string.Format("+{0}\0{1}\0{2}\0{3}\0{4}\0\0"' ColNameGeomType' ColNameProductIfcTypeId' ColNameProductLabel' ColNameSubPart' ColNameStyleLabel);                  Api.JetCreateIndex(sesid' tableid' GeometryTableGeomTypeIndex' CreateIndexGrbit.IndexUnique' indexDef' indexDef.Length' 100);                  //create index by style                  indexDef = string.Format("+{0}\0{1}\0{2}\0{3}\0{4}\0\0"' ColNameGeomType' ColNameStyleLabel' ColNameProductIfcTypeId' ColNameProductLabel' ColNameGeometryLabel);                  Api.JetCreateIndex(sesid' tableid' GeometryTableStyleIndex' CreateIndexGrbit.None' indexDef' indexDef.Length' 100);                  Api.JetCloseTable(sesid' tableid);                  transaction.Commit(CommitTransactionGrbit.LazyFlush);              }
Magic Number,Xbim.IO.Esent,XbimGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimGeometryCursor.cs,CreateTable,The following statement contains a magic number: using (var transaction = new Transaction(sesid))              {                  JET_COLUMNID columnid;                    var columndef = new JET_COLUMNDEF                  {                      coltyp = JET_coltyp.Long'                      grbit = ColumndefGrbit.ColumnAutoincrement                  };                    Api.JetAddColumn(sesid' tableid' ColNameGeometryLabel' columndef' null' 0' out columnid);                    columndef.grbit = ColumndefGrbit.ColumnNotNULL;                    Api.JetAddColumn(sesid' tableid' ColNameProductLabel' columndef' null' 0' out columnid);                    columndef.coltyp = JET_coltyp.UnsignedByte;                  Api.JetAddColumn(sesid' tableid' ColNameGeomType' columndef' null' 0' out columnid);                                    columndef.coltyp = JET_coltyp.Short;                  Api.JetAddColumn(sesid' tableid' ColNameProductIfcTypeId' columndef' null' 0' out columnid);                  Api.JetAddColumn(sesid' tableid' ColNameSubPart' columndef' null' 0' out columnid);                                     columndef.coltyp = JET_coltyp.Binary;                  columndef.grbit = ColumndefGrbit.ColumnMaybeNull;                  Api.JetAddColumn(sesid' tableid' ColNameTransformMatrix' columndef' null' 0' out columnid);                                   columndef.coltyp = JET_coltyp.LongBinary;                  //if (EsentVersion.SupportsWindows7Features)                  //    columndef.grbit |= Windows7Grbits.ColumnCompressed;                  Api.JetAddColumn(sesid' tableid' ColNameShapeData' columndef' null' 0' out columnid);                    columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' ColNameGeometryHash' columndef' null' 0' out columnid);                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' ColNameStyleLabel' columndef' null' 0' out columnid);                  // The primary index is the type and the entity label.                  var indexDef = string.Format("+{0}\0\0"' ColNameGeometryLabel);                  Api.JetCreateIndex(sesid' tableid' GeometryTablePrimaryIndex' CreateIndexGrbit.IndexPrimary' indexDef' indexDef.Length' 100);                  //create index by geometry hashes                      indexDef = string.Format("+{0}\0\0"' ColNameGeometryHash);                  Api.JetCreateIndex(sesid' tableid' GeometryTableHashIndex' CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100);                  //Create index by product                  indexDef = string.Format("+{0}\0{1}\0{2}\0{3}\0{4}\0\0"' ColNameGeomType' ColNameProductIfcTypeId' ColNameProductLabel' ColNameSubPart' ColNameStyleLabel);                  Api.JetCreateIndex(sesid' tableid' GeometryTableGeomTypeIndex' CreateIndexGrbit.IndexUnique' indexDef' indexDef.Length' 100);                  //create index by style                  indexDef = string.Format("+{0}\0{1}\0{2}\0{3}\0{4}\0\0"' ColNameGeomType' ColNameStyleLabel' ColNameProductIfcTypeId' ColNameProductLabel' ColNameGeometryLabel);                  Api.JetCreateIndex(sesid' tableid' GeometryTableStyleIndex' CreateIndexGrbit.None' indexDef' indexDef.Length' 100);                  Api.JetCloseTable(sesid' tableid);                  transaction.Commit(CommitTransactionGrbit.LazyFlush);              }
Magic Number,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,Init,The following statement contains a magic number: ModelFactors = new XbimModelFactors(Math.PI / 180' 1e-3' 1e-5);
Magic Number,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,Init,The following statement contains a magic number: ModelFactors = new XbimModelFactors(Math.PI / 180' 1e-3' 1e-5);
Magic Number,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,Init,The following statement contains a magic number: ModelFactors = new XbimModelFactors(Math.PI / 180' 1e-3' 1e-5);
Magic Number,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,GetEntityBinaryData,The following statement contains a magic number: if (!entity.Activated) //we have it in memory but not written to store yet              {                  var entityStream = new MemoryStream(4096);                  var entityWriter = new BinaryWriter(entityStream);                  entity.WriteEntity(entityWriter' Metadata);                  return entityStream.ToArray();              }
Magic Number,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,Close,The following statement contains a magic number: ModelFactors = new XbimModelFactors(Math.PI / 180' 1e-3' 1e-5);
Magic Number,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,Close,The following statement contains a magic number: ModelFactors = new XbimModelFactors(Math.PI / 180' 1e-3' 1e-5);
Magic Number,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,Close,The following statement contains a magic number: ModelFactors = new XbimModelFactors(Math.PI / 180' 1e-3' 1e-5);
Magic Number,Xbim.IO.Esent,EsentModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentModel.cs,ExportZippedIfc,The following statement contains a magic number: try              {                  using (var zis = new ZipInputStream(File.OpenRead(inputIfcFile)))                  {                      var zs = zis.GetNextEntry();                      while (zs != null)                      {                          var fileName = Path.GetFileName(zs.Name);                          if (fileName == null || !fileName.ToLower().EndsWith(".ifc"))                          {                              zs = zis.GetNextEntry();                              continue;                          }                          using (var fs = File.Create(fileName))                          {                              var i = 2048;                              var b = new byte[i];                              while (true)                              {                                  i = zis.Read(b' 0' b.Length);                                  if (i > 0)                                      fs.Write(b' 0' i);                                  else                                      break;                              }                          }                          return fileName;                      }                    }              }              catch (Exception e)              {                  throw new Exception("Error creating Ifc File from ZIP = " + inputIfcFile' e);              }
Magic Number,Xbim.IO.Esent,XbimParserState,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimParserState.cs,BeginList,The following statement contains a magic number: if (_listNestLevel < 2) return;
Magic Number,Xbim.IO.Esent,XbimParserState,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimParserState.cs,BeginList,The following statement contains a magic number: if (_listNestLevel - 1 > _nestedIndex.Count)                  _nestedIndex.Add(0);              else                  _nestedIndex[_listNestLevel - 2]++;
Magic Number,Xbim.IO.Esent,XbimReadWriteTransaction,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\XbimReadWriteTransaction.cs,XbimReadWriteTransaction,The following statement contains a magic number: _transactionBatchSize = 100;
Magic Number,Xbim.IO.Esent,EsentShapeGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeGeometryCursor.cs,CreateTable,The following statement contains a magic number: Api.JetCreateTable(sesid' dbid' GeometryTableName' 8' 80' out tableid);
Magic Number,Xbim.IO.Esent,EsentShapeGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeGeometryCursor.cs,CreateTable,The following statement contains a magic number: Api.JetCreateTable(sesid' dbid' GeometryTableName' 8' 80' out tableid);
Magic Number,Xbim.IO.Esent,EsentShapeGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeGeometryCursor.cs,CreateTable,The following statement contains a magic number: using (var transaction = new Microsoft.Isam.Esent.Interop.Transaction(sesid))              {                  JET_COLUMNID columnid;                    //Unique geometry label                  var columndef = new JET_COLUMNDEF                  {                      coltyp = JET_coltyp.Long'                      grbit = ColumndefGrbit.ColumnAutoincrement | ColumndefGrbit.ColumnNotNULL                  };                  Api.JetAddColumn(sesid' tableid' colNameShapeLabel' columndef' null' 0' out columnid);                  //IFC shape label                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameIfcShapeLabel' columndef' null' 0' out columnid);                  //Geometry hash                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnMaybeNull;                  Api.JetAddColumn(sesid' tableid' colNameGeometryHash' columndef' null' 0' out columnid);                    //cost                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameCost' columndef' null' 0' out columnid);                    //reference count                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameReferenceCount' columndef' null' 0' out columnid);                  //LOD                  columndef.coltyp = JET_coltyp.UnsignedByte;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameLOD' columndef' null' 0' out columnid);                                  //Data format type                  columndef.coltyp = JET_coltyp.UnsignedByte;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameFormat' columndef' null' 0' out columnid);                    //Bounding Box data                  columndef.coltyp = JET_coltyp.Binary;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameBoundingBox' columndef' null' 0' out columnid);                    //Shape data                  columndef.coltyp = JET_coltyp.LongBinary;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameShapeData' columndef' null' 0' out columnid);                    // The primary index is the geometry label.                  var indexDef = string.Format("+{0}\0\0"' colNameShapeLabel);                  Api.JetCreateIndex(sesid' tableid' geometryTablePrimaryIndex' CreateIndexGrbit.IndexPrimary|CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100);                    //create index by geometry hashes                      indexDef = string.Format("+{0}\0\0"' colNameGeometryHash);                //  Api.JetCreateIndex(sesid' tableid' geometryTableHashIndex' CreateIndexGrbit.None' indexDef' indexDef.Length' 100);                    //create index for reference count                  indexDef = string.Format("-{0}\0{1}\0{2}\0\0"' colNameCost' colNameReferenceCount' colNameShapeLabel);                  Api.JetCreateIndex(sesid' tableid' geometryTableReferenceIndex' CreateIndexGrbit.None' indexDef' indexDef.Length' 100);                    Api.JetCloseTable(sesid' tableid);                    transaction.Commit(CommitTransactionGrbit.LazyFlush);              }
Magic Number,Xbim.IO.Esent,EsentShapeGeometryCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeGeometryCursor.cs,CreateTable,The following statement contains a magic number: using (var transaction = new Microsoft.Isam.Esent.Interop.Transaction(sesid))              {                  JET_COLUMNID columnid;                    //Unique geometry label                  var columndef = new JET_COLUMNDEF                  {                      coltyp = JET_coltyp.Long'                      grbit = ColumndefGrbit.ColumnAutoincrement | ColumndefGrbit.ColumnNotNULL                  };                  Api.JetAddColumn(sesid' tableid' colNameShapeLabel' columndef' null' 0' out columnid);                  //IFC shape label                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameIfcShapeLabel' columndef' null' 0' out columnid);                  //Geometry hash                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnMaybeNull;                  Api.JetAddColumn(sesid' tableid' colNameGeometryHash' columndef' null' 0' out columnid);                    //cost                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameCost' columndef' null' 0' out columnid);                    //reference count                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameReferenceCount' columndef' null' 0' out columnid);                  //LOD                  columndef.coltyp = JET_coltyp.UnsignedByte;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameLOD' columndef' null' 0' out columnid);                                  //Data format type                  columndef.coltyp = JET_coltyp.UnsignedByte;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameFormat' columndef' null' 0' out columnid);                    //Bounding Box data                  columndef.coltyp = JET_coltyp.Binary;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameBoundingBox' columndef' null' 0' out columnid);                    //Shape data                  columndef.coltyp = JET_coltyp.LongBinary;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameShapeData' columndef' null' 0' out columnid);                    // The primary index is the geometry label.                  var indexDef = string.Format("+{0}\0\0"' colNameShapeLabel);                  Api.JetCreateIndex(sesid' tableid' geometryTablePrimaryIndex' CreateIndexGrbit.IndexPrimary|CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100);                    //create index by geometry hashes                      indexDef = string.Format("+{0}\0\0"' colNameGeometryHash);                //  Api.JetCreateIndex(sesid' tableid' geometryTableHashIndex' CreateIndexGrbit.None' indexDef' indexDef.Length' 100);                    //create index for reference count                  indexDef = string.Format("-{0}\0{1}\0{2}\0\0"' colNameCost' colNameReferenceCount' colNameShapeLabel);                  Api.JetCreateIndex(sesid' tableid' geometryTableReferenceIndex' CreateIndexGrbit.None' indexDef' indexDef.Length' 100);                    Api.JetCloseTable(sesid' tableid);                    transaction.Commit(CommitTransactionGrbit.LazyFlush);              }
Magic Number,Xbim.IO.Esent,EsentShapeInstanceCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeInstanceCursor.cs,CreateTable,The following statement contains a magic number: Api.JetCreateTable(sesid' dbid' InstanceTableName' 8' 80' out tableid);
Magic Number,Xbim.IO.Esent,EsentShapeInstanceCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeInstanceCursor.cs,CreateTable,The following statement contains a magic number: Api.JetCreateTable(sesid' dbid' InstanceTableName' 8' 80' out tableid);
Magic Number,Xbim.IO.Esent,EsentShapeInstanceCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeInstanceCursor.cs,CreateTable,The following statement contains a magic number: using (var transaction = new Microsoft.Isam.Esent.Interop.Transaction(sesid))              {                  JET_COLUMNID columnid;                    //Unique instanceData label                  var columndef = new JET_COLUMNDEF                  {                      coltyp = JET_coltyp.Long'                      grbit = ColumndefGrbit.ColumnAutoincrement |ColumndefGrbit.ColumnNotNULL                  };                  Api.JetAddColumn(sesid' tableid' colNameInstanceLabel' columndef' null' 0' out columnid);                                  //IFC type ID                  columndef.coltyp = JET_coltyp.Short;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameIfcTypeId' columndef' null' 0' out columnid);                    //ifc Product label                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameIfcProductLabel' columndef' null' 0' out columnid);                                    //style label                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameStyleLabel' columndef' null' 0' out columnid);                                 //shape label                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameShapeLabel' columndef' null' 0' out columnid);                                  //Representation Context                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameRepresentationContext' columndef' null' 0' out columnid);                    //Representation Context                  columndef.coltyp = JET_coltyp.UnsignedByte;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameRepType' columndef' null' 0' out columnid);                    //Transformation data                  columndef.coltyp = JET_coltyp.Binary;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  columndef.cbMax = MaxSizeOfTransformation;                  Api.JetAddColumn(sesid' tableid' colNameTransformation' columndef' null' 0' out columnid);                    //Bounding Box data                  columndef.coltyp = JET_coltyp.Binary;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameBoundingBox' columndef' null' 0' out columnid);                    string indexDef;                  // The  index on the shape geometry label.                  indexDef = string.Format("+{0}\0\0"' colNameShapeLabel);                  Api.JetCreateIndex(sesid' tableid' geometryShapeIndex' CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100);                    //create index by ifc product label..  ..                  indexDef = string.Format("+{0}\0\0"' colNameIfcProductLabel);                  Api.JetCreateIndex(sesid' tableid' productIndex' CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100);                    //create index by ifc product type label..  ..                  indexDef = string.Format("+{0}\0\0"' colNameIfcTypeId);                  Api.JetCreateIndex(sesid' tableid' productTypeIndex' CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100);                    //create by context'then ifc style...                    indexDef = string.Format("+{0}\0{1}\0{2}\0{3}\0\0"' colNameRepresentationContext' colNameStyleLabel' colNameIfcTypeId'  colNameInstanceLabel);                  Api.JetCreateIndex(sesid' tableid' instanceTablePrimaryIndex' CreateIndexGrbit.IndexPrimary' indexDef' indexDef.Length' 100);                    Api.JetCloseTable(sesid' tableid);                    transaction.Commit(CommitTransactionGrbit.LazyFlush);              }
Magic Number,Xbim.IO.Esent,EsentShapeInstanceCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeInstanceCursor.cs,CreateTable,The following statement contains a magic number: using (var transaction = new Microsoft.Isam.Esent.Interop.Transaction(sesid))              {                  JET_COLUMNID columnid;                    //Unique instanceData label                  var columndef = new JET_COLUMNDEF                  {                      coltyp = JET_coltyp.Long'                      grbit = ColumndefGrbit.ColumnAutoincrement |ColumndefGrbit.ColumnNotNULL                  };                  Api.JetAddColumn(sesid' tableid' colNameInstanceLabel' columndef' null' 0' out columnid);                                  //IFC type ID                  columndef.coltyp = JET_coltyp.Short;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameIfcTypeId' columndef' null' 0' out columnid);                    //ifc Product label                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameIfcProductLabel' columndef' null' 0' out columnid);                                    //style label                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameStyleLabel' columndef' null' 0' out columnid);                                 //shape label                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameShapeLabel' columndef' null' 0' out columnid);                                  //Representation Context                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameRepresentationContext' columndef' null' 0' out columnid);                    //Representation Context                  columndef.coltyp = JET_coltyp.UnsignedByte;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameRepType' columndef' null' 0' out columnid);                    //Transformation data                  columndef.coltyp = JET_coltyp.Binary;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  columndef.cbMax = MaxSizeOfTransformation;                  Api.JetAddColumn(sesid' tableid' colNameTransformation' columndef' null' 0' out columnid);                    //Bounding Box data                  columndef.coltyp = JET_coltyp.Binary;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameBoundingBox' columndef' null' 0' out columnid);                    string indexDef;                  // The  index on the shape geometry label.                  indexDef = string.Format("+{0}\0\0"' colNameShapeLabel);                  Api.JetCreateIndex(sesid' tableid' geometryShapeIndex' CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100);                    //create index by ifc product label..  ..                  indexDef = string.Format("+{0}\0\0"' colNameIfcProductLabel);                  Api.JetCreateIndex(sesid' tableid' productIndex' CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100);                    //create index by ifc product type label..  ..                  indexDef = string.Format("+{0}\0\0"' colNameIfcTypeId);                  Api.JetCreateIndex(sesid' tableid' productTypeIndex' CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100);                    //create by context'then ifc style...                    indexDef = string.Format("+{0}\0{1}\0{2}\0{3}\0\0"' colNameRepresentationContext' colNameStyleLabel' colNameIfcTypeId'  colNameInstanceLabel);                  Api.JetCreateIndex(sesid' tableid' instanceTablePrimaryIndex' CreateIndexGrbit.IndexPrimary' indexDef' indexDef.Length' 100);                    Api.JetCloseTable(sesid' tableid);                    transaction.Commit(CommitTransactionGrbit.LazyFlush);              }
Magic Number,Xbim.IO.Esent,EsentShapeInstanceCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeInstanceCursor.cs,CreateTable,The following statement contains a magic number: using (var transaction = new Microsoft.Isam.Esent.Interop.Transaction(sesid))              {                  JET_COLUMNID columnid;                    //Unique instanceData label                  var columndef = new JET_COLUMNDEF                  {                      coltyp = JET_coltyp.Long'                      grbit = ColumndefGrbit.ColumnAutoincrement |ColumndefGrbit.ColumnNotNULL                  };                  Api.JetAddColumn(sesid' tableid' colNameInstanceLabel' columndef' null' 0' out columnid);                                  //IFC type ID                  columndef.coltyp = JET_coltyp.Short;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameIfcTypeId' columndef' null' 0' out columnid);                    //ifc Product label                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameIfcProductLabel' columndef' null' 0' out columnid);                                    //style label                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameStyleLabel' columndef' null' 0' out columnid);                                 //shape label                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameShapeLabel' columndef' null' 0' out columnid);                                  //Representation Context                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameRepresentationContext' columndef' null' 0' out columnid);                    //Representation Context                  columndef.coltyp = JET_coltyp.UnsignedByte;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameRepType' columndef' null' 0' out columnid);                    //Transformation data                  columndef.coltyp = JET_coltyp.Binary;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  columndef.cbMax = MaxSizeOfTransformation;                  Api.JetAddColumn(sesid' tableid' colNameTransformation' columndef' null' 0' out columnid);                    //Bounding Box data                  columndef.coltyp = JET_coltyp.Binary;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameBoundingBox' columndef' null' 0' out columnid);                    string indexDef;                  // The  index on the shape geometry label.                  indexDef = string.Format("+{0}\0\0"' colNameShapeLabel);                  Api.JetCreateIndex(sesid' tableid' geometryShapeIndex' CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100);                    //create index by ifc product label..  ..                  indexDef = string.Format("+{0}\0\0"' colNameIfcProductLabel);                  Api.JetCreateIndex(sesid' tableid' productIndex' CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100);                    //create index by ifc product type label..  ..                  indexDef = string.Format("+{0}\0\0"' colNameIfcTypeId);                  Api.JetCreateIndex(sesid' tableid' productTypeIndex' CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100);                    //create by context'then ifc style...                    indexDef = string.Format("+{0}\0{1}\0{2}\0{3}\0\0"' colNameRepresentationContext' colNameStyleLabel' colNameIfcTypeId'  colNameInstanceLabel);                  Api.JetCreateIndex(sesid' tableid' instanceTablePrimaryIndex' CreateIndexGrbit.IndexPrimary' indexDef' indexDef.Length' 100);                    Api.JetCloseTable(sesid' tableid);                    transaction.Commit(CommitTransactionGrbit.LazyFlush);              }
Magic Number,Xbim.IO.Esent,EsentShapeInstanceCursor,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\EsentShapeInstanceCursor.cs,CreateTable,The following statement contains a magic number: using (var transaction = new Microsoft.Isam.Esent.Interop.Transaction(sesid))              {                  JET_COLUMNID columnid;                    //Unique instanceData label                  var columndef = new JET_COLUMNDEF                  {                      coltyp = JET_coltyp.Long'                      grbit = ColumndefGrbit.ColumnAutoincrement |ColumndefGrbit.ColumnNotNULL                  };                  Api.JetAddColumn(sesid' tableid' colNameInstanceLabel' columndef' null' 0' out columnid);                                  //IFC type ID                  columndef.coltyp = JET_coltyp.Short;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameIfcTypeId' columndef' null' 0' out columnid);                    //ifc Product label                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameIfcProductLabel' columndef' null' 0' out columnid);                                    //style label                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameStyleLabel' columndef' null' 0' out columnid);                                 //shape label                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameShapeLabel' columndef' null' 0' out columnid);                                  //Representation Context                  columndef.coltyp = JET_coltyp.Long;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameRepresentationContext' columndef' null' 0' out columnid);                    //Representation Context                  columndef.coltyp = JET_coltyp.UnsignedByte;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameRepType' columndef' null' 0' out columnid);                    //Transformation data                  columndef.coltyp = JET_coltyp.Binary;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  columndef.cbMax = MaxSizeOfTransformation;                  Api.JetAddColumn(sesid' tableid' colNameTransformation' columndef' null' 0' out columnid);                    //Bounding Box data                  columndef.coltyp = JET_coltyp.Binary;                  columndef.grbit = ColumndefGrbit.ColumnNotNULL;                  Api.JetAddColumn(sesid' tableid' colNameBoundingBox' columndef' null' 0' out columnid);                    string indexDef;                  // The  index on the shape geometry label.                  indexDef = string.Format("+{0}\0\0"' colNameShapeLabel);                  Api.JetCreateIndex(sesid' tableid' geometryShapeIndex' CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100);                    //create index by ifc product label..  ..                  indexDef = string.Format("+{0}\0\0"' colNameIfcProductLabel);                  Api.JetCreateIndex(sesid' tableid' productIndex' CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100);                    //create index by ifc product type label..  ..                  indexDef = string.Format("+{0}\0\0"' colNameIfcTypeId);                  Api.JetCreateIndex(sesid' tableid' productTypeIndex' CreateIndexGrbit.IndexDisallowNull' indexDef' indexDef.Length' 100);                    //create by context'then ifc style...                    indexDef = string.Format("+{0}\0{1}\0{2}\0{3}\0\0"' colNameRepresentationContext' colNameStyleLabel' colNameIfcTypeId'  colNameInstanceLabel);                  Api.JetCreateIndex(sesid' tableid' instanceTablePrimaryIndex' CreateIndexGrbit.IndexPrimary' indexDef' indexDef.Length' 100);                    Api.JetCloseTable(sesid' tableid);                    transaction.Commit(CommitTransactionGrbit.LazyFlush);              }
Magic Number,Xbim.IO,PersistEntityExtensions,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\IPersistEntityExtensions.cs,WriteEntity,The following statement contains a magic number: while (action != P21ParseAction.EndEntity)              {                  switch (action)                  {                      case P21ParseAction.BeginList:                          tw.Write("(");                          break;                      case P21ParseAction.EndList:                          tw.Write(")");                          break;                      case P21ParseAction.BeginComplex:                          tw.Write("&SCOPE");                          break;                      case P21ParseAction.EndComplex:                          tw.Write("ENDSCOPE");                          break;                      case P21ParseAction.SetIntegerValue:                          if (comma) tw.Write("'");                          comma = true;                          tw.Write(br.ReadInt64().ToString());                          break;                      case P21ParseAction.SetHexValue:                          if (comma) tw.Write("'");                          comma = true;                          tw.Write(Convert.ToString(br.ReadInt64()'16));                          break;                      case P21ParseAction.SetFloatValue:                          if (comma) tw.Write("'");                          comma = true;                          tw.Write(br.ReadDouble().AsPart21());                          break;                      case P21ParseAction.SetStringValue:                          if (comma) tw.Write("'");                          comma = true;                          tw.Write(br.ReadString());                          break;                      case P21ParseAction.SetEnumValue:                          if (comma) tw.Write("'");                          comma = true;                          tw.Write("." + br.ReadString() + ".");                          break;                      case P21ParseAction.SetBooleanValue:                          if (comma) tw.Write("'");                          comma = true;                          tw.Write(br.ReadBoolean() ? ".T." : ".F.");                          break;                      case P21ParseAction.SetNonDefinedValue:                          if (comma) tw.Write("'");                          comma = true;                          tw.Write("$");                          break;                      case P21ParseAction.SetOverrideValue:                          if (comma) tw.Write("'");                          comma = true;                          tw.Write("*");                          break;                      case P21ParseAction.SetObjectValueUInt16:                          if (comma) tw.Write("'");                          comma = true;                          tw.Write("#"+ br.ReadUInt16());                          break;                      case P21ParseAction.SetObjectValueInt32:                          if (comma) tw.Write("'");                          comma = true;                          tw.Write("#" + br.ReadInt32());                          break;                      case P21ParseAction.SetObjectValueInt64:                          if (comma) tw.Write("'");                          comma = true;                          tw.Write("#" + br.ReadInt64());                          break;                      case P21ParseAction.BeginNestedType:                          if (comma) tw.Write("'");                          comma = false;                          tw.Write(br.ReadString()+"(");                          break;                      case P21ParseAction.EndNestedType:                          comma = true;                          tw.Write(")");                          break;                      case P21ParseAction.EndEntity:                          tw.Write(");");                          break;                      case P21ParseAction.NewEntity:                          comma = false;                          tw.Write("(");                          break;                      default:                          throw new Exception("Invalid Property Record #" + entity.EntityLabel + " EntityType: " + entity.GetType().Name);                  }                  action = (P21ParseAction)br.ReadByte();              }
Magic Number,Xbim.IO.Memory,MemoryModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Memory\MemoryModel.cs,MemoryModel,The following statement contains a magic number: ModelFactors = new XbimModelFactors(Math.PI / 180' 1e-3' 1e-5);
Magic Number,Xbim.IO.Memory,MemoryModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Memory\MemoryModel.cs,MemoryModel,The following statement contains a magic number: ModelFactors = new XbimModelFactors(Math.PI / 180' 1e-3' 1e-5);
Magic Number,Xbim.IO.Memory,MemoryModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Memory\MemoryModel.cs,MemoryModel,The following statement contains a magic number: ModelFactors = new XbimModelFactors(Math.PI / 180' 1e-3' 1e-5);
Magic Number,Xbim.IO.Step21.Parser,PropertyValue,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\PropertyValue.cs,ConvertFromHex,The following statement contains a magic number: var value = Convert.ToInt32(m.Groups[1].Value' 16);
Magic Number,Xbim.IO.Step21,StepDateTimeHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepDateTimeHelper.cs,ToStep21,The following statement contains a magic number: var dt = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: var data2 = BitConverter.ToUInt16(winBytes' 4);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: var data3 = BitConverter.ToUInt16(winBytes' 6);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: var num = new uint[6];
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[0] = (data1 / 16777216);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[1] = (data1 % 16777216);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[2] = (uint)(data2 * 256 + data3 / 256);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[2] = (uint)(data2 * 256 + data3 / 256);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[2] = (uint)(data2 * 256 + data3 / 256);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[3] = (uint)((data3 % 256) * 65536 + winBytes[8] * 256 + winBytes[9]);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[3] = (uint)((data3 % 256) * 65536 + winBytes[8] * 256 + winBytes[9]);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[3] = (uint)((data3 % 256) * 65536 + winBytes[8] * 256 + winBytes[9]);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[3] = (uint)((data3 % 256) * 65536 + winBytes[8] * 256 + winBytes[9]);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[3] = (uint)((data3 % 256) * 65536 + winBytes[8] * 256 + winBytes[9]);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[3] = (uint)((data3 % 256) * 65536 + winBytes[8] * 256 + winBytes[9]);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[4] = (uint)(winBytes[10] * 65536 + winBytes[11] * 256 + winBytes[12]);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[4] = (uint)(winBytes[10] * 65536 + winBytes[11] * 256 + winBytes[12]);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[4] = (uint)(winBytes[10] * 65536 + winBytes[11] * 256 + winBytes[12]);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[4] = (uint)(winBytes[10] * 65536 + winBytes[11] * 256 + winBytes[12]);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[4] = (uint)(winBytes[10] * 65536 + winBytes[11] * 256 + winBytes[12]);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[4] = (uint)(winBytes[10] * 65536 + winBytes[11] * 256 + winBytes[12]);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[5] = (uint)(winBytes[13] * 65536 + winBytes[14] * 256 + winBytes[15]);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[5] = (uint)(winBytes[13] * 65536 + winBytes[14] * 256 + winBytes[15]);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[5] = (uint)(winBytes[13] * 65536 + winBytes[14] * 256 + winBytes[15]);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[5] = (uint)(winBytes[13] * 65536 + winBytes[14] * 256 + winBytes[15]);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[5] = (uint)(winBytes[13] * 65536 + winBytes[14] * 256 + winBytes[15]);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: num[5] = (uint)(winBytes[13] * 65536 + winBytes[14] * 256 + winBytes[15]);
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: var digits = 2;
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: for (var i = 0; i < 6; i++)              {                  chars.Append(To64String(num[i]' digits));                  digits = 4;              }
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,ConvertToBase64,The following statement contains a magic number: for (var i = 0; i < 6; i++)              {                  chars.Append(To64String(num[i]' digits));                  digits = 4;              }
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,To64String,The following statement contains a magic number: for (var iDigit = 0; iDigit < nDigits; iDigit++)              {                  result[nDigits - iDigit - 1] = CConversionTable[(int)(act % 64)];                  act /= 64;              }
Magic Number,Xbim.IO.Step21,StepGuidHelper,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepGuidHelper.cs,To64String,The following statement contains a magic number: for (var iDigit = 0; iDigit < nDigits; iDigit++)              {                  result[nDigits - iDigit - 1] = CConversionTable[(int)(act % 64)];                  act /= 64;              }
Magic Number,Xbim.IO.Step21,XbimP21StringDecoder,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21StringDecoder.cs,Unescape,The following statement contains a magic number: while (!eof)              {                  if (At(SingleApostrophToken))                      ReplaceApostrophes();                  else if (At(SingleBackslashToken))                      ReplaceBackSlashes();                  else if (At(CodeTableToken))                      ParseCodeTable();                  else if (At(UpperAsciiToken))                      ParseUpperAscii();                  else if (At(Hex8Token))                      ParseHex8();                  else if (At(Hex16Token))                      ParseTerminatedHex(4);                  else if (At(Hex32Token))                      ParseTerminatedHex(8);                  else                      CopyCharacter();              }
Magic Number,Xbim.IO.Step21,XbimP21StringDecoder,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21StringDecoder.cs,Unescape,The following statement contains a magic number: while (!eof)              {                  if (At(SingleApostrophToken))                      ReplaceApostrophes();                  else if (At(SingleBackslashToken))                      ReplaceBackSlashes();                  else if (At(CodeTableToken))                      ParseCodeTable();                  else if (At(UpperAsciiToken))                      ParseUpperAscii();                  else if (At(Hex8Token))                      ParseHex8();                  else if (At(Hex16Token))                      ParseTerminatedHex(4);                  else if (At(Hex32Token))                      ParseTerminatedHex(8);                  else                      CopyCharacter();              }
Magic Number,Xbim.IO.Step21,XbimP21StringDecoder,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21StringDecoder.cs,ParseCodeTable,The following statement contains a magic number: if (eof || !HasLength(2)) throw new XbimP21EofException();
Magic Number,Xbim.IO.Step21,XbimP21StringDecoder,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21StringDecoder.cs,ParseHex8,The following statement contains a magic number: if (eof || !HasLength(2)) throw new XbimP21EofException();
Magic Number,Xbim.IO.Step21,XbimP21StringDecoder,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21StringDecoder.cs,ParseHex8,The following statement contains a magic number: var byteval = GetHexLength(2);
Magic Number,Xbim.IO.Step21,XbimP21StringDecoder,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21StringDecoder.cs,GetHexLength,The following statement contains a magic number: StringLenght /= 2;
Magic Number,Xbim.IO.Step21,XbimP21StringDecoder,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21StringDecoder.cs,GetHexLength,The following statement contains a magic number: for (var i = 0; i < StringLenght; i++)              {                  var hex = p21.Substring(iCurChar' 2);                  try                  {                      ret[i] = Convert.ToByte(hex' 16);                      Move(2);                  }                  catch (Exception)                  {                      throw new XbimP21InvalidCharacterException(String.Format("Invalid hexadecimal representation '{0}'"' hex));                  }              }
Magic Number,Xbim.IO.Step21,XbimP21StringDecoder,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21StringDecoder.cs,GetHexLength,The following statement contains a magic number: for (var i = 0; i < StringLenght; i++)              {                  var hex = p21.Substring(iCurChar' 2);                  try                  {                      ret[i] = Convert.ToByte(hex' 16);                      Move(2);                  }                  catch (Exception)                  {                      throw new XbimP21InvalidCharacterException(String.Format("Invalid hexadecimal representation '{0}'"' hex));                  }              }
Magic Number,Xbim.IO.Step21,XbimP21StringDecoder,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21StringDecoder.cs,GetHexLength,The following statement contains a magic number: for (var i = 0; i < StringLenght; i++)              {                  var hex = p21.Substring(iCurChar' 2);                  try                  {                      ret[i] = Convert.ToByte(hex' 16);                      Move(2);                  }                  catch (Exception)                  {                      throw new XbimP21InvalidCharacterException(String.Format("Invalid hexadecimal representation '{0}'"' hex));                  }              }
Magic Number,Xbim.IO.Step21,XbimP21StringDecoder,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21StringDecoder.cs,ParseTerminatedHex,The following statement contains a magic number: Move(4);
Magic Number,Xbim.IO.Step21,XbimP21StringDecoder,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21StringDecoder.cs,ParseTerminatedHex,The following statement contains a magic number: if (stringLenght == 8)                  EncodingName = "utf-32BE";
Magic Number,Xbim.IO.Step21,XbimP21StringDecoder,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21StringDecoder.cs,ParseTerminatedHex,The following statement contains a magic number: do              {                  if (eof || !HasLength(stringLenght + LongHexEndToken.Length))                        throw new XbimP21EofException();                  var byteval = GetHexLength(stringLenght);                  builder.Append(enc.GetChars(byteval' 0' stringLenght / 2));              } while (!At(LongHexEndToken));
Magic Number,Xbim.IO.Step21,StepText,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepTextHelper.cs,ToPart21,The following statement contains a magic number: var sb = new StringBuilder(source.Length * 2);
Magic Number,Xbim.IO.Step21,StepText,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepTextHelper.cs,ToPart21,The following statement contains a magic number: for (var i = 0; i < source.Length; i++)              {                  int c;                  try                  {                      c = char.ConvertToUtf32(source' i);                  }                  catch (Exception)                  {                      c = '?';                  }                  if (c > 0xFFFF)                  {                      state = SetMode(WriteState.FourBytes' state' sb);                      sb.AppendFormat(@"{0:X8}"' c);                      i++; // to skip the next surrogate                  }                  else if (c > 0xFF)                  {                      state = SetMode(WriteState.TwoBytes' state' sb);                      sb.AppendFormat(@"{0:X4}"' c);                  }                  else                  {                      state = SetMode(WriteState.Normal' state' sb);                      // boundaries according to specs from http://www.buildingsmart-tech.org/downloads/accompanying-documents/guidelines/IFC2x%20Model%20Implementation%20Guide%20V2-0b.pdf                      if (c > 126 || c < 32)                          sb.AppendFormat(@"\X\{0:X2}"' c);                      //needs un-escaping as this is converting SIZE: 2'x2'x3/4" to SIZE: 2''x2''x3/4" and Manufacturer's to Manufacturer''s                       else if ((char)c == '\'')                          sb.Append("''");                      else if ((char)c == '\\')                          sb.Append("\\\\");                      else                          sb.Append((char)c);                  }              }
Magic Number,Xbim.IO.Step21,StepText,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\StepTextHelper.cs,ToPart21,The following statement contains a magic number: for (var i = 0; i < source.Length; i++)              {                  int c;                  try                  {                      c = char.ConvertToUtf32(source' i);                  }                  catch (Exception)                  {                      c = '?';                  }                  if (c > 0xFFFF)                  {                      state = SetMode(WriteState.FourBytes' state' sb);                      sb.AppendFormat(@"{0:X8}"' c);                      i++; // to skip the next surrogate                  }                  else if (c > 0xFF)                  {                      state = SetMode(WriteState.TwoBytes' state' sb);                      sb.AppendFormat(@"{0:X4}"' c);                  }                  else                  {                      state = SetMode(WriteState.Normal' state' sb);                      // boundaries according to specs from http://www.buildingsmart-tech.org/downloads/accompanying-documents/guidelines/IFC2x%20Model%20Implementation%20Guide%20V2-0b.pdf                      if (c > 126 || c < 32)                          sb.AppendFormat(@"\X\{0:X2}"' c);                      //needs un-escaping as this is converting SIZE: 2'x2'x3/4" to SIZE: 2''x2''x3/4" and Manufacturer's to Manufacturer''s                       else if ((char)c == '\'')                          sb.Append("''");                      else if ((char)c == '\\')                          sb.Append("\\\\");                      else                          sb.Append((char)c);                  }              }
Magic Number,Xbim.IO.Step21,XbimP21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21Parser.cs,XbimP21Parser,The following statement contains a magic number: var entityApproxCount = 5000;
Magic Number,Xbim.IO.Step21,XbimP21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21Parser.cs,XbimP21Parser,The following statement contains a magic number: if (streamSize>0)              {                  _streamSize = streamSize;                  entityApproxCount = Convert.ToInt32(_streamSize/50); //average 50 bytes per entity.              }
Magic Number,Xbim.IO.Step21,XbimP21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21Parser.cs,XbimP21Parser,The following statement contains a magic number: _deferredReferences = new List<DeferredReference>(entityApproxCount/2);
Magic Number,Xbim.IO.Step21,XbimP21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21Parser.cs,XbimP21Parser,The following statement contains a magic number: const int entityApproxCount = 5000;
Magic Number,Xbim.IO.Step21,XbimP21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21Parser.cs,XbimP21Parser,The following statement contains a magic number: _deferredReferences = new List<DeferredReference>(entityApproxCount / 2);
Magic Number,Xbim.IO.Step21,XbimP21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21Parser.cs,BeginList,The following statement contains a magic number: if (ListNestLevel < 2) return;
Magic Number,Xbim.IO.Step21,XbimP21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21Parser.cs,BeginList,The following statement contains a magic number: if (ListNestLevel -1 > _nestedIndex.Count)                  _nestedIndex.Add(0);              else                  _nestedIndex[ListNestLevel - 2]++;
Magic Number,Xbim.IO.Step21,XbimP21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\XbimP21Parser.cs,NewEntity,The following statement contains a magic number: var newPercentage = Convert.ToInt32(pos/_streamSize*100.0);
Magic Number,Xbim.IO.Step21,Part21Formatter,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Part21Formatter.cs,Format,The following statement contains a magic number: if (!string.IsNullOrEmpty(fmt) && fmt.ToUpper() == "T") //TimeStamp              {                  if (!(arg is DateTime))                      throw new ArgumentException("Only valid DateTime objects can be converted to Part21 Timestamp");                    var dateTime = (DateTime)arg;                  var dt = new DateTime(1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);                  //from 1970/1/1 00:00:00 to _lastModifiedDate                  var result = dateTime.Subtract(dt);                  var seconds = Convert.ToInt32(result.TotalSeconds);                  return seconds.ToString();              }
Magic Number,Xbim.IO.Xml,XbimXmlReader4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlReader4.cs,Read,The following statement contains a magic number: using (var input = XmlReader.Create(xmlStream))              {                  _streamSize = xmlStream.Length;                  _idMap = new Dictionary<string' int>();                    var header = new StepFileHeader(StepFileHeader.HeaderCreationMode.LeaveEmpty);                  var rootElement = true;                  var headerElement = true;                  while (input.Read())                  {                      //skip everything except for element nodes                      if (input.NodeType != XmlNodeType.Element)                          continue;                        if (rootElement)                      {                          ReadSchemaInHeader(input' header);                          rootElement = false;                          continue;                      }                        if (headerElement)                      {                          //header is the first inner node if defined (it is optional)                          var name = input.LocalName.ToLowerInvariant();                          if ((name == "header" || name == "iso_10303_28_header") && !input.IsEmptyElement)                          {                              header = ReadHeader(input' header);                          }                          headerElement = false;                          continue;                      }                        //if this is IFC2x3 file and we only need the header we need to make sure we read schema information from "uos" element                      if (input.LocalName == "uos")                      {                          ReadSchemaInHeader(input' header);                      }                        if (onlyHeader) return header;                        //process all root entities in the file (that has to be IPersistEntity)                      ReadEntity(input);                      if (_streamSize != -1 && ProgressStatus != null)                      {                          double pos = xmlStream.Position;                          var newPercentage = Convert.ToInt32(pos / _streamSize * 100.0);                          if (newPercentage > _percentageParsed)                          {                              ProgressStatus(_percentageParsed' "Parsing");                              _percentageParsed = newPercentage;                          }                      }                  }                  if(ProgressStatus!=null) ProgressStatus(100' "Parsing");                  return header;              }
Magic Number,Xbim.IO.Xml,XbimXmlReader4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlReader4.cs,Read,The following statement contains a magic number: using (var input = XmlReader.Create(xmlStream))              {                  _streamSize = xmlStream.Length;                  _idMap = new Dictionary<string' int>();                    var header = new StepFileHeader(StepFileHeader.HeaderCreationMode.LeaveEmpty);                  var rootElement = true;                  var headerElement = true;                  while (input.Read())                  {                      //skip everything except for element nodes                      if (input.NodeType != XmlNodeType.Element)                          continue;                        if (rootElement)                      {                          ReadSchemaInHeader(input' header);                          rootElement = false;                          continue;                      }                        if (headerElement)                      {                          //header is the first inner node if defined (it is optional)                          var name = input.LocalName.ToLowerInvariant();                          if ((name == "header" || name == "iso_10303_28_header") && !input.IsEmptyElement)                          {                              header = ReadHeader(input' header);                          }                          headerElement = false;                          continue;                      }                        //if this is IFC2x3 file and we only need the header we need to make sure we read schema information from "uos" element                      if (input.LocalName == "uos")                      {                          ReadSchemaInHeader(input' header);                      }                        if (onlyHeader) return header;                        //process all root entities in the file (that has to be IPersistEntity)                      ReadEntity(input);                      if (_streamSize != -1 && ProgressStatus != null)                      {                          double pos = xmlStream.Position;                          var newPercentage = Convert.ToInt32(pos / _streamSize * 100.0);                          if (newPercentage > _percentageParsed)                          {                              ProgressStatus(_percentageParsed' "Parsing");                              _percentageParsed = newPercentage;                          }                      }                  }                  if(ProgressStatus!=null) ProgressStatus(100' "Parsing");                  return header;              }
Magic Number,Xbim.IO.Xml,XbimXmlReader4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlReader4.cs,ReadSchemaVersion,The following statement contains a magic number: while (input.Read())              {                  //don't dig deeper than 100 elements                  if(dist > 100) return XmlSchemaVersion.Unknown;                    //skip any whitespaces or anything                  if (input.NodeType != XmlNodeType.Element) continue;                  dist++;                    //read namespace info                  while (input.MoveToNextAttribute())                  {                      if (string.Equals(input.Value' "http://www.iai-tech.org/ifcXML/IFC2x3/FINAL"' StringComparison.OrdinalIgnoreCase) ||                           string.Equals(input.Value' "http://www.iai-international.org/ifcXML2/RC2/IFC2X3"' StringComparison.OrdinalIgnoreCase))                          return XmlSchemaVersion.Ifc2x3;                        if (string.Equals(input.Value' "http://www.buildingsmart-tech.org/ifcXML/MVD4/IFC"' StringComparison.OrdinalIgnoreCase) ||                          string.Equals(input.Value' "http://www.buildingsmart-tech.org/ifcXML/IFC4/Add1"' StringComparison.OrdinalIgnoreCase))                          return XmlSchemaVersion.Ifc4Add1;                        if (string.Equals(input.Value' "http://www.buildingsmart-tech.org/ifcXML/IFC4/final"' StringComparison.OrdinalIgnoreCase))                          return XmlSchemaVersion.Ifc4;                  }                  input.MoveToElement();              }
Magic Number,Xbim.IO.Xml,IfcXmlReader,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,Read,The following statement contains a magic number: using (var input = XmlReader.Create(xmlStream))              {                  _streamSize = xmlStream.Length;                    // Read until end of file                  _idMap = new Dictionary<string' int>();                  _lastId = 0;                  _entitiesParsed = 0;                  var foundHeader = false;                  var header = new StepFileHeader(StepFileHeader.HeaderCreationMode.LeaveEmpty);                    //IFC2x3 was the first IFC mapped to XML so IFC version wasn't explicit. So we need to put it in to keep the data complete                  header.FileSchema.Schemas.Add("IFC2X3");                  var headerId = "";                                   while (_currentNode == null && input.Read()) //read through to UOS                  {                        switch (input.NodeType)                      {                          case XmlNodeType.Element:                              if (String.Compare(input.LocalName' "uos"' StringComparison.OrdinalIgnoreCase) == 0)                              {                                  _currentNode = new XmlUosCollection();                                }                              else if (                                  String.Compare(input.LocalName' "iso_10303_28"' StringComparison.OrdinalIgnoreCase) ==                                  0)                              {                                  foundHeader = true;                                    if (!string.IsNullOrWhiteSpace(input.Prefix))                                  {                                      _expressNamespace = input.Prefix;                                      _cTypeAttribute = _expressNamespace + ":cType";                                      _posAttribute = _expressNamespace + ":pos";                                      _expressNamespace += ":";                                  }                                  else                                  {                                      _cTypeAttribute = "cType";                                      _posAttribute = "pos";                                  } //correct the values if the namespace is defined correctly                                  while (input.MoveToNextAttribute())                                  {                                      if (input.Value == "urn:oid:1.0.10303.28.2.1.1" ||                                          input.Value ==                                          "urn:iso.org:standard:10303:part(28):version(2):xmlschema:common")                                      {                                          _expressNamespace = input.LocalName;                                          _cTypeAttribute = _expressNamespace + ":cType";                                          _posAttribute = _expressNamespace + ":pos";                                          _expressNamespace += ":";                                          break;                                      }                                  }                              }                              else                              {                                  headerId = input.LocalName.ToLower();                              }                              break;                          case XmlNodeType.Text:                              switch (headerId)                              {                                  case "name":                                      header.FileName.Name = input.Value;                                      break;                                  case "time_stamp":                                      header.FileName.TimeStamp = input.Value;                                      break;                                  case "author":                                      header.FileName.AuthorName.Add(input.Value);                                      break;                                  case "organization":                                      header.FileName.Organization.Add(input.Value);                                      break;                                  case "preprocessor_version":                                      header.FileName.PreprocessorVersion = input.Value;                                      break;                                  case "originating_system":                                      header.FileName.OriginatingSystem = input.Value;                                      break;                                  case "authorization":                                      header.FileName.AuthorizationName = input.Value;                                      break;                                  case "documentation":                                      header.FileDescription.Description.Add(input.Value);                                      break;                              }                              break;                      }                    }                  if (!foundHeader)                      throw new Exception("Invalid XML format' iso_10303_28 tag not found");                    var prevInputType = XmlNodeType.None;                  var prevInputName = "";                    // set counter for start of every element that is not empty' and reduce it on every end of that element                        try                  {                      while (input.Read())                      {                          if (_streamSize != -1 && ProgressStatus != null)                          {                              double pos = xmlStream.Position;                              var newPercentage = Convert.ToInt32(pos / _streamSize * 100.0);                              if (newPercentage > _percentageParsed)                              {                                  ProgressStatus(_percentageParsed' "Parsing");                                  _percentageParsed = newPercentage;                              }                          }                          switch (input.NodeType)                          {                              case XmlNodeType.Element:                                  StartElement(input);                                  break;                              case XmlNodeType.EndElement:                                  IPersistEntity toWrite;                                  //if toWrite has a value we have completed an Ifc Entity                                  EndElement(input' prevInputType' prevInputName' out toWrite);                                  if (toWrite != null)                                  {                                      _entitiesParsed++;                                      _finish(toWrite);                                  }                                  break;                              case XmlNodeType.Whitespace:                                  SetValue(input' prevInputType);                                  break;                              case XmlNodeType.Text:                                  SetValue(input' prevInputType);                                  break;                          }                          prevInputType = input.NodeType;                          prevInputName = input.LocalName;                      }                  }                  catch (Exception e)                  {                      throw new Exception(                          String.Format("Error reading XML' Line={0}' Position={1}' Tag='{2}'"'                              ((IXmlLineInfo) input).LineNumber' ((IXmlLineInfo) input).LinePosition' input.LocalName)' e);                  }                  if (ProgressStatus != null) ProgressStatus(100' "Parsing");                  return header;              }
Magic Number,Xbim.IO.Xml,IfcXmlReader,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,Read,The following statement contains a magic number: using (var input = XmlReader.Create(xmlStream))              {                  _streamSize = xmlStream.Length;                    // Read until end of file                  _idMap = new Dictionary<string' int>();                  _lastId = 0;                  _entitiesParsed = 0;                  var foundHeader = false;                  var header = new StepFileHeader(StepFileHeader.HeaderCreationMode.LeaveEmpty);                    //IFC2x3 was the first IFC mapped to XML so IFC version wasn't explicit. So we need to put it in to keep the data complete                  header.FileSchema.Schemas.Add("IFC2X3");                  var headerId = "";                                   while (_currentNode == null && input.Read()) //read through to UOS                  {                        switch (input.NodeType)                      {                          case XmlNodeType.Element:                              if (String.Compare(input.LocalName' "uos"' StringComparison.OrdinalIgnoreCase) == 0)                              {                                  _currentNode = new XmlUosCollection();                                }                              else if (                                  String.Compare(input.LocalName' "iso_10303_28"' StringComparison.OrdinalIgnoreCase) ==                                  0)                              {                                  foundHeader = true;                                    if (!string.IsNullOrWhiteSpace(input.Prefix))                                  {                                      _expressNamespace = input.Prefix;                                      _cTypeAttribute = _expressNamespace + ":cType";                                      _posAttribute = _expressNamespace + ":pos";                                      _expressNamespace += ":";                                  }                                  else                                  {                                      _cTypeAttribute = "cType";                                      _posAttribute = "pos";                                  } //correct the values if the namespace is defined correctly                                  while (input.MoveToNextAttribute())                                  {                                      if (input.Value == "urn:oid:1.0.10303.28.2.1.1" ||                                          input.Value ==                                          "urn:iso.org:standard:10303:part(28):version(2):xmlschema:common")                                      {                                          _expressNamespace = input.LocalName;                                          _cTypeAttribute = _expressNamespace + ":cType";                                          _posAttribute = _expressNamespace + ":pos";                                          _expressNamespace += ":";                                          break;                                      }                                  }                              }                              else                              {                                  headerId = input.LocalName.ToLower();                              }                              break;                          case XmlNodeType.Text:                              switch (headerId)                              {                                  case "name":                                      header.FileName.Name = input.Value;                                      break;                                  case "time_stamp":                                      header.FileName.TimeStamp = input.Value;                                      break;                                  case "author":                                      header.FileName.AuthorName.Add(input.Value);                                      break;                                  case "organization":                                      header.FileName.Organization.Add(input.Value);                                      break;                                  case "preprocessor_version":                                      header.FileName.PreprocessorVersion = input.Value;                                      break;                                  case "originating_system":                                      header.FileName.OriginatingSystem = input.Value;                                      break;                                  case "authorization":                                      header.FileName.AuthorizationName = input.Value;                                      break;                                  case "documentation":                                      header.FileDescription.Description.Add(input.Value);                                      break;                              }                              break;                      }                    }                  if (!foundHeader)                      throw new Exception("Invalid XML format' iso_10303_28 tag not found");                    var prevInputType = XmlNodeType.None;                  var prevInputName = "";                    // set counter for start of every element that is not empty' and reduce it on every end of that element                        try                  {                      while (input.Read())                      {                          if (_streamSize != -1 && ProgressStatus != null)                          {                              double pos = xmlStream.Position;                              var newPercentage = Convert.ToInt32(pos / _streamSize * 100.0);                              if (newPercentage > _percentageParsed)                              {                                  ProgressStatus(_percentageParsed' "Parsing");                                  _percentageParsed = newPercentage;                              }                          }                          switch (input.NodeType)                          {                              case XmlNodeType.Element:                                  StartElement(input);                                  break;                              case XmlNodeType.EndElement:                                  IPersistEntity toWrite;                                  //if toWrite has a value we have completed an Ifc Entity                                  EndElement(input' prevInputType' prevInputName' out toWrite);                                  if (toWrite != null)                                  {                                      _entitiesParsed++;                                      _finish(toWrite);                                  }                                  break;                              case XmlNodeType.Whitespace:                                  SetValue(input' prevInputType);                                  break;                              case XmlNodeType.Text:                                  SetValue(input' prevInputType);                                  break;                          }                          prevInputType = input.NodeType;                          prevInputName = input.LocalName;                      }                  }                  catch (Exception e)                  {                      throw new Exception(                          String.Format("Error reading XML' Line={0}' Position={1}' Tag='{2}'"'                              ((IXmlLineInfo) input).LineNumber' ((IXmlLineInfo) input).LinePosition' input.LocalName)' e);                  }                  if (ProgressStatus != null) ProgressStatus(100' "Parsing");                  return header;              }
Magic Number,Xbim.IO.Xml,IfcXmlWriter3,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlWriter3.cs,WriteProperty,The following statement contains a magic number: if (propType.IsGenericType && propType.GetGenericTypeDefinition() == typeof(Nullable<>) &&                  (propVal is IExpressValueType)) //deal with undefined types (nullables)              {                  if (string.IsNullOrEmpty((propVal).ToString()))                  {                      output.WriteElementString(propName' (propVal).ToString());                  }                  else                  {                      output.WriteStartElement(propName);                      if (pos > -1)                          output.WriteAttributeString("pos"' pos.ToString());                      var val = propVal as IExpressComplexType;                      if (val != null)                      {                          var complexProps = val.Properties;                          var wrapPos = 0;                          foreach (var complexProp in complexProps)                          {                              WriteProperty(propName' complexProp.GetType()' complexProp' entity' output' wrapPos' attr);                              wrapPos++;                          }                      }                      else                          output.WriteValue((propVal).ToString());                        output.WriteEndElement();                  }                }              else if (typeof(IExpressValueType).IsAssignableFrom(propType))              {                  var realType = propVal.GetType();                    if (realType != propType)                      //we have a type but it is a select type use the actual value but write out explicitly                  {                      output.WriteStartElement(propName);                      WriteProperty(realType.Name' realType' propVal' entity' output' pos' attr);                      output.WriteEndElement();                  }                  else                  {                      if (pos > -1)                      {                          output.WriteStartElement(propName);                          output.WriteAttributeString("pos"' pos.ToString());                          output.WriteValue((propVal).ToString());                          output.WriteEndElement();                      }                      // if its nullable                       //if (((ExpressType)propVal).ToPart21 != "$")                      else                           output.WriteElementString(propName' (propVal).ToString());                  }              }              else if (typeof(IExpressEnumerable).IsAssignableFrom(propType))              {                  output.WriteStartElement(propName);                  output.WriteAttributeString("ex"' "cType"' null' attr.ListType);                  var i = 0;                  foreach (var item in ((IExpressEnumerable)propVal))                  {                      WriteProperty(item.GetType().Name' item.GetType()' item' entity' output' i' attr);                      i++;                  }                  output.WriteEndElement();              }              else if (typeof(IPersistEntity).IsAssignableFrom(propType))                  //all writable entities must support this interface and ExpressType have been handled so only entities left              {                  var persistVal = (IPersistEntity)propVal;                  if (pos == -1) output.WriteStartElement(propName);                  if (_written.Contains(persistVal.EntityLabel)) //we have already written it so use an xlink                  {                      output.WriteStartElement(propVal.GetType().Name);                      output.WriteAttributeString("ref"' string.Format("i{0}"' persistVal.EntityLabel));                      output.WriteAttributeString("xsi"' "nil"' null' "true");                      if (pos > -1) //we are writing out a list element                          output.WriteAttributeString("pos"' pos.ToString());                      output.WriteEndElement();                  }                  else                  {                      Write(persistVal' output' pos);                  }                  if (pos == -1) output.WriteEndElement();              }              else if (typeof(IExpressComplexType).IsAssignableFrom(propType)) //it is a complex value tpye              {                  var properties = ((IExpressComplexType)propVal).Properties;              }              else if (propType.IsValueType) //it might be an in-built value type double' string etc              {                  var pInfoType = propVal.GetType();                    if (pInfoType.IsEnum) //convert enum                  {                      if (pos > -1)                      {                          output.WriteStartElement(propName);                          output.WriteAttributeString("pos"' pos.ToString());                      }                      else                          output.WriteStartElement(propName);                      output.WriteValue(propVal.ToString().ToLower());                  }                  else if (pInfoType.UnderlyingSystemType == typeof(Boolean))                  {                      if (pos > -1)                      {                          output.WriteStartElement("ex"' "boolean-wrapper"' null);                          output.WriteAttributeString("pos"' pos.ToString());                      }                      else                          output.WriteStartElement(propName);                      output.WriteValue((bool)propVal ? "true" : "false");                  }                  else if (pInfoType.UnderlyingSystemType == typeof(Double))                  {                      if (pos > -1)                      {                          output.WriteStartElement("ex"' "double-wrapper"' null);                          output.WriteAttributeString("pos"' pos.ToString());                      }                      else                          output.WriteStartElement(propName);                      output.WriteValue(string.Format(new Part21Formatter()' "{0:R}"' propVal));                  }                  else if (pInfoType.UnderlyingSystemType == typeof(Int16))                  {                      if (pos > -1)                      {                          output.WriteStartElement("ex"' "integer-wrapper"' null);                          output.WriteAttributeString("pos"' pos.ToString());                      }                      else                          output.WriteStartElement(propName);                      output.WriteValue(propVal.ToString());                  }                  else if (pInfoType.UnderlyingSystemType == typeof(Int32) ||                           pInfoType.UnderlyingSystemType == typeof(Int64))                  {                      if (pos > -1)                      {                          output.WriteStartElement("ex"' "long-wrapper"' null);                          output.WriteAttributeString("pos"' pos.ToString());                      }                      else                          output.WriteStartElement(propName);                      output.WriteValue(propVal.ToString());                  }                  else if (pInfoType.UnderlyingSystemType == typeof(String)) //convert  string                  {                      if (pos > -1)                      {                          output.WriteStartElement("ex"' "string-wrapper"' null);                          output.WriteAttributeString("pos"' pos.ToString());                      }                      else                          output.WriteStartElement(propName);                      output.WriteValue(string.Format(new Part21Formatter()' "{0}"' propVal));                  }                    else                      throw new ArgumentException(string.Format("Invalid Value Type {0}"' pInfoType.Name)' "pInfoType");                    output.WriteEndElement();              }              else if (typeof(IExpressSelectType).IsAssignableFrom(propType))                  // a select type get the type of the actual value              {                  if (propVal != null)                  {                      var realType = propVal.GetType();                      output.WriteStartElement(propName);                      if (typeof(IExpressValueType).IsAssignableFrom(realType))                      {                          //WriteProperty(model' realType.Name + "-wrapper"' realType' propVal' entity' output' pos' attr);                          WriteProperty(realType.Name' realType' propVal' entity' output' pos' attr);                      }                      else                      {                          WriteProperty(realType.Name' realType' propVal' entity' output' -2' attr);                      }                  }                  output.WriteEndElement();              }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,Scanner,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,Scan,The following statement contains a magic number: for (; ; ) {                      int next;              // next state to enter  #if LEFTANCHORS                      for (;;) {                          // Discard characters that do not start any pattern.                          // Must check the left anchor condition after *every* GetCode!                          state = ((cCol == 0) ? anchorState[currentScOrd] : currentStart);                          if ((next = NextState()) != goStart) break; // LOOP EXIT HERE...                          GetCode();                      }                        #else // !LEFTANCHORS                      state = currentStart;                      while ((next = NextState()) == goStart) {                          // At this point' the current character has no                          // transition from the current state.  We discard                           // the "no-match" char.   In traditional LEX such                           // characters are echoed to the console.                          GetCode();                      }  #endif // LEFTANCHORS                                          // At last' a valid transition ...                          MarkToken();                      state = next;                      GetCode();                      #if BACKUP                      bool contextSaved = false;                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                          if (state <= maxAccept && next > maxAccept) { // need to prepare backup data                              // Store data for the *latest* accept state that was found.                              SaveStateAndPos( ref ctx );                              contextSaved = true;                          }                          state = next;                          GetCode();                      }                      if (state > maxAccept && contextSaved)                          RestoreStateAndPos( ref ctx );  #else  // BACKUP                      while ((next = NextState()) > eofNum) { // Exit for goStart AND for eofNum                           state = next;                           GetCode();                      }  #endif // BACKUP                      if (state <= maxAccept) {                          MarkEnd();  #region ActionSwitch  #pragma warning disable 162' 1522      switch (state)      {          case eofNum:              if (yywrap())                  return (int)Tokens.EOF;              break;          case 1: // Recognized '[\0]+''	Shortest string ""  ;              break;          case 2: // Recognized '[^)]''	Shortest string "\x01"          case 7: // Recognized '[^)]''	Shortest string "!"          case 8: // Recognized '[^)]''	Shortest string "\""          case 9: // Recognized '[^)]''	Shortest string "#"          case 11: // Recognized '[^)]''	Shortest string "&"          case 12: // Recognized '[^)]''	Shortest string "'"          case 18: // Recognized '[^)]''	Shortest string "."  SetValue();  return((int)Tokens.MISC);              break;          case 3: // Recognized '"\t"''	Shortest string "\t"  ;              break;          case 4: // Recognized '[\n]''	Shortest string "\n"  ;              break;          case 5: // Recognized '[\r]''	Shortest string "\r"  ;              break;          case 6: // Recognized '" "''	Shortest string "\x20"  ;              break;          case 10: // Recognized '[$]''	Shortest string "$"  return((int)Tokens.NONDEF);              break;          case 13: // Recognized '[(]''	Shortest string "("  return ('(');              break;          case 14: // Recognized '[)]''	Shortest string ")"  return (')');              break;          case 15: // Recognized '[\*]''	Shortest string "*"  return((int)Tokens.OVERRIDE);              break;          case 16: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+"          case 20: // Recognized '[\-\+0-9][0-9]*''	Shortest string "0"          case 63: // Recognized '[\-\+0-9][0-9]*''	Shortest string "00"          case 74: // Recognized '[\-\+0-9][0-9]*''	Shortest string "+0"  SetValue();  return((int)Tokens.INTEGER);              break;          case 17: // Recognized '[']''	Shortest string "'"  return (''');              break;          case 19: // Recognized '[/]''	Shortest string "/"  return ('/');              break;          case 21: // Recognized '[;]''	Shortest string ";"  return (';');              break;          case 22: // Recognized '[=]''	Shortest string "="  return ('=');              break;          case 23: // Recognized '[a-zA-Z0-9_]+''	Shortest string "A"          case 24: // Recognized '[a-zA-Z0-9_]+''	Shortest string "D"          case 25: // Recognized '[a-zA-Z0-9_]+''	Shortest string "E"          case 26: // Recognized '[a-zA-Z0-9_]+''	Shortest string "H"          case 27: // Recognized '[a-zA-Z0-9_]+''	Shortest string "I"          case 28: // Recognized '[a-zA-Z0-9_]+''	Shortest string "S"          case 29: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ST"          case 30: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STE"          case 31: // Recognized '[a-zA-Z0-9_]+''	Shortest string "STEP"          case 33: // Recognized '[a-zA-Z0-9_]+''	Shortest string "IS"          case 34: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ISO"          case 36: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HE"          case 37: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEA"          case 38: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEAD"          case 39: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADE"          case 40: // Recognized '[a-zA-Z0-9_]+''	Shortest string "HEADER"          case 42: // Recognized '[a-zA-Z0-9_]+''	Shortest string "EN"          case 43: // Recognized '[a-zA-Z0-9_]+''	Shortest string "END"          case 44: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDS"          case 45: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSC"          case 46: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSE"          case 47: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDST"          case 48: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTE"          case 49: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSTEP"          case 52: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSEC"          case 54: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCO"          case 55: // Recognized '[a-zA-Z0-9_]+''	Shortest string "ENDSCOP"          case 58: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DA"          case 59: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DAT"          case 60: // Recognized '[a-zA-Z0-9_]+''	Shortest string "DATA"          case 64: // Recognized '[a-zA-Z0-9_]+''	Shortest string "00E"  SetValue(); return((int)Tokens.TYPE);              break;          case 32: // Recognized 'STEP;''	Shortest string "STEP;"  return((int)Tokens.ISOSTEPSTART);              break;          case 35: // Recognized 'ISO[0-9\-]*;''	Shortest string "ISO;"  return((int)Tokens.ISOSTEPSTART);              break;          case 41: // Recognized 'HEADER;''	Shortest string "HEADER;"  return((int)Tokens.HEADER);              break;          case 50: // Recognized 'ENDSTEP;''	Shortest string "ENDSTEP;"  return((int)Tokens.ISOSTEPEND);              break;          case 51: // Recognized '"ENDSTEP;".*''	Shortest string "ENDSTEP;\x01"  return((int)Tokens.ISOSTEPEND);              break;          case 53: // Recognized 'ENDSEC;''	Shortest string "ENDSEC;"  return((int)Tokens.ENDSEC);              break;          case 56: // Recognized 'ENDSCOPE''	Shortest string "ENDSCOPE"  return((int)Tokens.ENDSCOPE);              break;          case 57: // Recognized '"END-ISO"[0-9\-]*;''	Shortest string "END-ISO;"  return((int)Tokens.ISOSTEPEND);              break;          case 61: // Recognized 'DATA;''	Shortest string "DATA;"  return((int)Tokens.DATA);              break;          case 62: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+."          case 67: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string "+.#IND"          case 69: // Recognized '[\-\+\.0-9][\.0-9]+((#INF)|(#IND))?''	Shortest string ".0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 65: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "+.E+"          case 66: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string "00E0"          case 73: // Recognized '[\-\+\.0-9][\.0-9]+E[\-\+0-9][0-9]*''	Shortest string ".0E0"  SetValue(); return((int)Tokens.FLOAT);              break;          case 68: // Recognized '"/*"''	Shortest string "/*"  BEGIN(COMMENT);              break;          case 70: // Recognized '[\.][U][\.]''	Shortest string ".U."  return((int)Tokens.NONDEF);              break;          case 71: // Recognized '[\.][a-zA-Z0-9_ ]+[\.]''	Shortest string ".\x20."  SetValue(); return((int)Tokens.ENUM);              break;          case 72: // Recognized '[\.][TF][\.]''	Shortest string ".F."  SetValue(); return((int)Tokens.BOOLEAN);              break;          case 75: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "''"          case 76: // Recognized '[\']([\001-\046\050-\377]|(\'\')|(\\S\\.))*[\']''	Shortest string "'\\S\\'"  SetValue();  return((int)Tokens.STRING);              break;          case 77: // Recognized '&SCOPE''	Shortest string "&SCOPE"  return((int)Tokens.SCOPE);              break;          case 78: // Recognized '#[0-9]+''	Shortest string "#0"  SetValue(); return((int)Tokens.IDENTITY);              break;          case 79: // Recognized '#[0-9]+/=''	Shortest string "#0="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 80: // Recognized '#[0-9]+[ \t]*/=''	Shortest string "#0\t="  _yytrunc(1);   SetValue(); return((int)Tokens.ENTITY);              break;          case 81: // Recognized '[\"][0-9A-Fa-f]+[\"]''	Shortest string "\"0\""  SetValue(); return((int)Tokens.HEXA);              break;          case 82: // Recognized '![a-zA-Z0-9_]+''	Shortest string "!0"  SetValue(); return((int)Tokens.TYPE);              break;          case 83: // In <COMMENT> Recognized '"*/"''	Shortest string "*/"  BEGIN(INITIAL);              break;          default:              break;      }  #pragma warning restore 162' 1522  #endregion                      }                  }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[0] = new State(new int[]{65'93'72'72'63'73}'new int[]{-1'1'-7'3'-5'4'-12'94'-13'95'-11'96'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[1] = new State(new int[]{64'2});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[1] = new State(new int[]{64'2});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[2] = new State(-1);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[3] = new State(-11);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[3] = new State(-11);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[4] = new State(new int[]{66'92}'new int[]{-6'5});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[4] = new State(new int[]{66'92}'new int[]{-6'5});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[4] = new State(new int[]{66'92}'new int[]{-6'5});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[4] = new State(new int[]{66'92}'new int[]{-6'5});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[4] = new State(new int[]{66'92}'new int[]{-6'5});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[5] = new State(new int[]{73'54'84'55'63'84'67'17}'new int[]{-8'6'-9'85'-14'91'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[5] = new State(new int[]{73'54'84'55'63'84'67'17}'new int[]{-8'6'-9'85'-14'91'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[5] = new State(new int[]{73'54'84'55'63'84'67'17}'new int[]{-8'6'-9'85'-14'91'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[5] = new State(new int[]{73'54'84'55'63'84'67'17}'new int[]{-8'6'-9'85'-14'91'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[5] = new State(new int[]{73'54'84'55'63'84'67'17}'new int[]{-8'6'-9'85'-14'91'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[5] = new State(new int[]{73'54'84'55'63'84'67'17}'new int[]{-8'6'-9'85'-14'91'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[5] = new State(new int[]{73'54'84'55'63'84'67'17}'new int[]{-8'6'-9'85'-14'91'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[5] = new State(new int[]{73'54'84'55'63'84'67'17}'new int[]{-8'6'-9'85'-14'91'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[5] = new State(new int[]{73'54'84'55'63'84'67'17}'new int[]{-8'6'-9'85'-14'91'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[5] = new State(new int[]{73'54'84'55'63'84'67'17}'new int[]{-8'6'-9'85'-14'91'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[5] = new State(new int[]{73'54'84'55'63'84'67'17}'new int[]{-8'6'-9'85'-14'91'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[5] = new State(new int[]{73'54'84'55'63'84'67'17}'new int[]{-8'6'-9'85'-14'91'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[5] = new State(new int[]{73'54'84'55'63'84'67'17}'new int[]{-8'6'-9'85'-14'91'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[5] = new State(new int[]{73'54'84'55'63'84'67'17}'new int[]{-8'6'-9'85'-14'91'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[5] = new State(new int[]{73'54'84'55'63'84'67'17}'new int[]{-8'6'-9'85'-14'91'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[5] = new State(new int[]{73'54'84'55'63'84'67'17}'new int[]{-8'6'-9'85'-14'91'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[5] = new State(new int[]{73'54'84'55'63'84'67'17}'new int[]{-8'6'-9'85'-14'91'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[6] = new State(new int[]{67'17'73'54'84'55'63'84}'new int[]{-9'7'-14'80'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[6] = new State(new int[]{67'17'73'54'84'55'63'84}'new int[]{-9'7'-14'80'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[6] = new State(new int[]{67'17'73'54'84'55'63'84}'new int[]{-9'7'-14'80'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[6] = new State(new int[]{67'17'73'54'84'55'63'84}'new int[]{-9'7'-14'80'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[6] = new State(new int[]{67'17'73'54'84'55'63'84}'new int[]{-9'7'-14'80'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[6] = new State(new int[]{67'17'73'54'84'55'63'84}'new int[]{-9'7'-14'80'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[6] = new State(new int[]{67'17'73'54'84'55'63'84}'new int[]{-9'7'-14'80'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[6] = new State(new int[]{67'17'73'54'84'55'63'84}'new int[]{-9'7'-14'80'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[6] = new State(new int[]{67'17'73'54'84'55'63'84}'new int[]{-9'7'-14'80'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[6] = new State(new int[]{67'17'73'54'84'55'63'84}'new int[]{-9'7'-14'80'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[6] = new State(new int[]{67'17'73'54'84'55'63'84}'new int[]{-9'7'-14'80'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[6] = new State(new int[]{67'17'73'54'84'55'63'84}'new int[]{-9'7'-14'80'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[6] = new State(new int[]{67'17'73'54'84'55'63'84}'new int[]{-9'7'-14'80'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[6] = new State(new int[]{67'17'73'54'84'55'63'84}'new int[]{-9'7'-14'80'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[6] = new State(new int[]{67'17'73'54'84'55'63'84}'new int[]{-9'7'-14'80'-15'81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[7] = new State(new int[]{68'79}'new int[]{-10'8});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[7] = new State(new int[]{68'79}'new int[]{-10'8});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[7] = new State(new int[]{68'79}'new int[]{-10'8});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[7] = new State(new int[]{68'79}'new int[]{-10'8});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[7] = new State(new int[]{68'79}'new int[]{-10'8});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[8] = new State(new int[]{72'72'63'73}'new int[]{-11'9'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[8] = new State(new int[]{72'72'63'73}'new int[]{-11'9'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[8] = new State(new int[]{72'72'63'73}'new int[]{-11'9'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[8] = new State(new int[]{72'72'63'73}'new int[]{-11'9'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[8] = new State(new int[]{72'72'63'73}'new int[]{-11'9'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[8] = new State(new int[]{72'72'63'73}'new int[]{-11'9'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[8] = new State(new int[]{72'72'63'73}'new int[]{-11'9'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[8] = new State(new int[]{72'72'63'73}'new int[]{-11'9'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[8] = new State(new int[]{72'72'63'73}'new int[]{-11'9'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[8] = new State(new int[]{72'72'63'73}'new int[]{-11'9'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[8] = new State(new int[]{72'72'63'73}'new int[]{-11'9'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[9] = new State(new int[]{67'17'72'72'63'73}'new int[]{-9'10'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[9] = new State(new int[]{67'17'72'72'63'73}'new int[]{-9'10'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[9] = new State(new int[]{67'17'72'72'63'73}'new int[]{-9'10'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[9] = new State(new int[]{67'17'72'72'63'73}'new int[]{-9'10'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[9] = new State(new int[]{67'17'72'72'63'73}'new int[]{-9'10'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[9] = new State(new int[]{67'17'72'72'63'73}'new int[]{-9'10'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[9] = new State(new int[]{67'17'72'72'63'73}'new int[]{-9'10'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[9] = new State(new int[]{67'17'72'72'63'73}'new int[]{-9'10'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[9] = new State(new int[]{67'17'72'72'63'73}'new int[]{-9'10'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[9] = new State(new int[]{67'17'72'72'63'73}'new int[]{-9'10'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[9] = new State(new int[]{67'17'72'72'63'73}'new int[]{-9'10'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[9] = new State(new int[]{67'17'72'72'63'73}'new int[]{-9'10'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[9] = new State(new int[]{67'17'72'72'63'73}'new int[]{-9'10'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[10] = new State(new int[]{69'12}'new int[]{-4'11});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[10] = new State(new int[]{69'12}'new int[]{-4'11});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[10] = new State(new int[]{69'12}'new int[]{-4'11});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[10] = new State(new int[]{69'12}'new int[]{-4'11});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[10] = new State(new int[]{69'12}'new int[]{-4'11});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[11] = new State(-8);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[11] = new State(-8);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[12] = new State(new int[]{32'15'64'-4}'new int[]{-2'13});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[12] = new State(new int[]{32'15'64'-4}'new int[]{-2'13});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[12] = new State(new int[]{32'15'64'-4}'new int[]{-2'13});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[12] = new State(new int[]{32'15'64'-4}'new int[]{-2'13});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[12] = new State(new int[]{32'15'64'-4}'new int[]{-2'13});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[12] = new State(new int[]{32'15'64'-4}'new int[]{-2'13});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[12] = new State(new int[]{32'15'64'-4}'new int[]{-2'13});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[13] = new State(new int[]{32'14'64'-5});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[13] = new State(new int[]{32'14'64'-5});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[13] = new State(new int[]{32'14'64'-5});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[13] = new State(new int[]{32'14'64'-5});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[13] = new State(new int[]{32'14'64'-5});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[14] = new State(-3);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[14] = new State(-3);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[15] = new State(-2);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[15] = new State(-2);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[16] = new State(-43);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[16] = new State(-43);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[17] = new State(new int[]{32'15'68'-15'69'-15}'new int[]{-2'18});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[17] = new State(new int[]{32'15'68'-15'69'-15}'new int[]{-2'18});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[17] = new State(new int[]{32'15'68'-15'69'-15}'new int[]{-2'18});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[17] = new State(new int[]{32'15'68'-15'69'-15}'new int[]{-2'18});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[17] = new State(new int[]{32'15'68'-15'69'-15}'new int[]{-2'18});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[17] = new State(new int[]{32'15'68'-15'69'-15}'new int[]{-2'18});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[17] = new State(new int[]{32'15'68'-15'69'-15}'new int[]{-2'18});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[17] = new State(new int[]{32'15'68'-15'69'-15}'new int[]{-2'18});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[17] = new State(new int[]{32'15'68'-15'69'-15}'new int[]{-2'18});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[18] = new State(new int[]{32'14'68'-16'69'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[18] = new State(new int[]{32'14'68'-16'69'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[18] = new State(new int[]{32'14'68'-16'69'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[18] = new State(new int[]{32'14'68'-16'69'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[18] = new State(new int[]{32'14'68'-16'69'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[18] = new State(new int[]{32'14'68'-16'69'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[18] = new State(new int[]{32'14'68'-16'69'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[19] = new State(new int[]{61'20});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[19] = new State(new int[]{61'20});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[19] = new State(new int[]{61'20});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[20] = new State(new int[]{73'54'84'55'40'56'70'78}'new int[]{-24'21'-25'23'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[20] = new State(new int[]{73'54'84'55'40'56'70'78}'new int[]{-24'21'-25'23'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[20] = new State(new int[]{73'54'84'55'40'56'70'78}'new int[]{-24'21'-25'23'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[20] = new State(new int[]{73'54'84'55'40'56'70'78}'new int[]{-24'21'-25'23'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[20] = new State(new int[]{73'54'84'55'40'56'70'78}'new int[]{-24'21'-25'23'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[20] = new State(new int[]{73'54'84'55'40'56'70'78}'new int[]{-24'21'-25'23'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[20] = new State(new int[]{73'54'84'55'40'56'70'78}'new int[]{-24'21'-25'23'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[20] = new State(new int[]{73'54'84'55'40'56'70'78}'new int[]{-24'21'-25'23'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[20] = new State(new int[]{73'54'84'55'40'56'70'78}'new int[]{-24'21'-25'23'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[20] = new State(new int[]{73'54'84'55'40'56'70'78}'new int[]{-24'21'-25'23'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[20] = new State(new int[]{73'54'84'55'40'56'70'78}'new int[]{-24'21'-25'23'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[20] = new State(new int[]{73'54'84'55'40'56'70'78}'new int[]{-24'21'-25'23'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[20] = new State(new int[]{73'54'84'55'40'56'70'78}'new int[]{-24'21'-25'23'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[20] = new State(new int[]{73'54'84'55'40'56'70'78}'new int[]{-24'21'-25'23'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[20] = new State(new int[]{73'54'84'55'40'56'70'78}'new int[]{-24'21'-25'23'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[21] = new State(new int[]{59'22});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[21] = new State(new int[]{59'22});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[21] = new State(new int[]{59'22});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[22] = new State(-44);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[22] = new State(-44);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[23] = new State(new int[]{72'72'63'73'71'63}'new int[]{-11'24'-26'74'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[23] = new State(new int[]{72'72'63'73'71'63}'new int[]{-11'24'-26'74'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[23] = new State(new int[]{72'72'63'73'71'63}'new int[]{-11'24'-26'74'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[23] = new State(new int[]{72'72'63'73'71'63}'new int[]{-11'24'-26'74'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[23] = new State(new int[]{72'72'63'73'71'63}'new int[]{-11'24'-26'74'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[23] = new State(new int[]{72'72'63'73'71'63}'new int[]{-11'24'-26'74'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[23] = new State(new int[]{72'72'63'73'71'63}'new int[]{-11'24'-26'74'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[23] = new State(new int[]{72'72'63'73'71'63}'new int[]{-11'24'-26'74'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[23] = new State(new int[]{72'72'63'73'71'63}'new int[]{-11'24'-26'74'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[23] = new State(new int[]{72'72'63'73'71'63}'new int[]{-11'24'-26'74'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[23] = new State(new int[]{72'72'63'73'71'63}'new int[]{-11'24'-26'74'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[23] = new State(new int[]{72'72'63'73'71'63}'new int[]{-11'24'-26'74'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[23] = new State(new int[]{72'72'63'73'71'63}'new int[]{-11'24'-26'74'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[23] = new State(new int[]{72'72'63'73'71'63}'new int[]{-11'24'-26'74'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[23] = new State(new int[]{72'72'63'73'71'63}'new int[]{-11'24'-26'74'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[24] = new State(new int[]{71'63'72'72'63'73}'new int[]{-26'25'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[24] = new State(new int[]{71'63'72'72'63'73}'new int[]{-26'25'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[24] = new State(new int[]{71'63'72'72'63'73}'new int[]{-26'25'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[24] = new State(new int[]{71'63'72'72'63'73}'new int[]{-26'25'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[24] = new State(new int[]{71'63'72'72'63'73}'new int[]{-26'25'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[24] = new State(new int[]{71'63'72'72'63'73}'new int[]{-26'25'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[24] = new State(new int[]{71'63'72'72'63'73}'new int[]{-26'25'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[24] = new State(new int[]{71'63'72'72'63'73}'new int[]{-26'25'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[24] = new State(new int[]{71'63'72'72'63'73}'new int[]{-26'25'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[24] = new State(new int[]{71'63'72'72'63'73}'new int[]{-26'25'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[24] = new State(new int[]{71'63'72'72'63'73}'new int[]{-26'25'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[24] = new State(new int[]{71'63'72'72'63'73}'new int[]{-26'25'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[24] = new State(new int[]{71'63'72'72'63'73}'new int[]{-26'25'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[25] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'26'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[25] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'26'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[25] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'26'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[25] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'26'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[25] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'26'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[25] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'26'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[25] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'26'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[25] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'26'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[25] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'26'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[25] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'26'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[25] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'26'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[26] = new State(new int[]{59'27});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[26] = new State(new int[]{59'27});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[26] = new State(new int[]{59'27});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[27] = new State(-45);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[27] = new State(-45);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[28] = new State(new int[]{40'46}'new int[]{-16'29'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[28] = new State(new int[]{40'46}'new int[]{-16'29'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[28] = new State(new int[]{40'46}'new int[]{-16'29'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[28] = new State(new int[]{40'46}'new int[]{-16'29'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[28] = new State(new int[]{40'46}'new int[]{-16'29'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[28] = new State(new int[]{40'46}'new int[]{-16'29'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[28] = new State(new int[]{40'46}'new int[]{-16'29'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[29] = new State(-50);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[29] = new State(-50);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[30] = new State(new int[]{63'52'41'51'78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-20'31'-21'32'-17'53'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[31] = new State(-36);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[31] = new State(-36);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[32] = new State(new int[]{44'34'63'50'41'51}'new int[]{-20'33});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[32] = new State(new int[]{44'34'63'50'41'51}'new int[]{-20'33});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[32] = new State(new int[]{44'34'63'50'41'51}'new int[]{-20'33});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[32] = new State(new int[]{44'34'63'50'41'51}'new int[]{-20'33});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[32] = new State(new int[]{44'34'63'50'41'51}'new int[]{-20'33});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[32] = new State(new int[]{44'34'63'50'41'51}'new int[]{-20'33});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[32] = new State(new int[]{44'34'63'50'41'51}'new int[]{-20'33});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[32] = new State(new int[]{44'34'63'50'41'51}'new int[]{-20'33});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[32] = new State(new int[]{44'34'63'50'41'51}'new int[]{-20'33});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[33] = new State(-37);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[33] = new State(-37);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[34] = new State(new int[]{78'36'74'37'75'38'76'39'77'40'82'41'83'42'80'43'81'44'40'46'73'49}'new int[]{-17'35'-16'45'-19'30'-18'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[35] = new State(-40);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[35] = new State(-40);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[36] = new State(-22);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[36] = new State(-22);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[37] = new State(-23);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[37] = new State(-23);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[38] = new State(-24);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[38] = new State(-24);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[39] = new State(-25);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[39] = new State(-25);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[40] = new State(-26);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[40] = new State(-26);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[41] = new State(-27);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[41] = new State(-27);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[42] = new State(-28);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[42] = new State(-28);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[43] = new State(-29);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[43] = new State(-29);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[44] = new State(-30);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[44] = new State(-30);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[45] = new State(-31);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[45] = new State(-31);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[46] = new State(-34);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[46] = new State(-34);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[47] = new State(new int[]{40'46}'new int[]{-16'48'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[47] = new State(new int[]{40'46}'new int[]{-16'48'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[47] = new State(new int[]{40'46}'new int[]{-16'48'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[47] = new State(new int[]{40'46}'new int[]{-16'48'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[47] = new State(new int[]{40'46}'new int[]{-16'48'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[47] = new State(new int[]{40'46}'new int[]{-16'48'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[47] = new State(new int[]{40'46}'new int[]{-16'48'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[48] = new State(-32);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[48] = new State(-32);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[49] = new State(-33);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[49] = new State(-33);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[50] = new State(-41);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[50] = new State(-41);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[51] = new State(-35);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[51] = new State(-35);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[52] = new State(-38);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[52] = new State(-38);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[53] = new State(-39);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[53] = new State(-39);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[54] = new State(-60);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[54] = new State(-60);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[55] = new State(-61);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[55] = new State(-61);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[56] = new State(new int[]{73'54'84'55}'new int[]{-27'57'-15'61});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[56] = new State(new int[]{73'54'84'55}'new int[]{-27'57'-15'61});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[56] = new State(new int[]{73'54'84'55}'new int[]{-27'57'-15'61});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[56] = new State(new int[]{73'54'84'55}'new int[]{-27'57'-15'61});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[56] = new State(new int[]{73'54'84'55}'new int[]{-27'57'-15'61});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[56] = new State(new int[]{73'54'84'55}'new int[]{-27'57'-15'61});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[56] = new State(new int[]{73'54'84'55}'new int[]{-27'57'-15'61});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[56] = new State(new int[]{73'54'84'55}'new int[]{-27'57'-15'61});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[56] = new State(new int[]{73'54'84'55}'new int[]{-27'57'-15'61});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[57] = new State(new int[]{41'58'73'54'84'55}'new int[]{-15'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[57] = new State(new int[]{41'58'73'54'84'55}'new int[]{-15'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[57] = new State(new int[]{41'58'73'54'84'55}'new int[]{-15'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[57] = new State(new int[]{41'58'73'54'84'55}'new int[]{-15'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[57] = new State(new int[]{41'58'73'54'84'55}'new int[]{-15'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[57] = new State(new int[]{41'58'73'54'84'55}'new int[]{-15'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[57] = new State(new int[]{41'58'73'54'84'55}'new int[]{-15'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[57] = new State(new int[]{41'58'73'54'84'55}'new int[]{-15'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[57] = new State(new int[]{41'58'73'54'84'55}'new int[]{-15'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[58] = new State(-51);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[58] = new State(-51);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[59] = new State(new int[]{40'46}'new int[]{-16'60'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[59] = new State(new int[]{40'46}'new int[]{-16'60'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[59] = new State(new int[]{40'46}'new int[]{-16'60'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[59] = new State(new int[]{40'46}'new int[]{-16'60'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[59] = new State(new int[]{40'46}'new int[]{-16'60'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[59] = new State(new int[]{40'46}'new int[]{-16'60'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[59] = new State(new int[]{40'46}'new int[]{-16'60'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[60] = new State(-49);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[60] = new State(-49);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[61] = new State(new int[]{40'46}'new int[]{-16'62'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[61] = new State(new int[]{40'46}'new int[]{-16'62'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[61] = new State(new int[]{40'46}'new int[]{-16'62'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[61] = new State(new int[]{40'46}'new int[]{-16'62'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[61] = new State(new int[]{40'46}'new int[]{-16'62'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[61] = new State(new int[]{40'46}'new int[]{-16'62'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[61] = new State(new int[]{40'46}'new int[]{-16'62'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[62] = new State(-48);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[62] = new State(-48);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[63] = new State(new int[]{47'71'73'-57'84'-57'40'-57}'new int[]{-30'64});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[63] = new State(new int[]{47'71'73'-57'84'-57'40'-57}'new int[]{-30'64});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[63] = new State(new int[]{47'71'73'-57'84'-57'40'-57}'new int[]{-30'64});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[63] = new State(new int[]{47'71'73'-57'84'-57'40'-57}'new int[]{-30'64});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[63] = new State(new int[]{47'71'73'-57'84'-57'40'-57}'new int[]{-30'64});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[63] = new State(new int[]{47'71'73'-57'84'-57'40'-57}'new int[]{-30'64});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[63] = new State(new int[]{47'71'73'-57'84'-57'40'-57}'new int[]{-30'64});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[63] = new State(new int[]{47'71'73'-57'84'-57'40'-57}'new int[]{-30'64});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[63] = new State(new int[]{47'71'73'-57'84'-57'40'-57}'new int[]{-30'64});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[63] = new State(new int[]{47'71'73'-57'84'-57'40'-57}'new int[]{-30'64});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[63] = new State(new int[]{47'71'73'-57'84'-57'40'-57}'new int[]{-30'64});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[64] = new State(new int[]{78'69}'new int[]{-29'65'-28'70});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[64] = new State(new int[]{78'69}'new int[]{-29'65'-28'70});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[64] = new State(new int[]{78'69}'new int[]{-29'65'-28'70});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[64] = new State(new int[]{78'69}'new int[]{-29'65'-28'70});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[64] = new State(new int[]{78'69}'new int[]{-29'65'-28'70});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[64] = new State(new int[]{78'69}'new int[]{-29'65'-28'70});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[64] = new State(new int[]{78'69}'new int[]{-29'65'-28'70});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[65] = new State(new int[]{47'66'44'67});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[65] = new State(new int[]{47'66'44'67});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[65] = new State(new int[]{47'66'44'67});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[65] = new State(new int[]{47'66'44'67});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[65] = new State(new int[]{47'66'44'67});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[66] = new State(-58);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[66] = new State(-58);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[67] = new State(new int[]{78'69}'new int[]{-28'68});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[67] = new State(new int[]{78'69}'new int[]{-28'68});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[67] = new State(new int[]{78'69}'new int[]{-28'68});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[67] = new State(new int[]{78'69}'new int[]{-28'68});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[67] = new State(new int[]{78'69}'new int[]{-28'68});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[68] = new State(-55);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[68] = new State(-55);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[69] = new State(-53);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[69] = new State(-53);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[70] = new State(-54);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[70] = new State(-54);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[71] = new State(-56);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[71] = new State(-56);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[72] = new State(-59);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[72] = new State(-59);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[73] = new State(-47);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[73] = new State(-47);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[74] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'75'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[74] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'75'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[74] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'75'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[74] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'75'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[74] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'75'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[74] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'75'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[74] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'75'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[74] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'75'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[74] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'75'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[74] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'75'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[74] = new State(new int[]{73'54'84'55'40'56}'new int[]{-24'75'-15'28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[75] = new State(new int[]{59'76});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[75] = new State(new int[]{59'76});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[75] = new State(new int[]{59'76});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[76] = new State(-46);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[76] = new State(-46);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[77] = new State(-42);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[77] = new State(-42);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[78] = new State(-52);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[78] = new State(-52);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[79] = new State(-21);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[79] = new State(-21);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[80] = new State(-18);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[80] = new State(-18);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[81] = new State(new int[]{40'46}'new int[]{-16'82'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[81] = new State(new int[]{40'46}'new int[]{-16'82'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[81] = new State(new int[]{40'46}'new int[]{-16'82'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[81] = new State(new int[]{40'46}'new int[]{-16'82'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[81] = new State(new int[]{40'46}'new int[]{-16'82'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[81] = new State(new int[]{40'46}'new int[]{-16'82'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[81] = new State(new int[]{40'46}'new int[]{-16'82'-19'30});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[82] = new State(new int[]{59'83});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[82] = new State(new int[]{59'83});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[82] = new State(new int[]{59'83});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[83] = new State(-19);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[83] = new State(-19);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[84] = new State(-20);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[84] = new State(-20);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[85] = new State(new int[]{68'79}'new int[]{-10'86});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[85] = new State(new int[]{68'79}'new int[]{-10'86});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[85] = new State(new int[]{68'79}'new int[]{-10'86});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[85] = new State(new int[]{68'79}'new int[]{-10'86});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[85] = new State(new int[]{68'79}'new int[]{-10'86});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[86] = new State(new int[]{72'72'63'73}'new int[]{-11'87'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[86] = new State(new int[]{72'72'63'73}'new int[]{-11'87'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[86] = new State(new int[]{72'72'63'73}'new int[]{-11'87'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[86] = new State(new int[]{72'72'63'73}'new int[]{-11'87'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[86] = new State(new int[]{72'72'63'73}'new int[]{-11'87'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[86] = new State(new int[]{72'72'63'73}'new int[]{-11'87'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[86] = new State(new int[]{72'72'63'73}'new int[]{-11'87'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[86] = new State(new int[]{72'72'63'73}'new int[]{-11'87'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[86] = new State(new int[]{72'72'63'73}'new int[]{-11'87'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[86] = new State(new int[]{72'72'63'73}'new int[]{-11'87'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[86] = new State(new int[]{72'72'63'73}'new int[]{-11'87'-22'77'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[87] = new State(new int[]{63'90'67'17'72'72}'new int[]{-9'88'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[87] = new State(new int[]{63'90'67'17'72'72}'new int[]{-9'88'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[87] = new State(new int[]{63'90'67'17'72'72}'new int[]{-9'88'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[87] = new State(new int[]{63'90'67'17'72'72}'new int[]{-9'88'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[87] = new State(new int[]{63'90'67'17'72'72}'new int[]{-9'88'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[87] = new State(new int[]{63'90'67'17'72'72}'new int[]{-9'88'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[87] = new State(new int[]{63'90'67'17'72'72}'new int[]{-9'88'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[87] = new State(new int[]{63'90'67'17'72'72}'new int[]{-9'88'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[87] = new State(new int[]{63'90'67'17'72'72}'new int[]{-9'88'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[87] = new State(new int[]{63'90'67'17'72'72}'new int[]{-9'88'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[87] = new State(new int[]{63'90'67'17'72'72}'new int[]{-9'88'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[87] = new State(new int[]{63'90'67'17'72'72}'new int[]{-9'88'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[87] = new State(new int[]{63'90'67'17'72'72}'new int[]{-9'88'-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[88] = new State(new int[]{69'12}'new int[]{-4'89});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[88] = new State(new int[]{69'12}'new int[]{-4'89});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[88] = new State(new int[]{69'12}'new int[]{-4'89});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[88] = new State(new int[]{69'12}'new int[]{-4'89});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[88] = new State(new int[]{69'12}'new int[]{-4'89});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[89] = new State(-9);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[89] = new State(-9);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[90] = new State(new int[]{64'-10'63'-47'67'-47'72'-47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[90] = new State(new int[]{64'-10'63'-47'67'-47'72'-47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[90] = new State(new int[]{64'-10'63'-47'67'-47'72'-47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[90] = new State(new int[]{64'-10'63'-47'67'-47'72'-47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[90] = new State(new int[]{64'-10'63'-47'67'-47'72'-47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[90] = new State(new int[]{64'-10'63'-47'67'-47'72'-47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[90] = new State(new int[]{64'-10'63'-47'67'-47'72'-47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[90] = new State(new int[]{64'-10'63'-47'67'-47'72'-47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[90] = new State(new int[]{64'-10'63'-47'67'-47'72'-47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[91] = new State(-17);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[91] = new State(-17);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[92] = new State(-7);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[92] = new State(-7);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[93] = new State(-6);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[93] = new State(-6);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[94] = new State(-12);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[94] = new State(-12);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[95] = new State(-13);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[95] = new State(-13);
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[96] = new State(new int[]{72'72'63'73'64'-14}'new int[]{-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[96] = new State(new int[]{72'72'63'73'64'-14}'new int[]{-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[96] = new State(new int[]{72'72'63'73'64'-14}'new int[]{-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[96] = new State(new int[]{72'72'63'73'64'-14}'new int[]{-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[96] = new State(new int[]{72'72'63'73'64'-14}'new int[]{-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[96] = new State(new int[]{72'72'63'73'64'-14}'new int[]{-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[96] = new State(new int[]{72'72'63'73'64'-14}'new int[]{-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[96] = new State(new int[]{72'72'63'73'64'-14}'new int[]{-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[96] = new State(new int[]{72'72'63'73'64'-14}'new int[]{-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[96] = new State(new int[]{72'72'63'73'64'-14}'new int[]{-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: states[96] = new State(new int[]{72'72'63'73'64'-14}'new int[]{-22'16'-23'19});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[1] = new Rule(-3' new int[]{-1'64});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[1] = new Rule(-3' new int[]{-1'64});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[2] = new Rule(-2' new int[]{32});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[2] = new Rule(-2' new int[]{32});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[2] = new Rule(-2' new int[]{32});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[3] = new Rule(-2' new int[]{-2'32});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[3] = new Rule(-2' new int[]{-2'32});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[3] = new Rule(-2' new int[]{-2'32});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[3] = new Rule(-2' new int[]{-2'32});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[4] = new Rule(-4' new int[]{69});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[4] = new Rule(-4' new int[]{69});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[4] = new Rule(-4' new int[]{69});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[5] = new Rule(-4' new int[]{69'-2});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[5] = new Rule(-4' new int[]{69'-2});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[5] = new Rule(-4' new int[]{69'-2});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[5] = new Rule(-4' new int[]{69'-2});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[6] = new Rule(-5' new int[]{65});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[6] = new Rule(-5' new int[]{65});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[6] = new Rule(-5' new int[]{65});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[7] = new Rule(-6' new int[]{66});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[7] = new Rule(-6' new int[]{66});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[7] = new Rule(-6' new int[]{66});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[8] = new Rule(-7' new int[]{-5'-6'-8'-9'-10'-11'-9'-4});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[8] = new Rule(-7' new int[]{-5'-6'-8'-9'-10'-11'-9'-4});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[8] = new Rule(-7' new int[]{-5'-6'-8'-9'-10'-11'-9'-4});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[8] = new Rule(-7' new int[]{-5'-6'-8'-9'-10'-11'-9'-4});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[8] = new Rule(-7' new int[]{-5'-6'-8'-9'-10'-11'-9'-4});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[8] = new Rule(-7' new int[]{-5'-6'-8'-9'-10'-11'-9'-4});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[8] = new Rule(-7' new int[]{-5'-6'-8'-9'-10'-11'-9'-4});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[8] = new Rule(-7' new int[]{-5'-6'-8'-9'-10'-11'-9'-4});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[8] = new Rule(-7' new int[]{-5'-6'-8'-9'-10'-11'-9'-4});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[8] = new Rule(-7' new int[]{-5'-6'-8'-9'-10'-11'-9'-4});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[9] = new Rule(-12' new int[]{-5'-6'-9'-10'-11'-9'-4});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[9] = new Rule(-12' new int[]{-5'-6'-9'-10'-11'-9'-4});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[9] = new Rule(-12' new int[]{-5'-6'-9'-10'-11'-9'-4});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[9] = new Rule(-12' new int[]{-5'-6'-9'-10'-11'-9'-4});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[9] = new Rule(-12' new int[]{-5'-6'-9'-10'-11'-9'-4});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[9] = new Rule(-12' new int[]{-5'-6'-9'-10'-11'-9'-4});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[9] = new Rule(-12' new int[]{-5'-6'-9'-10'-11'-9'-4});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[9] = new Rule(-12' new int[]{-5'-6'-9'-10'-11'-9'-4});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[9] = new Rule(-12' new int[]{-5'-6'-9'-10'-11'-9'-4});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[10] = new Rule(-13' new int[]{-5'-6'-9'-10'-11'63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[10] = new Rule(-13' new int[]{-5'-6'-9'-10'-11'63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[10] = new Rule(-13' new int[]{-5'-6'-9'-10'-11'63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[10] = new Rule(-13' new int[]{-5'-6'-9'-10'-11'63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[10] = new Rule(-13' new int[]{-5'-6'-9'-10'-11'63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[10] = new Rule(-13' new int[]{-5'-6'-9'-10'-11'63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[10] = new Rule(-13' new int[]{-5'-6'-9'-10'-11'63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[10] = new Rule(-13' new int[]{-5'-6'-9'-10'-11'63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[11] = new Rule(-1' new int[]{-7});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[11] = new Rule(-1' new int[]{-7});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[12] = new Rule(-1' new int[]{-12});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[12] = new Rule(-1' new int[]{-12});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[13] = new Rule(-1' new int[]{-13});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[13] = new Rule(-1' new int[]{-13});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[14] = new Rule(-1' new int[]{-11});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[14] = new Rule(-1' new int[]{-11});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[15] = new Rule(-9' new int[]{67});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[15] = new Rule(-9' new int[]{67});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[15] = new Rule(-9' new int[]{67});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[16] = new Rule(-9' new int[]{67'-2});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[16] = new Rule(-9' new int[]{67'-2});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[16] = new Rule(-9' new int[]{67'-2});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[16] = new Rule(-9' new int[]{67'-2});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[17] = new Rule(-8' new int[]{-14});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[17] = new Rule(-8' new int[]{-14});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[17] = new Rule(-8' new int[]{-14});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[18] = new Rule(-8' new int[]{-8'-14});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[18] = new Rule(-8' new int[]{-8'-14});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[18] = new Rule(-8' new int[]{-8'-14});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[18] = new Rule(-8' new int[]{-8'-14});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[19] = new Rule(-14' new int[]{-15'-16'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[19] = new Rule(-14' new int[]{-15'-16'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[19] = new Rule(-14' new int[]{-15'-16'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[19] = new Rule(-14' new int[]{-15'-16'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[19] = new Rule(-14' new int[]{-15'-16'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[20] = new Rule(-14' new int[]{63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[20] = new Rule(-14' new int[]{63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[20] = new Rule(-14' new int[]{63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[21] = new Rule(-10' new int[]{68});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[21] = new Rule(-10' new int[]{68});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[21] = new Rule(-10' new int[]{68});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[22] = new Rule(-17' new int[]{78});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[22] = new Rule(-17' new int[]{78});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[22] = new Rule(-17' new int[]{78});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[23] = new Rule(-17' new int[]{74});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[23] = new Rule(-17' new int[]{74});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[23] = new Rule(-17' new int[]{74});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[24] = new Rule(-17' new int[]{75});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[24] = new Rule(-17' new int[]{75});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[24] = new Rule(-17' new int[]{75});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[25] = new Rule(-17' new int[]{76});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[25] = new Rule(-17' new int[]{76});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[25] = new Rule(-17' new int[]{76});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[26] = new Rule(-17' new int[]{77});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[26] = new Rule(-17' new int[]{77});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[26] = new Rule(-17' new int[]{77});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[27] = new Rule(-17' new int[]{82});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[27] = new Rule(-17' new int[]{82});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[27] = new Rule(-17' new int[]{82});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[28] = new Rule(-17' new int[]{83});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[28] = new Rule(-17' new int[]{83});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[28] = new Rule(-17' new int[]{83});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[29] = new Rule(-17' new int[]{80});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[29] = new Rule(-17' new int[]{80});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[29] = new Rule(-17' new int[]{80});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[30] = new Rule(-17' new int[]{81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[30] = new Rule(-17' new int[]{81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[30] = new Rule(-17' new int[]{81});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[31] = new Rule(-17' new int[]{-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[31] = new Rule(-17' new int[]{-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[31] = new Rule(-17' new int[]{-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[32] = new Rule(-17' new int[]{-18'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[32] = new Rule(-17' new int[]{-18'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[32] = new Rule(-17' new int[]{-18'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[32] = new Rule(-17' new int[]{-18'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[33] = new Rule(-18' new int[]{73});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[33] = new Rule(-18' new int[]{73});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[33] = new Rule(-18' new int[]{73});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[34] = new Rule(-19' new int[]{40});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[34] = new Rule(-19' new int[]{40});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[34] = new Rule(-19' new int[]{40});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[35] = new Rule(-20' new int[]{41});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[35] = new Rule(-20' new int[]{41});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[35] = new Rule(-20' new int[]{41});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[36] = new Rule(-16' new int[]{-19'-20});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[36] = new Rule(-16' new int[]{-19'-20});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[36] = new Rule(-16' new int[]{-19'-20});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[36] = new Rule(-16' new int[]{-19'-20});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[37] = new Rule(-16' new int[]{-19'-21'-20});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[37] = new Rule(-16' new int[]{-19'-21'-20});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[37] = new Rule(-16' new int[]{-19'-21'-20});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[37] = new Rule(-16' new int[]{-19'-21'-20});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[37] = new Rule(-16' new int[]{-19'-21'-20});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[38] = new Rule(-16' new int[]{-19'63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[38] = new Rule(-16' new int[]{-19'63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[38] = new Rule(-16' new int[]{-19'63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[38] = new Rule(-16' new int[]{-19'63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[39] = new Rule(-21' new int[]{-17});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[39] = new Rule(-21' new int[]{-17});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[39] = new Rule(-21' new int[]{-17});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[40] = new Rule(-21' new int[]{-21'44'-17});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[40] = new Rule(-21' new int[]{-21'44'-17});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[40] = new Rule(-21' new int[]{-21'44'-17});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[40] = new Rule(-21' new int[]{-21'44'-17});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[40] = new Rule(-21' new int[]{-21'44'-17});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[41] = new Rule(-21' new int[]{-21'63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[41] = new Rule(-21' new int[]{-21'63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[41] = new Rule(-21' new int[]{-21'63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[41] = new Rule(-21' new int[]{-21'63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[42] = new Rule(-11' new int[]{-22});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[42] = new Rule(-11' new int[]{-22});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[42] = new Rule(-11' new int[]{-22});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[43] = new Rule(-11' new int[]{-11'-22});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[43] = new Rule(-11' new int[]{-11'-22});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[43] = new Rule(-11' new int[]{-11'-22});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[43] = new Rule(-11' new int[]{-11'-22});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[44] = new Rule(-22' new int[]{-23'61'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[44] = new Rule(-22' new int[]{-23'61'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[44] = new Rule(-22' new int[]{-23'61'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[44] = new Rule(-22' new int[]{-23'61'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[44] = new Rule(-22' new int[]{-23'61'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[44] = new Rule(-22' new int[]{-23'61'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[45] = new Rule(-22' new int[]{-23'61'-25'-11'-26'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[45] = new Rule(-22' new int[]{-23'61'-25'-11'-26'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[45] = new Rule(-22' new int[]{-23'61'-25'-11'-26'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[45] = new Rule(-22' new int[]{-23'61'-25'-11'-26'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[45] = new Rule(-22' new int[]{-23'61'-25'-11'-26'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[45] = new Rule(-22' new int[]{-23'61'-25'-11'-26'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[45] = new Rule(-22' new int[]{-23'61'-25'-11'-26'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[45] = new Rule(-22' new int[]{-23'61'-25'-11'-26'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[45] = new Rule(-22' new int[]{-23'61'-25'-11'-26'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[46] = new Rule(-22' new int[]{-23'61'-25'-26'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[46] = new Rule(-22' new int[]{-23'61'-25'-26'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[46] = new Rule(-22' new int[]{-23'61'-25'-26'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[46] = new Rule(-22' new int[]{-23'61'-25'-26'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[46] = new Rule(-22' new int[]{-23'61'-25'-26'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[46] = new Rule(-22' new int[]{-23'61'-25'-26'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[46] = new Rule(-22' new int[]{-23'61'-25'-26'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[46] = new Rule(-22' new int[]{-23'61'-25'-26'-24'59});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[47] = new Rule(-22' new int[]{63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[47] = new Rule(-22' new int[]{63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[47] = new Rule(-22' new int[]{63});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[48] = new Rule(-27' new int[]{-15'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[48] = new Rule(-27' new int[]{-15'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[48] = new Rule(-27' new int[]{-15'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[48] = new Rule(-27' new int[]{-15'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[49] = new Rule(-27' new int[]{-27'-15'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[49] = new Rule(-27' new int[]{-27'-15'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[49] = new Rule(-27' new int[]{-27'-15'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[49] = new Rule(-27' new int[]{-27'-15'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[49] = new Rule(-27' new int[]{-27'-15'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[50] = new Rule(-24' new int[]{-15'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[50] = new Rule(-24' new int[]{-15'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[50] = new Rule(-24' new int[]{-15'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[50] = new Rule(-24' new int[]{-15'-16});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[51] = new Rule(-24' new int[]{40'-27'41});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[51] = new Rule(-24' new int[]{40'-27'41});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[51] = new Rule(-24' new int[]{40'-27'41});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[51] = new Rule(-24' new int[]{40'-27'41});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[51] = new Rule(-24' new int[]{40'-27'41});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[52] = new Rule(-25' new int[]{70});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[52] = new Rule(-25' new int[]{70});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[52] = new Rule(-25' new int[]{70});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[53] = new Rule(-28' new int[]{78});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[53] = new Rule(-28' new int[]{78});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[53] = new Rule(-28' new int[]{78});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[54] = new Rule(-29' new int[]{-28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[54] = new Rule(-29' new int[]{-28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[54] = new Rule(-29' new int[]{-28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[55] = new Rule(-29' new int[]{-29'44'-28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[55] = new Rule(-29' new int[]{-29'44'-28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[55] = new Rule(-29' new int[]{-29'44'-28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[55] = new Rule(-29' new int[]{-29'44'-28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[55] = new Rule(-29' new int[]{-29'44'-28});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[56] = new Rule(-30' new int[]{47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[56] = new Rule(-30' new int[]{47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[56] = new Rule(-30' new int[]{47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[57] = new Rule(-26' new int[]{71});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[57] = new Rule(-26' new int[]{71});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[57] = new Rule(-26' new int[]{71});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[58] = new Rule(-26' new int[]{71'-30'-29'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[58] = new Rule(-26' new int[]{71'-30'-29'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[58] = new Rule(-26' new int[]{71'-30'-29'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[58] = new Rule(-26' new int[]{71'-30'-29'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[58] = new Rule(-26' new int[]{71'-30'-29'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[58] = new Rule(-26' new int[]{71'-30'-29'47});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[59] = new Rule(-23' new int[]{72});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[59] = new Rule(-23' new int[]{72});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[59] = new Rule(-23' new int[]{72});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[60] = new Rule(-15' new int[]{73});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[60] = new Rule(-15' new int[]{73});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[60] = new Rule(-15' new int[]{73});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[61] = new Rule(-15' new int[]{84});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[61] = new Rule(-15' new int[]{84});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,P21Parser,The following statement contains a magic number: rules[61] = new Rule(-15' new int[]{84});
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following statement contains a magic number: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
Magic Number,Xbim.IO.Parser,BuildBuffer,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\StepP21Lex.cs,Mark,The following statement contains a magic number: data.Mark(bPos - 2);
Magic Number,Xbim.IO.Parser,BuildBuffer,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\StepP21Lex.cs,Read,The following statement contains a magic number: if (bPos < data.MaxIndex)              {                  // ch0 cannot be EOF                  return (int)data[bPos++];              }              else // Read from underlying stream              {                  // Experimental code' blocks of page size                  char[] chrs = new char[4096];                  int count = NextBlk(chrs' 0' 4096);                  if (count == 0)                      return EndOfFile;                  else                  {                      data.Append(chrs' count);                      return (int)data[bPos++];                  }              }
Magic Number,Xbim.IO.Parser,BuildBuffer,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\StepP21Lex.cs,Read,The following statement contains a magic number: if (bPos < data.MaxIndex)              {                  // ch0 cannot be EOF                  return (int)data[bPos++];              }              else // Read from underlying stream              {                  // Experimental code' blocks of page size                  char[] chrs = new char[4096];                  int count = NextBlk(chrs' 0' 4096);                  if (count == 0)                      return EndOfFile;                  else                  {                      data.Append(chrs' count);                      return (int)data[bPos++];                  }              }
Magic Number,Xbim.IO.Parser,BufferElement,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\StepP21Lex.cs,Mark,The following statement contains a magic number: if (limit > brkIx + 16) // Rotate blocks                  {                      StringBuilder temp = bldr;                      bldr = next;                      next = temp;                      next.Length = 0;                      minIx = brkIx;                      brkIx = maxIx;                  }
Magic Number,Xbim.IO.Parser,CodePageHandling,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\StepP21Lex.cs,GetCodePage,The following statement contains a magic number: if (command.StartsWith("CodePage:"' StringComparison.OrdinalIgnoreCase))                  command = command.Substring(9);
Magic Number,Xbim.IO.Parser,CodePageHandling,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\StepP21Lex.cs,GetCodePage,The following statement contains a magic number: try              {                  if (command.Equals("RAW"))                      return -1;                  else if (command.Equals("GUESS"))                      return -2;                  else if (command.Equals("DEFAULT"))                      return 0;                  else if (char.IsDigit(command[0]))                      return int.Parse(command' CultureInfo.InvariantCulture);                  else                  {                      Encoding enc = Encoding.GetEncoding(command);                      return enc.CodePage;                  }              }              catch (FormatException)              {                  Console.Error.WriteLine(                      "Invalid format \"{0}\"' using machine default"' option);              }              catch (ArgumentException)              {                  Console.Error.WriteLine(                      "Unknown code page \"{0}\"' using machine default"' option);              }
Magic Number,QUT.Gppg,ShiftReduceParser<TValue;TSpan>,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\ShiftReduceParserCode.cs,Shift,The following statement contains a magic number: if (recovering) {                  if (NextToken != errorToken)                      tokensSinceLastError++;                    if (tokensSinceLastError > 5)                      recovering = false;              }
Magic Number,QUT.Gppg,ShiftReduceParser<TValue;TSpan>,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\ShiftReduceParserCode.cs,ReportError,The following statement contains a magic number: if (FsaState.ParserTable.Count < 7) {                  bool first = true;                  foreach (int terminal in FsaState.ParserTable.Keys) {                      if (first)                          errorMsg.Append( "' expecting " );                      else                          errorMsg.Append( "' or " );                        errorMsg.Append( TerminalToString( terminal ) );                      first = false;                  }              }
Magic Number,QUT.Gppg,State,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\ShiftReduceParserCode.cs,State,The following statement contains a magic number: for (int i = 0; i < goToList.Length; i += 2)                  Goto.Add( goToList[i]' goToList[i + 1] );
Magic Number,QUT.Gppg,State,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\ShiftReduceParserCode.cs,State,The following statement contains a magic number: for (int i = 0; i < actions.Length; i += 2)                  ParserTable.Add( actions[i]' actions[i + 1] );
Magic Number,QUT.Gppg,State,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\ShiftReduceParserCode.cs,State,The following statement contains a magic number: for (int i = 0; i < goToList.Length; i += 2)                  Goto.Add( goToList[i]' goToList[i + 1] );
Magic Number,QUT.Gppg,PushdownPrefixState<T>,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\ShiftReduceParserCode.cs,Push,The following statement contains a magic number: if (tos >= array.Length) {                  T[] newarray = new T[array.Length * 2];                  System.Array.Copy( array' newarray' tos );                  array = newarray;              }
Magic Number,QUT.Gppg,PushdownPrefixState<T>,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\ShiftReduceParserCode.cs,Clear,The following statement contains a magic number: array = new T[8];
Missing Default,Xbim.IO.Esent,PersistedEntityInstanceCache,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Esent\PersistedEntityInstanceCache.cs,SaveAs,The following switch statement is missing a default case: switch (storageType)              {                  case IfcStorageType.IfcXml:                      SaveAsIfcXml(storageFileName);                      break;                  case IfcStorageType.Ifc:                  case IfcStorageType.Stp:                      SaveAsIfc(storageFileName' map);                      break;                  case IfcStorageType.IfcZip:                  case IfcStorageType.StpZip:                  case IfcStorageType.Zip:                      SaveAsIfcZip(storageFileName);                      break;                  case IfcStorageType.Xbim:                      Debug.Assert(false' "Incorrect call' see XbimModel.SaveAs");                      break;              }
Missing Default,Xbim.IO.Memory,MemoryModel,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Memory\MemoryModel.cs,GetFileHeader,The following switch statement is missing a default case: switch (zipStorageType)                              {                                  case IfcStorageType.Ifc:                                      return GetStepFileHeader(reader);                                  case IfcStorageType.IfcXml:                                      return XbimXmlReader4.ReadHeader(reader);                              }
Missing Default,Xbim.IO.Xml,XbimXmlReader4,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\XbimXmlReader4.cs,ReadHeader,The following switch statement is missing a default case: switch (input.LocalName.ToLowerInvariant())                  {                      case "name":                          header.FileName.Name = input.ReadInnerXml();                          break;                      case "time_stamp":                          header.FileName.TimeStamp = input.ReadInnerXml();                          break;                      case "author":                          header.FileName.AuthorName.Add(input.ReadInnerXml());                          break;                      case "organization":                          header.FileName.Organization.Add(input.ReadInnerXml());                          break;                      case "preprocessor_version":                          header.FileName.PreprocessorVersion = input.ReadInnerXml();                          break;                      case "originating_system":                          header.FileName.OriginatingSystem = input.ReadInnerXml();                          break;                      case "authorization":                          header.FileName.AuthorizationName = input.ReadInnerXml();                          break;                      case "documentation":                          header.FileDescription.Description.Add(input.ReadInnerXml());                          break;                  }
Missing Default,Xbim.IO.Xml,IfcXmlReader,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,Read,The following switch statement is missing a default case: switch (input.NodeType)                      {                          case XmlNodeType.Element:                              if (String.Compare(input.LocalName' "uos"' StringComparison.OrdinalIgnoreCase) == 0)                              {                                  _currentNode = new XmlUosCollection();                                }                              else if (                                  String.Compare(input.LocalName' "iso_10303_28"' StringComparison.OrdinalIgnoreCase) ==                                  0)                              {                                  foundHeader = true;                                    if (!string.IsNullOrWhiteSpace(input.Prefix))                                  {                                      _expressNamespace = input.Prefix;                                      _cTypeAttribute = _expressNamespace + ":cType";                                      _posAttribute = _expressNamespace + ":pos";                                      _expressNamespace += ":";                                  }                                  else                                  {                                      _cTypeAttribute = "cType";                                      _posAttribute = "pos";                                  } //correct the values if the namespace is defined correctly                                  while (input.MoveToNextAttribute())                                  {                                      if (input.Value == "urn:oid:1.0.10303.28.2.1.1" ||                                          input.Value ==                                          "urn:iso.org:standard:10303:part(28):version(2):xmlschema:common")                                      {                                          _expressNamespace = input.LocalName;                                          _cTypeAttribute = _expressNamespace + ":cType";                                          _posAttribute = _expressNamespace + ":pos";                                          _expressNamespace += ":";                                          break;                                      }                                  }                              }                              else                              {                                  headerId = input.LocalName.ToLower();                              }                              break;                          case XmlNodeType.Text:                              switch (headerId)                              {                                  case "name":                                      header.FileName.Name = input.Value;                                      break;                                  case "time_stamp":                                      header.FileName.TimeStamp = input.Value;                                      break;                                  case "author":                                      header.FileName.AuthorName.Add(input.Value);                                      break;                                  case "organization":                                      header.FileName.Organization.Add(input.Value);                                      break;                                  case "preprocessor_version":                                      header.FileName.PreprocessorVersion = input.Value;                                      break;                                  case "originating_system":                                      header.FileName.OriginatingSystem = input.Value;                                      break;                                  case "authorization":                                      header.FileName.AuthorizationName = input.Value;                                      break;                                  case "documentation":                                      header.FileDescription.Description.Add(input.Value);                                      break;                              }                              break;                      }
Missing Default,Xbim.IO.Xml,IfcXmlReader,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,Read,The following switch statement is missing a default case: switch (headerId)                              {                                  case "name":                                      header.FileName.Name = input.Value;                                      break;                                  case "time_stamp":                                      header.FileName.TimeStamp = input.Value;                                      break;                                  case "author":                                      header.FileName.AuthorName.Add(input.Value);                                      break;                                  case "organization":                                      header.FileName.Organization.Add(input.Value);                                      break;                                  case "preprocessor_version":                                      header.FileName.PreprocessorVersion = input.Value;                                      break;                                  case "originating_system":                                      header.FileName.OriginatingSystem = input.Value;                                      break;                                  case "authorization":                                      header.FileName.AuthorizationName = input.Value;                                      break;                                  case "documentation":                                      header.FileDescription.Description.Add(input.Value);                                      break;                              }
Missing Default,Xbim.IO.Xml,IfcXmlReader,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Xml\IfcXmlReader.cs,Read,The following switch statement is missing a default case: switch (input.NodeType)                          {                              case XmlNodeType.Element:                                  StartElement(input);                                  break;                              case XmlNodeType.EndElement:                                  IPersistEntity toWrite;                                  //if toWrite has a value we have completed an Ifc Entity                                  EndElement(input' prevInputType' prevInputName' out toWrite);                                  if (toWrite != null)                                  {                                      _entitiesParsed++;                                      _finish(toWrite);                                  }                                  break;                              case XmlNodeType.Whitespace:                                  SetValue(input' prevInputType);                                  break;                              case XmlNodeType.Text:                                  SetValue(input' prevInputType);                                  break;                          }
Missing Default,Xbim.IO.Parser,P21Parser,C:\repos\xBimTeam_XbimEssentials\Xbim.IO\Step21\Parser\Parser.cs,DoAction,The following switch statement is missing a default case: switch (action)      {        case 4: // endStep -> ISOSTEPEND  #line 38 "StepP21Parser.y"                      {EndParse();}  #line default          break;        case 5: // endStep -> ISOSTEPEND' trailingSpace  #line 40 "StepP21Parser.y"   {EndParse();}  #line default          break;        case 6: // beginStep -> ISOSTEPSTART  #line 43 "StepP21Parser.y"      {BeginParse(); }  #line default          break;        case 7: // startHeader -> HEADER  #line 48 "StepP21Parser.y"      {InHeader=true; BeginHeader();}  #line default          break;        case 15: // endSec -> ENDSEC  #line 57 "StepP21Parser.y"                 {EndSec();}  #line default          break;        case 16: // endSec -> ENDSEC' trailingSpace  #line 58 "StepP21Parser.y"                          {EndSec();}  #line default          break;        case 19: // headerEntity -> entityType' listArgument' ';'  #line 64 "StepP21Parser.y"                                             {EndHeaderEntity();}  #line default          break;        case 21: // endOfHeader -> DATA  #line 68 "StepP21Parser.y"   {  InHeader=false; EndHeader();  }  #line default          break;        case 22: // argument -> IDENTITY  #line 71 "StepP21Parser.y"                              {SetObjectValue(CurrentSemanticValue.strVal);}  #line default          break;        case 23: // argument -> INTEGER  #line 72 "StepP21Parser.y"                          {SetIntegerValue(CurrentSemanticValue.strVal);}  #line default          break;        case 24: // argument -> FLOAT  #line 73 "StepP21Parser.y"                            {SetFloatValue(CurrentSemanticValue.strVal);}  #line default          break;        case 25: // argument -> STRING  #line 74 "StepP21Parser.y"                         {SetStringValue(CurrentSemanticValue.strVal);}  #line default          break;        case 26: // argument -> BOOLEAN  #line 75 "StepP21Parser.y"                          {SetBooleanValue(CurrentSemanticValue.strVal);}  #line default          break;        case 27: // argument -> ENUM  #line 76 "StepP21Parser.y"                           {SetEnumValue(CurrentSemanticValue.strVal);}  #line default          break;        case 28: // argument -> HEXA  #line 77 "StepP21Parser.y"                           {SetHexValue(CurrentSemanticValue.strVal);}  #line default          break;        case 29: // argument -> NONDEF  #line 78 "StepP21Parser.y"                         {SetNonDefinedValue();}  #line default          break;        case 30: // argument -> OVERRIDE  #line 79 "StepP21Parser.y"                           {SetOverrideValue();}  #line default          break;        case 32: // argument -> listType' listArgument  #line 81 "StepP21Parser.y"                            {EndNestedType(CurrentSemanticValue.strVal);}  #line default          break;        case 33: // listType -> TYPE  #line 85 "StepP21Parser.y"   {  BeginNestedType(CurrentSemanticValue.strVal);  }  #line default          break;        case 34: // beginList -> '('  #line 88 "StepP21Parser.y"   {  BeginList(); }  #line default          break;        case 35: // endList -> ')'  #line 91 "StepP21Parser.y"   { EndList(); }  #line default          break;        case 41: // argumentList -> argumentList' error  #line 99 "StepP21Parser.y"                        {SetErrorMessage();}  #line default          break;        case 44: // bloc -> entityLabel' '='' entity' ';'  #line 104 "StepP21Parser.y"                                    {EndEntity();}  #line default          break;        case 45: // bloc -> entityLabel' '='' beginScope' model' endScope' entity' ';'  #line 105 "StepP21Parser.y"                                                         {EndEntity();}  #line default          break;        case 46: // bloc -> entityLabel' '='' beginScope' endScope' entity' ';'  #line 106 "StepP21Parser.y"                                                   {EndEntity();}  #line default          break;        case 47: // bloc -> error  #line 107 "StepP21Parser.y"            {SetErrorMessage();EndEntity();}  #line default          break;        case 53: // uniqueID -> IDENTITY  #line 119 "StepP21Parser.y"   {   SetObjectValue(CurrentSemanticValue.strVal);  }  #line default          break;        case 56: // beginExport -> '/'  #line 125 "StepP21Parser.y"   {  BeginList();  }  #line default          break;        case 59: // entityLabel -> ENTITY  #line 134 "StepP21Parser.y"   {  NewEntity(CurrentSemanticValue.strVal);  }  #line default          break;        case 60: // entityType -> TYPE  #line 137 "StepP21Parser.y"   {  SetType(CurrentSemanticValue.strVal);  }  #line default          break;        case 61: // entityType -> ILLEGALCHAR  #line 140 "StepP21Parser.y"   {  CharacterError();  }  #line default          break;      }
