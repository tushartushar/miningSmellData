Implementation smell,Namespace,Class,File,Method,Description
Long Method,CoreTweet,Request,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\Request.Async.cs,HttpPostWithMultipartFormDataAsync,The method has 108 lines of code.
Long Method,CoreTweet.Core,InternalUtils,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\InternalUtils.cs,ResolveObject,The method has 117 lines of code.
Long Method,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedAsyncImpl,The method has 101 lines of code.
Complex Method,CoreTweet,Request,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\Request.Async.cs,HttpPostWithMultipartFormDataAsync,Cyclomatic complexity of the method is 8
Complex Method,CoreTweet.Core,InternalUtils,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\InternalUtils.cs,ResolveObject,Cyclomatic complexity of the method is 15
Complex Method,CoreTweet.Core,InternalUtils,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\InternalUtils.cs,FormatObjectForParameter,Cyclomatic complexity of the method is 19
Complex Method,CoreTweet.Streaming,StreamingMessage,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Streaming\Messages.cs,ExtractRoot,Cyclomatic complexity of the method is 14
Long Parameter List,CoreTweet,TwitterException,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Exceptions.cs,TwitterException,The method has 5 parameters. Parameters: status' errors' rateLimit' json' innerException
Long Parameter List,CoreTweet,Request,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\Request.Async.cs,ExecuteRequest,The method has 5 parameters. Parameters: req' authorizationHeader' options' cancellationToken' progress
Long Parameter List,CoreTweet,Request,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\Request.Async.cs,HttpPostAsync,The method has 7 parameters. Parameters: url' contentType' content' authorizationHeader' options' cancellationToken' progress
Long Parameter List,CoreTweet,Request,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\Request.Async.cs,HttpPostAsync,The method has 6 parameters. Parameters: url' prm' authorizationHeader' options' cancellationToken' progress
Long Parameter List,CoreTweet,Request,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\Request.Async.cs,HttpPostWithMultipartFormDataAsync,The method has 6 parameters. Parameters: url' prm' authorizationHeader' options' cancellationToken' progress
Long Parameter List,CoreTweet,OAuth,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\OAuth.Async.cs,AuthorizeAsync,The method has 5 parameters. Parameters: consumerKey' consumerSecret' oauthCallback' options' cancellationToken
Long Parameter List,CoreTweet,Tokens,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Objects\Tokens.cs,Create,The method has 6 parameters. Parameters: consumerKey' consumerSecret' accessToken' accessSecret' userID' screenName
Long Parameter List,CoreTweet.Core,ProgressStream,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\ProgressHttpContent.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiAsync,The method has 5 parameters. Parameters: type' url' parameters' cancellationToken' jsonPath
Long Parameter List,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiAsync,The method has 5 parameters. Parameters: type' url' parameters' cancellationToken' jsonPath
Long Parameter List,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiAsyncImpl,The method has 5 parameters. Parameters: type' url' parameters' cancellationToken' jsonPath
Long Parameter List,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiArrayAsync,The method has 5 parameters. Parameters: type' url' parameters' cancellationToken' jsonPath
Long Parameter List,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiArrayAsync,The method has 5 parameters. Parameters: type' url' parameters' cancellationToken' jsonPath
Long Parameter List,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiArrayAsyncImpl,The method has 5 parameters. Parameters: type' url' parameters' cancellationToken' jsonPath
Long Parameter List,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiDictionaryAsync,The method has 5 parameters. Parameters: type' url' parameters' cancellationToken' jsonPath
Long Parameter List,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiDictionaryAsync,The method has 5 parameters. Parameters: type' url' parameters' cancellationToken' jsonPath
Long Parameter List,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiDictionaryAsyncImpl,The method has 5 parameters. Parameters: type' url' parameters' cancellationToken' jsonPath
Long Parameter List,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessJsonParameteredApiAsync,The method has 5 parameters. Parameters: url' parameters' jsonMap' cancellationToken' jsonPath
Long Parameter List,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessJsonParameteredApiAsync,The method has 5 parameters. Parameters: url' parameters' jsonMap' cancellationToken' jsonPath
Long Parameter List,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessJsonParameteredApiAsyncImpl,The method has 5 parameters. Parameters: url' parameters' jsonMap' cancellationToken' jsonPath
Long Parameter List,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessJsonParameteredApiArrayAsync,The method has 5 parameters. Parameters: url' parameters' jsonMap' cancellationToken' jsonPath
Long Parameter List,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessJsonParameteredApiArrayAsync,The method has 5 parameters. Parameters: url' parameters' jsonMap' cancellationToken' jsonPath
Long Parameter List,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessJsonParameteredApiArrayAsyncImpl,The method has 5 parameters. Parameters: url' parameters' jsonMap' cancellationToken' jsonPath
Long Parameter List,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,SendRequestAsyncImpl,The method has 5 parameters. Parameters: type' url' parameters' cancellationToken' progress
Long Parameter List,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,SendRequestAsyncImpl,The method has 6 parameters. Parameters: type' url' parameters' options' cancellationToken' progress
Long Parameter List,CoreTweet.Core,InternalUtils,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\InternalUtils.cs,AccessParameterReservedApiAsync,The method has 6 parameters. Parameters: t' m' uri' reserved' parameters' cancellationToken
Long Parameter List,CoreTweet.Core,InternalUtils,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\InternalUtils.cs,AccessParameterReservedApiArrayAsync,The method has 6 parameters. Parameters: t' m' uri' reserved' parameters' cancellationToken
Long Parameter List,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadAppendCommandAsync,The method has 5 parameters. Parameters: media_id' segment_index' media' cancellationToken' progress
Long Parameter List,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadAppendCommandAsync,The method has 5 parameters. Parameters: media_id' segment_index' media' cancellationToken' progress
Long Parameter List,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedAsyncImpl,The method has 8 parameters. Parameters: media' totalBytes' mediaType' parameters' retryCount' delay' cancellationToken' progress
Long Parameter List,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,AppendCore,The method has 7 parameters. Parameters: mediaId' segmentIndex' media' retryCount' delay' cancellationToken' report
Long Parameter List,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedAsync,The method has 6 parameters. Parameters: media' totalBytes' mediaType' parameters' cancellationToken' progress
Long Parameter List,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedAsync,The method has 6 parameters. Parameters: media' totalBytes' mediaType' parameters' cancellationToken' progress
Long Parameter List,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedAsync,The method has 7 parameters. Parameters: media' totalBytes' mediaType' media_category' additional_owners' cancellationToken' progress
Long Parameter List,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedAsync,The method has 5 parameters. Parameters: media' mediaType' parameters' cancellationToken' progress
Long Parameter List,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedAsync,The method has 5 parameters. Parameters: media' mediaType' parameters' cancellationToken' progress
Long Parameter List,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedAsync,The method has 6 parameters. Parameters: media' mediaType' media_category' additional_owners' cancellationToken' progress
Long Parameter List,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedWithRetryAsync,The method has 6 parameters. Parameters: media' totalBytes' mediaType' retryCount' retryDelayInMilliseconds' parameters
Long Parameter List,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedWithRetryAsync,The method has 5 parameters. Parameters: media' mediaType' retryCount' retryDelayInMilliseconds' parameters
Long Parameter List,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedWithRetryAsync,The method has 8 parameters. Parameters: media' totalBytes' mediaType' retryCount' retryDelayInMilliseconds' parameters' cancellationToken' progress
Long Parameter List,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedWithRetryAsync,The method has 8 parameters. Parameters: media' totalBytes' mediaType' retryCount' retryDelayInMilliseconds' parameters' cancellationToken' progress
Long Parameter List,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedWithRetryAsync,The method has 9 parameters. Parameters: media' totalBytes' mediaType' retryCount' retryDelayInMilliseconds' media_category' additional_owners' cancellationToken' progress
Long Parameter List,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedWithRetryAsync,The method has 7 parameters. Parameters: media' mediaType' retryCount' retryDelayInMilliseconds' parameters' cancellationToken' progress
Long Parameter List,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedWithRetryAsync,The method has 7 parameters. Parameters: media' mediaType' parameters' retryCount' retryDelayInMilliseconds' cancellationToken' progress
Long Parameter List,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedWithRetryAsync,The method has 8 parameters. Parameters: media' mediaType' retryCount' retryDelayInMilliseconds' media_category' additional_owners' cancellationToken' progress
Long Parameter List,CoreTweet.Streaming,StreamingApi,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Streaming\Stream.cs,UserAsObservable,The method has 5 parameters. Parameters: stall_warnings' with' replies' track' locations
Long Statement,CoreTweet,TwitterException,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Exceptions.cs,ParseErrors,The length of the statement  "            var match = Regex.Match(json' @"(Reason:\n<pre>\s+?(?<reason>[^<]+)<\/pre>|<h1>(?<reason>[^<]+)<\/h1>|<error>(?<reason>[^<]+)<\/error>)"); " is 138.
Long Statement,CoreTweet,Request,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\Request.Async.cs,GenerateSignature,The length of the statement  "                    UrlEncode(url.GetComponents(UriComponents.Scheme | UriComponents.UserInfo | UriComponents.Host | UriComponents.Port | UriComponents.Path' UriFormat.UriEscaped))' " is 161.
Long Statement,CoreTweet,OAuth,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\OAuth.Async.cs,GetTokensAsync,The length of the statement  "            var header = Tokens.Create(session.ConsumerKey' session.ConsumerSecret' session.RequestToken' session.RequestTokenSecret) " is 121.
Long Statement,CoreTweet,Tokens,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Objects\Tokens.cs,CreateAuthorizationHeader,The length of the statement  "            return "OAuth " + prms.Select(p => string.Format(@"{0}=""{1}"""' Request.UrlEncode(p.Key)' Request.UrlEncode(p.Value))).JoinToString("'"); " is 138.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiAsync,The length of the statement  "            return this.AccessApiAsyncImpl<T>(type' url' InternalUtils.ExpressionsToDictionary(parameters)' CancellationToken.None' jsonPath); " is 130.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiAsyncImpl,The length of the statement  "            return this.SendRequestAsyncImpl(type' InternalUtils.GetUrl(this.ConnectionOptions' url)' parameters' cancellationToken) " is 120.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiArrayAsync,The length of the statement  "            return this.AccessApiArrayAsyncImpl<T>(type' url' InternalUtils.ExpressionsToDictionary(parameters)' CancellationToken.None' jsonPath); " is 135.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiArrayAsync,The length of the statement  "            return this.AccessApiArrayAsyncImpl<T>(type' url' InternalUtils.ResolveObject(parameters)' cancellationToken' jsonPath); " is 120.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiArrayAsyncImpl,The length of the statement  "            return this.SendRequestAsyncImpl(type' InternalUtils.GetUrl(this.ConnectionOptions' url)' parameters' cancellationToken) " is 120.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiDictionaryAsync,The length of the statement  "            return this.AccessApiDictionaryAsyncImpl<TKey' TValue>(type' url' InternalUtils.ExpressionsToDictionary(parameters)' CancellationToken.None' jsonPath); " is 151.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiDictionaryAsync,The length of the statement  "            return this.AccessApiDictionaryAsyncImpl<TKey' TValue>(type' url' InternalUtils.ResolveObject(parameters)' cancellationToken' jsonPath); " is 136.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiDictionaryAsyncImpl,The length of the statement  "            return this.SendRequestAsyncImpl(type' InternalUtils.GetUrl(this.ConnectionOptions' url)' parameters' cancellationToken) " is 120.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiDictionaryAsyncImpl,The length of the statement  "                .ReadResponse(s => new DictionaryResponse<TKey' TValue>(CoreBase.Convert<Dictionary<TKey' TValue>>(s' jsonPath))' cancellationToken); " is 133.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiNoResponseAsync,The length of the statement  "            return this.AccessApiNoResponseAsyncImpl(type' url' InternalUtils.ExpressionsToDictionary(parameters)' CancellationToken.None); " is 127.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessApiNoResponseAsyncImpl,The length of the statement  "            return this.SendRequestAsyncImpl(type' InternalUtils.GetUrl(this.ConnectionOptions' url)' parameters' cancellationToken) " is 120.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessJsonParameteredApiAsync,The length of the statement  "            return this.AccessJsonParameteredApiAsyncImpl<T>(url' InternalUtils.ExpressionsToDictionary(parameters)' jsonMap' CancellationToken.None' jsonPath); " is 148.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessJsonParameteredApiAsync,The length of the statement  "            return this.AccessJsonParameteredApiAsyncImpl<T>(url' InternalUtils.ResolveObject(parameters)' jsonMap' cancellationToken' jsonPath); " is 133.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessJsonParameteredApiAsyncImpl,The length of the statement  "            return this.SendJsonRequestAsync(InternalUtils.GetUrl(this.ConnectionOptions' url)' parameters' jsonMap' cancellationToken) " is 123.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessJsonParameteredApiArrayAsync,The length of the statement  "            return this.AccessJsonParameteredApiArrayAsyncImpl<T>(url' InternalUtils.ExpressionsToDictionary(parameters)' jsonMap' CancellationToken.None' jsonPath); " is 153.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessJsonParameteredApiArrayAsync,The length of the statement  "            return this.AccessJsonParameteredApiArrayAsyncImpl<T>(url' InternalUtils.ResolveObject(parameters)' jsonMap' cancellationToken' jsonPath); " is 138.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,AccessJsonParameteredApiArrayAsyncImpl,The length of the statement  "            return this.SendJsonRequestAsync(InternalUtils.GetUrl(this.ConnectionOptions' url)' parameters' jsonMap' cancellationToken) " is 123.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,SendJsonRequestAsync,The length of the statement  "            return this.PostContentAsync(fullUrl' JsonContentType' InternalUtils.MapDictToJson(parameters' jsonMap)' cancellationToken); " is 124.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,SendRequestAsync,The length of the statement  "            return this.SendRequestAsyncImpl(type' url' InternalUtils.ExpressionsToDictionary(parameters)' this.ConnectionOptions' cancellationToken); " is 138.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,SendRequestAsync,The length of the statement  "            return this.SendRequestAsyncImpl(type' url' InternalUtils.ResolveObject(parameters)' this.ConnectionOptions' cancellationToken); " is 128.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,SendStreamingRequestAsync,The length of the statement  "            var options = this.ConnectionOptions != null ? (ConnectionOptions)this.ConnectionOptions.Clone() : new ConnectionOptions(); " is 123.
Long Statement,CoreTweet.Core,TokensBase,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\TokensBase.Async.cs,PostContentAsync,The length of the statement  "            return Request.HttpPostAsync(uri' contentType' content' CreateAuthorizationHeader(MethodType.Post' uri' null)' this.ConnectionOptions' cancellationToken) " is 153.
Long Statement,CoreTweet.Core,InternalUtils,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\InternalUtils.cs,AccessParameterReservedApiAsync,The length of the statement  "            return t.AccessApiAsyncImpl<T>(m' uri.Replace(string.Format("{{{0}}}"' reserved)' kvp.Value.ToString())' list' cancellationToken' ""); " is 134.
Long Statement,CoreTweet.Core,InternalUtils,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\InternalUtils.cs,AccessParameterReservedApiArrayAsync,The length of the statement  "            return t.AccessApiArrayAsyncImpl<T>(m' uri.Replace(string.Format("{{{0}}}"' reserved)' kvp.Value.ToString())' list' cancellationToken' ""); " is 139.
Long Statement,CoreTweet.Rest,Collections,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Collections.Async.cs,AccessApiAsync,The length of the statement  "            return this.Tokens.AccessApiAsyncImpl<CollectionsApiResult>(type' "collections/" + apiName' parameters' cancellationToken' ""); " is 127.
Long Statement,CoreTweet.Rest,MediaMetadata,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\MediaMetadata.Async.cs,CreateAsyncImpl,The length of the statement  "                .SendJsonRequestAsync(InternalUtils.GetUrl(options' options.UploadUrl' true' "media/metadata/create.json")' parameters' jsonMap' cancellationToken) " is 147.
Long Statement,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,AccessUploadApiAsync,The length of the statement  "            return this.Tokens.SendRequestAsyncImpl(MethodType.Post' InternalUtils.GetUrl(options' options.UploadUrl' true' "media/upload.json")' parameters' cancellationToken' progress); " is 175.
Long Statement,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,CommandAsync,The length of the statement  "            return this.AccessUploadApiAsync(parameters.EndWith(new KeyValuePair<string' object>("command"' command))' cancellationToken' progress); " is 136.
Long Statement,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadStatusCommandAsyncImpl,The length of the statement  "            return this.Tokens.SendRequestAsyncImpl(MethodType.Get' InternalUtils.GetUrl(options' options.UploadUrl' true' "media/upload.json")' " is 132.
Long Statement,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedAsyncImpl,The length of the statement  "                            this.AppendCore(result.MediaId' segmentIndex' new ArraySegment<byte>(chunk' 0' readCount)' retryCount' delay' cancellationToken' uploadReport) " is 142.
Long Statement,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedAsync,The length of the statement  "            return this.UploadChunkedAsyncImpl(media' totalBytes' mediaType' InternalUtils.ExpressionsToDictionary(parameters)' 0' 0' CancellationToken.None); " is 146.
Long Statement,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedAsync,The length of the statement  "            return this.UploadChunkedAsyncImpl(media' totalBytes' mediaType' InternalUtils.ResolveObject(parameters)' 0' 0' cancellationToken' progress); " is 141.
Long Statement,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedAsync,The length of the statement  "            return this.UploadChunkedAsync(media' media.Length' mediaType' media_category' additional_owners' cancellationToken' progress); " is 127.
Long Statement,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedWithRetryAsync,The length of the statement  "            return this.UploadChunkedAsyncImpl(media' totalBytes' mediaType' InternalUtils.ExpressionsToDictionary(parameters)' retryCount' retryDelayInMilliseconds' CancellationToken.None); " is 178.
Long Statement,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedWithRetryAsync,The length of the statement  "            return this.UploadChunkedWithRetryAsync(media' media.Length' mediaType' retryCount' retryDelayInMilliseconds' parameters); " is 122.
Long Statement,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedWithRetryAsync,The length of the statement  "            return this.UploadChunkedAsyncImpl(media' totalBytes' mediaType' parameters' retryCount' retryDelayInMilliseconds' cancellationToken' progress); " is 144.
Long Statement,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedWithRetryAsync,The length of the statement  "            return this.UploadChunkedAsyncImpl(media' totalBytes' mediaType' InternalUtils.ResolveObject(parameters)' retryCount' retryDelayInMilliseconds' cancellationToken' progress); " is 173.
Long Statement,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedWithRetryAsync,The length of the statement  "            return this.UploadChunkedAsyncImpl(media' totalBytes' mediaType' parameters'retryCount' retryDelayInMilliseconds' cancellationToken' progress); " is 143.
Long Statement,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedWithRetryAsync,The length of the statement  "            return this.UploadChunkedWithRetryAsync(media' media.Length' mediaType' retryCount' retryDelayInMilliseconds' parameters' cancellationToken' progress); " is 151.
Long Statement,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedWithRetryAsync,The length of the statement  "            return this.UploadChunkedWithRetryAsync(media' media.Length' mediaType' retryCount' retryDelayInMilliseconds' parameters' cancellationToken' progress); " is 151.
Long Statement,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedWithRetryAsync,The length of the statement  "            return this.UploadChunkedWithRetryAsync(media' media.Length' mediaType' retryCount' retryDelayInMilliseconds' media_category' additional_owners' cancellationToken' progress); " is 174.
Long Statement,CoreTweet.Streaming,StreamingMessage,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Streaming\Messages.cs,ExtractRoot,The length of the statement  "            throw new ParsingException("on streaming' cannot parse the json: unsupported type"' jo.ToString(Formatting.Indented)' null); " is 124.
Long Statement,CoreTweet.Streaming,StreamingApi,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Streaming\Stream.cs,StartStreamAsync,The length of the statement  "            return this.Tokens.SendStreamingRequestAsync(GetMethodType(type)' this.GetUrl(type)' parameters.Parameters' cancellationToken) " is 126.
Long Statement,CoreTweet.Streaming,StreamingConnection,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Streaming\StreamingObservable.cs,Start,The length of the statement  "                var firstTask = Task.Run(() => client.IncludedTokens.SendStreamingRequestAsync(GetMethodType(type)' client.GetUrl(type)' parameters' token)' token); " is 148.
Complex Conditional,CoreTweet.Core,InternalUtils,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\InternalUtils.cs,FormatObjectForParameter,The conditional expression  "x is IEnumerable<string>                  || x is IEnumerable<int>                  || x is IEnumerable<long>                  || x is IEnumerable<double>                  || x is IEnumerable<float>                  || x is IEnumerable<uint>                  || x is IEnumerable<ulong>                  || x is IEnumerable<short>                  || x is IEnumerable<ushort>                  || x is IEnumerable<decimal>"  is complex.
Empty Catch Block,CoreTweet,TwitterException,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Exceptions.cs,ParseErrors,The method has an empty catch block.
Magic Number,CoreTweet,Coordinates,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Objects\Status.cs,Coordinates,The following statement contains a magic number: _coordinates = new double[2];
Magic Number,CoreTweet.Core,TimestampConverter,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\Converters.cs,WriteJson,The following statement contains a magic number: if(value is DateTimeOffset)                  writer.WriteValue(((((DateTimeOffset)value).UtcTicks - InternalUtils.unixEpoch.UtcTicks) / 10000).ToString("D"));              else                  throw new InvalidOperationException("This object is not a DateTimeOffset");
Magic Number,CoreTweet.Core,InternalUtils,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\InternalUtils.cs,GetUnixTime,The following statement contains a magic number: return unixEpoch.AddTicks(checked(seconds * 10000000));
Magic Number,CoreTweet.Core,InternalUtils,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\InternalUtils.cs,GetUnixTimeMs,The following statement contains a magic number: return unixEpoch.AddTicks(checked(milliseconds * 10000));
Magic Number,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedAsyncImpl,The following statement contains a magic number: return this.UploadInitCommandAsyncImpl(                  parameters.EndWith(                      new KeyValuePair<string' object>("total_bytes"' totalBytes)'                      new KeyValuePair<string' object>("media_type"' mediaType)                  )' cancellationToken)                  .Done(result =>                  {                      const int maxChunkSize = 5 * 1000 * 1000;                      var estSegments = (int)((totalBytes + maxChunkSize - 1) / maxChunkSize);                      var tasks = new List<Task>(estSegments);                      var sem = new Semaphore(2' 2);                      var remainingBytes = totalBytes;                        List<UploadProgressInfo> reports = null;                      Action<int' UploadProgressInfo> uploadReport = null;                      Action<UploadFinalizeCommandResult> statusReport = null;                      var lastReport = new UploadChunkedProgressInfo(UploadChunkedProgressStage.SendingContent' 0' totalBytes' 0);                      if (progress != null)                      {                          reports = new List<UploadProgressInfo>(estSegments);                          uploadReport = (segmentIndex' info) =>                          {                              // Lock not to conflict with Add.                              lock (reports)                                  reports[segmentIndex] = info;                              long bytesSent = 0;                              long? totalBytesToSend = remainingBytes;                              // Don't use foreach to avoid InvalidOperationException.                              for (var i = 0; i < reports.Count; i++)                              {                                  var x = reports[i];                                  bytesSent += x.BytesSent;                                  totalBytesToSend += x.TotalBytesToSend;                              }                              if (totalBytesToSend.HasValue)                                  lastReport.TotalBytesToSend = totalBytesToSend.Value;                              lastReport.BytesSent = bytesSent;                              progress.Report(lastReport);                          };                          statusReport = x =>                          {                              if (x.ProcessingInfo == null) return;                              switch (x.ProcessingInfo.State)                              {                                  case "pending":                                      lastReport.Stage = UploadChunkedProgressStage.Pending;                                      break;                                  case "in_progress":                                      lastReport.Stage = UploadChunkedProgressStage.InProgress;                                      break;                              }                              var progressPercent = x.ProcessingInfo.ProgressPercent;                              if (progressPercent.HasValue)                                  lastReport.ProcessingProgressPercent = progressPercent.Value;                              progress.Report(lastReport);                          };                      }                        for (var segmentIndex = 0; remainingBytes > 0; segmentIndex++)                      {                          sem.WaitOne();                          if (tasks.Any(x => x.IsFaulted)) break;                            var chunkSize = (int)Math.Min(remainingBytes' maxChunkSize);                          var chunk = new byte[chunkSize];                          var readCount = media.Read(chunk' 0' chunkSize);                          if (readCount == 0) break;                          remainingBytes -= readCount;                          if (reports != null)                          {                              lock (reports)                                  reports.Add(new UploadProgressInfo(0' readCount));                          }                          tasks.Add(                              this.AppendCore(result.MediaId' segmentIndex' new ArraySegment<byte>(chunk' 0' readCount)' retryCount' delay' cancellationToken' uploadReport)                                  .ContinueWith(                                      t =>                                      {                                          sem.Release();                                          return t;                                      }'                                      CancellationToken.None'                                      TaskContinuationOptions.ExecuteSynchronously'                                      TaskScheduler.Default                                  )                                  .Unwrap()                          );                      }                        return Task.WhenAll(tasks)                          .Done(() => this.UploadFinalizeCommandAsync(result.MediaId' cancellationToken)' cancellationToken)                          .Unwrap()                          .Done(x =>                          {                              statusReport?.Invoke(x);                                return x.ProcessingInfo?.CheckAfterSecs != null                                  ? this.WaitForProcessing(x.MediaId' cancellationToken' statusReport)                                  : Task.FromResult(x);                          }' cancellationToken)                          .Unwrap()                          .Done(x => x as MediaUploadResult' cancellationToken);                  }' cancellationToken' TaskContinuationOptions.LongRunning)                  .Unwrap();
Magic Number,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedAsyncImpl,The following statement contains a magic number: return this.UploadInitCommandAsyncImpl(                  parameters.EndWith(                      new KeyValuePair<string' object>("total_bytes"' totalBytes)'                      new KeyValuePair<string' object>("media_type"' mediaType)                  )' cancellationToken)                  .Done(result =>                  {                      const int maxChunkSize = 5 * 1000 * 1000;                      var estSegments = (int)((totalBytes + maxChunkSize - 1) / maxChunkSize);                      var tasks = new List<Task>(estSegments);                      var sem = new Semaphore(2' 2);                      var remainingBytes = totalBytes;                        List<UploadProgressInfo> reports = null;                      Action<int' UploadProgressInfo> uploadReport = null;                      Action<UploadFinalizeCommandResult> statusReport = null;                      var lastReport = new UploadChunkedProgressInfo(UploadChunkedProgressStage.SendingContent' 0' totalBytes' 0);                      if (progress != null)                      {                          reports = new List<UploadProgressInfo>(estSegments);                          uploadReport = (segmentIndex' info) =>                          {                              // Lock not to conflict with Add.                              lock (reports)                                  reports[segmentIndex] = info;                              long bytesSent = 0;                              long? totalBytesToSend = remainingBytes;                              // Don't use foreach to avoid InvalidOperationException.                              for (var i = 0; i < reports.Count; i++)                              {                                  var x = reports[i];                                  bytesSent += x.BytesSent;                                  totalBytesToSend += x.TotalBytesToSend;                              }                              if (totalBytesToSend.HasValue)                                  lastReport.TotalBytesToSend = totalBytesToSend.Value;                              lastReport.BytesSent = bytesSent;                              progress.Report(lastReport);                          };                          statusReport = x =>                          {                              if (x.ProcessingInfo == null) return;                              switch (x.ProcessingInfo.State)                              {                                  case "pending":                                      lastReport.Stage = UploadChunkedProgressStage.Pending;                                      break;                                  case "in_progress":                                      lastReport.Stage = UploadChunkedProgressStage.InProgress;                                      break;                              }                              var progressPercent = x.ProcessingInfo.ProgressPercent;                              if (progressPercent.HasValue)                                  lastReport.ProcessingProgressPercent = progressPercent.Value;                              progress.Report(lastReport);                          };                      }                        for (var segmentIndex = 0; remainingBytes > 0; segmentIndex++)                      {                          sem.WaitOne();                          if (tasks.Any(x => x.IsFaulted)) break;                            var chunkSize = (int)Math.Min(remainingBytes' maxChunkSize);                          var chunk = new byte[chunkSize];                          var readCount = media.Read(chunk' 0' chunkSize);                          if (readCount == 0) break;                          remainingBytes -= readCount;                          if (reports != null)                          {                              lock (reports)                                  reports.Add(new UploadProgressInfo(0' readCount));                          }                          tasks.Add(                              this.AppendCore(result.MediaId' segmentIndex' new ArraySegment<byte>(chunk' 0' readCount)' retryCount' delay' cancellationToken' uploadReport)                                  .ContinueWith(                                      t =>                                      {                                          sem.Release();                                          return t;                                      }'                                      CancellationToken.None'                                      TaskContinuationOptions.ExecuteSynchronously'                                      TaskScheduler.Default                                  )                                  .Unwrap()                          );                      }                        return Task.WhenAll(tasks)                          .Done(() => this.UploadFinalizeCommandAsync(result.MediaId' cancellationToken)' cancellationToken)                          .Unwrap()                          .Done(x =>                          {                              statusReport?.Invoke(x);                                return x.ProcessingInfo?.CheckAfterSecs != null                                  ? this.WaitForProcessing(x.MediaId' cancellationToken' statusReport)                                  : Task.FromResult(x);                          }' cancellationToken)                          .Unwrap()                          .Done(x => x as MediaUploadResult' cancellationToken);                  }' cancellationToken' TaskContinuationOptions.LongRunning)                  .Unwrap();
Magic Number,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedAsyncImpl,The following statement contains a magic number: return this.UploadInitCommandAsyncImpl(                  parameters.EndWith(                      new KeyValuePair<string' object>("total_bytes"' totalBytes)'                      new KeyValuePair<string' object>("media_type"' mediaType)                  )' cancellationToken)                  .Done(result =>                  {                      const int maxChunkSize = 5 * 1000 * 1000;                      var estSegments = (int)((totalBytes + maxChunkSize - 1) / maxChunkSize);                      var tasks = new List<Task>(estSegments);                      var sem = new Semaphore(2' 2);                      var remainingBytes = totalBytes;                        List<UploadProgressInfo> reports = null;                      Action<int' UploadProgressInfo> uploadReport = null;                      Action<UploadFinalizeCommandResult> statusReport = null;                      var lastReport = new UploadChunkedProgressInfo(UploadChunkedProgressStage.SendingContent' 0' totalBytes' 0);                      if (progress != null)                      {                          reports = new List<UploadProgressInfo>(estSegments);                          uploadReport = (segmentIndex' info) =>                          {                              // Lock not to conflict with Add.                              lock (reports)                                  reports[segmentIndex] = info;                              long bytesSent = 0;                              long? totalBytesToSend = remainingBytes;                              // Don't use foreach to avoid InvalidOperationException.                              for (var i = 0; i < reports.Count; i++)                              {                                  var x = reports[i];                                  bytesSent += x.BytesSent;                                  totalBytesToSend += x.TotalBytesToSend;                              }                              if (totalBytesToSend.HasValue)                                  lastReport.TotalBytesToSend = totalBytesToSend.Value;                              lastReport.BytesSent = bytesSent;                              progress.Report(lastReport);                          };                          statusReport = x =>                          {                              if (x.ProcessingInfo == null) return;                              switch (x.ProcessingInfo.State)                              {                                  case "pending":                                      lastReport.Stage = UploadChunkedProgressStage.Pending;                                      break;                                  case "in_progress":                                      lastReport.Stage = UploadChunkedProgressStage.InProgress;                                      break;                              }                              var progressPercent = x.ProcessingInfo.ProgressPercent;                              if (progressPercent.HasValue)                                  lastReport.ProcessingProgressPercent = progressPercent.Value;                              progress.Report(lastReport);                          };                      }                        for (var segmentIndex = 0; remainingBytes > 0; segmentIndex++)                      {                          sem.WaitOne();                          if (tasks.Any(x => x.IsFaulted)) break;                            var chunkSize = (int)Math.Min(remainingBytes' maxChunkSize);                          var chunk = new byte[chunkSize];                          var readCount = media.Read(chunk' 0' chunkSize);                          if (readCount == 0) break;                          remainingBytes -= readCount;                          if (reports != null)                          {                              lock (reports)                                  reports.Add(new UploadProgressInfo(0' readCount));                          }                          tasks.Add(                              this.AppendCore(result.MediaId' segmentIndex' new ArraySegment<byte>(chunk' 0' readCount)' retryCount' delay' cancellationToken' uploadReport)                                  .ContinueWith(                                      t =>                                      {                                          sem.Release();                                          return t;                                      }'                                      CancellationToken.None'                                      TaskContinuationOptions.ExecuteSynchronously'                                      TaskScheduler.Default                                  )                                  .Unwrap()                          );                      }                        return Task.WhenAll(tasks)                          .Done(() => this.UploadFinalizeCommandAsync(result.MediaId' cancellationToken)' cancellationToken)                          .Unwrap()                          .Done(x =>                          {                              statusReport?.Invoke(x);                                return x.ProcessingInfo?.CheckAfterSecs != null                                  ? this.WaitForProcessing(x.MediaId' cancellationToken' statusReport)                                  : Task.FromResult(x);                          }' cancellationToken)                          .Unwrap()                          .Done(x => x as MediaUploadResult' cancellationToken);                  }' cancellationToken' TaskContinuationOptions.LongRunning)                  .Unwrap();
Magic Number,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedAsyncImpl,The following statement contains a magic number: return this.UploadInitCommandAsyncImpl(                  parameters.EndWith(                      new KeyValuePair<string' object>("total_bytes"' totalBytes)'                      new KeyValuePair<string' object>("media_type"' mediaType)                  )' cancellationToken)                  .Done(result =>                  {                      const int maxChunkSize = 5 * 1000 * 1000;                      var estSegments = (int)((totalBytes + maxChunkSize - 1) / maxChunkSize);                      var tasks = new List<Task>(estSegments);                      var sem = new Semaphore(2' 2);                      var remainingBytes = totalBytes;                        List<UploadProgressInfo> reports = null;                      Action<int' UploadProgressInfo> uploadReport = null;                      Action<UploadFinalizeCommandResult> statusReport = null;                      var lastReport = new UploadChunkedProgressInfo(UploadChunkedProgressStage.SendingContent' 0' totalBytes' 0);                      if (progress != null)                      {                          reports = new List<UploadProgressInfo>(estSegments);                          uploadReport = (segmentIndex' info) =>                          {                              // Lock not to conflict with Add.                              lock (reports)                                  reports[segmentIndex] = info;                              long bytesSent = 0;                              long? totalBytesToSend = remainingBytes;                              // Don't use foreach to avoid InvalidOperationException.                              for (var i = 0; i < reports.Count; i++)                              {                                  var x = reports[i];                                  bytesSent += x.BytesSent;                                  totalBytesToSend += x.TotalBytesToSend;                              }                              if (totalBytesToSend.HasValue)                                  lastReport.TotalBytesToSend = totalBytesToSend.Value;                              lastReport.BytesSent = bytesSent;                              progress.Report(lastReport);                          };                          statusReport = x =>                          {                              if (x.ProcessingInfo == null) return;                              switch (x.ProcessingInfo.State)                              {                                  case "pending":                                      lastReport.Stage = UploadChunkedProgressStage.Pending;                                      break;                                  case "in_progress":                                      lastReport.Stage = UploadChunkedProgressStage.InProgress;                                      break;                              }                              var progressPercent = x.ProcessingInfo.ProgressPercent;                              if (progressPercent.HasValue)                                  lastReport.ProcessingProgressPercent = progressPercent.Value;                              progress.Report(lastReport);                          };                      }                        for (var segmentIndex = 0; remainingBytes > 0; segmentIndex++)                      {                          sem.WaitOne();                          if (tasks.Any(x => x.IsFaulted)) break;                            var chunkSize = (int)Math.Min(remainingBytes' maxChunkSize);                          var chunk = new byte[chunkSize];                          var readCount = media.Read(chunk' 0' chunkSize);                          if (readCount == 0) break;                          remainingBytes -= readCount;                          if (reports != null)                          {                              lock (reports)                                  reports.Add(new UploadProgressInfo(0' readCount));                          }                          tasks.Add(                              this.AppendCore(result.MediaId' segmentIndex' new ArraySegment<byte>(chunk' 0' readCount)' retryCount' delay' cancellationToken' uploadReport)                                  .ContinueWith(                                      t =>                                      {                                          sem.Release();                                          return t;                                      }'                                      CancellationToken.None'                                      TaskContinuationOptions.ExecuteSynchronously'                                      TaskScheduler.Default                                  )                                  .Unwrap()                          );                      }                        return Task.WhenAll(tasks)                          .Done(() => this.UploadFinalizeCommandAsync(result.MediaId' cancellationToken)' cancellationToken)                          .Unwrap()                          .Done(x =>                          {                              statusReport?.Invoke(x);                                return x.ProcessingInfo?.CheckAfterSecs != null                                  ? this.WaitForProcessing(x.MediaId' cancellationToken' statusReport)                                  : Task.FromResult(x);                          }' cancellationToken)                          .Unwrap()                          .Done(x => x as MediaUploadResult' cancellationToken);                  }' cancellationToken' TaskContinuationOptions.LongRunning)                  .Unwrap();
Magic Number,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedAsyncImpl,The following statement contains a magic number: return this.UploadInitCommandAsyncImpl(                  parameters.EndWith(                      new KeyValuePair<string' object>("total_bytes"' totalBytes)'                      new KeyValuePair<string' object>("media_type"' mediaType)                  )' cancellationToken)                  .Done(result =>                  {                      const int maxChunkSize = 5 * 1000 * 1000;                      var estSegments = (int)((totalBytes + maxChunkSize - 1) / maxChunkSize);                      var tasks = new List<Task>(estSegments);                      var sem = new Semaphore(2' 2);                      var remainingBytes = totalBytes;                        List<UploadProgressInfo> reports = null;                      Action<int' UploadProgressInfo> uploadReport = null;                      Action<UploadFinalizeCommandResult> statusReport = null;                      var lastReport = new UploadChunkedProgressInfo(UploadChunkedProgressStage.SendingContent' 0' totalBytes' 0);                      if (progress != null)                      {                          reports = new List<UploadProgressInfo>(estSegments);                          uploadReport = (segmentIndex' info) =>                          {                              // Lock not to conflict with Add.                              lock (reports)                                  reports[segmentIndex] = info;                              long bytesSent = 0;                              long? totalBytesToSend = remainingBytes;                              // Don't use foreach to avoid InvalidOperationException.                              for (var i = 0; i < reports.Count; i++)                              {                                  var x = reports[i];                                  bytesSent += x.BytesSent;                                  totalBytesToSend += x.TotalBytesToSend;                              }                              if (totalBytesToSend.HasValue)                                  lastReport.TotalBytesToSend = totalBytesToSend.Value;                              lastReport.BytesSent = bytesSent;                              progress.Report(lastReport);                          };                          statusReport = x =>                          {                              if (x.ProcessingInfo == null) return;                              switch (x.ProcessingInfo.State)                              {                                  case "pending":                                      lastReport.Stage = UploadChunkedProgressStage.Pending;                                      break;                                  case "in_progress":                                      lastReport.Stage = UploadChunkedProgressStage.InProgress;                                      break;                              }                              var progressPercent = x.ProcessingInfo.ProgressPercent;                              if (progressPercent.HasValue)                                  lastReport.ProcessingProgressPercent = progressPercent.Value;                              progress.Report(lastReport);                          };                      }                        for (var segmentIndex = 0; remainingBytes > 0; segmentIndex++)                      {                          sem.WaitOne();                          if (tasks.Any(x => x.IsFaulted)) break;                            var chunkSize = (int)Math.Min(remainingBytes' maxChunkSize);                          var chunk = new byte[chunkSize];                          var readCount = media.Read(chunk' 0' chunkSize);                          if (readCount == 0) break;                          remainingBytes -= readCount;                          if (reports != null)                          {                              lock (reports)                                  reports.Add(new UploadProgressInfo(0' readCount));                          }                          tasks.Add(                              this.AppendCore(result.MediaId' segmentIndex' new ArraySegment<byte>(chunk' 0' readCount)' retryCount' delay' cancellationToken' uploadReport)                                  .ContinueWith(                                      t =>                                      {                                          sem.Release();                                          return t;                                      }'                                      CancellationToken.None'                                      TaskContinuationOptions.ExecuteSynchronously'                                      TaskScheduler.Default                                  )                                  .Unwrap()                          );                      }                        return Task.WhenAll(tasks)                          .Done(() => this.UploadFinalizeCommandAsync(result.MediaId' cancellationToken)' cancellationToken)                          .Unwrap()                          .Done(x =>                          {                              statusReport?.Invoke(x);                                return x.ProcessingInfo?.CheckAfterSecs != null                                  ? this.WaitForProcessing(x.MediaId' cancellationToken' statusReport)                                  : Task.FromResult(x);                          }' cancellationToken)                          .Unwrap()                          .Done(x => x as MediaUploadResult' cancellationToken);                  }' cancellationToken' TaskContinuationOptions.LongRunning)                  .Unwrap();
Magic Number,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,WaitForProcessing,The following statement contains a magic number: return this.UploadStatusCommandAsync(mediaId' cancellationToken)                  .ContinueWith(t =>                  {                      if (t.Status == TaskStatus.RanToCompletion)                      {                          var res = t.Result;                            if (res.ProcessingInfo?.State == "failed")                              throw new MediaProcessingException(res);                            report?.Invoke(res);                            if (res.ProcessingInfo?.CheckAfterSecs != null)                          {                              return Task.Delay(res.ProcessingInfo.CheckAfterSecs.Value * 1000' cancellationToken)                                  .Done(() => this.WaitForProcessing(mediaId' cancellationToken' report)' cancellationToken)                                  .Unwrap();                          }                            return Task.FromResult(res);                      }                        if (t.Exception != null)                      {                          var ex = t.Exception.InnerException;                          // Be sure that ex is not caused by a bug                          if (!(ex is TwitterException || ex is NullReferenceException || ex is ArgumentException))                          {                              // Retry                              return Task.Delay(5000' cancellationToken)                                  .Done(() => this.WaitForProcessing(mediaId' cancellationToken' report)' cancellationToken)                                  .Unwrap();                          }                      }                        return t;                  }' cancellationToken' TaskContinuationOptions.ExecuteSynchronously' TaskScheduler.Default)                  .Unwrap();
Magic Number,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,WaitForProcessing,The following statement contains a magic number: return this.UploadStatusCommandAsync(mediaId' cancellationToken)                  .ContinueWith(t =>                  {                      if (t.Status == TaskStatus.RanToCompletion)                      {                          var res = t.Result;                            if (res.ProcessingInfo?.State == "failed")                              throw new MediaProcessingException(res);                            report?.Invoke(res);                            if (res.ProcessingInfo?.CheckAfterSecs != null)                          {                              return Task.Delay(res.ProcessingInfo.CheckAfterSecs.Value * 1000' cancellationToken)                                  .Done(() => this.WaitForProcessing(mediaId' cancellationToken' report)' cancellationToken)                                  .Unwrap();                          }                            return Task.FromResult(res);                      }                        if (t.Exception != null)                      {                          var ex = t.Exception.InnerException;                          // Be sure that ex is not caused by a bug                          if (!(ex is TwitterException || ex is NullReferenceException || ex is ArgumentException))                          {                              // Retry                              return Task.Delay(5000' cancellationToken)                                  .Done(() => this.WaitForProcessing(mediaId' cancellationToken' report)' cancellationToken)                                  .Unwrap();                          }                      }                        return t;                  }' cancellationToken' TaskContinuationOptions.ExecuteSynchronously' TaskScheduler.Default)                  .Unwrap();
Missing Default,CoreTweet,TwitterException,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Exceptions.cs,ParseErrors,The following switch statement is missing a default case: switch(errors.Type)                      {                          case JTokenType.Array:                              return errors.Select(x => x.ToObject<Error>()).ToArray();                          case JTokenType.String:                              return errors.ToString().Replace("\\n"' "\n").Split('\n').Select(x => new Error { Message = x }).ToArray();                      }
Missing Default,CoreTweet.Core,DateTimeOffsetConverter,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Internal\Converters.cs,ReadJson,The following switch statement is missing a default case: switch(reader.TokenType)              {                  case JsonToken.String:                      return DateTimeOffset.ParseExact(reader.Value as string' "ddd MMM dd HH:mm:ss K yyyy"'                                                       DateTimeFormatInfo.InvariantInfo'                                                       DateTimeStyles.AllowWhiteSpaces);                  case JsonToken.Date:                      if (reader.Value is DateTimeOffset)                          return (DateTimeOffset)reader.Value;                      else                          return new DateTimeOffset(((DateTime)reader.Value).ToUniversalTime()' TimeSpan.Zero);                  case JsonToken.Integer:                      return InternalUtils.GetUnixTime((long)reader.Value);                    case JsonToken.Null:                      return DateTimeOffset.Now;              }
Missing Default,CoreTweet.Rest,Media,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Rest\Media.Async.cs,UploadChunkedAsyncImpl,The following switch statement is missing a default case: switch (x.ProcessingInfo.State)                              {                                  case "pending":                                      lastReport.Stage = UploadChunkedProgressStage.Pending;                                      break;                                  case "in_progress":                                      lastReport.Stage = UploadChunkedProgressStage.InProgress;                                      break;                              }
Missing Default,CoreTweet.Streaming,EventMessage,C:\repos\CoreTweet_CoreTweet\CoreTweet.Shared\Streaming\Messages.cs,Parse,The following switch statement is missing a default case: switch(e.TargetType)              {                  case EventTargetType.Status:                      e.TargetStatus = j["target_object"].ToObject<Status>();                      break;                  case EventTargetType.List:                      e.TargetList = j["target_object"].ToObject<List>();                      break;                  case EventTargetType.AccessRevocation:                      e.TargetToken = j["target_object"].ToObject<AccessRevocation>();                      break;              }
