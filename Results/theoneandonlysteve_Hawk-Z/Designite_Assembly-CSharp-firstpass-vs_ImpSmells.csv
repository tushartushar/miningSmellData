Implementation smell,Namespace,Class,File,Method,Description
Long Method,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The method has 103 lines of code.
Long Method,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The method has 379 lines of code.
Long Method,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The method has 138 lines of code.
Long Method,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,SerializeObject,The method has 113 lines of code.
Long Method,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DeserializeObject,The method has 161 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,Decode,The method has 100 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The method has 110 lines of code.
Complex Method,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,Cyclomatic complexity of the method is 23
Complex Method,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Skip,Cyclomatic complexity of the method is 13
Complex Method,SevenZipRadical.Compression.LZMA,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaDecoder.cs,Code,Cyclomatic complexity of the method is 16
Complex Method,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,Cyclomatic complexity of the method is 80
Complex Method,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,Cyclomatic complexity of the method is 26
Complex Method,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,FillDistancesPrices,Cyclomatic complexity of the method is 11
Complex Method,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,Cyclomatic complexity of the method is 36
Complex Method,LitJson,JsonData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonData.cs,WriteJson,Cyclomatic complexity of the method is 11
Complex Method,LitJson,JsonData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonData.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,LitJson,JsonData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonData.cs,SetJsonType,Cyclomatic complexity of the method is 24
Complex Method,LitJson,JsonMapper,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonMapper.cs,ReadValue,Cyclomatic complexity of the method is 21
Complex Method,LitJson,JsonMapper,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonMapper.cs,ReadValue,Cyclomatic complexity of the method is 12
Complex Method,LitJson,JsonMapper,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonMapper.cs,WriteValue,Cyclomatic complexity of the method is 25
Complex Method,LitJson,JsonReader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonReader.cs,ProcessSymbol,Cyclomatic complexity of the method is 14
Complex Method,LitJson,JsonReader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonReader.cs,Read,Cyclomatic complexity of the method is 14
Complex Method,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,DoValidation,Cyclomatic complexity of the method is 22
Complex Method,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,PutString,Cyclomatic complexity of the method is 22
Complex Method,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,HexValue,Cyclomatic complexity of the method is 13
Complex Method,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,ProcessEscChar,Cyclomatic complexity of the method is 10
Complex Method,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,Cyclomatic complexity of the method is 35
Complex Method,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State3,Cyclomatic complexity of the method is 17
Complex Method,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State4,Cyclomatic complexity of the method is 15
Complex Method,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State6,Cyclomatic complexity of the method is 14
Complex Method,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State8,Cyclomatic complexity of the method is 10
Complex Method,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State19,Cyclomatic complexity of the method is 11
Complex Method,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State21,Cyclomatic complexity of the method is 14
Complex Method,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State23,Cyclomatic complexity of the method is 11
Complex Method,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,CreateStacks,Cyclomatic complexity of the method is 9
Complex Method,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,SerializeObject,Cyclomatic complexity of the method is 23
Complex Method,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DeserializeObject,Cyclomatic complexity of the method is 28
Complex Method,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DeserializeDictionary,Cyclomatic complexity of the method is 9
Complex Method,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DeserializeProperties,Cyclomatic complexity of the method is 8
Complex Method,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DeserializeFields,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Checksums\Adler32.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,Deflate,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,SetLevel,Cyclomatic complexity of the method is 19
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,FindLongestMatch,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateFast,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateSlow,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,FlushBlock,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHuffman,Cyclomatic complexity of the method is 32
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,Decode,Cyclomatic complexity of the method is 40
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,Inflate,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,Cyclomatic complexity of the method is 53
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Encryption,ZipAESStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\ZipAESStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipHelperStream.cs,WriteLocalHeader,Cyclomatic complexity of the method is 14
Long Parameter List,SevenZipRadical,ICoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\ICoder.cs,Code,The method has 5 parameters.
Long Parameter List,SevenZipRadical.Compression.LZMA,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaDecoder.cs,Code,The method has 5 parameters.
Long Parameter List,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,Code,The method has 5 parameters.
Long Parameter List,SevenZipRadical.Compression.RangeCoder,BitTreeEncoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoderBitTree.cs,ReverseEncode,The method has 5 parameters.
Long Parameter List,LitJson,JsonMapper,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonMapper.cs,RegisterBaseExporters,The method has 18 parameters.
Long Parameter List,LitJson,JsonMapper,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonMapper.cs,RegisterBaseImporters,The method has 12 parameters.
Long Parameter List,Serialization,GetSetGeneric,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetSetGeneric.cs,GetSetGeneric,The method has 10 parameters.
Long Parameter List,Serialization,GetSetGeneric,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetSetGeneric.cs,GetSetGeneric,The method has 5 parameters.
Long Parameter List,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetAccessors,The method has 13 parameters.
Long Parameter List,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,RegisterSerializationAssembly,The method has 11 parameters.
Long Parameter List,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GetPropertyInfo,The method has 12 parameters.
Long Parameter List,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GetFieldInfo,The method has 10 parameters.
Long Parameter List,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DeserializeArray,The method has 5 parameters.
Long Parameter List,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DeserializeArrayPart,The method has 6 parameters.
Long Parameter List,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DeserializeDictionary,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\DeflaterOutputStream.cs,BeginRead,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\DeflaterOutputStream.cs,BeginWrite,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\InflaterInputStream.cs,BeginWrite,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Encryption,PkzipClassicEncryptCryptoTransform,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,TransformBlock,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Encryption,PkzipClassicDecryptCryptoTransform,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,TransformBlock,The method has 5 parameters.
Long Parameter List,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\ZipAESTransform.cs,TransformBlock,The method has 5 parameters.
Long Statement,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The length of the statement  "		UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1; " is 132.
Long Statement,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Skip,The length of the statement  "			UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1; " is 132.
Long Statement,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,ReadMatchDistances,The length of the statement  "			lenRes += _matchFinder.GetMatchLen ((int)lenRes - 1' _matchDistances [numDistancePairs - 1]' Base.kMatchMaxLen - lenRes); " is 121.
Long Statement,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetRepLen1Price,The length of the statement  "	return _isRepG0 [state.Index].GetPrice0 () + _isRep0Long [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 (); " is 126.
Long Statement,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosLenPrice,The length of the statement  "		price = _posSlotPrices [(lenToPosState << Base.kNumPosSlotBits) + GetPosSlot2 (pos)] + _alignPrices [pos & Base.kAlignMask]; " is 124.
Long Statement,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "	_optimum [1].Price = _isMatch [(_state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _previousByte).GetPrice (!_state.IsCharState ()' matchByte' currentByte); " is 214.
Long Statement,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "		UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte); " is 244.
Long Statement,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "				UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 (); " is 162.
Long Statement,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "					UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1)); " is 433.
Long Statement,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "					UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 (); " is 128.
Long Statement,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "							UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1)); " is 366.
Long Statement,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 (); " is 128.
Long Statement,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,FillDistancesPrices,The length of the statement  "			_posSlotPrices [st + posSlot] += ((((posSlot >> 1) - 1) - Base.kNumAlignBits) << RangeCoder.BitEncoder.kNumBitPriceShiftBits); " is 126.
Long Statement,LitJson,JsonMapper,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonMapper.cs,ReadValue,The length of the statement  "	if (reader.Token == JsonToken.Double || reader.Token == JsonToken.Int || reader.Token == JsonToken.Long || reader.Token == JsonToken.String || reader.Token == JsonToken.Boolean) { " is 179.
Long Statement,LitJson,JsonMapper,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonMapper.cs,ReadValue,The length of the statement  "		throw new JsonException (String.Format ("Can't assign value '{0}' (type {1}) to type {2}"' reader.Value' json_type' inst_type)); " is 128.
Long Statement,LitJson,JsonMapper,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonMapper.cs,WriteValue,The length of the statement  "		throw new JsonException (String.Format ("Max allowed object depth reached while " + "trying to export from type {0}"' obj.GetType ())); " is 135.
Long Statement,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State22,The length of the statement  "		if (ctx.L.input_char >= '0' && ctx.L.input_char <= '9' || ctx.L.input_char >= 'A' && ctx.L.input_char <= 'F' || ctx.L.input_char >= 'a' && ctx.L.input_char <= 'f') { " is 165.
Long Statement,RadicalLibrary,SmoothVector3,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Radical\System\Smoothing.cs,ToString,The length of the statement  "	return string.Format ("[SmoothVector3: IsComplete={0}' Target={1}' Current={2}' x={3}' y={4}' z={5}' Value={6}]"' IsComplete' Target' Current' x' y' z' Value); " is 159.
Long Statement,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetAccessors,The length of the statement  "				priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)' " is 177.
Long Statement,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetAccessors,The length of the statement  "				priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)' " is 177.
Long Statement,Serialization,SerializePrivateFieldOfType,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GetFields,The length of the statement  "		return type.GetFields (BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.SetField | BindingFlags.Static).Where (f => fields.Any (fld => fld._fieldName == f.Name)); " is 175.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,RunDeferredActions,The length of the statement  "					Radical.LogError ("Failed deferred deserialization with error " + e.GetType ().FullName + "'" + e.Message + "' @ " + e.StackTrace); " is 131.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,RegisterSerializationAssembly,The length of the statement  "		AttributeLists [((AttributeListProvider)attr).AttributeListType] = Activator.CreateInstance (tp) as IProvideAttributeList; " is 122.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,RegisterSerializationAssembly,The length of the statement  "		SubTypeSerializers [((SubTypeSerializerAttribute)attr).SerializesType] = Activator.CreateInstance (tp) as ISerializeObject; " is 123.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GetPropertyInfo,The length of the statement  "				ret = containingType.GetProperties (BindingFlags.Instance | BindingFlags.Public | BindingFlags.Static).Where (p => !typeof(Component).IsAssignableFrom (tp) || tp == typeof(Component) || !componentNames.ContainsKey (p.Name)).Where (p => p.PropertyType.GetCustomAttributes (typeof(DoNotSerialize)' true).Count () == 0 && p.GetGetMethod () != null && (!containingType.IsDefined (typeof(DoNotSerializePublic)' true) || p.IsDefined (typeof(SerializeThis)' true)) && !p.GetCustomAttributes (typeof(DoNotSerialize)' true).Any () && !p.GetCustomAttributes (typeof(ObsoleteAttribute)' true).Any () && !(p.GetIndexParameters ().Any ()) && (p.GetSetMethod () != null && CanSerializeType (p.PropertyType)) && ((p.PropertyType.IsValueType && allowSimple) || validNames == null || validNames.Any (n => n == p.Name))).ToArray (); " is 814.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GetPropertyInfo,The length of the statement  "				ret = tp.GetProperties (BindingFlags.Instance | BindingFlags.Public | BindingFlags.Static).Where (p => !typeof(Component).IsAssignableFrom (tp) || tp == typeof(Component) || !componentNames.ContainsKey (p.Name)).Where (p => !p.PropertyType.GetCustomAttributes (typeof(DoNotSerialize)' true).Any () && p.GetGetMethod () != null && (!tp.IsDefined (typeof(DoNotSerializePublic)' true) || p.IsDefined (typeof(SerializeThis)' true)) && !p.GetCustomAttributes (typeof(DoNotSerialize)' true).Any () && !p.GetCustomAttributes (typeof(DoNotChecksum)' true).Any () && !p.GetCustomAttributes (typeof(ObsoleteAttribute)' true).Any () && !(p.GetIndexParameters ().Any ()) && (p.GetSetMethod () != null && CanSerializeType (p.PropertyType)) && ((allowSimple && p.PropertyType.IsValueType) || validNames == null || availableNames.Any (n => n == p.Name))).ToArray (); " is 851.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GetPropertyInfo,The length of the statement  "		return IgnoreIds && ret != null ? propertyInfos.Where (p => !p.GetCustomAttributes (typeof(SerializerId)' true).Any ()) : propertyInfos; " is 136.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GetFieldInfo,The length of the statement  "				if (privateTypes.Any (currentTypes.Contains) || addAll || scan.IsDefined (typeof(SerializeAll)' false) || (scan.GetInterface ("IEnumerator") != null)) { " is 152.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GetFieldInfo,The length of the statement  "			ret = FieldLists [itm] = tp.GetFields (BindingFlags.Instance | BindingFlags.Public | BindingFlags.SetField | BindingFlags.Static).Concat (allParents.SelectMany (type => type.GetFields (BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.SetField | BindingFlags.Static).Where (f => f.IsDefined (typeof(SerializeThis)' true)))).Concat (parents.SelectMany (p => p.GetFields (BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.SetField))).Concat (SerializePrivateFieldOfType.GetFields (tp)).Where (p => !p.IsLiteral && !p.FieldType.IsDefined (typeof(DoNotSerialize)' false) && !p.IsDefined (typeof(DoNotSerialize)' false) && CanSerializeType (p.FieldType) && ((p.FieldType.IsValueType && allowSimple) || validNames == null || (validNames.Any (n => n == p.Name)))).Where (p => !typeof(Component).IsAssignableFrom (tp) || tp == typeof(Component) || !componentNames.ContainsKey (p.Name)).ToArray (); " is 913.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,IsSimpleType,The length of the statement  "	return tp.IsPrimitive || tp == typeof(string) || tp.IsEnum || tp == typeof(DateTime) || tp == typeof(TimeSpan) || tp == typeof(Guid) || tp == typeof(decimal); " is 158.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,CreateObject,The length of the statement  "		return itemType.IsDefined (typeof(CreateUsingEvent)' false) ? CreateInstance (itemType) : Activator.CreateInstance (itemType); " is 126.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,CreateObject,The length of the statement  "			var constructorInfo = itemType.GetConstructor (BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic' null' new Type[] { " is 135.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,CreateInstance,The length of the statement  "		return (object)Delegate.CreateDelegate (typeof(Action)' typeof(UnitySerializer).GetMethod ("DummyAction"' BindingFlags.Public | BindingFlags.Static)); " is 150.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,CreateInstance,The length of the statement  "	var error = string.Format ("Could not construct an object of type '{0}'' it must be creatable in this scope and have a default parameterless constructor or you should handle the CreateType event on UnitySerializer to construct the object"' itemType.FullName); " is 259.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GetField,The length of the statement  "	while (tp != null && (fi = tp.GetField (name' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static)) == null) { " is 149.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,SerializeObject,The length of the statement  "			storage.WriteSimpleValue (itemType.IsEnum ? Convert.ChangeType (item' Enum.GetUnderlyingType (itemType)' CultureInfo.InvariantCulture) : item); " is 143.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,SerializeObject,The length of the statement  "					if (!tp.Key.IsAssignableFrom (itemType) || (tp.Value.GetType ().IsDefined (typeof(OnlyInterfaces)' false) && !itemType.IsInterface)) { " is 134.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,SerializeObject,The length of the statement  "				if (!(serializeObject is ISerializeObjectEx) || (serializeObject as ISerializeObjectEx).CanSerialize (itemType' entry.Value)) { " is 127.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DeserializeObject,The length of the statement  "					throw new SerializationException ("Error when trying to link to a previously seen object. The stream gave an object id of " + existingId + " but that was not found.  It is possible that an" + "error has caused the data stream to become corrupt and that this id is wildly out of range.  Ids should be sequential numbers starting at 1 for the first object or value seen and then incrementing thereafter."); " is 404.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DeserializeObject,The length of the statement  "					if (!tp.Key.IsAssignableFrom (itemType) || (tp.Value.GetType ().IsDefined (typeof(OnlyInterfaces)' false) && !itemType.IsInterface)) { " is 134.
Long Statement,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DeserializeObject,The length of the statement  "				if (!(serializeObject is ISerializeObjectEx) || (serializeObject as ISerializeObjectEx).CanSerialize (itemType' entry.Value)) { " is 127.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,FindLongestMatch,The length of the statement  "		if (window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]) { " is 180.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,FindLongestMatch,The length of the statement  "				*/while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && (scan < strend)) { " is 339.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateFast,The length of the statement  "		if (lookahead >= MIN_MATCH && (hashHead = InsertString ()) != 0 && strategy != DeflateStrategy.HuffmanOnly && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) { " is 175.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateSlow,The length of the statement  "			if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) { " is 129.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateSlow,The length of the statement  "				if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) { " is 123.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,FlushBlock,The length of the statement  "	int opt_len = 14 + blTreeCodes * 3 + blTree.GetEncodedLength () + literalTree.GetEncodedLength () + distTree.GetEncodedLength () + extra_bits; " is 142.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,BitReverse,The length of the statement  "	return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]); " is 172.
Long Statement,ICSharpCode.SharpZipLib.Encryption,ZipAESStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\ZipAESStream.cs,Read,The length of the statement  "					throw new Exception ("AES Authentication Code does not match. This is a super-CRC check on the data in the file after compression and encryption. \r\n" + "The file may be damaged."); " is 182.
Long Statement,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\ZipAESTransform.cs,TransformBlock,The length of the statement  "			/* encrypt the nonce to form next xor buffer    */_encryptor.TransformBlock (_counterNonce' 0' _blockSize' _encryptBuffer' 0); " is 126.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,HasDosAttributes,The length of the statement  "		if (((HostSystem == (int)HostSystemID.Msdos) || (HostSystem == (int)HostSystemID.WindowsNT)) && (ExternalFileAttributes & attributes) == attributes) { " is 150.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The length of the statement  "		if (((versionToExtract & 0xff) >= ZipConstants.VersionZip64) && ((size == uint.MaxValue) || (compressedSize == uint.MaxValue))) { " is 129.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The length of the statement  "			DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime (); " is 124.
Long Statement,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The length of the statement  "				_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime (); " is 126.
Long Statement,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The length of the statement  "				_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime (); " is 124.
Long Statement,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The length of the statement  "				_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime (); " is 120.
Complex Conditional,LitJson,JsonMapper,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonMapper.cs,ReadValue,The conditional expression  "reader.Token == JsonToken.Double || reader.Token == JsonToken.Int || reader.Token == JsonToken.Long || reader.Token == JsonToken.String || reader.Token == JsonToken.Boolean"  is complex.
Complex Conditional,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State22,The conditional expression  "ctx.L.input_char >= '0' && ctx.L.input_char <= '9' || ctx.L.input_char >= 'A' && ctx.L.input_char <= 'F' || ctx.L.input_char >= 'a' && ctx.L.input_char <= 'f'"  is complex.
Complex Conditional,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GetFieldInfo,The conditional expression  "privateTypes.Any (currentTypes.Contains) || addAll || scan.IsDefined (typeof(SerializeAll)' false) || (scan.GetInterface ("IEnumerator") != null)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,FindLongestMatch,The conditional expression  "window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateStored,The conditional expression  "(storedLength >= DeflaterConstants.MAX_BLOCK_SIZE) || // Block is full  (blockStart < WSIZE && storedLength >= MAX_DIST) || // Block may move out of window  flush"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateFast,The conditional expression  "lookahead >= MIN_MATCH && (hashHead = InsertString ()) != 0 && strategy != DeflateStrategy.HuffmanOnly && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateSlow,The conditional expression  "strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateSlow,The conditional expression  "matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))"  is complex.
Empty Catch Block,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,InformDeserializedObjects,The method has an empty catch block.
Empty Catch Block,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,ScanAllTypesForAttribute,The method has an empty catch block.
Magic Number,SevenZipRadical,CRC,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Common\CRC.cs,CRC,The following statement contains a magic number: Table = new uint[256];  
Magic Number,SevenZipRadical,CRC,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Common\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++) {  	uint r = i;  	for (int j = 0; j < 8; j++)  		if ((r & 1) != 0)  			r = (r >> 1) ^ kPoly;  		else  			r >>= 1;  	Table [i] = r;  }  
Magic Number,SevenZipRadical,CRC,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Common\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++) {  	uint r = i;  	for (int j = 0; j < 8; j++)  		if ((r & 1) != 0)  			r = (r >> 1) ^ kPoly;  		else  			r >>= 1;  	Table [i] = r;  }  
Magic Number,SevenZipRadical,CRC,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Common\CRC.cs,CRC,The following statement contains a magic number: for (int j = 0; j < 8; j++)  	if ((r & 1) != 0)  		r = (r >> 1) ^ kPoly;  	else  		r >>= 1;  
Magic Number,SevenZipRadical,CRC,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Common\CRC.cs,UpdateByte,The following statement contains a magic number: _value = Table [(((byte)(_value)) ^ b)] ^ (_value >> 8);  
Magic Number,SevenZipRadical,CRC,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Common\CRC.cs,Update,The following statement contains a magic number: for (uint i = 0; i < size; i++)  	_value = Table [(((byte)(_value)) ^ data [offset + i])] ^ (_value >> 8);  
Magic Number,SevenZipRadical,CRC,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Common\CRC.cs,Update,The following statement contains a magic number: _value = Table [(((byte)(_value)) ^ data [offset + i])] ^ (_value >> 8);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: HASH_ARRAY = (numHashBytes > 2);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY) {  	kNumHashDirectBytes = 0;  	kMinMatchCheck = 4;  	kFixHashSize = kHash2Size + kHash3Size;  }  else {  	kNumHashDirectBytes = 2;  	kMinMatchCheck = 2 + 1;  	kFixHashSize = 0;  }  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY) {  	kNumHashDirectBytes = 0;  	kMinMatchCheck = 4;  	kFixHashSize = kHash2Size + kHash3Size;  }  else {  	kNumHashDirectBytes = 2;  	kMinMatchCheck = 2 + 1;  	kFixHashSize = 0;  }  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY) {  	kNumHashDirectBytes = 0;  	kMinMatchCheck = 4;  	kFixHashSize = kHash2Size + kHash3Size;  }  else {  	kNumHashDirectBytes = 2;  	kMinMatchCheck = 2 + 1;  	kFixHashSize = 0;  }  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: kMinMatchCheck = 4;  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: kNumHashDirectBytes = 2;  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: kMinMatchCheck = 2 + 1;  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (historySize > kMaxValForNormalize - 256)  	throw new Exception ();  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: _cutValue = 16 + (matchMaxLen >> 1);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (_cyclicBufferSize != cyclicBufferSize)  	_son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: _son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY) {  	hs = historySize - 1;  	hs |= (hs >> 1);  	hs |= (hs >> 2);  	hs |= (hs >> 4);  	hs |= (hs >> 8);  	hs >>= 1;  	hs |= 0xFFFF;  	if (hs > (1 << 24))  		hs >>= 1;  	_hashMask = hs;  	hs++;  	hs += kFixHashSize;  }  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY) {  	hs = historySize - 1;  	hs |= (hs >> 1);  	hs |= (hs >> 2);  	hs |= (hs >> 4);  	hs |= (hs >> 8);  	hs >>= 1;  	hs |= 0xFFFF;  	if (hs > (1 << 24))  		hs >>= 1;  	_hashMask = hs;  	hs++;  	hs += kFixHashSize;  }  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY) {  	hs = historySize - 1;  	hs |= (hs >> 1);  	hs |= (hs >> 2);  	hs |= (hs >> 4);  	hs |= (hs >> 8);  	hs >>= 1;  	hs |= 0xFFFF;  	if (hs > (1 << 24))  		hs >>= 1;  	_hashMask = hs;  	hs++;  	hs += kFixHashSize;  }  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY) {  	hs = historySize - 1;  	hs |= (hs >> 1);  	hs |= (hs >> 2);  	hs |= (hs >> 4);  	hs |= (hs >> 8);  	hs >>= 1;  	hs |= 0xFFFF;  	if (hs > (1 << 24))  		hs >>= 1;  	_hashMask = hs;  	hs++;  	hs += kFixHashSize;  }  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: hs |= (hs >> 2);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: hs |= (hs >> 4);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: hs |= (hs >> 8);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (hs > (1 << 24))  	hs >>= 1;  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	hash2Value = temp & (kHash2Size - 1);  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	hash3Value = temp & (kHash3Size - 1);  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	hash2Value = temp & (kHash2Size - 1);  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	hash3Value = temp & (kHash3Size - 1);  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	hash2Value = temp & (kHash2Size - 1);  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	hash3Value = temp & (kHash3Size - 1);  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	hash2Value = temp & (kHash2Size - 1);  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	hash3Value = temp & (kHash3Size - 1);  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	hash2Value = temp & (kHash2Size - 1);  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	hash3Value = temp & (kHash3Size - 1);  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 curMatch2 = _hash [hash2Value];  	UInt32 curMatch3 = _hash [kHash3Offset + hash3Value];  	_hash [hash2Value] = _pos;  	_hash [kHash3Offset + hash3Value] = _pos;  	if (curMatch2 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch2] == _bufferBase [cur]) {  			distances [offset++] = maxLen = 2;  			distances [offset++] = _pos - curMatch2 - 1;  		}  	if (curMatch3 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  			if (curMatch3 == curMatch2)  				offset -= 2;  			distances [offset++] = maxLen = 3;  			distances [offset++] = _pos - curMatch3 - 1;  			curMatch2 = curMatch3;  		}  	if (offset != 0 && curMatch2 == curMatch) {  		offset -= 2;  		maxLen = kStartMaxLen;  	}  }  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 curMatch2 = _hash [hash2Value];  	UInt32 curMatch3 = _hash [kHash3Offset + hash3Value];  	_hash [hash2Value] = _pos;  	_hash [kHash3Offset + hash3Value] = _pos;  	if (curMatch2 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch2] == _bufferBase [cur]) {  			distances [offset++] = maxLen = 2;  			distances [offset++] = _pos - curMatch2 - 1;  		}  	if (curMatch3 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  			if (curMatch3 == curMatch2)  				offset -= 2;  			distances [offset++] = maxLen = 3;  			distances [offset++] = _pos - curMatch3 - 1;  			curMatch2 = curMatch3;  		}  	if (offset != 0 && curMatch2 == curMatch) {  		offset -= 2;  		maxLen = kStartMaxLen;  	}  }  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 curMatch2 = _hash [hash2Value];  	UInt32 curMatch3 = _hash [kHash3Offset + hash3Value];  	_hash [hash2Value] = _pos;  	_hash [kHash3Offset + hash3Value] = _pos;  	if (curMatch2 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch2] == _bufferBase [cur]) {  			distances [offset++] = maxLen = 2;  			distances [offset++] = _pos - curMatch2 - 1;  		}  	if (curMatch3 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  			if (curMatch3 == curMatch2)  				offset -= 2;  			distances [offset++] = maxLen = 3;  			distances [offset++] = _pos - curMatch3 - 1;  			curMatch2 = curMatch3;  		}  	if (offset != 0 && curMatch2 == curMatch) {  		offset -= 2;  		maxLen = kStartMaxLen;  	}  }  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 curMatch2 = _hash [hash2Value];  	UInt32 curMatch3 = _hash [kHash3Offset + hash3Value];  	_hash [hash2Value] = _pos;  	_hash [kHash3Offset + hash3Value] = _pos;  	if (curMatch2 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch2] == _bufferBase [cur]) {  			distances [offset++] = maxLen = 2;  			distances [offset++] = _pos - curMatch2 - 1;  		}  	if (curMatch3 > matchMinPos)  		if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  			if (curMatch3 == curMatch2)  				offset -= 2;  			distances [offset++] = maxLen = 3;  			distances [offset++] = _pos - curMatch3 - 1;  			curMatch2 = curMatch3;  		}  	if (offset != 0 && curMatch2 == curMatch) {  		offset -= 2;  		maxLen = kStartMaxLen;  	}  }  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (curMatch2 > matchMinPos)  	if (_bufferBase [_bufferOffset + curMatch2] == _bufferBase [cur]) {  		distances [offset++] = maxLen = 2;  		distances [offset++] = _pos - curMatch2 - 1;  	}  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (_bufferBase [_bufferOffset + curMatch2] == _bufferBase [cur]) {  	distances [offset++] = maxLen = 2;  	distances [offset++] = _pos - curMatch2 - 1;  }  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: distances [offset++] = maxLen = 2;  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (curMatch3 > matchMinPos)  	if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  		if (curMatch3 == curMatch2)  			offset -= 2;  		distances [offset++] = maxLen = 3;  		distances [offset++] = _pos - curMatch3 - 1;  		curMatch2 = curMatch3;  	}  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (curMatch3 > matchMinPos)  	if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  		if (curMatch3 == curMatch2)  			offset -= 2;  		distances [offset++] = maxLen = 3;  		distances [offset++] = _pos - curMatch3 - 1;  		curMatch2 = curMatch3;  	}  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  	if (curMatch3 == curMatch2)  		offset -= 2;  	distances [offset++] = maxLen = 3;  	distances [offset++] = _pos - curMatch3 - 1;  	curMatch2 = curMatch3;  }  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (_bufferBase [_bufferOffset + curMatch3] == _bufferBase [cur]) {  	if (curMatch3 == curMatch2)  		offset -= 2;  	distances [offset++] = maxLen = 3;  	distances [offset++] = _pos - curMatch3 - 1;  	curMatch2 = curMatch3;  }  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (curMatch3 == curMatch2)  	offset -= 2;  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: offset -= 2;  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: distances [offset++] = maxLen = 3;  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (offset != 0 && curMatch2 == curMatch) {  	offset -= 2;  	maxLen = kStartMaxLen;  }  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: offset -= 2;  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do {  	UInt32 lenLimit;  	if (_pos + _matchMaxLen <= _streamPos)  		lenLimit = _matchMaxLen;  	else {  		lenLimit = _streamPos - _pos;  		if (lenLimit < kMinMatchCheck) {  			MovePos ();  			continue;  		}  	}  	UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  	UInt32 cur = _bufferOffset + _pos;  	UInt32 hashValue;  	if (HASH_ARRAY) {  		UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  		UInt32 hash2Value = temp & (kHash2Size - 1);  		_hash [hash2Value] = _pos;  		temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  		UInt32 hash3Value = temp & (kHash3Size - 1);  		_hash [kHash3Offset + hash3Value] = _pos;  		hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  	}  	else  		hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  	UInt32 curMatch = _hash [kFixHashSize + hashValue];  	_hash [kFixHashSize + hashValue] = _pos;  	UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  	UInt32 ptr1 = (_cyclicBufferPos << 1);  	UInt32 len0' len1;  	len0 = len1 = kNumHashDirectBytes;  	UInt32 count = _cutValue;  	while (true) {  		if (curMatch <= matchMinPos || count-- == 0) {  			_son [ptr0] = _son [ptr1] = kEmptyHashValue;  			break;  		}  		UInt32 delta = _pos - curMatch;  		UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;  		UInt32 pby1 = _bufferOffset + curMatch;  		UInt32 len = Math.Min (len0' len1);  		if (_bufferBase [pby1 + len] == _bufferBase [cur + len]) {  			while (++len != lenLimit)  				if (_bufferBase [pby1 + len] != _bufferBase [cur + len])  					break;  			if (len == lenLimit) {  				_son [ptr1] = _son [cyclicPos];  				_son [ptr0] = _son [cyclicPos + 1];  				break;  			}  		}  		if (_bufferBase [pby1 + len] < _bufferBase [cur + len]) {  			_son [ptr1] = curMatch;  			ptr1 = cyclicPos + 1;  			curMatch = _son [ptr1];  			len1 = len;  		}  		else {  			_son [ptr0] = curMatch;  			ptr0 = cyclicPos;  			curMatch = _son [ptr0];  			len0 = len;  		}  	}  	MovePos ();  }  while (--num != 0);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do {  	UInt32 lenLimit;  	if (_pos + _matchMaxLen <= _streamPos)  		lenLimit = _matchMaxLen;  	else {  		lenLimit = _streamPos - _pos;  		if (lenLimit < kMinMatchCheck) {  			MovePos ();  			continue;  		}  	}  	UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  	UInt32 cur = _bufferOffset + _pos;  	UInt32 hashValue;  	if (HASH_ARRAY) {  		UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  		UInt32 hash2Value = temp & (kHash2Size - 1);  		_hash [hash2Value] = _pos;  		temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  		UInt32 hash3Value = temp & (kHash3Size - 1);  		_hash [kHash3Offset + hash3Value] = _pos;  		hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  	}  	else  		hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  	UInt32 curMatch = _hash [kFixHashSize + hashValue];  	_hash [kFixHashSize + hashValue] = _pos;  	UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  	UInt32 ptr1 = (_cyclicBufferPos << 1);  	UInt32 len0' len1;  	len0 = len1 = kNumHashDirectBytes;  	UInt32 count = _cutValue;  	while (true) {  		if (curMatch <= matchMinPos || count-- == 0) {  			_son [ptr0] = _son [ptr1] = kEmptyHashValue;  			break;  		}  		UInt32 delta = _pos - curMatch;  		UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;  		UInt32 pby1 = _bufferOffset + curMatch;  		UInt32 len = Math.Min (len0' len1);  		if (_bufferBase [pby1 + len] == _bufferBase [cur + len]) {  			while (++len != lenLimit)  				if (_bufferBase [pby1 + len] != _bufferBase [cur + len])  					break;  			if (len == lenLimit) {  				_son [ptr1] = _son [cyclicPos];  				_son [ptr0] = _son [cyclicPos + 1];  				break;  			}  		}  		if (_bufferBase [pby1 + len] < _bufferBase [cur + len]) {  			_son [ptr1] = curMatch;  			ptr1 = cyclicPos + 1;  			curMatch = _son [ptr1];  			len1 = len;  		}  		else {  			_son [ptr0] = curMatch;  			ptr0 = cyclicPos;  			curMatch = _son [ptr0];  			len0 = len;  		}  	}  	MovePos ();  }  while (--num != 0);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do {  	UInt32 lenLimit;  	if (_pos + _matchMaxLen <= _streamPos)  		lenLimit = _matchMaxLen;  	else {  		lenLimit = _streamPos - _pos;  		if (lenLimit < kMinMatchCheck) {  			MovePos ();  			continue;  		}  	}  	UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  	UInt32 cur = _bufferOffset + _pos;  	UInt32 hashValue;  	if (HASH_ARRAY) {  		UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  		UInt32 hash2Value = temp & (kHash2Size - 1);  		_hash [hash2Value] = _pos;  		temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  		UInt32 hash3Value = temp & (kHash3Size - 1);  		_hash [kHash3Offset + hash3Value] = _pos;  		hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  	}  	else  		hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  	UInt32 curMatch = _hash [kFixHashSize + hashValue];  	_hash [kFixHashSize + hashValue] = _pos;  	UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  	UInt32 ptr1 = (_cyclicBufferPos << 1);  	UInt32 len0' len1;  	len0 = len1 = kNumHashDirectBytes;  	UInt32 count = _cutValue;  	while (true) {  		if (curMatch <= matchMinPos || count-- == 0) {  			_son [ptr0] = _son [ptr1] = kEmptyHashValue;  			break;  		}  		UInt32 delta = _pos - curMatch;  		UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;  		UInt32 pby1 = _bufferOffset + curMatch;  		UInt32 len = Math.Min (len0' len1);  		if (_bufferBase [pby1 + len] == _bufferBase [cur + len]) {  			while (++len != lenLimit)  				if (_bufferBase [pby1 + len] != _bufferBase [cur + len])  					break;  			if (len == lenLimit) {  				_son [ptr1] = _son [cyclicPos];  				_son [ptr0] = _son [cyclicPos + 1];  				break;  			}  		}  		if (_bufferBase [pby1 + len] < _bufferBase [cur + len]) {  			_son [ptr1] = curMatch;  			ptr1 = cyclicPos + 1;  			curMatch = _son [ptr1];  			len1 = len;  		}  		else {  			_son [ptr0] = curMatch;  			ptr0 = cyclicPos;  			curMatch = _son [ptr0];  			len0 = len;  		}  	}  	MovePos ();  }  while (--num != 0);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do {  	UInt32 lenLimit;  	if (_pos + _matchMaxLen <= _streamPos)  		lenLimit = _matchMaxLen;  	else {  		lenLimit = _streamPos - _pos;  		if (lenLimit < kMinMatchCheck) {  			MovePos ();  			continue;  		}  	}  	UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  	UInt32 cur = _bufferOffset + _pos;  	UInt32 hashValue;  	if (HASH_ARRAY) {  		UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  		UInt32 hash2Value = temp & (kHash2Size - 1);  		_hash [hash2Value] = _pos;  		temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  		UInt32 hash3Value = temp & (kHash3Size - 1);  		_hash [kHash3Offset + hash3Value] = _pos;  		hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  	}  	else  		hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  	UInt32 curMatch = _hash [kFixHashSize + hashValue];  	_hash [kFixHashSize + hashValue] = _pos;  	UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  	UInt32 ptr1 = (_cyclicBufferPos << 1);  	UInt32 len0' len1;  	len0 = len1 = kNumHashDirectBytes;  	UInt32 count = _cutValue;  	while (true) {  		if (curMatch <= matchMinPos || count-- == 0) {  			_son [ptr0] = _son [ptr1] = kEmptyHashValue;  			break;  		}  		UInt32 delta = _pos - curMatch;  		UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;  		UInt32 pby1 = _bufferOffset + curMatch;  		UInt32 len = Math.Min (len0' len1);  		if (_bufferBase [pby1 + len] == _bufferBase [cur + len]) {  			while (++len != lenLimit)  				if (_bufferBase [pby1 + len] != _bufferBase [cur + len])  					break;  			if (len == lenLimit) {  				_son [ptr1] = _son [cyclicPos];  				_son [ptr0] = _son [cyclicPos + 1];  				break;  			}  		}  		if (_bufferBase [pby1 + len] < _bufferBase [cur + len]) {  			_son [ptr1] = curMatch;  			ptr1 = cyclicPos + 1;  			curMatch = _son [ptr1];  			len1 = len;  		}  		else {  			_son [ptr0] = curMatch;  			ptr0 = cyclicPos;  			curMatch = _son [ptr0];  			len0 = len;  		}  	}  	MovePos ();  }  while (--num != 0);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do {  	UInt32 lenLimit;  	if (_pos + _matchMaxLen <= _streamPos)  		lenLimit = _matchMaxLen;  	else {  		lenLimit = _streamPos - _pos;  		if (lenLimit < kMinMatchCheck) {  			MovePos ();  			continue;  		}  	}  	UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  	UInt32 cur = _bufferOffset + _pos;  	UInt32 hashValue;  	if (HASH_ARRAY) {  		UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  		UInt32 hash2Value = temp & (kHash2Size - 1);  		_hash [hash2Value] = _pos;  		temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  		UInt32 hash3Value = temp & (kHash3Size - 1);  		_hash [kHash3Offset + hash3Value] = _pos;  		hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  	}  	else  		hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  	UInt32 curMatch = _hash [kFixHashSize + hashValue];  	_hash [kFixHashSize + hashValue] = _pos;  	UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  	UInt32 ptr1 = (_cyclicBufferPos << 1);  	UInt32 len0' len1;  	len0 = len1 = kNumHashDirectBytes;  	UInt32 count = _cutValue;  	while (true) {  		if (curMatch <= matchMinPos || count-- == 0) {  			_son [ptr0] = _son [ptr1] = kEmptyHashValue;  			break;  		}  		UInt32 delta = _pos - curMatch;  		UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ? (_cyclicBufferPos - delta) : (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;  		UInt32 pby1 = _bufferOffset + curMatch;  		UInt32 len = Math.Min (len0' len1);  		if (_bufferBase [pby1 + len] == _bufferBase [cur + len]) {  			while (++len != lenLimit)  				if (_bufferBase [pby1 + len] != _bufferBase [cur + len])  					break;  			if (len == lenLimit) {  				_son [ptr1] = _son [cyclicPos];  				_son [ptr0] = _son [cyclicPos + 1];  				break;  			}  		}  		if (_bufferBase [pby1 + len] < _bufferBase [cur + len]) {  			_son [ptr1] = curMatch;  			ptr1 = cyclicPos + 1;  			curMatch = _son [ptr1];  			len1 = len;  		}  		else {  			_son [ptr0] = curMatch;  			ptr0 = cyclicPos;  			curMatch = _son [ptr0];  			len0 = len;  		}  	}  	MovePos ();  }  while (--num != 0);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	UInt32 hash2Value = temp & (kHash2Size - 1);  	_hash [hash2Value] = _pos;  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	UInt32 hash3Value = temp & (kHash3Size - 1);  	_hash [kHash3Offset + hash3Value] = _pos;  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	UInt32 hash2Value = temp & (kHash2Size - 1);  	_hash [hash2Value] = _pos;  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	UInt32 hash3Value = temp & (kHash3Size - 1);  	_hash [kHash3Offset + hash3Value] = _pos;  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	UInt32 hash2Value = temp & (kHash2Size - 1);  	_hash [hash2Value] = _pos;  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	UInt32 hash3Value = temp & (kHash3Size - 1);  	_hash [kHash3Offset + hash3Value] = _pos;  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	UInt32 hash2Value = temp & (kHash2Size - 1);  	_hash [hash2Value] = _pos;  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	UInt32 hash3Value = temp & (kHash3Size - 1);  	_hash [kHash3Offset + hash3Value] = _pos;  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: if (HASH_ARRAY) {  	UInt32 temp = CRC.Table [_bufferBase [cur]] ^ _bufferBase [cur + 1];  	UInt32 hash2Value = temp & (kHash2Size - 1);  	_hash [hash2Value] = _pos;  	temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  	UInt32 hash3Value = temp & (kHash3Size - 1);  	_hash [kHash3Offset + hash3Value] = _pos;  	hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  }  else  	hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase [cur + 2]) << 8);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table [_bufferBase [cur + 3]] << 5)) & _hashMask;  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: hashValue = _bufferBase [cur] ^ ((UInt32)(_bufferBase [cur + 1]) << 8);  
Magic Number,SevenZipRadical.Compression.LZ,BinTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZ\LzBinTree.cs,Normalize,The following statement contains a magic number: NormalizeLinks (_son' _cyclicBufferSize * 2' subValue);  
Magic Number,SevenZipRadical.Compression.LZMA,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaDecoder.cs,SetDictionarySize,The following statement contains a magic number: if (m_DictionarySize != dictionarySize) {  	m_DictionarySize = dictionarySize;  	m_DictionarySizeCheck = Math.Max (m_DictionarySize' 1);  	uint blockSize = Math.Max (m_DictionarySizeCheck' (1 << 12));  	m_OutWindow.Create (blockSize);  }  
Magic Number,SevenZipRadical.Compression.LZMA,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lp > 8)  	throw new InvalidParamException ();  
Magic Number,SevenZipRadical.Compression.LZMA,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lc > 8)  	throw new InvalidParamException ();  
Magic Number,SevenZipRadical.Compression.LZMA,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: while (nowPos64 < outSize64) {  	// UInt64 next = Math.Min(nowPos64 + (1 << 18)' outSize64);  	// while(nowPos64 < next)  	{  		uint posState = (uint)nowPos64 & m_PosStateMask;  		if (m_IsMatchDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  			byte b;  			byte prevByte = m_OutWindow.GetByte (0);  			if (!state.IsCharState ())  				b = m_LiteralDecoder.DecodeWithMatchByte (m_RangeDecoder' (uint)nowPos64' prevByte' m_OutWindow.GetByte (rep0));  			else  				b = m_LiteralDecoder.DecodeNormal (m_RangeDecoder' (uint)nowPos64' prevByte);  			m_OutWindow.PutByte (b);  			state.UpdateChar ();  			nowPos64++;  		}  		else {  			uint len;  			if (m_IsRepDecoders [state.Index].Decode (m_RangeDecoder) == 1) {  				if (m_IsRepG0Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  					if (m_IsRep0LongDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  						state.UpdateShortRep ();  						m_OutWindow.PutByte (m_OutWindow.GetByte (rep0));  						nowPos64++;  						continue;  					}  				}  				else {  					UInt32 distance;  					if (m_IsRepG1Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  						distance = rep1;  					}  					else {  						if (m_IsRepG2Decoders [state.Index].Decode (m_RangeDecoder) == 0)  							distance = rep2;  						else {  							distance = rep3;  							rep3 = rep2;  						}  						rep2 = rep1;  					}  					rep1 = rep0;  					rep0 = distance;  				}  				len = m_RepLenDecoder.Decode (m_RangeDecoder' posState) + Base.kMatchMinLen;  				state.UpdateRep ();  			}  			else {  				rep3 = rep2;  				rep2 = rep1;  				rep1 = rep0;  				len = Base.kMatchMinLen + m_LenDecoder.Decode (m_RangeDecoder' posState);  				state.UpdateMatch ();  				uint posSlot = m_PosSlotDecoder [Base.GetLenToPosState (len)].Decode (m_RangeDecoder);  				if (posSlot >= Base.kStartPosModelIndex) {  					int numDirectBits = (int)((posSlot >> 1) - 1);  					rep0 = ((2 | (posSlot & 1)) << numDirectBits);  					if (posSlot < Base.kEndPosModelIndex)  						rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  					else {  						rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  						rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  					}  				}  				else  					rep0 = posSlot;  			}  			if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck) {  				if (rep0 == 0xFFFFFFFF)  					break;  				throw new DataErrorException ();  			}  			m_OutWindow.CopyBlock (rep0' len);  			nowPos64 += len;  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: if (m_IsMatchDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  	byte b;  	byte prevByte = m_OutWindow.GetByte (0);  	if (!state.IsCharState ())  		b = m_LiteralDecoder.DecodeWithMatchByte (m_RangeDecoder' (uint)nowPos64' prevByte' m_OutWindow.GetByte (rep0));  	else  		b = m_LiteralDecoder.DecodeNormal (m_RangeDecoder' (uint)nowPos64' prevByte);  	m_OutWindow.PutByte (b);  	state.UpdateChar ();  	nowPos64++;  }  else {  	uint len;  	if (m_IsRepDecoders [state.Index].Decode (m_RangeDecoder) == 1) {  		if (m_IsRepG0Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  			if (m_IsRep0LongDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  				state.UpdateShortRep ();  				m_OutWindow.PutByte (m_OutWindow.GetByte (rep0));  				nowPos64++;  				continue;  			}  		}  		else {  			UInt32 distance;  			if (m_IsRepG1Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  				distance = rep1;  			}  			else {  				if (m_IsRepG2Decoders [state.Index].Decode (m_RangeDecoder) == 0)  					distance = rep2;  				else {  					distance = rep3;  					rep3 = rep2;  				}  				rep2 = rep1;  			}  			rep1 = rep0;  			rep0 = distance;  		}  		len = m_RepLenDecoder.Decode (m_RangeDecoder' posState) + Base.kMatchMinLen;  		state.UpdateRep ();  	}  	else {  		rep3 = rep2;  		rep2 = rep1;  		rep1 = rep0;  		len = Base.kMatchMinLen + m_LenDecoder.Decode (m_RangeDecoder' posState);  		state.UpdateMatch ();  		uint posSlot = m_PosSlotDecoder [Base.GetLenToPosState (len)].Decode (m_RangeDecoder);  		if (posSlot >= Base.kStartPosModelIndex) {  			int numDirectBits = (int)((posSlot >> 1) - 1);  			rep0 = ((2 | (posSlot & 1)) << numDirectBits);  			if (posSlot < Base.kEndPosModelIndex)  				rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  			else {  				rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  				rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  			}  		}  		else  			rep0 = posSlot;  	}  	if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck) {  		if (rep0 == 0xFFFFFFFF)  			break;  		throw new DataErrorException ();  	}  	m_OutWindow.CopyBlock (rep0' len);  	nowPos64 += len;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: if (m_IsRepDecoders [state.Index].Decode (m_RangeDecoder) == 1) {  	if (m_IsRepG0Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  		if (m_IsRep0LongDecoders [(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode (m_RangeDecoder) == 0) {  			state.UpdateShortRep ();  			m_OutWindow.PutByte (m_OutWindow.GetByte (rep0));  			nowPos64++;  			continue;  		}  	}  	else {  		UInt32 distance;  		if (m_IsRepG1Decoders [state.Index].Decode (m_RangeDecoder) == 0) {  			distance = rep1;  		}  		else {  			if (m_IsRepG2Decoders [state.Index].Decode (m_RangeDecoder) == 0)  				distance = rep2;  			else {  				distance = rep3;  				rep3 = rep2;  			}  			rep2 = rep1;  		}  		rep1 = rep0;  		rep0 = distance;  	}  	len = m_RepLenDecoder.Decode (m_RangeDecoder' posState) + Base.kMatchMinLen;  	state.UpdateRep ();  }  else {  	rep3 = rep2;  	rep2 = rep1;  	rep1 = rep0;  	len = Base.kMatchMinLen + m_LenDecoder.Decode (m_RangeDecoder' posState);  	state.UpdateMatch ();  	uint posSlot = m_PosSlotDecoder [Base.GetLenToPosState (len)].Decode (m_RangeDecoder);  	if (posSlot >= Base.kStartPosModelIndex) {  		int numDirectBits = (int)((posSlot >> 1) - 1);  		rep0 = ((2 | (posSlot & 1)) << numDirectBits);  		if (posSlot < Base.kEndPosModelIndex)  			rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  		else {  			rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  			rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  		}  	}  	else  		rep0 = posSlot;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: if (posSlot >= Base.kStartPosModelIndex) {  	int numDirectBits = (int)((posSlot >> 1) - 1);  	rep0 = ((2 | (posSlot & 1)) << numDirectBits);  	if (posSlot < Base.kEndPosModelIndex)  		rep0 += BitTreeDecoder.ReverseDecode (m_PosDecoders' rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  	else {  		rep0 += (m_RangeDecoder.DecodeDirectBits (numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  		rep0 += m_PosAlignDecoder.ReverseDecode (m_RangeDecoder);  	}  }  else  	rep0 = posSlot;  
Magic Number,SevenZipRadical.Compression.LZMA,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: rep0 = ((2 | (posSlot & 1)) << numDirectBits);  
Magic Number,SevenZipRadical.Compression.LZMA,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: if (properties.Length < 5)  	throw new InvalidParamException ();  
Magic Number,SevenZipRadical.Compression.LZMA,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	dictionarySize += ((UInt32)(properties [1 + i])) << (i * 8);  
Magic Number,SevenZipRadical.Compression.LZMA,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	dictionarySize += ((UInt32)(properties [1 + i])) << (i * 8);  
Magic Number,SevenZipRadical.Compression.LZMA,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: dictionarySize += ((UInt32)(properties [1 + i])) << (i * 8);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: for (Byte slotFast = 2; slotFast < kFastSlots; slotFast++) {  	UInt32 k = ((UInt32)1 << ((slotFast >> 1) - 1));  	for (UInt32 j = 0; j < k; j++' c++)  		g_FastPos [c] = slotFast;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 11))  	return g_FastPos [pos];  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  	return (UInt32)(g_FastPos [pos >> 10] + 20);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  	return (UInt32)(g_FastPos [pos >> 10] + 20);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  	return (UInt32)(g_FastPos [pos >> 10] + 20);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 10] + 20);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 10] + 20);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 20] + 40);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 20] + 40);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  	return (UInt32)(g_FastPos [pos >> 6] + 12);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  	return (UInt32)(g_FastPos [pos >> 6] + 12);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  	return (UInt32)(g_FastPos [pos >> 6] + 12);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 6] + 12);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 6] + 12);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  	return (UInt32)(g_FastPos [pos >> 16] + 32);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  	return (UInt32)(g_FastPos [pos >> 16] + 32);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  	return (UInt32)(g_FastPos [pos >> 16] + 32);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 16] + 32);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 16] + 32);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 26] + 52);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos [pos >> 26] + 52);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null) {  	LZ.BinTree bt = new LZ.BinTree ();  	int numHashBytes = 4;  	if (_matchFinderType == EMatchFinderType.BT2)  		numHashBytes = 2;  	bt.SetType (numHashBytes);  	_matchFinder = bt;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null) {  	LZ.BinTree bt = new LZ.BinTree ();  	int numHashBytes = 4;  	if (_matchFinderType == EMatchFinderType.BT2)  		numHashBytes = 2;  	bt.SetType (numHashBytes);  	_matchFinder = bt;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinderType == EMatchFinderType.BT2)  	numHashBytes = 2;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: numHashBytes = 2;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,ReadMatchDistances,The following statement contains a magic number: if (numDistancePairs > 0) {  	lenRes = _matchDistances [numDistancePairs - 2];  	if (lenRes == _numFastBytes)  		lenRes += _matchFinder.GetMatchLen ((int)lenRes - 1' _matchDistances [numDistancePairs - 1]' Base.kMatchMaxLen - lenRes);  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,ReadMatchDistances,The following statement contains a magic number: lenRes = _matchDistances [numDistancePairs - 2];  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPureRepPrice,The following statement contains a magic number: if (repIndex == 0) {  	price = _isRepG0 [state.Index].GetPrice0 ();  	price += _isRep0Long [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  }  else {  	price = _isRepG0 [state.Index].GetPrice1 ();  	if (repIndex == 1)  		price += _isRepG1 [state.Index].GetPrice0 ();  	else {  		price += _isRepG1 [state.Index].GetPrice1 ();  		price += _isRepG2 [state.Index].GetPrice (repIndex - 2);  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPureRepPrice,The following statement contains a magic number: if (repIndex == 1)  	price += _isRepG1 [state.Index].GetPrice0 ();  else {  	price += _isRepG1 [state.Index].GetPrice1 ();  	price += _isRepG2 [state.Index].GetPrice (repIndex - 2);  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetPureRepPrice,The following statement contains a magic number: price += _isRepG2 [state.Index].GetPrice (repIndex - 2);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (numAvailableBytes < 2) {  	backRes = 0xFFFFFFFF;  	return 1;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens [repMaxIndex] < 2) {  	backRes = (UInt32)0xFFFFFFFF;  	return 1;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens [repMaxIndex] < 2) {  	backRes = (UInt32)0xFFFFFFFF;  	return 1;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenEnd < 2) {  	backRes = _optimum [1].BackPrev;  	return 1;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum [0].Backs2 = reps [2];  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum [0].Backs3 = reps [3];  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: do  	_optimum [len--].Price = kIfinityPrice;  while (len >= 2);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++) {  	UInt32 repLen = repLens [i];  	if (repLen < 2)  		continue;  	UInt32 price = repMatchPrice + GetPureRepPrice (i' _state' posState);  	do {  		UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice (repLen - 2' posState);  		Optimal optimum = _optimum [repLen];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = 0;  			optimum.BackPrev = i;  			optimum.Prev1IsChar = false;  		}  	}  	while (--repLen >= 2);  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++) {  	UInt32 repLen = repLens [i];  	if (repLen < 2)  		continue;  	UInt32 price = repMatchPrice + GetPureRepPrice (i' _state' posState);  	do {  		UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice (repLen - 2' posState);  		Optimal optimum = _optimum [repLen];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = 0;  			optimum.BackPrev = i;  			optimum.Prev1IsChar = false;  		}  	}  	while (--repLen >= 2);  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++) {  	UInt32 repLen = repLens [i];  	if (repLen < 2)  		continue;  	UInt32 price = repMatchPrice + GetPureRepPrice (i' _state' posState);  	do {  		UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice (repLen - 2' posState);  		Optimal optimum = _optimum [repLen];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = 0;  			optimum.BackPrev = i;  			optimum.Prev1IsChar = false;  		}  	}  	while (--repLen >= 2);  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (repLen < 2)  	continue;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: do {  	UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice (repLen - 2' posState);  	Optimal optimum = _optimum [repLen];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = 0;  		optimum.BackPrev = i;  		optimum.Prev1IsChar = false;  	}  }  while (--repLen >= 2);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: do {  	UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice (repLen - 2' posState);  	Optimal optimum = _optimum [repLen];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = 0;  		optimum.BackPrev = i;  		optimum.Prev1IsChar = false;  	}  }  while (--repLen >= 2);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens [0] >= 2) ? repLens [0] + 1 : 2);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens [0] >= 2) ? repLens [0] + 1 : 2);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain) {  	UInt32 offs = 0;  	while (len > _matchDistances [offs])  		offs += 2;  	for (; ; len++) {  		UInt32 distance = _matchDistances [offs + 1];  		UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (distance' len' posState);  		Optimal optimum = _optimum [len];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = 0;  			optimum.BackPrev = distance + Base.kNumRepDistances;  			optimum.Prev1IsChar = false;  		}  		if (len == _matchDistances [offs]) {  			offs += 2;  			if (offs == numDistancePairs)  				break;  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain) {  	UInt32 offs = 0;  	while (len > _matchDistances [offs])  		offs += 2;  	for (; ; len++) {  		UInt32 distance = _matchDistances [offs + 1];  		UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (distance' len' posState);  		Optimal optimum = _optimum [len];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = 0;  			optimum.BackPrev = distance + Base.kNumRepDistances;  			optimum.Prev1IsChar = false;  		}  		if (len == _matchDistances [offs]) {  			offs += 2;  			if (offs == numDistancePairs)  				break;  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (len > _matchDistances [offs])  	offs += 2;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (; ; len++) {  	UInt32 distance = _matchDistances [offs + 1];  	UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (distance' len' posState);  	Optimal optimum = _optimum [len];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = 0;  		optimum.BackPrev = distance + Base.kNumRepDistances;  		optimum.Prev1IsChar = false;  	}  	if (len == _matchDistances [offs]) {  		offs += 2;  		if (offs == numDistancePairs)  			break;  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len == _matchDistances [offs]) {  	offs += 2;  	if (offs == numDistancePairs)  		break;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  	cur++;  	if (cur == lenEnd)  		return Backward (out backRes' cur);  	UInt32 newLen;  	ReadMatchDistances (out newLen' out numDistancePairs);  	if (newLen >= _numFastBytes) {  		_numDistancePairs = numDistancePairs;  		_longestMatchLength = newLen;  		_longestMatchWasFound = true;  		return Backward (out backRes' cur);  	}  	position++;  	UInt32 posPrev = _optimum [cur].PosPrev;  	Base.State state;  	if (_optimum [cur].Prev1IsChar) {  		posPrev--;  		if (_optimum [cur].Prev2) {  			state = _optimum [_optimum [cur].PosPrev2].State;  			if (_optimum [cur].BackPrev2 < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		else  			state = _optimum [posPrev].State;  		state.UpdateChar ();  	}  	else  		state = _optimum [posPrev].State;  	if (posPrev == cur - 1) {  		if (_optimum [cur].IsShortRep ())  			state.UpdateShortRep ();  		else  			state.UpdateChar ();  	}  	else {  		UInt32 pos;  		if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  			posPrev = _optimum [cur].PosPrev2;  			pos = _optimum [cur].BackPrev2;  			state.UpdateRep ();  		}  		else {  			pos = _optimum [cur].BackPrev;  			if (pos < Base.kNumRepDistances)  				state.UpdateRep ();  			else  				state.UpdateMatch ();  		}  		Optimal opt = _optimum [posPrev];  		if (pos < Base.kNumRepDistances) {  			if (pos == 0) {  				reps [0] = opt.Backs0;  				reps [1] = opt.Backs1;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 1) {  				reps [0] = opt.Backs1;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs2;  				reps [3] = opt.Backs3;  			}  			else if (pos == 2) {  				reps [0] = opt.Backs2;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs3;  			}  			else {  				reps [0] = opt.Backs3;  				reps [1] = opt.Backs0;  				reps [2] = opt.Backs1;  				reps [3] = opt.Backs2;  			}  		}  		else {  			reps [0] = (pos - Base.kNumRepDistances);  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	_optimum [cur].State = state;  	_optimum [cur].Backs0 = reps [0];  	_optimum [cur].Backs1 = reps [1];  	_optimum [cur].Backs2 = reps [2];  	_optimum [cur].Backs3 = reps [3];  	UInt32 curPrice = _optimum [cur].Price;  	currentByte = _matchFinder.GetIndexByte (0 - 1);  	matchByte = _matchFinder.GetIndexByte ((Int32)(0 - reps [0] - 1 - 1));  	posState = (position & _posStateMask);  	UInt32 curAnd1Price = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0 () + _literalEncoder.GetSubCoder (position' _matchFinder.GetIndexByte (0 - 2)).GetPrice (!state.IsCharState ()' matchByte' currentByte);  	Optimal nextOptimum = _optimum [cur + 1];  	bool nextIsChar = false;  	if (curAnd1Price < nextOptimum.Price) {  		nextOptimum.Price = curAnd1Price;  		nextOptimum.PosPrev = cur;  		nextOptimum.MakeAsChar ();  		nextIsChar = true;  	}  	matchPrice = curPrice + _isMatch [(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1 ();  	repMatchPrice = matchPrice + _isRep [state.Index].GetPrice1 ();  	if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  		UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price (state' posState);  		if (shortRepPrice <= nextOptimum.Price) {  			nextOptimum.Price = shortRepPrice;  			nextOptimum.PosPrev = cur;  			nextOptimum.MakeAsShortRep ();  			nextIsChar = true;  		}  	}  	UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes () + 1;  	numAvailableBytesFull = Math.Min (kNumOpts - 1 - cur' numAvailableBytesFull);  	numAvailableBytes = numAvailableBytesFull;  	if (numAvailableBytes < 2)  		continue;  	if (numAvailableBytes > _numFastBytes)  		numAvailableBytes = _numFastBytes;  	if (!nextIsChar && matchByte != currentByte) {  		// try Literal + rep0  		UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateChar ();  			UInt32 posStateNext = (position + 1) & _posStateMask;  			UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  			{  				UInt32 offset = cur + 1 + lenTest2;  				while (lenEnd < offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = false;  				}  			}  		}  	}  	UInt32 startLen = 2;  	// speed optimization   	for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  		UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  		if (lenTest < 2)  			continue;  		UInt32 lenTestTemp = lenTest;  		do {  			while (lenEnd < cur + lenTest)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = repIndex;  				optimum.Prev1IsChar = false;  			}  		}  		while (--lenTest >= 2);  		lenTest = lenTestTemp;  		if (repIndex == 0)  			startLen = lenTest + 1;  		// if (_maxMode)  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateRep ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				// for(; lenTest2 >= 2; lenTest2--)  				{  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					Optimal optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = repIndex;  					}  				}  			}  		}  	}  	if (newLen > numAvailableBytes) {  		newLen = numAvailableBytes;  		for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  			;  		_matchDistances [numDistancePairs] = newLen;  		numDistancePairs += 2;  	}  	if (newLen >= startLen) {  		normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  		while (lenEnd < cur + newLen)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 offs = 0;  		while (startLen > _matchDistances [offs])  			offs += 2;  		for (UInt32 lenTest = startLen; ; lenTest++) {  			UInt32 curBack = _matchDistances [offs + 1];  			UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  			Optimal optimum = _optimum [cur + lenTest];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur;  				optimum.BackPrev = curBack + Base.kNumRepDistances;  				optimum.Prev1IsChar = false;  			}  			if (lenTest == _matchDistances [offs]) {  				if (lenTest < numAvailableBytesFull) {  					UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateMatch ();  						UInt32 posStateNext = (position + lenTest) & _posStateMask;  						UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  						state2.UpdateChar ();  						posStateNext = (position + lenTest + 1) & _posStateMask;  						UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  						UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  						UInt32 offset = lenTest + 1 + lenTest2;  						while (lenEnd < cur + offset)  							_optimum [++lenEnd].Price = kIfinityPrice;  						curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  						optimum = _optimum [cur + offset];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur + lenTest + 1;  							optimum.BackPrev = 0;  							optimum.Prev1IsChar = true;  							optimum.Prev2 = true;  							optimum.PosPrev2 = cur;  							optimum.BackPrev2 = curBack + Base.kNumRepDistances;  						}  					}  				}  				offs += 2;  				if (offs == numDistancePairs)  					break;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (posPrev == cur - 1) {  	if (_optimum [cur].IsShortRep ())  		state.UpdateShortRep ();  	else  		state.UpdateChar ();  }  else {  	UInt32 pos;  	if (_optimum [cur].Prev1IsChar && _optimum [cur].Prev2) {  		posPrev = _optimum [cur].PosPrev2;  		pos = _optimum [cur].BackPrev2;  		state.UpdateRep ();  	}  	else {  		pos = _optimum [cur].BackPrev;  		if (pos < Base.kNumRepDistances)  			state.UpdateRep ();  		else  			state.UpdateMatch ();  	}  	Optimal opt = _optimum [posPrev];  	if (pos < Base.kNumRepDistances) {  		if (pos == 0) {  			reps [0] = opt.Backs0;  			reps [1] = opt.Backs1;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 1) {  			reps [0] = opt.Backs1;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs2;  			reps [3] = opt.Backs3;  		}  		else if (pos == 2) {  			reps [0] = opt.Backs2;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs3;  		}  		else {  			reps [0] = opt.Backs3;  			reps [1] = opt.Backs0;  			reps [2] = opt.Backs1;  			reps [3] = opt.Backs2;  		}  	}  	else {  		reps [0] = (pos - Base.kNumRepDistances);  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	if (pos == 0) {  		reps [0] = opt.Backs0;  		reps [1] = opt.Backs1;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 1) {  		reps [0] = opt.Backs1;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs2;  		reps [3] = opt.Backs3;  	}  	else if (pos == 2) {  		reps [0] = opt.Backs2;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs3;  	}  	else {  		reps [0] = opt.Backs3;  		reps [1] = opt.Backs0;  		reps [2] = opt.Backs1;  		reps [3] = opt.Backs2;  	}  }  else {  	reps [0] = (pos - Base.kNumRepDistances);  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 0) {  	reps [0] = opt.Backs0;  	reps [1] = opt.Backs1;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [2] = opt.Backs2;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [3] = opt.Backs3;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 1) {  	reps [0] = opt.Backs1;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs2;  	reps [3] = opt.Backs3;  }  else if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [2] = opt.Backs2;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [3] = opt.Backs3;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (pos == 2) {  	reps [0] = opt.Backs2;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs3;  }  else {  	reps [0] = opt.Backs3;  	reps [1] = opt.Backs0;  	reps [2] = opt.Backs1;  	reps [3] = opt.Backs2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [2] = opt.Backs1;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [3] = opt.Backs3;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [2] = opt.Backs1;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [3] = opt.Backs2;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [2] = opt.Backs1;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: reps [3] = opt.Backs2;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum [cur].Backs2 = reps [2];  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum [cur].Backs3 = reps [3];  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (numAvailableBytes < 2)  	continue;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (!nextIsChar && matchByte != currentByte) {  	// try Literal + rep0  	UInt32 t = Math.Min (numAvailableBytesFull - 1' _numFastBytes);  	UInt32 lenTest2 = _matchFinder.GetMatchLen (0' reps [0]' t);  	if (lenTest2 >= 2) {  		Base.State state2 = state;  		state2.UpdateChar ();  		UInt32 posStateNext = (position + 1) & _posStateMask;  		UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  		{  			UInt32 offset = cur + 1 + lenTest2;  			while (lenEnd < offset)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  			Optimal optimum = _optimum [offset];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur + 1;  				optimum.BackPrev = 0;  				optimum.Prev1IsChar = true;  				optimum.Prev2 = false;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest2 >= 2) {  	Base.State state2 = state;  	state2.UpdateChar ();  	UInt32 posStateNext = (position + 1) & _posStateMask;  	UInt32 nextRepMatchPrice = curAnd1Price + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 () + _isRep [state2.Index].GetPrice1 ();  	{  		UInt32 offset = cur + 1 + lenTest2;  		while (lenEnd < offset)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  		Optimal optimum = _optimum [offset];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur + 1;  			optimum.BackPrev = 0;  			optimum.Prev1IsChar = true;  			optimum.Prev2 = false;  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  	UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  	if (lenTest < 2)  		continue;  	UInt32 lenTestTemp = lenTest;  	do {  		while (lenEnd < cur + lenTest)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  		Optimal optimum = _optimum [cur + lenTest];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur;  			optimum.BackPrev = repIndex;  			optimum.Prev1IsChar = false;  		}  	}  	while (--lenTest >= 2);  	lenTest = lenTestTemp;  	if (repIndex == 0)  		startLen = lenTest + 1;  	// if (_maxMode)  	if (lenTest < numAvailableBytesFull) {  		UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateRep ();  			UInt32 posStateNext = (position + lenTest) & _posStateMask;  			UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  			state2.UpdateChar ();  			posStateNext = (position + lenTest + 1) & _posStateMask;  			UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  			UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  			// for(; lenTest2 >= 2; lenTest2--)  			{  				UInt32 offset = lenTest + 1 + lenTest2;  				while (lenEnd < cur + offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [cur + offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + lenTest + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = true;  					optimum.PosPrev2 = cur;  					optimum.BackPrev2 = repIndex;  				}  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  	UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  	if (lenTest < 2)  		continue;  	UInt32 lenTestTemp = lenTest;  	do {  		while (lenEnd < cur + lenTest)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  		Optimal optimum = _optimum [cur + lenTest];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur;  			optimum.BackPrev = repIndex;  			optimum.Prev1IsChar = false;  		}  	}  	while (--lenTest >= 2);  	lenTest = lenTestTemp;  	if (repIndex == 0)  		startLen = lenTest + 1;  	// if (_maxMode)  	if (lenTest < numAvailableBytesFull) {  		UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateRep ();  			UInt32 posStateNext = (position + lenTest) & _posStateMask;  			UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  			state2.UpdateChar ();  			posStateNext = (position + lenTest + 1) & _posStateMask;  			UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  			UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  			// for(; lenTest2 >= 2; lenTest2--)  			{  				UInt32 offset = lenTest + 1 + lenTest2;  				while (lenEnd < cur + offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [cur + offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + lenTest + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = true;  					optimum.PosPrev2 = cur;  					optimum.BackPrev2 = repIndex;  				}  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  	UInt32 lenTest = _matchFinder.GetMatchLen (0 - 1' reps [repIndex]' numAvailableBytes);  	if (lenTest < 2)  		continue;  	UInt32 lenTestTemp = lenTest;  	do {  		while (lenEnd < cur + lenTest)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  		Optimal optimum = _optimum [cur + lenTest];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur;  			optimum.BackPrev = repIndex;  			optimum.Prev1IsChar = false;  		}  	}  	while (--lenTest >= 2);  	lenTest = lenTestTemp;  	if (repIndex == 0)  		startLen = lenTest + 1;  	// if (_maxMode)  	if (lenTest < numAvailableBytesFull) {  		UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateRep ();  			UInt32 posStateNext = (position + lenTest) & _posStateMask;  			UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  			state2.UpdateChar ();  			posStateNext = (position + lenTest + 1) & _posStateMask;  			UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  			UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  			// for(; lenTest2 >= 2; lenTest2--)  			{  				UInt32 offset = lenTest + 1 + lenTest2;  				while (lenEnd < cur + offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				Optimal optimum = _optimum [cur + offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + lenTest + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = true;  					optimum.PosPrev2 = cur;  					optimum.BackPrev2 = repIndex;  				}  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest < 2)  	continue;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: do {  	while (lenEnd < cur + lenTest)  		_optimum [++lenEnd].Price = kIfinityPrice;  	UInt32 curAndLenPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState);  	Optimal optimum = _optimum [cur + lenTest];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = cur;  		optimum.BackPrev = repIndex;  		optimum.Prev1IsChar = false;  	}  }  while (--lenTest >= 2);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest < numAvailableBytesFull) {  	UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  	UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' reps [repIndex]' t);  	if (lenTest2 >= 2) {  		Base.State state2 = state;  		state2.UpdateRep ();  		UInt32 posStateNext = (position + lenTest) & _posStateMask;  		UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  		state2.UpdateChar ();  		posStateNext = (position + lenTest + 1) & _posStateMask;  		UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  		UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  		// for(; lenTest2 >= 2; lenTest2--)  		{  			UInt32 offset = lenTest + 1 + lenTest2;  			while (lenEnd < cur + offset)  				_optimum [++lenEnd].Price = kIfinityPrice;  			UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  			Optimal optimum = _optimum [cur + offset];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur + lenTest + 1;  				optimum.BackPrev = 0;  				optimum.Prev1IsChar = true;  				optimum.Prev2 = true;  				optimum.PosPrev2 = cur;  				optimum.BackPrev2 = repIndex;  			}  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest2 >= 2) {  	Base.State state2 = state;  	state2.UpdateRep ();  	UInt32 posStateNext = (position + lenTest) & _posStateMask;  	UInt32 curAndLenCharPrice = repMatchPrice + GetRepPrice (repIndex' lenTest' state' posState) + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)((Int32)lenTest - 1 - (Int32)(reps [repIndex] + 1)))' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  	state2.UpdateChar ();  	posStateNext = (position + lenTest + 1) & _posStateMask;  	UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  	UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  	// for(; lenTest2 >= 2; lenTest2--)  	{  		UInt32 offset = lenTest + 1 + lenTest2;  		while (lenEnd < cur + offset)  			_optimum [++lenEnd].Price = kIfinityPrice;  		UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  		Optimal optimum = _optimum [cur + offset];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur + lenTest + 1;  			optimum.BackPrev = 0;  			optimum.Prev1IsChar = true;  			optimum.Prev2 = true;  			optimum.PosPrev2 = cur;  			optimum.BackPrev2 = repIndex;  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (newLen > numAvailableBytes) {  	newLen = numAvailableBytes;  	for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  		;  	_matchDistances [numDistancePairs] = newLen;  	numDistancePairs += 2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (newLen > numAvailableBytes) {  	newLen = numAvailableBytes;  	for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  		;  	_matchDistances [numDistancePairs] = newLen;  	numDistancePairs += 2;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (numDistancePairs = 0; newLen > _matchDistances [numDistancePairs]; numDistancePairs += 2)  	;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: numDistancePairs += 2
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: numDistancePairs += 2;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (newLen >= startLen) {  	normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  	while (lenEnd < cur + newLen)  		_optimum [++lenEnd].Price = kIfinityPrice;  	UInt32 offs = 0;  	while (startLen > _matchDistances [offs])  		offs += 2;  	for (UInt32 lenTest = startLen; ; lenTest++) {  		UInt32 curBack = _matchDistances [offs + 1];  		UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  		Optimal optimum = _optimum [cur + lenTest];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur;  			optimum.BackPrev = curBack + Base.kNumRepDistances;  			optimum.Prev1IsChar = false;  		}  		if (lenTest == _matchDistances [offs]) {  			if (lenTest < numAvailableBytesFull) {  				UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  				UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  				if (lenTest2 >= 2) {  					Base.State state2 = state;  					state2.UpdateMatch ();  					UInt32 posStateNext = (position + lenTest) & _posStateMask;  					UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  					state2.UpdateChar ();  					posStateNext = (position + lenTest + 1) & _posStateMask;  					UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  					UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = curBack + Base.kNumRepDistances;  					}  				}  			}  			offs += 2;  			if (offs == numDistancePairs)  				break;  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (newLen >= startLen) {  	normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  	while (lenEnd < cur + newLen)  		_optimum [++lenEnd].Price = kIfinityPrice;  	UInt32 offs = 0;  	while (startLen > _matchDistances [offs])  		offs += 2;  	for (UInt32 lenTest = startLen; ; lenTest++) {  		UInt32 curBack = _matchDistances [offs + 1];  		UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  		Optimal optimum = _optimum [cur + lenTest];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur;  			optimum.BackPrev = curBack + Base.kNumRepDistances;  			optimum.Prev1IsChar = false;  		}  		if (lenTest == _matchDistances [offs]) {  			if (lenTest < numAvailableBytesFull) {  				UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  				UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  				if (lenTest2 >= 2) {  					Base.State state2 = state;  					state2.UpdateMatch ();  					UInt32 posStateNext = (position + lenTest) & _posStateMask;  					UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  					state2.UpdateChar ();  					posStateNext = (position + lenTest + 1) & _posStateMask;  					UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  					UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = curBack + Base.kNumRepDistances;  					}  				}  			}  			offs += 2;  			if (offs == numDistancePairs)  				break;  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (newLen >= startLen) {  	normalMatchPrice = matchPrice + _isRep [state.Index].GetPrice0 ();  	while (lenEnd < cur + newLen)  		_optimum [++lenEnd].Price = kIfinityPrice;  	UInt32 offs = 0;  	while (startLen > _matchDistances [offs])  		offs += 2;  	for (UInt32 lenTest = startLen; ; lenTest++) {  		UInt32 curBack = _matchDistances [offs + 1];  		UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  		Optimal optimum = _optimum [cur + lenTest];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur;  			optimum.BackPrev = curBack + Base.kNumRepDistances;  			optimum.Prev1IsChar = false;  		}  		if (lenTest == _matchDistances [offs]) {  			if (lenTest < numAvailableBytesFull) {  				UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  				UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  				if (lenTest2 >= 2) {  					Base.State state2 = state;  					state2.UpdateMatch ();  					UInt32 posStateNext = (position + lenTest) & _posStateMask;  					UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  					state2.UpdateChar ();  					posStateNext = (position + lenTest + 1) & _posStateMask;  					UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  					UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  					UInt32 offset = lenTest + 1 + lenTest2;  					while (lenEnd < cur + offset)  						_optimum [++lenEnd].Price = kIfinityPrice;  					curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  					optimum = _optimum [cur + offset];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = cur + lenTest + 1;  						optimum.BackPrev = 0;  						optimum.Prev1IsChar = true;  						optimum.Prev2 = true;  						optimum.PosPrev2 = cur;  						optimum.BackPrev2 = curBack + Base.kNumRepDistances;  					}  				}  			}  			offs += 2;  			if (offs == numDistancePairs)  				break;  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (startLen > _matchDistances [offs])  	offs += 2;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (UInt32 lenTest = startLen; ; lenTest++) {  	UInt32 curBack = _matchDistances [offs + 1];  	UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  	Optimal optimum = _optimum [cur + lenTest];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = cur;  		optimum.BackPrev = curBack + Base.kNumRepDistances;  		optimum.Prev1IsChar = false;  	}  	if (lenTest == _matchDistances [offs]) {  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateMatch ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				UInt32 offset = lenTest + 1 + lenTest2;  				while (lenEnd < cur + offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				optimum = _optimum [cur + offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + lenTest + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = true;  					optimum.PosPrev2 = cur;  					optimum.BackPrev2 = curBack + Base.kNumRepDistances;  				}  			}  		}  		offs += 2;  		if (offs == numDistancePairs)  			break;  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (UInt32 lenTest = startLen; ; lenTest++) {  	UInt32 curBack = _matchDistances [offs + 1];  	UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice (curBack' lenTest' posState);  	Optimal optimum = _optimum [cur + lenTest];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = cur;  		optimum.BackPrev = curBack + Base.kNumRepDistances;  		optimum.Prev1IsChar = false;  	}  	if (lenTest == _matchDistances [offs]) {  		if (lenTest < numAvailableBytesFull) {  			UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  			UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  			if (lenTest2 >= 2) {  				Base.State state2 = state;  				state2.UpdateMatch ();  				UInt32 posStateNext = (position + lenTest) & _posStateMask;  				UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  				state2.UpdateChar ();  				posStateNext = (position + lenTest + 1) & _posStateMask;  				UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  				UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  				UInt32 offset = lenTest + 1 + lenTest2;  				while (lenEnd < cur + offset)  					_optimum [++lenEnd].Price = kIfinityPrice;  				curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  				optimum = _optimum [cur + offset];  				if (curAndLenPrice < optimum.Price) {  					optimum.Price = curAndLenPrice;  					optimum.PosPrev = cur + lenTest + 1;  					optimum.BackPrev = 0;  					optimum.Prev1IsChar = true;  					optimum.Prev2 = true;  					optimum.PosPrev2 = cur;  					optimum.BackPrev2 = curBack + Base.kNumRepDistances;  				}  			}  		}  		offs += 2;  		if (offs == numDistancePairs)  			break;  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest == _matchDistances [offs]) {  	if (lenTest < numAvailableBytesFull) {  		UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateMatch ();  			UInt32 posStateNext = (position + lenTest) & _posStateMask;  			UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  			state2.UpdateChar ();  			posStateNext = (position + lenTest + 1) & _posStateMask;  			UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  			UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  			UInt32 offset = lenTest + 1 + lenTest2;  			while (lenEnd < cur + offset)  				_optimum [++lenEnd].Price = kIfinityPrice;  			curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  			optimum = _optimum [cur + offset];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur + lenTest + 1;  				optimum.BackPrev = 0;  				optimum.Prev1IsChar = true;  				optimum.Prev2 = true;  				optimum.PosPrev2 = cur;  				optimum.BackPrev2 = curBack + Base.kNumRepDistances;  			}  		}  	}  	offs += 2;  	if (offs == numDistancePairs)  		break;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest == _matchDistances [offs]) {  	if (lenTest < numAvailableBytesFull) {  		UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  		UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  		if (lenTest2 >= 2) {  			Base.State state2 = state;  			state2.UpdateMatch ();  			UInt32 posStateNext = (position + lenTest) & _posStateMask;  			UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  			state2.UpdateChar ();  			posStateNext = (position + lenTest + 1) & _posStateMask;  			UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  			UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  			UInt32 offset = lenTest + 1 + lenTest2;  			while (lenEnd < cur + offset)  				_optimum [++lenEnd].Price = kIfinityPrice;  			curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  			optimum = _optimum [cur + offset];  			if (curAndLenPrice < optimum.Price) {  				optimum.Price = curAndLenPrice;  				optimum.PosPrev = cur + lenTest + 1;  				optimum.BackPrev = 0;  				optimum.Prev1IsChar = true;  				optimum.Prev2 = true;  				optimum.PosPrev2 = cur;  				optimum.BackPrev2 = curBack + Base.kNumRepDistances;  			}  		}  	}  	offs += 2;  	if (offs == numDistancePairs)  		break;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest < numAvailableBytesFull) {  	UInt32 t = Math.Min (numAvailableBytesFull - 1 - lenTest' _numFastBytes);  	UInt32 lenTest2 = _matchFinder.GetMatchLen ((Int32)lenTest' curBack' t);  	if (lenTest2 >= 2) {  		Base.State state2 = state;  		state2.UpdateMatch ();  		UInt32 posStateNext = (position + lenTest) & _posStateMask;  		UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  		state2.UpdateChar ();  		posStateNext = (position + lenTest + 1) & _posStateMask;  		UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  		UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  		UInt32 offset = lenTest + 1 + lenTest2;  		while (lenEnd < cur + offset)  			_optimum [++lenEnd].Price = kIfinityPrice;  		curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  		optimum = _optimum [cur + offset];  		if (curAndLenPrice < optimum.Price) {  			optimum.Price = curAndLenPrice;  			optimum.PosPrev = cur + lenTest + 1;  			optimum.BackPrev = 0;  			optimum.Prev1IsChar = true;  			optimum.Prev2 = true;  			optimum.PosPrev2 = cur;  			optimum.BackPrev2 = curBack + Base.kNumRepDistances;  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenTest2 >= 2) {  	Base.State state2 = state;  	state2.UpdateMatch ();  	UInt32 posStateNext = (position + lenTest) & _posStateMask;  	UInt32 curAndLenCharPrice = curAndLenPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0 () + _literalEncoder.GetSubCoder (position + lenTest' _matchFinder.GetIndexByte ((Int32)lenTest - 1 - 1)).GetPrice (true' _matchFinder.GetIndexByte ((Int32)lenTest - (Int32)(curBack + 1) - 1)' _matchFinder.GetIndexByte ((Int32)lenTest - 1));  	state2.UpdateChar ();  	posStateNext = (position + lenTest + 1) & _posStateMask;  	UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch [(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1 ();  	UInt32 nextRepMatchPrice = nextMatchPrice + _isRep [state2.Index].GetPrice1 ();  	UInt32 offset = lenTest + 1 + lenTest2;  	while (lenEnd < cur + offset)  		_optimum [++lenEnd].Price = kIfinityPrice;  	curAndLenPrice = nextRepMatchPrice + GetRepPrice (0' lenTest2' state2' posStateNext);  	optimum = _optimum [cur + offset];  	if (curAndLenPrice < optimum.Price) {  		optimum.Price = curAndLenPrice;  		optimum.PosPrev = cur + lenTest + 1;  		optimum.BackPrev = 0;  		optimum.Prev1IsChar = true;  		optimum.Prev2 = true;  		optimum.PosPrev2 = cur;  		optimum.BackPrev2 = curBack + Base.kNumRepDistances;  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: return (smallDist < ((UInt32)(1) << (32 - kDif)) && bigDist >= (smallDist << kDif));  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true) {  	UInt32 pos;  	UInt32 len = GetOptimum ((UInt32)nowPos64' out pos);  	UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  	UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  	if (len == 1 && pos == 0xFFFFFFFF) {  		_isMatch [complexState].Encode (_rangeEncoder' 0);  		Byte curByte = _matchFinder.GetIndexByte ((Int32)(0 - _additionalOffset));  		LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder ((UInt32)nowPos64' _previousByte);  		if (!_state.IsCharState ()) {  			Byte matchByte = _matchFinder.GetIndexByte ((Int32)(0 - _repDistances [0] - 1 - _additionalOffset));  			subCoder.EncodeMatched (_rangeEncoder' matchByte' curByte);  		}  		else  			subCoder.Encode (_rangeEncoder' curByte);  		_previousByte = curByte;  		_state.UpdateChar ();  	}  	else {  		_isMatch [complexState].Encode (_rangeEncoder' 1);  		if (pos < Base.kNumRepDistances) {  			_isRep [_state.Index].Encode (_rangeEncoder' 1);  			if (pos == 0) {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  				if (len == 1)  					_isRep0Long [complexState].Encode (_rangeEncoder' 0);  				else  					_isRep0Long [complexState].Encode (_rangeEncoder' 1);  			}  			else {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  				if (pos == 1)  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  				else {  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  					_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  				}  			}  			if (len == 1)  				_state.UpdateShortRep ();  			else {  				_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  				_state.UpdateRep ();  			}  			UInt32 distance = _repDistances [pos];  			if (pos != 0) {  				for (UInt32 i = pos; i >= 1; i--)  					_repDistances [i] = _repDistances [i - 1];  				_repDistances [0] = distance;  			}  		}  		else {  			_isRep [_state.Index].Encode (_rangeEncoder' 0);  			_state.UpdateMatch ();  			_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  			pos -= Base.kNumRepDistances;  			UInt32 posSlot = GetPosSlot (pos);  			UInt32 lenToPosState = Base.GetLenToPosState (len);  			_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  			if (posSlot >= Base.kStartPosModelIndex) {  				int footerBits = (int)((posSlot >> 1) - 1);  				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  				UInt32 posReduced = pos - baseVal;  				if (posSlot < Base.kEndPosModelIndex)  					RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  				else {  					_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  					_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  					_alignPriceCount++;  				}  			}  			UInt32 distance = pos;  			for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  				_repDistances [i] = _repDistances [i - 1];  			_repDistances [0] = distance;  			_matchPriceCount++;  		}  		_previousByte = _matchFinder.GetIndexByte ((Int32)(len - 1 - _additionalOffset));  	}  	_additionalOffset -= len;  	nowPos64 += len;  	if (_additionalOffset == 0) {  		// if (!_fastMode)  		if (_matchPriceCount >= (1 << 7))  			FillDistancesPrices ();  		if (_alignPriceCount >= Base.kAlignTableSize)  			FillAlignPrices ();  		inSize = nowPos64;  		outSize = _rangeEncoder.GetProcessedSizeAdd ();  		if (_matchFinder.GetNumAvailableBytes () == 0) {  			Flush ((UInt32)nowPos64);  			return;  		}  		if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  			_finished = false;  			finished = false;  			return;  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true) {  	UInt32 pos;  	UInt32 len = GetOptimum ((UInt32)nowPos64' out pos);  	UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  	UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  	if (len == 1 && pos == 0xFFFFFFFF) {  		_isMatch [complexState].Encode (_rangeEncoder' 0);  		Byte curByte = _matchFinder.GetIndexByte ((Int32)(0 - _additionalOffset));  		LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder ((UInt32)nowPos64' _previousByte);  		if (!_state.IsCharState ()) {  			Byte matchByte = _matchFinder.GetIndexByte ((Int32)(0 - _repDistances [0] - 1 - _additionalOffset));  			subCoder.EncodeMatched (_rangeEncoder' matchByte' curByte);  		}  		else  			subCoder.Encode (_rangeEncoder' curByte);  		_previousByte = curByte;  		_state.UpdateChar ();  	}  	else {  		_isMatch [complexState].Encode (_rangeEncoder' 1);  		if (pos < Base.kNumRepDistances) {  			_isRep [_state.Index].Encode (_rangeEncoder' 1);  			if (pos == 0) {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  				if (len == 1)  					_isRep0Long [complexState].Encode (_rangeEncoder' 0);  				else  					_isRep0Long [complexState].Encode (_rangeEncoder' 1);  			}  			else {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  				if (pos == 1)  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  				else {  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  					_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  				}  			}  			if (len == 1)  				_state.UpdateShortRep ();  			else {  				_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  				_state.UpdateRep ();  			}  			UInt32 distance = _repDistances [pos];  			if (pos != 0) {  				for (UInt32 i = pos; i >= 1; i--)  					_repDistances [i] = _repDistances [i - 1];  				_repDistances [0] = distance;  			}  		}  		else {  			_isRep [_state.Index].Encode (_rangeEncoder' 0);  			_state.UpdateMatch ();  			_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  			pos -= Base.kNumRepDistances;  			UInt32 posSlot = GetPosSlot (pos);  			UInt32 lenToPosState = Base.GetLenToPosState (len);  			_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  			if (posSlot >= Base.kStartPosModelIndex) {  				int footerBits = (int)((posSlot >> 1) - 1);  				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  				UInt32 posReduced = pos - baseVal;  				if (posSlot < Base.kEndPosModelIndex)  					RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  				else {  					_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  					_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  					_alignPriceCount++;  				}  			}  			UInt32 distance = pos;  			for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  				_repDistances [i] = _repDistances [i - 1];  			_repDistances [0] = distance;  			_matchPriceCount++;  		}  		_previousByte = _matchFinder.GetIndexByte ((Int32)(len - 1 - _additionalOffset));  	}  	_additionalOffset -= len;  	nowPos64 += len;  	if (_additionalOffset == 0) {  		// if (!_fastMode)  		if (_matchPriceCount >= (1 << 7))  			FillDistancesPrices ();  		if (_alignPriceCount >= Base.kAlignTableSize)  			FillAlignPrices ();  		inSize = nowPos64;  		outSize = _rangeEncoder.GetProcessedSizeAdd ();  		if (_matchFinder.GetNumAvailableBytes () == 0) {  			Flush ((UInt32)nowPos64);  			return;  		}  		if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  			_finished = false;  			finished = false;  			return;  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true) {  	UInt32 pos;  	UInt32 len = GetOptimum ((UInt32)nowPos64' out pos);  	UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  	UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  	if (len == 1 && pos == 0xFFFFFFFF) {  		_isMatch [complexState].Encode (_rangeEncoder' 0);  		Byte curByte = _matchFinder.GetIndexByte ((Int32)(0 - _additionalOffset));  		LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder ((UInt32)nowPos64' _previousByte);  		if (!_state.IsCharState ()) {  			Byte matchByte = _matchFinder.GetIndexByte ((Int32)(0 - _repDistances [0] - 1 - _additionalOffset));  			subCoder.EncodeMatched (_rangeEncoder' matchByte' curByte);  		}  		else  			subCoder.Encode (_rangeEncoder' curByte);  		_previousByte = curByte;  		_state.UpdateChar ();  	}  	else {  		_isMatch [complexState].Encode (_rangeEncoder' 1);  		if (pos < Base.kNumRepDistances) {  			_isRep [_state.Index].Encode (_rangeEncoder' 1);  			if (pos == 0) {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  				if (len == 1)  					_isRep0Long [complexState].Encode (_rangeEncoder' 0);  				else  					_isRep0Long [complexState].Encode (_rangeEncoder' 1);  			}  			else {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  				if (pos == 1)  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  				else {  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  					_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  				}  			}  			if (len == 1)  				_state.UpdateShortRep ();  			else {  				_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  				_state.UpdateRep ();  			}  			UInt32 distance = _repDistances [pos];  			if (pos != 0) {  				for (UInt32 i = pos; i >= 1; i--)  					_repDistances [i] = _repDistances [i - 1];  				_repDistances [0] = distance;  			}  		}  		else {  			_isRep [_state.Index].Encode (_rangeEncoder' 0);  			_state.UpdateMatch ();  			_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  			pos -= Base.kNumRepDistances;  			UInt32 posSlot = GetPosSlot (pos);  			UInt32 lenToPosState = Base.GetLenToPosState (len);  			_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  			if (posSlot >= Base.kStartPosModelIndex) {  				int footerBits = (int)((posSlot >> 1) - 1);  				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  				UInt32 posReduced = pos - baseVal;  				if (posSlot < Base.kEndPosModelIndex)  					RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  				else {  					_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  					_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  					_alignPriceCount++;  				}  			}  			UInt32 distance = pos;  			for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  				_repDistances [i] = _repDistances [i - 1];  			_repDistances [0] = distance;  			_matchPriceCount++;  		}  		_previousByte = _matchFinder.GetIndexByte ((Int32)(len - 1 - _additionalOffset));  	}  	_additionalOffset -= len;  	nowPos64 += len;  	if (_additionalOffset == 0) {  		// if (!_fastMode)  		if (_matchPriceCount >= (1 << 7))  			FillDistancesPrices ();  		if (_alignPriceCount >= Base.kAlignTableSize)  			FillAlignPrices ();  		inSize = nowPos64;  		outSize = _rangeEncoder.GetProcessedSizeAdd ();  		if (_matchFinder.GetNumAvailableBytes () == 0) {  			Flush ((UInt32)nowPos64);  			return;  		}  		if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  			_finished = false;  			finished = false;  			return;  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true) {  	UInt32 pos;  	UInt32 len = GetOptimum ((UInt32)nowPos64' out pos);  	UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  	UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  	if (len == 1 && pos == 0xFFFFFFFF) {  		_isMatch [complexState].Encode (_rangeEncoder' 0);  		Byte curByte = _matchFinder.GetIndexByte ((Int32)(0 - _additionalOffset));  		LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder ((UInt32)nowPos64' _previousByte);  		if (!_state.IsCharState ()) {  			Byte matchByte = _matchFinder.GetIndexByte ((Int32)(0 - _repDistances [0] - 1 - _additionalOffset));  			subCoder.EncodeMatched (_rangeEncoder' matchByte' curByte);  		}  		else  			subCoder.Encode (_rangeEncoder' curByte);  		_previousByte = curByte;  		_state.UpdateChar ();  	}  	else {  		_isMatch [complexState].Encode (_rangeEncoder' 1);  		if (pos < Base.kNumRepDistances) {  			_isRep [_state.Index].Encode (_rangeEncoder' 1);  			if (pos == 0) {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  				if (len == 1)  					_isRep0Long [complexState].Encode (_rangeEncoder' 0);  				else  					_isRep0Long [complexState].Encode (_rangeEncoder' 1);  			}  			else {  				_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  				if (pos == 1)  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  				else {  					_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  					_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  				}  			}  			if (len == 1)  				_state.UpdateShortRep ();  			else {  				_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  				_state.UpdateRep ();  			}  			UInt32 distance = _repDistances [pos];  			if (pos != 0) {  				for (UInt32 i = pos; i >= 1; i--)  					_repDistances [i] = _repDistances [i - 1];  				_repDistances [0] = distance;  			}  		}  		else {  			_isRep [_state.Index].Encode (_rangeEncoder' 0);  			_state.UpdateMatch ();  			_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  			pos -= Base.kNumRepDistances;  			UInt32 posSlot = GetPosSlot (pos);  			UInt32 lenToPosState = Base.GetLenToPosState (len);  			_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  			if (posSlot >= Base.kStartPosModelIndex) {  				int footerBits = (int)((posSlot >> 1) - 1);  				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  				UInt32 posReduced = pos - baseVal;  				if (posSlot < Base.kEndPosModelIndex)  					RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  				else {  					_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  					_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  					_alignPriceCount++;  				}  			}  			UInt32 distance = pos;  			for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  				_repDistances [i] = _repDistances [i - 1];  			_repDistances [0] = distance;  			_matchPriceCount++;  		}  		_previousByte = _matchFinder.GetIndexByte ((Int32)(len - 1 - _additionalOffset));  	}  	_additionalOffset -= len;  	nowPos64 += len;  	if (_additionalOffset == 0) {  		// if (!_fastMode)  		if (_matchPriceCount >= (1 << 7))  			FillDistancesPrices ();  		if (_alignPriceCount >= Base.kAlignTableSize)  			FillAlignPrices ();  		inSize = nowPos64;  		outSize = _rangeEncoder.GetProcessedSizeAdd ();  		if (_matchFinder.GetNumAvailableBytes () == 0) {  			Flush ((UInt32)nowPos64);  			return;  		}  		if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  			_finished = false;  			finished = false;  			return;  		}  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (len == 1 && pos == 0xFFFFFFFF) {  	_isMatch [complexState].Encode (_rangeEncoder' 0);  	Byte curByte = _matchFinder.GetIndexByte ((Int32)(0 - _additionalOffset));  	LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder ((UInt32)nowPos64' _previousByte);  	if (!_state.IsCharState ()) {  		Byte matchByte = _matchFinder.GetIndexByte ((Int32)(0 - _repDistances [0] - 1 - _additionalOffset));  		subCoder.EncodeMatched (_rangeEncoder' matchByte' curByte);  	}  	else  		subCoder.Encode (_rangeEncoder' curByte);  	_previousByte = curByte;  	_state.UpdateChar ();  }  else {  	_isMatch [complexState].Encode (_rangeEncoder' 1);  	if (pos < Base.kNumRepDistances) {  		_isRep [_state.Index].Encode (_rangeEncoder' 1);  		if (pos == 0) {  			_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  			if (len == 1)  				_isRep0Long [complexState].Encode (_rangeEncoder' 0);  			else  				_isRep0Long [complexState].Encode (_rangeEncoder' 1);  		}  		else {  			_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  			if (pos == 1)  				_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  			else {  				_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  				_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  			}  		}  		if (len == 1)  			_state.UpdateShortRep ();  		else {  			_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  			_state.UpdateRep ();  		}  		UInt32 distance = _repDistances [pos];  		if (pos != 0) {  			for (UInt32 i = pos; i >= 1; i--)  				_repDistances [i] = _repDistances [i - 1];  			_repDistances [0] = distance;  		}  	}  	else {  		_isRep [_state.Index].Encode (_rangeEncoder' 0);  		_state.UpdateMatch ();  		_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  		pos -= Base.kNumRepDistances;  		UInt32 posSlot = GetPosSlot (pos);  		UInt32 lenToPosState = Base.GetLenToPosState (len);  		_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  		if (posSlot >= Base.kStartPosModelIndex) {  			int footerBits = (int)((posSlot >> 1) - 1);  			UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  			UInt32 posReduced = pos - baseVal;  			if (posSlot < Base.kEndPosModelIndex)  				RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  			else {  				_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  				_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  				_alignPriceCount++;  			}  		}  		UInt32 distance = pos;  		for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  			_repDistances [i] = _repDistances [i - 1];  		_repDistances [0] = distance;  		_matchPriceCount++;  	}  	_previousByte = _matchFinder.GetIndexByte ((Int32)(len - 1 - _additionalOffset));  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (len == 1 && pos == 0xFFFFFFFF) {  	_isMatch [complexState].Encode (_rangeEncoder' 0);  	Byte curByte = _matchFinder.GetIndexByte ((Int32)(0 - _additionalOffset));  	LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder ((UInt32)nowPos64' _previousByte);  	if (!_state.IsCharState ()) {  		Byte matchByte = _matchFinder.GetIndexByte ((Int32)(0 - _repDistances [0] - 1 - _additionalOffset));  		subCoder.EncodeMatched (_rangeEncoder' matchByte' curByte);  	}  	else  		subCoder.Encode (_rangeEncoder' curByte);  	_previousByte = curByte;  	_state.UpdateChar ();  }  else {  	_isMatch [complexState].Encode (_rangeEncoder' 1);  	if (pos < Base.kNumRepDistances) {  		_isRep [_state.Index].Encode (_rangeEncoder' 1);  		if (pos == 0) {  			_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  			if (len == 1)  				_isRep0Long [complexState].Encode (_rangeEncoder' 0);  			else  				_isRep0Long [complexState].Encode (_rangeEncoder' 1);  		}  		else {  			_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  			if (pos == 1)  				_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  			else {  				_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  				_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  			}  		}  		if (len == 1)  			_state.UpdateShortRep ();  		else {  			_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  			_state.UpdateRep ();  		}  		UInt32 distance = _repDistances [pos];  		if (pos != 0) {  			for (UInt32 i = pos; i >= 1; i--)  				_repDistances [i] = _repDistances [i - 1];  			_repDistances [0] = distance;  		}  	}  	else {  		_isRep [_state.Index].Encode (_rangeEncoder' 0);  		_state.UpdateMatch ();  		_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  		pos -= Base.kNumRepDistances;  		UInt32 posSlot = GetPosSlot (pos);  		UInt32 lenToPosState = Base.GetLenToPosState (len);  		_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  		if (posSlot >= Base.kStartPosModelIndex) {  			int footerBits = (int)((posSlot >> 1) - 1);  			UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  			UInt32 posReduced = pos - baseVal;  			if (posSlot < Base.kEndPosModelIndex)  				RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  			else {  				_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  				_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  				_alignPriceCount++;  			}  		}  		UInt32 distance = pos;  		for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  			_repDistances [i] = _repDistances [i - 1];  		_repDistances [0] = distance;  		_matchPriceCount++;  	}  	_previousByte = _matchFinder.GetIndexByte ((Int32)(len - 1 - _additionalOffset));  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	_isRep [_state.Index].Encode (_rangeEncoder' 1);  	if (pos == 0) {  		_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  		if (len == 1)  			_isRep0Long [complexState].Encode (_rangeEncoder' 0);  		else  			_isRep0Long [complexState].Encode (_rangeEncoder' 1);  	}  	else {  		_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  		if (pos == 1)  			_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  		else {  			_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  			_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  		}  	}  	if (len == 1)  		_state.UpdateShortRep ();  	else {  		_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  		_state.UpdateRep ();  	}  	UInt32 distance = _repDistances [pos];  	if (pos != 0) {  		for (UInt32 i = pos; i >= 1; i--)  			_repDistances [i] = _repDistances [i - 1];  		_repDistances [0] = distance;  	}  }  else {  	_isRep [_state.Index].Encode (_rangeEncoder' 0);  	_state.UpdateMatch ();  	_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  	pos -= Base.kNumRepDistances;  	UInt32 posSlot = GetPosSlot (pos);  	UInt32 lenToPosState = Base.GetLenToPosState (len);  	_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  	if (posSlot >= Base.kStartPosModelIndex) {  		int footerBits = (int)((posSlot >> 1) - 1);  		UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  		UInt32 posReduced = pos - baseVal;  		if (posSlot < Base.kEndPosModelIndex)  			RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  		else {  			_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  			_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  			_alignPriceCount++;  		}  	}  	UInt32 distance = pos;  	for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  		_repDistances [i] = _repDistances [i - 1];  	_repDistances [0] = distance;  	_matchPriceCount++;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (pos < Base.kNumRepDistances) {  	_isRep [_state.Index].Encode (_rangeEncoder' 1);  	if (pos == 0) {  		_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  		if (len == 1)  			_isRep0Long [complexState].Encode (_rangeEncoder' 0);  		else  			_isRep0Long [complexState].Encode (_rangeEncoder' 1);  	}  	else {  		_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  		if (pos == 1)  			_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  		else {  			_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  			_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  		}  	}  	if (len == 1)  		_state.UpdateShortRep ();  	else {  		_repMatchLenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  		_state.UpdateRep ();  	}  	UInt32 distance = _repDistances [pos];  	if (pos != 0) {  		for (UInt32 i = pos; i >= 1; i--)  			_repDistances [i] = _repDistances [i - 1];  		_repDistances [0] = distance;  	}  }  else {  	_isRep [_state.Index].Encode (_rangeEncoder' 0);  	_state.UpdateMatch ();  	_lenEncoder.Encode (_rangeEncoder' len - Base.kMatchMinLen' posState);  	pos -= Base.kNumRepDistances;  	UInt32 posSlot = GetPosSlot (pos);  	UInt32 lenToPosState = Base.GetLenToPosState (len);  	_posSlotEncoder [lenToPosState].Encode (_rangeEncoder' posSlot);  	if (posSlot >= Base.kStartPosModelIndex) {  		int footerBits = (int)((posSlot >> 1) - 1);  		UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  		UInt32 posReduced = pos - baseVal;  		if (posSlot < Base.kEndPosModelIndex)  			RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  		else {  			_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  			_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  			_alignPriceCount++;  		}  	}  	UInt32 distance = pos;  	for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  		_repDistances [i] = _repDistances [i - 1];  	_repDistances [0] = distance;  	_matchPriceCount++;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (pos == 0) {  	_isRepG0 [_state.Index].Encode (_rangeEncoder' 0);  	if (len == 1)  		_isRep0Long [complexState].Encode (_rangeEncoder' 0);  	else  		_isRep0Long [complexState].Encode (_rangeEncoder' 1);  }  else {  	_isRepG0 [_state.Index].Encode (_rangeEncoder' 1);  	if (pos == 1)  		_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  	else {  		_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  		_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (pos == 1)  	_isRepG1 [_state.Index].Encode (_rangeEncoder' 0);  else {  	_isRepG1 [_state.Index].Encode (_rangeEncoder' 1);  	_isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: _isRepG2 [_state.Index].Encode (_rangeEncoder' pos - 2);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (posSlot >= Base.kStartPosModelIndex) {  	int footerBits = (int)((posSlot >> 1) - 1);  	UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  	UInt32 posReduced = pos - baseVal;  	if (posSlot < Base.kEndPosModelIndex)  		RangeCoder.BitTreeEncoder.ReverseEncode (_posEncoders' baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  	else {  		_rangeEncoder.EncodeDirectBits (posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  		_posAlignEncoder.ReverseEncode (_rangeEncoder' posReduced & Base.kAlignMask);  		_alignPriceCount++;  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (_additionalOffset == 0) {  	// if (!_fastMode)  	if (_matchPriceCount >= (1 << 7))  		FillDistancesPrices ();  	if (_alignPriceCount >= Base.kAlignTableSize)  		FillAlignPrices ();  	inSize = nowPos64;  	outSize = _rangeEncoder.GetProcessedSizeAdd ();  	if (_matchFinder.GetNumAvailableBytes () == 0) {  		Flush ((UInt32)nowPos64);  		return;  	}  	if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  		_finished = false;  		finished = false;  		return;  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (_additionalOffset == 0) {  	// if (!_fastMode)  	if (_matchPriceCount >= (1 << 7))  		FillDistancesPrices ();  	if (_alignPriceCount >= Base.kAlignTableSize)  		FillAlignPrices ();  	inSize = nowPos64;  	outSize = _rangeEncoder.GetProcessedSizeAdd ();  	if (_matchFinder.GetNumAvailableBytes () == 0) {  		Flush ((UInt32)nowPos64);  		return;  	}  	if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  		_finished = false;  		finished = false;  		return;  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (_matchPriceCount >= (1 << 7))  	FillDistancesPrices ();  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  	_finished = false;  	finished = false;  	return;  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties [0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties [0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	properties [1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	properties [1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties [1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,FillDistancesPrices,The following statement contains a magic number: for (UInt32 i = Base.kStartPosModelIndex; i < Base.kNumFullDistances; i++) {  	UInt32 posSlot = GetPosSlot (i);  	int footerBits = (int)((posSlot >> 1) - 1);  	UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  	tempPrices [i] = BitTreeEncoder.ReverseGetPrice (_posEncoders' baseVal - posSlot - 1' footerBits' i - baseVal);  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++) {  	object prop = properties [i];  	switch (propIDs [i]) {  	case CoderPropID.NumFastBytes: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 numFastBytes = (Int32)prop;  		if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  			throw new InvalidParamException ();  		_numFastBytes = (UInt32)numFastBytes;  		break;  	}  	case CoderPropID.Algorithm: {  		/* 						if (!(prop is Int32)) 							throw new InvalidParamException(); 						Int32 maximize = (Int32)prop; 						_fastMode = (maximize == 0); 						_maxMode = (maximize >= 2); 						*/break;  	}  	case CoderPropID.MatchFinder: {  		if (!(prop is String))  			throw new InvalidParamException ();  		EMatchFinderType matchFinderIndexPrev = _matchFinderType;  		int m = FindMatchFinder (((string)prop).ToUpper ());  		if (m < 0)  			throw new InvalidParamException ();  		_matchFinderType = (EMatchFinderType)m;  		if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  			_dictionarySizePrev = 0xFFFFFFFF;  			_matchFinder = null;  		}  		break;  	}  	case CoderPropID.DictionarySize: {  		const int kDicLogSizeMaxCompress = 30;  		if (!(prop is Int32))  			throw new InvalidParamException ();  		;  		Int32 dictionarySize = (Int32)prop;  		if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) || dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  			throw new InvalidParamException ();  		_dictionarySize = (UInt32)dictionarySize;  		int dicLogSize;  		for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  			if (dictionarySize <= ((UInt32)(1) << dicLogSize))  				break;  		_distTableSize = (UInt32)dicLogSize * 2;  		break;  	}  	case CoderPropID.PosStateBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  			throw new InvalidParamException ();  		_posStateBits = (int)v;  		_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  		break;  	}  	case CoderPropID.LitPosBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  			throw new InvalidParamException ();  		_numLiteralPosStateBits = (int)v;  		break;  	}  	case CoderPropID.LitContextBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  			throw new InvalidParamException ();  		;  		_numLiteralContextBits = (int)v;  		break;  	}  	case CoderPropID.EndMarker: {  		if (!(prop is Boolean))  			throw new InvalidParamException ();  		SetWriteEndMarkerMode ((Boolean)prop);  		break;  	}  	default:  		throw new InvalidParamException ();  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++) {  	object prop = properties [i];  	switch (propIDs [i]) {  	case CoderPropID.NumFastBytes: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 numFastBytes = (Int32)prop;  		if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  			throw new InvalidParamException ();  		_numFastBytes = (UInt32)numFastBytes;  		break;  	}  	case CoderPropID.Algorithm: {  		/* 						if (!(prop is Int32)) 							throw new InvalidParamException(); 						Int32 maximize = (Int32)prop; 						_fastMode = (maximize == 0); 						_maxMode = (maximize >= 2); 						*/break;  	}  	case CoderPropID.MatchFinder: {  		if (!(prop is String))  			throw new InvalidParamException ();  		EMatchFinderType matchFinderIndexPrev = _matchFinderType;  		int m = FindMatchFinder (((string)prop).ToUpper ());  		if (m < 0)  			throw new InvalidParamException ();  		_matchFinderType = (EMatchFinderType)m;  		if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  			_dictionarySizePrev = 0xFFFFFFFF;  			_matchFinder = null;  		}  		break;  	}  	case CoderPropID.DictionarySize: {  		const int kDicLogSizeMaxCompress = 30;  		if (!(prop is Int32))  			throw new InvalidParamException ();  		;  		Int32 dictionarySize = (Int32)prop;  		if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) || dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  			throw new InvalidParamException ();  		_dictionarySize = (UInt32)dictionarySize;  		int dicLogSize;  		for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  			if (dictionarySize <= ((UInt32)(1) << dicLogSize))  				break;  		_distTableSize = (UInt32)dicLogSize * 2;  		break;  	}  	case CoderPropID.PosStateBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  			throw new InvalidParamException ();  		_posStateBits = (int)v;  		_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  		break;  	}  	case CoderPropID.LitPosBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  			throw new InvalidParamException ();  		_numLiteralPosStateBits = (int)v;  		break;  	}  	case CoderPropID.LitContextBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  			throw new InvalidParamException ();  		;  		_numLiteralContextBits = (int)v;  		break;  	}  	case CoderPropID.EndMarker: {  		if (!(prop is Boolean))  			throw new InvalidParamException ();  		SetWriteEndMarkerMode ((Boolean)prop);  		break;  	}  	default:  		throw new InvalidParamException ();  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++) {  	object prop = properties [i];  	switch (propIDs [i]) {  	case CoderPropID.NumFastBytes: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 numFastBytes = (Int32)prop;  		if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  			throw new InvalidParamException ();  		_numFastBytes = (UInt32)numFastBytes;  		break;  	}  	case CoderPropID.Algorithm: {  		/* 						if (!(prop is Int32)) 							throw new InvalidParamException(); 						Int32 maximize = (Int32)prop; 						_fastMode = (maximize == 0); 						_maxMode = (maximize >= 2); 						*/break;  	}  	case CoderPropID.MatchFinder: {  		if (!(prop is String))  			throw new InvalidParamException ();  		EMatchFinderType matchFinderIndexPrev = _matchFinderType;  		int m = FindMatchFinder (((string)prop).ToUpper ());  		if (m < 0)  			throw new InvalidParamException ();  		_matchFinderType = (EMatchFinderType)m;  		if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  			_dictionarySizePrev = 0xFFFFFFFF;  			_matchFinder = null;  		}  		break;  	}  	case CoderPropID.DictionarySize: {  		const int kDicLogSizeMaxCompress = 30;  		if (!(prop is Int32))  			throw new InvalidParamException ();  		;  		Int32 dictionarySize = (Int32)prop;  		if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) || dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  			throw new InvalidParamException ();  		_dictionarySize = (UInt32)dictionarySize;  		int dicLogSize;  		for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  			if (dictionarySize <= ((UInt32)(1) << dicLogSize))  				break;  		_distTableSize = (UInt32)dicLogSize * 2;  		break;  	}  	case CoderPropID.PosStateBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  			throw new InvalidParamException ();  		_posStateBits = (int)v;  		_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  		break;  	}  	case CoderPropID.LitPosBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  			throw new InvalidParamException ();  		_numLiteralPosStateBits = (int)v;  		break;  	}  	case CoderPropID.LitContextBits: {  		if (!(prop is Int32))  			throw new InvalidParamException ();  		Int32 v = (Int32)prop;  		if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  			throw new InvalidParamException ();  		;  		_numLiteralContextBits = (int)v;  		break;  	}  	case CoderPropID.EndMarker: {  		if (!(prop is Boolean))  			throw new InvalidParamException ();  		SetWriteEndMarkerMode ((Boolean)prop);  		break;  	}  	default:  		throw new InvalidParamException ();  	}  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs [i]) {  case CoderPropID.NumFastBytes: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 numFastBytes = (Int32)prop;  	if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  		throw new InvalidParamException ();  	_numFastBytes = (UInt32)numFastBytes;  	break;  }  case CoderPropID.Algorithm: {  	/* 						if (!(prop is Int32)) 							throw new InvalidParamException(); 						Int32 maximize = (Int32)prop; 						_fastMode = (maximize == 0); 						_maxMode = (maximize >= 2); 						*/break;  }  case CoderPropID.MatchFinder: {  	if (!(prop is String))  		throw new InvalidParamException ();  	EMatchFinderType matchFinderIndexPrev = _matchFinderType;  	int m = FindMatchFinder (((string)prop).ToUpper ());  	if (m < 0)  		throw new InvalidParamException ();  	_matchFinderType = (EMatchFinderType)m;  	if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  		_dictionarySizePrev = 0xFFFFFFFF;  		_matchFinder = null;  	}  	break;  }  case CoderPropID.DictionarySize: {  	const int kDicLogSizeMaxCompress = 30;  	if (!(prop is Int32))  		throw new InvalidParamException ();  	;  	Int32 dictionarySize = (Int32)prop;  	if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) || dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  		throw new InvalidParamException ();  	_dictionarySize = (UInt32)dictionarySize;  	int dicLogSize;  	for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  		if (dictionarySize <= ((UInt32)(1) << dicLogSize))  			break;  	_distTableSize = (UInt32)dicLogSize * 2;  	break;  }  case CoderPropID.PosStateBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  		throw new InvalidParamException ();  	_posStateBits = (int)v;  	_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  	break;  }  case CoderPropID.LitPosBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  		throw new InvalidParamException ();  	_numLiteralPosStateBits = (int)v;  	break;  }  case CoderPropID.LitContextBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  		throw new InvalidParamException ();  	;  	_numLiteralContextBits = (int)v;  	break;  }  case CoderPropID.EndMarker: {  	if (!(prop is Boolean))  		throw new InvalidParamException ();  	SetWriteEndMarkerMode ((Boolean)prop);  	break;  }  default:  	throw new InvalidParamException ();  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs [i]) {  case CoderPropID.NumFastBytes: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 numFastBytes = (Int32)prop;  	if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  		throw new InvalidParamException ();  	_numFastBytes = (UInt32)numFastBytes;  	break;  }  case CoderPropID.Algorithm: {  	/* 						if (!(prop is Int32)) 							throw new InvalidParamException(); 						Int32 maximize = (Int32)prop; 						_fastMode = (maximize == 0); 						_maxMode = (maximize >= 2); 						*/break;  }  case CoderPropID.MatchFinder: {  	if (!(prop is String))  		throw new InvalidParamException ();  	EMatchFinderType matchFinderIndexPrev = _matchFinderType;  	int m = FindMatchFinder (((string)prop).ToUpper ());  	if (m < 0)  		throw new InvalidParamException ();  	_matchFinderType = (EMatchFinderType)m;  	if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  		_dictionarySizePrev = 0xFFFFFFFF;  		_matchFinder = null;  	}  	break;  }  case CoderPropID.DictionarySize: {  	const int kDicLogSizeMaxCompress = 30;  	if (!(prop is Int32))  		throw new InvalidParamException ();  	;  	Int32 dictionarySize = (Int32)prop;  	if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) || dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  		throw new InvalidParamException ();  	_dictionarySize = (UInt32)dictionarySize;  	int dicLogSize;  	for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  		if (dictionarySize <= ((UInt32)(1) << dicLogSize))  			break;  	_distTableSize = (UInt32)dicLogSize * 2;  	break;  }  case CoderPropID.PosStateBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  		throw new InvalidParamException ();  	_posStateBits = (int)v;  	_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  	break;  }  case CoderPropID.LitPosBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  		throw new InvalidParamException ();  	_numLiteralPosStateBits = (int)v;  	break;  }  case CoderPropID.LitContextBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  		throw new InvalidParamException ();  	;  	_numLiteralContextBits = (int)v;  	break;  }  case CoderPropID.EndMarker: {  	if (!(prop is Boolean))  		throw new InvalidParamException ();  	SetWriteEndMarkerMode ((Boolean)prop);  	break;  }  default:  	throw new InvalidParamException ();  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs [i]) {  case CoderPropID.NumFastBytes: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 numFastBytes = (Int32)prop;  	if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  		throw new InvalidParamException ();  	_numFastBytes = (UInt32)numFastBytes;  	break;  }  case CoderPropID.Algorithm: {  	/* 						if (!(prop is Int32)) 							throw new InvalidParamException(); 						Int32 maximize = (Int32)prop; 						_fastMode = (maximize == 0); 						_maxMode = (maximize >= 2); 						*/break;  }  case CoderPropID.MatchFinder: {  	if (!(prop is String))  		throw new InvalidParamException ();  	EMatchFinderType matchFinderIndexPrev = _matchFinderType;  	int m = FindMatchFinder (((string)prop).ToUpper ());  	if (m < 0)  		throw new InvalidParamException ();  	_matchFinderType = (EMatchFinderType)m;  	if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  		_dictionarySizePrev = 0xFFFFFFFF;  		_matchFinder = null;  	}  	break;  }  case CoderPropID.DictionarySize: {  	const int kDicLogSizeMaxCompress = 30;  	if (!(prop is Int32))  		throw new InvalidParamException ();  	;  	Int32 dictionarySize = (Int32)prop;  	if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) || dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  		throw new InvalidParamException ();  	_dictionarySize = (UInt32)dictionarySize;  	int dicLogSize;  	for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  		if (dictionarySize <= ((UInt32)(1) << dicLogSize))  			break;  	_distTableSize = (UInt32)dicLogSize * 2;  	break;  }  case CoderPropID.PosStateBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  		throw new InvalidParamException ();  	_posStateBits = (int)v;  	_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  	break;  }  case CoderPropID.LitPosBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  		throw new InvalidParamException ();  	_numLiteralPosStateBits = (int)v;  	break;  }  case CoderPropID.LitContextBits: {  	if (!(prop is Int32))  		throw new InvalidParamException ();  	Int32 v = (Int32)prop;  	if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  		throw new InvalidParamException ();  	;  	_numLiteralContextBits = (int)v;  	break;  }  case CoderPropID.EndMarker: {  	if (!(prop is Boolean))  		throw new InvalidParamException ();  	SetWriteEndMarkerMode ((Boolean)prop);  	break;  }  default:  	throw new InvalidParamException ();  }  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  	throw new InvalidParamException ();  
Magic Number,SevenZipRadical.Compression.LZMA,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: _distTableSize = (UInt32)dicLogSize * 2;  
Magic Number,SevenZipRadical.Compression.LZMA,SevenZipRadicalHelper,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\SevenZipHelper.cs,Compress,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	outStream.WriteByte ((Byte)(fileSize >> (8 * i)));  
Magic Number,SevenZipRadical.Compression.LZMA,SevenZipRadicalHelper,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\SevenZipHelper.cs,Compress,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	outStream.WriteByte ((Byte)(fileSize >> (8 * i)));  
Magic Number,SevenZipRadical.Compression.LZMA,SevenZipRadicalHelper,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\SevenZipHelper.cs,Compress,The following statement contains a magic number: outStream.WriteByte ((Byte)(fileSize >> (8 * i)));  
Magic Number,SevenZipRadical.Compression.LZMA,SevenZipRadicalHelper,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\SevenZipHelper.cs,Decompress,The following statement contains a magic number: if (newInStream.Read (properties2' 0' 5) != 5)  	throw (new Exception ("input .lzma is too short"));  
Magic Number,SevenZipRadical.Compression.LZMA,SevenZipRadicalHelper,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\SevenZipHelper.cs,Decompress,The following statement contains a magic number: if (newInStream.Read (properties2' 0' 5) != 5)  	throw (new Exception ("input .lzma is too short"));  
Magic Number,SevenZipRadical.Compression.LZMA,SevenZipRadicalHelper,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\SevenZipHelper.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int v = newInStream.ReadByte ();  	if (v < 0)  		throw (new Exception ("Can't Read 1"));  	outSize |= ((long)(byte)v) << (8 * i);  }  
Magic Number,SevenZipRadical.Compression.LZMA,SevenZipRadicalHelper,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\SevenZipHelper.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int v = newInStream.ReadByte ();  	if (v < 0)  		throw (new Exception ("Can't Read 1"));  	outSize |= ((long)(byte)v) << (8 * i);  }  
Magic Number,SevenZipRadical.Compression.LZMA,SevenZipRadicalHelper,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\SevenZipHelper.cs,Decompress,The following statement contains a magic number: outSize |= ((long)(byte)v) << (8 * i);  
Magic Number,SevenZipRadical.Compression.RangeCoder,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,FlushData,The following statement contains a magic number: for (int i = 0; i < 5; i++)  	ShiftLow ();  
Magic Number,SevenZipRadical.Compression.RangeCoder,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,Encode,The following statement contains a magic number: while (Range < kTopValue) {  	Range <<= 8;  	ShiftLow ();  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,Encode,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZipRadical.Compression.RangeCoder,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1) {  	byte temp = _cache;  	do {  		Stream.WriteByte ((byte)(temp + (Low >> 32)));  		temp = 0xFF;  	}  	while (--_cacheSize != 0);  	_cache = (byte)(((uint)Low) >> 24);  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1) {  	byte temp = _cache;  	do {  		Stream.WriteByte ((byte)(temp + (Low >> 32)));  		temp = 0xFF;  	}  	while (--_cacheSize != 0);  	_cache = (byte)(((uint)Low) >> 24);  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1) {  	byte temp = _cache;  	do {  		Stream.WriteByte ((byte)(temp + (Low >> 32)));  		temp = 0xFF;  	}  	while (--_cacheSize != 0);  	_cache = (byte)(((uint)Low) >> 24);  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: do {  	Stream.WriteByte ((byte)(temp + (Low >> 32)));  	temp = 0xFF;  }  while (--_cacheSize != 0);  
Magic Number,SevenZipRadical.Compression.RangeCoder,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Stream.WriteByte ((byte)(temp + (Low >> 32)));  
Magic Number,SevenZipRadical.Compression.RangeCoder,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: _cache = (byte)(((uint)Low) >> 24);  
Magic Number,SevenZipRadical.Compression.RangeCoder,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Low = ((uint)Low) << 8;  
Magic Number,SevenZipRadical.Compression.RangeCoder,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits - 1; i >= 0; i--) {  	Range >>= 1;  	if (((v >> i) & 1) == 1)  		Low += Range;  	if (Range < kTopValue) {  		Range <<= 8;  		ShiftLow ();  	}  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: if (Range < kTopValue) {  	Range <<= 8;  	ShiftLow ();  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZipRadical.Compression.RangeCoder,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,EncodeBit,The following statement contains a magic number: while (Range < kTopValue) {  	Range <<= 8;  	ShiftLow ();  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,EncodeBit,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZipRadical.Compression.RangeCoder,Encoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,GetProcessedSizeAdd,The following statement contains a magic number: return _cacheSize + Stream.Position - StartPosition + 4;  
Magic Number,SevenZipRadical.Compression.RangeCoder,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  	Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZipRadical.Compression.RangeCoder,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  	Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZipRadical.Compression.RangeCoder,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZipRadical.Compression.RangeCoder,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZipRadical.Compression.RangeCoder,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZipRadical.Compression.RangeCoder,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue) {  	Code = (Code << 8) | (byte)Stream.ReadByte ();  	Range <<= 8;  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZipRadical.Compression.RangeCoder,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: Range <<= 8;  
Magic Number,SevenZipRadical.Compression.RangeCoder,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  	range >>= 1;  	/* 				result <<= 1; 				if (code >= range) 				{ 					code -= range; 					result |= 1; 				} 				*/uint t = (code - range) >> 31;  	code -= range & (t - 1);  	result = (result << 1) | (1 - t);  	if (range < kTopValue) {  		code = (code << 8) | (byte)Stream.ReadByte ();  		range <<= 8;  	}  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  	range >>= 1;  	/* 				result <<= 1; 				if (code >= range) 				{ 					code -= range; 					result |= 1; 				} 				*/uint t = (code - range) >> 31;  	code -= range & (t - 1);  	result = (result << 1) | (1 - t);  	if (range < kTopValue) {  		code = (code << 8) | (byte)Stream.ReadByte ();  		range <<= 8;  	}  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  	range >>= 1;  	/* 				result <<= 1; 				if (code >= range) 				{ 					code -= range; 					result |= 1; 				} 				*/uint t = (code - range) >> 31;  	code -= range & (t - 1);  	result = (result << 1) | (1 - t);  	if (range < kTopValue) {  		code = (code << 8) | (byte)Stream.ReadByte ();  		range <<= 8;  	}  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: if (range < kTopValue) {  	code = (code << 8) | (byte)Stream.ReadByte ();  	range <<= 8;  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: if (range < kTopValue) {  	code = (code << 8) | (byte)Stream.ReadByte ();  	range <<= 8;  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: code = (code << 8) | (byte)Stream.ReadByte ();  
Magic Number,SevenZipRadical.Compression.RangeCoder,Decoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: range <<= 8;  
Magic Number,SevenZipRadical.Compression.RangeCoder,BitEncoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoderBit.cs,Encode,The following statement contains a magic number: if (encoder.Range < Encoder.kTopValue) {  	encoder.Range <<= 8;  	encoder.ShiftLow ();  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,BitEncoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoderBit.cs,Encode,The following statement contains a magic number: encoder.Range <<= 8;  
Magic Number,SevenZipRadical.Compression.RangeCoder,BitDecoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  }  else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,BitDecoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  }  else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,BitDecoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  }  else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,BitDecoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  	rangeDecoder.Range = newBound;  	Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 0;  }  else {  	rangeDecoder.Range -= newBound;  	rangeDecoder.Code -= newBound;  	Prob -= (Prob) >> kNumMoveBits;  	if (rangeDecoder.Range < Decoder.kTopValue) {  		rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  		rangeDecoder.Range <<= 8;  	}  	return 1;  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,BitDecoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,BitDecoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,BitDecoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  
Magic Number,SevenZipRadical.Compression.RangeCoder,BitDecoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Range <<= 8;  
Magic Number,SevenZipRadical.Compression.RangeCoder,BitDecoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,BitDecoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  	rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  	rangeDecoder.Range <<= 8;  }  
Magic Number,SevenZipRadical.Compression.RangeCoder,BitDecoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte ();  
Magic Number,SevenZipRadical.Compression.RangeCoder,BitDecoder,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\7zip\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Range <<= 8;  
Magic Number,LitJson,JsonMapper,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonMapper.cs,JsonMapper,The following statement contains a magic number: max_nesting_depth = 100;  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,Init,The following statement contains a magic number: hex_seq = new char[4];  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,Init,The following statement contains a magic number: indent_value = 4;  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,IntToHex,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	num = n % 16;  	if (num < 10)  		hex [3 - i] = (char)('0' + num);  	else  		hex [3 - i] = (char)('A' + (num - 10));  	n >>= 4;  }  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,IntToHex,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	num = n % 16;  	if (num < 10)  		hex [3 - i] = (char)('0' + num);  	else  		hex [3 - i] = (char)('A' + (num - 10));  	n >>= 4;  }  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,IntToHex,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	num = n % 16;  	if (num < 10)  		hex [3 - i] = (char)('0' + num);  	else  		hex [3 - i] = (char)('A' + (num - 10));  	n >>= 4;  }  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,IntToHex,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	num = n % 16;  	if (num < 10)  		hex [3 - i] = (char)('0' + num);  	else  		hex [3 - i] = (char)('A' + (num - 10));  	n >>= 4;  }  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,IntToHex,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	num = n % 16;  	if (num < 10)  		hex [3 - i] = (char)('0' + num);  	else  		hex [3 - i] = (char)('A' + (num - 10));  	n >>= 4;  }  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,IntToHex,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	num = n % 16;  	if (num < 10)  		hex [3 - i] = (char)('0' + num);  	else  		hex [3 - i] = (char)('A' + (num - 10));  	n >>= 4;  }  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,IntToHex,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	num = n % 16;  	if (num < 10)  		hex [3 - i] = (char)('0' + num);  	else  		hex [3 - i] = (char)('A' + (num - 10));  	n >>= 4;  }  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,IntToHex,The following statement contains a magic number: num = n % 16;  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,IntToHex,The following statement contains a magic number: if (num < 10)  	hex [3 - i] = (char)('0' + num);  else  	hex [3 - i] = (char)('A' + (num - 10));  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,IntToHex,The following statement contains a magic number: if (num < 10)  	hex [3 - i] = (char)('0' + num);  else  	hex [3 - i] = (char)('A' + (num - 10));  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,IntToHex,The following statement contains a magic number: if (num < 10)  	hex [3 - i] = (char)('0' + num);  else  	hex [3 - i] = (char)('A' + (num - 10));  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,IntToHex,The following statement contains a magic number: if (num < 10)  	hex [3 - i] = (char)('0' + num);  else  	hex [3 - i] = (char)('A' + (num - 10));  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,IntToHex,The following statement contains a magic number: hex [3 - i] = (char)('0' + num);  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,IntToHex,The following statement contains a magic number: hex [3 - i] = (char)('A' + (num - 10));  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,IntToHex,The following statement contains a magic number: hex [3 - i] = (char)('A' + (num - 10));  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,IntToHex,The following statement contains a magic number: n >>= 4;  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,PutString,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	switch (str [i]) {  	case '\n':  		writer.Write ("\\n");  		continue;  	case '\r':  		writer.Write ("\\r");  		continue;  	case '\t':  		writer.Write ("\\t");  		continue;  	case '"':  	case '\\':  		writer.Write ('\\');  		writer.Write (str [i]);  		continue;  	case '\f':  		writer.Write ("\\f");  		continue;  	case '\b':  		writer.Write ("\\b");  		continue;  	}  	if ((int)str [i] >= 32 && (int)str [i] <= 126) {  		writer.Write (str [i]);  		continue;  	}  	// Default' turn into a \uXXXX sequence  	IntToHex ((int)str [i]' hex_seq);  	writer.Write ("\\u");  	writer.Write (hex_seq);  }  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,PutString,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	switch (str [i]) {  	case '\n':  		writer.Write ("\\n");  		continue;  	case '\r':  		writer.Write ("\\r");  		continue;  	case '\t':  		writer.Write ("\\t");  		continue;  	case '"':  	case '\\':  		writer.Write ('\\');  		writer.Write (str [i]);  		continue;  	case '\f':  		writer.Write ("\\f");  		continue;  	case '\b':  		writer.Write ("\\b");  		continue;  	}  	if ((int)str [i] >= 32 && (int)str [i] <= 126) {  		writer.Write (str [i]);  		continue;  	}  	// Default' turn into a \uXXXX sequence  	IntToHex ((int)str [i]' hex_seq);  	writer.Write ("\\u");  	writer.Write (hex_seq);  }  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,PutString,The following statement contains a magic number: if ((int)str [i] >= 32 && (int)str [i] <= 126) {  	writer.Write (str [i]);  	continue;  }  
Magic Number,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,PutString,The following statement contains a magic number: if ((int)str [i] >= 32 && (int)str [i] <= 126) {  	writer.Write (str [i]);  	continue;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,Lexer,The following statement contains a magic number: string_buffer = new StringBuilder (128);  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,HexValue,The following statement contains a magic number: switch (digit) {  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	return digit - '0';  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,HexValue,The following statement contains a magic number: switch (digit) {  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	return digit - '0';  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,HexValue,The following statement contains a magic number: switch (digit) {  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	return digit - '0';  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,HexValue,The following statement contains a magic number: switch (digit) {  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	return digit - '0';  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,HexValue,The following statement contains a magic number: switch (digit) {  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	return digit - '0';  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,HexValue,The following statement contains a magic number: switch (digit) {  case 'a':  case 'A':  	return 10;  case 'b':  case 'B':  	return 11;  case 'c':  case 'C':  	return 12;  case 'd':  case 'D':  	return 13;  case 'e':  case 'E':  	return 14;  case 'f':  case 'F':  	return 15;  default:  	return digit - '0';  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,HexValue,The following statement contains a magic number: return 10;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,HexValue,The following statement contains a magic number: return 11;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,HexValue,The following statement contains a magic number: return 12;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,HexValue,The following statement contains a magic number: return 13;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,HexValue,The following statement contains a magic number: return 14;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,HexValue,The following statement contains a magic number: return 15;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,PopulateFsmTables,The following statement contains a magic number: fsm_handler_table = new StateHandler[28] {  	State1'  	State2'  	State3'  	State4'  	State5'  	State6'  	State7'  	State8'  	State9'  	State10'  	State11'  	State12'  	State13'  	State14'  	State15'  	State16'  	State17'  	State18'  	State19'  	State20'  	State21'  	State22'  	State23'  	State24'  	State25'  	State26'  	State27'  	State28  };  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,PopulateFsmTables,The following statement contains a magic number: fsm_return_table = new int[28] {  	(int)ParserToken.Char'  	0'  	(int)ParserToken.Number'  	(int)ParserToken.Number'  	0'  	(int)ParserToken.Number'  	0'  	(int)ParserToken.Number'  	0'  	0'  	(int)ParserToken.True'  	0'  	0'  	0'  	(int)ParserToken.False'  	0'  	0'  	(int)ParserToken.Null'  	(int)ParserToken.CharSeq'  	(int)ParserToken.Char'  	0'  	0'  	(int)ParserToken.CharSeq'  	(int)ParserToken.Char'  	0'  	0'  	0'  	0  };  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	if (ctx.L.input_char == ' ' || ctx.L.input_char >= '\t' && ctx.L.input_char <= '\r')  		continue;  	if (ctx.L.input_char >= '1' && ctx.L.input_char <= '9') {  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 3;  		return true;  	}  	switch (ctx.L.input_char) {  	case '"':  		ctx.NextState = 19;  		ctx.Return = true;  		return true;  	case ''':  	case ':':  	case '[':  	case ']':  	case '{':  	case '}':  		ctx.NextState = 1;  		ctx.Return = true;  		return true;  	case '-':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 2;  		return true;  	case '0':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 4;  		return true;  	case 'f':  		ctx.NextState = 12;  		return true;  	case 'n':  		ctx.NextState = 16;  		return true;  	case 't':  		ctx.NextState = 9;  		return true;  	case '\'':  		if (!ctx.L.allow_single_quoted_strings)  			return false;  		ctx.L.input_char = '"';  		ctx.NextState = 23;  		ctx.Return = true;  		return true;  	case '/':  		if (!ctx.L.allow_comments)  			return false;  		ctx.NextState = 25;  		return true;  	default:  		return false;  	}  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	if (ctx.L.input_char == ' ' || ctx.L.input_char >= '\t' && ctx.L.input_char <= '\r')  		continue;  	if (ctx.L.input_char >= '1' && ctx.L.input_char <= '9') {  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 3;  		return true;  	}  	switch (ctx.L.input_char) {  	case '"':  		ctx.NextState = 19;  		ctx.Return = true;  		return true;  	case ''':  	case ':':  	case '[':  	case ']':  	case '{':  	case '}':  		ctx.NextState = 1;  		ctx.Return = true;  		return true;  	case '-':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 2;  		return true;  	case '0':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 4;  		return true;  	case 'f':  		ctx.NextState = 12;  		return true;  	case 'n':  		ctx.NextState = 16;  		return true;  	case 't':  		ctx.NextState = 9;  		return true;  	case '\'':  		if (!ctx.L.allow_single_quoted_strings)  			return false;  		ctx.L.input_char = '"';  		ctx.NextState = 23;  		ctx.Return = true;  		return true;  	case '/':  		if (!ctx.L.allow_comments)  			return false;  		ctx.NextState = 25;  		return true;  	default:  		return false;  	}  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	if (ctx.L.input_char == ' ' || ctx.L.input_char >= '\t' && ctx.L.input_char <= '\r')  		continue;  	if (ctx.L.input_char >= '1' && ctx.L.input_char <= '9') {  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 3;  		return true;  	}  	switch (ctx.L.input_char) {  	case '"':  		ctx.NextState = 19;  		ctx.Return = true;  		return true;  	case ''':  	case ':':  	case '[':  	case ']':  	case '{':  	case '}':  		ctx.NextState = 1;  		ctx.Return = true;  		return true;  	case '-':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 2;  		return true;  	case '0':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 4;  		return true;  	case 'f':  		ctx.NextState = 12;  		return true;  	case 'n':  		ctx.NextState = 16;  		return true;  	case 't':  		ctx.NextState = 9;  		return true;  	case '\'':  		if (!ctx.L.allow_single_quoted_strings)  			return false;  		ctx.L.input_char = '"';  		ctx.NextState = 23;  		ctx.Return = true;  		return true;  	case '/':  		if (!ctx.L.allow_comments)  			return false;  		ctx.NextState = 25;  		return true;  	default:  		return false;  	}  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	if (ctx.L.input_char == ' ' || ctx.L.input_char >= '\t' && ctx.L.input_char <= '\r')  		continue;  	if (ctx.L.input_char >= '1' && ctx.L.input_char <= '9') {  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 3;  		return true;  	}  	switch (ctx.L.input_char) {  	case '"':  		ctx.NextState = 19;  		ctx.Return = true;  		return true;  	case ''':  	case ':':  	case '[':  	case ']':  	case '{':  	case '}':  		ctx.NextState = 1;  		ctx.Return = true;  		return true;  	case '-':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 2;  		return true;  	case '0':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 4;  		return true;  	case 'f':  		ctx.NextState = 12;  		return true;  	case 'n':  		ctx.NextState = 16;  		return true;  	case 't':  		ctx.NextState = 9;  		return true;  	case '\'':  		if (!ctx.L.allow_single_quoted_strings)  			return false;  		ctx.L.input_char = '"';  		ctx.NextState = 23;  		ctx.Return = true;  		return true;  	case '/':  		if (!ctx.L.allow_comments)  			return false;  		ctx.NextState = 25;  		return true;  	default:  		return false;  	}  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	if (ctx.L.input_char == ' ' || ctx.L.input_char >= '\t' && ctx.L.input_char <= '\r')  		continue;  	if (ctx.L.input_char >= '1' && ctx.L.input_char <= '9') {  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 3;  		return true;  	}  	switch (ctx.L.input_char) {  	case '"':  		ctx.NextState = 19;  		ctx.Return = true;  		return true;  	case ''':  	case ':':  	case '[':  	case ']':  	case '{':  	case '}':  		ctx.NextState = 1;  		ctx.Return = true;  		return true;  	case '-':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 2;  		return true;  	case '0':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 4;  		return true;  	case 'f':  		ctx.NextState = 12;  		return true;  	case 'n':  		ctx.NextState = 16;  		return true;  	case 't':  		ctx.NextState = 9;  		return true;  	case '\'':  		if (!ctx.L.allow_single_quoted_strings)  			return false;  		ctx.L.input_char = '"';  		ctx.NextState = 23;  		ctx.Return = true;  		return true;  	case '/':  		if (!ctx.L.allow_comments)  			return false;  		ctx.NextState = 25;  		return true;  	default:  		return false;  	}  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	if (ctx.L.input_char == ' ' || ctx.L.input_char >= '\t' && ctx.L.input_char <= '\r')  		continue;  	if (ctx.L.input_char >= '1' && ctx.L.input_char <= '9') {  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 3;  		return true;  	}  	switch (ctx.L.input_char) {  	case '"':  		ctx.NextState = 19;  		ctx.Return = true;  		return true;  	case ''':  	case ':':  	case '[':  	case ']':  	case '{':  	case '}':  		ctx.NextState = 1;  		ctx.Return = true;  		return true;  	case '-':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 2;  		return true;  	case '0':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 4;  		return true;  	case 'f':  		ctx.NextState = 12;  		return true;  	case 'n':  		ctx.NextState = 16;  		return true;  	case 't':  		ctx.NextState = 9;  		return true;  	case '\'':  		if (!ctx.L.allow_single_quoted_strings)  			return false;  		ctx.L.input_char = '"';  		ctx.NextState = 23;  		ctx.Return = true;  		return true;  	case '/':  		if (!ctx.L.allow_comments)  			return false;  		ctx.NextState = 25;  		return true;  	default:  		return false;  	}  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	if (ctx.L.input_char == ' ' || ctx.L.input_char >= '\t' && ctx.L.input_char <= '\r')  		continue;  	if (ctx.L.input_char >= '1' && ctx.L.input_char <= '9') {  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 3;  		return true;  	}  	switch (ctx.L.input_char) {  	case '"':  		ctx.NextState = 19;  		ctx.Return = true;  		return true;  	case ''':  	case ':':  	case '[':  	case ']':  	case '{':  	case '}':  		ctx.NextState = 1;  		ctx.Return = true;  		return true;  	case '-':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 2;  		return true;  	case '0':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 4;  		return true;  	case 'f':  		ctx.NextState = 12;  		return true;  	case 'n':  		ctx.NextState = 16;  		return true;  	case 't':  		ctx.NextState = 9;  		return true;  	case '\'':  		if (!ctx.L.allow_single_quoted_strings)  			return false;  		ctx.L.input_char = '"';  		ctx.NextState = 23;  		ctx.Return = true;  		return true;  	case '/':  		if (!ctx.L.allow_comments)  			return false;  		ctx.NextState = 25;  		return true;  	default:  		return false;  	}  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	if (ctx.L.input_char == ' ' || ctx.L.input_char >= '\t' && ctx.L.input_char <= '\r')  		continue;  	if (ctx.L.input_char >= '1' && ctx.L.input_char <= '9') {  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 3;  		return true;  	}  	switch (ctx.L.input_char) {  	case '"':  		ctx.NextState = 19;  		ctx.Return = true;  		return true;  	case ''':  	case ':':  	case '[':  	case ']':  	case '{':  	case '}':  		ctx.NextState = 1;  		ctx.Return = true;  		return true;  	case '-':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 2;  		return true;  	case '0':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 4;  		return true;  	case 'f':  		ctx.NextState = 12;  		return true;  	case 'n':  		ctx.NextState = 16;  		return true;  	case 't':  		ctx.NextState = 9;  		return true;  	case '\'':  		if (!ctx.L.allow_single_quoted_strings)  			return false;  		ctx.L.input_char = '"';  		ctx.NextState = 23;  		ctx.Return = true;  		return true;  	case '/':  		if (!ctx.L.allow_comments)  			return false;  		ctx.NextState = 25;  		return true;  	default:  		return false;  	}  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	if (ctx.L.input_char == ' ' || ctx.L.input_char >= '\t' && ctx.L.input_char <= '\r')  		continue;  	if (ctx.L.input_char >= '1' && ctx.L.input_char <= '9') {  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 3;  		return true;  	}  	switch (ctx.L.input_char) {  	case '"':  		ctx.NextState = 19;  		ctx.Return = true;  		return true;  	case ''':  	case ':':  	case '[':  	case ']':  	case '{':  	case '}':  		ctx.NextState = 1;  		ctx.Return = true;  		return true;  	case '-':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 2;  		return true;  	case '0':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 4;  		return true;  	case 'f':  		ctx.NextState = 12;  		return true;  	case 'n':  		ctx.NextState = 16;  		return true;  	case 't':  		ctx.NextState = 9;  		return true;  	case '\'':  		if (!ctx.L.allow_single_quoted_strings)  			return false;  		ctx.L.input_char = '"';  		ctx.NextState = 23;  		ctx.Return = true;  		return true;  	case '/':  		if (!ctx.L.allow_comments)  			return false;  		ctx.NextState = 25;  		return true;  	default:  		return false;  	}  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: if (ctx.L.input_char >= '1' && ctx.L.input_char <= '9') {  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 3;  	return true;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: ctx.NextState = 3;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: switch (ctx.L.input_char) {  case '"':  	ctx.NextState = 19;  	ctx.Return = true;  	return true;  case ''':  case ':':  case '[':  case ']':  case '{':  case '}':  	ctx.NextState = 1;  	ctx.Return = true;  	return true;  case '-':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 2;  	return true;  case '0':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 4;  	return true;  case 'f':  	ctx.NextState = 12;  	return true;  case 'n':  	ctx.NextState = 16;  	return true;  case 't':  	ctx.NextState = 9;  	return true;  case '\'':  	if (!ctx.L.allow_single_quoted_strings)  		return false;  	ctx.L.input_char = '"';  	ctx.NextState = 23;  	ctx.Return = true;  	return true;  case '/':  	if (!ctx.L.allow_comments)  		return false;  	ctx.NextState = 25;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: switch (ctx.L.input_char) {  case '"':  	ctx.NextState = 19;  	ctx.Return = true;  	return true;  case ''':  case ':':  case '[':  case ']':  case '{':  case '}':  	ctx.NextState = 1;  	ctx.Return = true;  	return true;  case '-':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 2;  	return true;  case '0':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 4;  	return true;  case 'f':  	ctx.NextState = 12;  	return true;  case 'n':  	ctx.NextState = 16;  	return true;  case 't':  	ctx.NextState = 9;  	return true;  case '\'':  	if (!ctx.L.allow_single_quoted_strings)  		return false;  	ctx.L.input_char = '"';  	ctx.NextState = 23;  	ctx.Return = true;  	return true;  case '/':  	if (!ctx.L.allow_comments)  		return false;  	ctx.NextState = 25;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: switch (ctx.L.input_char) {  case '"':  	ctx.NextState = 19;  	ctx.Return = true;  	return true;  case ''':  case ':':  case '[':  case ']':  case '{':  case '}':  	ctx.NextState = 1;  	ctx.Return = true;  	return true;  case '-':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 2;  	return true;  case '0':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 4;  	return true;  case 'f':  	ctx.NextState = 12;  	return true;  case 'n':  	ctx.NextState = 16;  	return true;  case 't':  	ctx.NextState = 9;  	return true;  case '\'':  	if (!ctx.L.allow_single_quoted_strings)  		return false;  	ctx.L.input_char = '"';  	ctx.NextState = 23;  	ctx.Return = true;  	return true;  case '/':  	if (!ctx.L.allow_comments)  		return false;  	ctx.NextState = 25;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: switch (ctx.L.input_char) {  case '"':  	ctx.NextState = 19;  	ctx.Return = true;  	return true;  case ''':  case ':':  case '[':  case ']':  case '{':  case '}':  	ctx.NextState = 1;  	ctx.Return = true;  	return true;  case '-':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 2;  	return true;  case '0':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 4;  	return true;  case 'f':  	ctx.NextState = 12;  	return true;  case 'n':  	ctx.NextState = 16;  	return true;  case 't':  	ctx.NextState = 9;  	return true;  case '\'':  	if (!ctx.L.allow_single_quoted_strings)  		return false;  	ctx.L.input_char = '"';  	ctx.NextState = 23;  	ctx.Return = true;  	return true;  case '/':  	if (!ctx.L.allow_comments)  		return false;  	ctx.NextState = 25;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: switch (ctx.L.input_char) {  case '"':  	ctx.NextState = 19;  	ctx.Return = true;  	return true;  case ''':  case ':':  case '[':  case ']':  case '{':  case '}':  	ctx.NextState = 1;  	ctx.Return = true;  	return true;  case '-':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 2;  	return true;  case '0':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 4;  	return true;  case 'f':  	ctx.NextState = 12;  	return true;  case 'n':  	ctx.NextState = 16;  	return true;  case 't':  	ctx.NextState = 9;  	return true;  case '\'':  	if (!ctx.L.allow_single_quoted_strings)  		return false;  	ctx.L.input_char = '"';  	ctx.NextState = 23;  	ctx.Return = true;  	return true;  case '/':  	if (!ctx.L.allow_comments)  		return false;  	ctx.NextState = 25;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: switch (ctx.L.input_char) {  case '"':  	ctx.NextState = 19;  	ctx.Return = true;  	return true;  case ''':  case ':':  case '[':  case ']':  case '{':  case '}':  	ctx.NextState = 1;  	ctx.Return = true;  	return true;  case '-':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 2;  	return true;  case '0':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 4;  	return true;  case 'f':  	ctx.NextState = 12;  	return true;  case 'n':  	ctx.NextState = 16;  	return true;  case 't':  	ctx.NextState = 9;  	return true;  case '\'':  	if (!ctx.L.allow_single_quoted_strings)  		return false;  	ctx.L.input_char = '"';  	ctx.NextState = 23;  	ctx.Return = true;  	return true;  case '/':  	if (!ctx.L.allow_comments)  		return false;  	ctx.NextState = 25;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: switch (ctx.L.input_char) {  case '"':  	ctx.NextState = 19;  	ctx.Return = true;  	return true;  case ''':  case ':':  case '[':  case ']':  case '{':  case '}':  	ctx.NextState = 1;  	ctx.Return = true;  	return true;  case '-':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 2;  	return true;  case '0':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 4;  	return true;  case 'f':  	ctx.NextState = 12;  	return true;  case 'n':  	ctx.NextState = 16;  	return true;  case 't':  	ctx.NextState = 9;  	return true;  case '\'':  	if (!ctx.L.allow_single_quoted_strings)  		return false;  	ctx.L.input_char = '"';  	ctx.NextState = 23;  	ctx.Return = true;  	return true;  case '/':  	if (!ctx.L.allow_comments)  		return false;  	ctx.NextState = 25;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: switch (ctx.L.input_char) {  case '"':  	ctx.NextState = 19;  	ctx.Return = true;  	return true;  case ''':  case ':':  case '[':  case ']':  case '{':  case '}':  	ctx.NextState = 1;  	ctx.Return = true;  	return true;  case '-':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 2;  	return true;  case '0':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 4;  	return true;  case 'f':  	ctx.NextState = 12;  	return true;  case 'n':  	ctx.NextState = 16;  	return true;  case 't':  	ctx.NextState = 9;  	return true;  case '\'':  	if (!ctx.L.allow_single_quoted_strings)  		return false;  	ctx.L.input_char = '"';  	ctx.NextState = 23;  	ctx.Return = true;  	return true;  case '/':  	if (!ctx.L.allow_comments)  		return false;  	ctx.NextState = 25;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: ctx.NextState = 19;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: ctx.NextState = 2;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: ctx.NextState = 4;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: ctx.NextState = 12;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: ctx.NextState = 16;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: ctx.NextState = 9;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: ctx.NextState = 23;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State1,The following statement contains a magic number: ctx.NextState = 25;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State2,The following statement contains a magic number: if (ctx.L.input_char >= '1' && ctx.L.input_char <= '9') {  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 3;  	return true;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State2,The following statement contains a magic number: ctx.NextState = 3;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State2,The following statement contains a magic number: switch (ctx.L.input_char) {  case '0':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 4;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State2,The following statement contains a magic number: ctx.NextState = 4;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State3,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	if (ctx.L.input_char >= '0' && ctx.L.input_char <= '9') {  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		continue;  	}  	if (ctx.L.input_char == ' ' || ctx.L.input_char >= '\t' && ctx.L.input_char <= '\r') {  		ctx.Return = true;  		ctx.NextState = 1;  		return true;  	}  	switch (ctx.L.input_char) {  	case ''':  	case ']':  	case '}':  		ctx.L.UngetChar ();  		ctx.Return = true;  		ctx.NextState = 1;  		return true;  	case '.':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 5;  		return true;  	case 'e':  	case 'E':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 7;  		return true;  	default:  		return false;  	}  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State3,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	if (ctx.L.input_char >= '0' && ctx.L.input_char <= '9') {  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		continue;  	}  	if (ctx.L.input_char == ' ' || ctx.L.input_char >= '\t' && ctx.L.input_char <= '\r') {  		ctx.Return = true;  		ctx.NextState = 1;  		return true;  	}  	switch (ctx.L.input_char) {  	case ''':  	case ']':  	case '}':  		ctx.L.UngetChar ();  		ctx.Return = true;  		ctx.NextState = 1;  		return true;  	case '.':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 5;  		return true;  	case 'e':  	case 'E':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 7;  		return true;  	default:  		return false;  	}  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State3,The following statement contains a magic number: switch (ctx.L.input_char) {  case ''':  case ']':  case '}':  	ctx.L.UngetChar ();  	ctx.Return = true;  	ctx.NextState = 1;  	return true;  case '.':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 5;  	return true;  case 'e':  case 'E':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 7;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State3,The following statement contains a magic number: switch (ctx.L.input_char) {  case ''':  case ']':  case '}':  	ctx.L.UngetChar ();  	ctx.Return = true;  	ctx.NextState = 1;  	return true;  case '.':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 5;  	return true;  case 'e':  case 'E':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 7;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State3,The following statement contains a magic number: ctx.NextState = 5;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State3,The following statement contains a magic number: ctx.NextState = 7;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State4,The following statement contains a magic number: switch (ctx.L.input_char) {  case ''':  case ']':  case '}':  	ctx.L.UngetChar ();  	ctx.Return = true;  	ctx.NextState = 1;  	return true;  case '.':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 5;  	return true;  case 'e':  case 'E':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 7;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State4,The following statement contains a magic number: switch (ctx.L.input_char) {  case ''':  case ']':  case '}':  	ctx.L.UngetChar ();  	ctx.Return = true;  	ctx.NextState = 1;  	return true;  case '.':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 5;  	return true;  case 'e':  case 'E':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 7;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State4,The following statement contains a magic number: ctx.NextState = 5;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State4,The following statement contains a magic number: ctx.NextState = 7;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State5,The following statement contains a magic number: if (ctx.L.input_char >= '0' && ctx.L.input_char <= '9') {  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 6;  	return true;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State5,The following statement contains a magic number: ctx.NextState = 6;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State6,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	if (ctx.L.input_char >= '0' && ctx.L.input_char <= '9') {  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		continue;  	}  	if (ctx.L.input_char == ' ' || ctx.L.input_char >= '\t' && ctx.L.input_char <= '\r') {  		ctx.Return = true;  		ctx.NextState = 1;  		return true;  	}  	switch (ctx.L.input_char) {  	case ''':  	case ']':  	case '}':  		ctx.L.UngetChar ();  		ctx.Return = true;  		ctx.NextState = 1;  		return true;  	case 'e':  	case 'E':  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		ctx.NextState = 7;  		return true;  	default:  		return false;  	}  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State6,The following statement contains a magic number: switch (ctx.L.input_char) {  case ''':  case ']':  case '}':  	ctx.L.UngetChar ();  	ctx.Return = true;  	ctx.NextState = 1;  	return true;  case 'e':  case 'E':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 7;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State6,The following statement contains a magic number: ctx.NextState = 7;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State7,The following statement contains a magic number: if (ctx.L.input_char >= '0' && ctx.L.input_char <= '9') {  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 8;  	return true;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State7,The following statement contains a magic number: ctx.NextState = 8;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State7,The following statement contains a magic number: switch (ctx.L.input_char) {  case '+':  case '-':  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	ctx.NextState = 8;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State7,The following statement contains a magic number: ctx.NextState = 8;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State9,The following statement contains a magic number: switch (ctx.L.input_char) {  case 'r':  	ctx.NextState = 10;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State9,The following statement contains a magic number: ctx.NextState = 10;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State10,The following statement contains a magic number: switch (ctx.L.input_char) {  case 'u':  	ctx.NextState = 11;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State10,The following statement contains a magic number: ctx.NextState = 11;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State12,The following statement contains a magic number: switch (ctx.L.input_char) {  case 'a':  	ctx.NextState = 13;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State12,The following statement contains a magic number: ctx.NextState = 13;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State13,The following statement contains a magic number: switch (ctx.L.input_char) {  case 'l':  	ctx.NextState = 14;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State13,The following statement contains a magic number: ctx.NextState = 14;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State14,The following statement contains a magic number: switch (ctx.L.input_char) {  case 's':  	ctx.NextState = 15;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State14,The following statement contains a magic number: ctx.NextState = 15;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State16,The following statement contains a magic number: switch (ctx.L.input_char) {  case 'u':  	ctx.NextState = 17;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State16,The following statement contains a magic number: ctx.NextState = 17;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State17,The following statement contains a magic number: switch (ctx.L.input_char) {  case 'l':  	ctx.NextState = 18;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State17,The following statement contains a magic number: ctx.NextState = 18;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State19,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	switch (ctx.L.input_char) {  	case '"':  		ctx.L.UngetChar ();  		ctx.Return = true;  		ctx.NextState = 20;  		return true;  	case '\\':  		ctx.StateStack = 19;  		ctx.NextState = 21;  		return true;  	default:  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		continue;  	}  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State19,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	switch (ctx.L.input_char) {  	case '"':  		ctx.L.UngetChar ();  		ctx.Return = true;  		ctx.NextState = 20;  		return true;  	case '\\':  		ctx.StateStack = 19;  		ctx.NextState = 21;  		return true;  	default:  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		continue;  	}  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State19,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	switch (ctx.L.input_char) {  	case '"':  		ctx.L.UngetChar ();  		ctx.Return = true;  		ctx.NextState = 20;  		return true;  	case '\\':  		ctx.StateStack = 19;  		ctx.NextState = 21;  		return true;  	default:  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		continue;  	}  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State19,The following statement contains a magic number: switch (ctx.L.input_char) {  case '"':  	ctx.L.UngetChar ();  	ctx.Return = true;  	ctx.NextState = 20;  	return true;  case '\\':  	ctx.StateStack = 19;  	ctx.NextState = 21;  	return true;  default:  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	continue;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State19,The following statement contains a magic number: switch (ctx.L.input_char) {  case '"':  	ctx.L.UngetChar ();  	ctx.Return = true;  	ctx.NextState = 20;  	return true;  case '\\':  	ctx.StateStack = 19;  	ctx.NextState = 21;  	return true;  default:  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	continue;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State19,The following statement contains a magic number: switch (ctx.L.input_char) {  case '"':  	ctx.L.UngetChar ();  	ctx.Return = true;  	ctx.NextState = 20;  	return true;  case '\\':  	ctx.StateStack = 19;  	ctx.NextState = 21;  	return true;  default:  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	continue;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State19,The following statement contains a magic number: ctx.NextState = 20;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State19,The following statement contains a magic number: ctx.StateStack = 19;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State19,The following statement contains a magic number: ctx.NextState = 21;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State21,The following statement contains a magic number: switch (ctx.L.input_char) {  case 'u':  	ctx.NextState = 22;  	return true;  case '"':  case '\'':  case '/':  case '\\':  case 'b':  case 'f':  case 'n':  case 'r':  case 't':  	ctx.L.string_buffer.Append (ProcessEscChar (ctx.L.input_char));  	ctx.NextState = ctx.StateStack;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State21,The following statement contains a magic number: ctx.NextState = 22;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State22,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	if (ctx.L.input_char >= '0' && ctx.L.input_char <= '9' || ctx.L.input_char >= 'A' && ctx.L.input_char <= 'F' || ctx.L.input_char >= 'a' && ctx.L.input_char <= 'f') {  		ctx.L.unichar += HexValue (ctx.L.input_char) * mult;  		counter++;  		mult /= 16;  		if (counter == 4) {  			ctx.L.string_buffer.Append (Convert.ToChar (ctx.L.unichar));  			ctx.NextState = ctx.StateStack;  			return true;  		}  		continue;  	}  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State22,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	if (ctx.L.input_char >= '0' && ctx.L.input_char <= '9' || ctx.L.input_char >= 'A' && ctx.L.input_char <= 'F' || ctx.L.input_char >= 'a' && ctx.L.input_char <= 'f') {  		ctx.L.unichar += HexValue (ctx.L.input_char) * mult;  		counter++;  		mult /= 16;  		if (counter == 4) {  			ctx.L.string_buffer.Append (Convert.ToChar (ctx.L.unichar));  			ctx.NextState = ctx.StateStack;  			return true;  		}  		continue;  	}  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State22,The following statement contains a magic number: if (ctx.L.input_char >= '0' && ctx.L.input_char <= '9' || ctx.L.input_char >= 'A' && ctx.L.input_char <= 'F' || ctx.L.input_char >= 'a' && ctx.L.input_char <= 'f') {  	ctx.L.unichar += HexValue (ctx.L.input_char) * mult;  	counter++;  	mult /= 16;  	if (counter == 4) {  		ctx.L.string_buffer.Append (Convert.ToChar (ctx.L.unichar));  		ctx.NextState = ctx.StateStack;  		return true;  	}  	continue;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State22,The following statement contains a magic number: if (ctx.L.input_char >= '0' && ctx.L.input_char <= '9' || ctx.L.input_char >= 'A' && ctx.L.input_char <= 'F' || ctx.L.input_char >= 'a' && ctx.L.input_char <= 'f') {  	ctx.L.unichar += HexValue (ctx.L.input_char) * mult;  	counter++;  	mult /= 16;  	if (counter == 4) {  		ctx.L.string_buffer.Append (Convert.ToChar (ctx.L.unichar));  		ctx.NextState = ctx.StateStack;  		return true;  	}  	continue;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State22,The following statement contains a magic number: mult /= 16;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State22,The following statement contains a magic number: if (counter == 4) {  	ctx.L.string_buffer.Append (Convert.ToChar (ctx.L.unichar));  	ctx.NextState = ctx.StateStack;  	return true;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State23,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	switch (ctx.L.input_char) {  	case '\'':  		ctx.L.UngetChar ();  		ctx.Return = true;  		ctx.NextState = 24;  		return true;  	case '\\':  		ctx.StateStack = 23;  		ctx.NextState = 21;  		return true;  	default:  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		continue;  	}  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State23,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	switch (ctx.L.input_char) {  	case '\'':  		ctx.L.UngetChar ();  		ctx.Return = true;  		ctx.NextState = 24;  		return true;  	case '\\':  		ctx.StateStack = 23;  		ctx.NextState = 21;  		return true;  	default:  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		continue;  	}  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State23,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	switch (ctx.L.input_char) {  	case '\'':  		ctx.L.UngetChar ();  		ctx.Return = true;  		ctx.NextState = 24;  		return true;  	case '\\':  		ctx.StateStack = 23;  		ctx.NextState = 21;  		return true;  	default:  		ctx.L.string_buffer.Append ((char)ctx.L.input_char);  		continue;  	}  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State23,The following statement contains a magic number: switch (ctx.L.input_char) {  case '\'':  	ctx.L.UngetChar ();  	ctx.Return = true;  	ctx.NextState = 24;  	return true;  case '\\':  	ctx.StateStack = 23;  	ctx.NextState = 21;  	return true;  default:  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	continue;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State23,The following statement contains a magic number: switch (ctx.L.input_char) {  case '\'':  	ctx.L.UngetChar ();  	ctx.Return = true;  	ctx.NextState = 24;  	return true;  case '\\':  	ctx.StateStack = 23;  	ctx.NextState = 21;  	return true;  default:  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	continue;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State23,The following statement contains a magic number: switch (ctx.L.input_char) {  case '\'':  	ctx.L.UngetChar ();  	ctx.Return = true;  	ctx.NextState = 24;  	return true;  case '\\':  	ctx.StateStack = 23;  	ctx.NextState = 21;  	return true;  default:  	ctx.L.string_buffer.Append ((char)ctx.L.input_char);  	continue;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State23,The following statement contains a magic number: ctx.NextState = 24;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State23,The following statement contains a magic number: ctx.StateStack = 23;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State23,The following statement contains a magic number: ctx.NextState = 21;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State25,The following statement contains a magic number: switch (ctx.L.input_char) {  case '*':  	ctx.NextState = 27;  	return true;  case '/':  	ctx.NextState = 26;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State25,The following statement contains a magic number: switch (ctx.L.input_char) {  case '*':  	ctx.NextState = 27;  	return true;  case '/':  	ctx.NextState = 26;  	return true;  default:  	return false;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State25,The following statement contains a magic number: ctx.NextState = 27;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State25,The following statement contains a magic number: ctx.NextState = 26;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State27,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	if (ctx.L.input_char == '*') {  		ctx.NextState = 28;  		return true;  	}  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State27,The following statement contains a magic number: if (ctx.L.input_char == '*') {  	ctx.NextState = 28;  	return true;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State27,The following statement contains a magic number: ctx.NextState = 28;  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State28,The following statement contains a magic number: while (ctx.L.GetChar ()) {  	if (ctx.L.input_char == '*')  		continue;  	if (ctx.L.input_char == '/') {  		ctx.NextState = 1;  		return true;  	}  	ctx.NextState = 27;  	return true;  }  
Magic Number,LitJson,Lexer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\Lexer.cs,State28,The following statement contains a magic number: ctx.NextState = 27;  
Magic Number,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetProperties,The following statement contains a magic number: return (from a in accessors [seen ? 0 : 2]  let value = a.Get (obj)  where (a.IsStatic || (value != null && !value.Equals (a.Vanilla)) || (value == null && a.Vanilla != null))  select new Entry () {  	PropertyInfo = a.Info'  	MustHaveName = true'  	Value = value'  	IsStatic = a.IsStatic  }).ToArray ();  
Magic Number,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetFields,The following statement contains a magic number: return (from a in accessors [seen ? 1 : 3]  let value = a.Get (obj)  where (a.IsStatic || (value != null && !value.Equals (a.Vanilla)) || (value == null && a.Vanilla != null))  select new Entry () {  	FieldInfo = a.FieldInfo'  	MustHaveName = true'  	Value = value'  	IsStatic = a.IsStatic  }).ToArray ();  
Magic Number,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetAccessors,The following statement contains a magic number: lock (PropertyAccess) {  	var index = (UnitySerializer.IsChecksum ? 1 : 0) + (UnitySerializer.IsChecksum && UnitySerializer.IgnoreIds ? 1 : 0);  	GetSet[][][] collection;  	if (!PropertyAccess.TryGetValue (type' out collection)) {  		collection = new GetSet[3][][];  		PropertyAccess [type] = collection;  	}  	var accessors = collection [index];  	if (accessors == null) {  		object vanilla = GetVanilla (type);  		bool canGetVanilla = false;  		if (vanilla != null) {  			canGetVanilla = !vanilla.Equals (null);  		}  		var acs = new List<GetSet> ();  		var props = UnitySerializer.GetPropertyInfo (type).Where (p => p.Name != "hideFlags").Select (p => new {  			priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  			info = p  		}).OrderBy (p => p.priority.Priority).Select (p => p.info);  		foreach (var p in props) {  			var getSet = new GetSetGeneric (p);  			if (!canGetVanilla) {  				getSet.Vanilla = null;  			}  			else {  				getSet.Vanilla = getSet.Get (vanilla);  			}  			acs.Add (getSet);  		}  		accessors = new GetSet[4][];  		accessors [0] = acs.Where (a => !a.IsStatic).ToArray ();  		accessors [2] = acs.ToArray ();  		acs.Clear ();  		var fields = UnitySerializer.GetFieldInfo (type).Where (f => f.Name != "hideFlags").Select (p => new {  			priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  			info = p  		}).OrderBy (p => p.priority.Priority).Select (p => p.info);  		foreach (var f in fields) {  			var getSet = new GetSetGeneric (f);  			if (!canGetVanilla) {  				getSet.Vanilla = null;  			}  			else {  				getSet.Vanilla = getSet.Get (vanilla);  			}  			acs.Add (getSet);  		}  		accessors [1] = acs.Where (a => !a.IsStatic).ToArray ();  		accessors [3] = acs.ToArray ();  		collection [index] = accessors;  	}  	return accessors;  }  
Magic Number,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetAccessors,The following statement contains a magic number: lock (PropertyAccess) {  	var index = (UnitySerializer.IsChecksum ? 1 : 0) + (UnitySerializer.IsChecksum && UnitySerializer.IgnoreIds ? 1 : 0);  	GetSet[][][] collection;  	if (!PropertyAccess.TryGetValue (type' out collection)) {  		collection = new GetSet[3][][];  		PropertyAccess [type] = collection;  	}  	var accessors = collection [index];  	if (accessors == null) {  		object vanilla = GetVanilla (type);  		bool canGetVanilla = false;  		if (vanilla != null) {  			canGetVanilla = !vanilla.Equals (null);  		}  		var acs = new List<GetSet> ();  		var props = UnitySerializer.GetPropertyInfo (type).Where (p => p.Name != "hideFlags").Select (p => new {  			priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  			info = p  		}).OrderBy (p => p.priority.Priority).Select (p => p.info);  		foreach (var p in props) {  			var getSet = new GetSetGeneric (p);  			if (!canGetVanilla) {  				getSet.Vanilla = null;  			}  			else {  				getSet.Vanilla = getSet.Get (vanilla);  			}  			acs.Add (getSet);  		}  		accessors = new GetSet[4][];  		accessors [0] = acs.Where (a => !a.IsStatic).ToArray ();  		accessors [2] = acs.ToArray ();  		acs.Clear ();  		var fields = UnitySerializer.GetFieldInfo (type).Where (f => f.Name != "hideFlags").Select (p => new {  			priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  			info = p  		}).OrderBy (p => p.priority.Priority).Select (p => p.info);  		foreach (var f in fields) {  			var getSet = new GetSetGeneric (f);  			if (!canGetVanilla) {  				getSet.Vanilla = null;  			}  			else {  				getSet.Vanilla = getSet.Get (vanilla);  			}  			acs.Add (getSet);  		}  		accessors [1] = acs.Where (a => !a.IsStatic).ToArray ();  		accessors [3] = acs.ToArray ();  		collection [index] = accessors;  	}  	return accessors;  }  
Magic Number,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetAccessors,The following statement contains a magic number: lock (PropertyAccess) {  	var index = (UnitySerializer.IsChecksum ? 1 : 0) + (UnitySerializer.IsChecksum && UnitySerializer.IgnoreIds ? 1 : 0);  	GetSet[][][] collection;  	if (!PropertyAccess.TryGetValue (type' out collection)) {  		collection = new GetSet[3][][];  		PropertyAccess [type] = collection;  	}  	var accessors = collection [index];  	if (accessors == null) {  		object vanilla = GetVanilla (type);  		bool canGetVanilla = false;  		if (vanilla != null) {  			canGetVanilla = !vanilla.Equals (null);  		}  		var acs = new List<GetSet> ();  		var props = UnitySerializer.GetPropertyInfo (type).Where (p => p.Name != "hideFlags").Select (p => new {  			priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  			info = p  		}).OrderBy (p => p.priority.Priority).Select (p => p.info);  		foreach (var p in props) {  			var getSet = new GetSetGeneric (p);  			if (!canGetVanilla) {  				getSet.Vanilla = null;  			}  			else {  				getSet.Vanilla = getSet.Get (vanilla);  			}  			acs.Add (getSet);  		}  		accessors = new GetSet[4][];  		accessors [0] = acs.Where (a => !a.IsStatic).ToArray ();  		accessors [2] = acs.ToArray ();  		acs.Clear ();  		var fields = UnitySerializer.GetFieldInfo (type).Where (f => f.Name != "hideFlags").Select (p => new {  			priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  			info = p  		}).OrderBy (p => p.priority.Priority).Select (p => p.info);  		foreach (var f in fields) {  			var getSet = new GetSetGeneric (f);  			if (!canGetVanilla) {  				getSet.Vanilla = null;  			}  			else {  				getSet.Vanilla = getSet.Get (vanilla);  			}  			acs.Add (getSet);  		}  		accessors [1] = acs.Where (a => !a.IsStatic).ToArray ();  		accessors [3] = acs.ToArray ();  		collection [index] = accessors;  	}  	return accessors;  }  
Magic Number,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetAccessors,The following statement contains a magic number: lock (PropertyAccess) {  	var index = (UnitySerializer.IsChecksum ? 1 : 0) + (UnitySerializer.IsChecksum && UnitySerializer.IgnoreIds ? 1 : 0);  	GetSet[][][] collection;  	if (!PropertyAccess.TryGetValue (type' out collection)) {  		collection = new GetSet[3][][];  		PropertyAccess [type] = collection;  	}  	var accessors = collection [index];  	if (accessors == null) {  		object vanilla = GetVanilla (type);  		bool canGetVanilla = false;  		if (vanilla != null) {  			canGetVanilla = !vanilla.Equals (null);  		}  		var acs = new List<GetSet> ();  		var props = UnitySerializer.GetPropertyInfo (type).Where (p => p.Name != "hideFlags").Select (p => new {  			priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  			info = p  		}).OrderBy (p => p.priority.Priority).Select (p => p.info);  		foreach (var p in props) {  			var getSet = new GetSetGeneric (p);  			if (!canGetVanilla) {  				getSet.Vanilla = null;  			}  			else {  				getSet.Vanilla = getSet.Get (vanilla);  			}  			acs.Add (getSet);  		}  		accessors = new GetSet[4][];  		accessors [0] = acs.Where (a => !a.IsStatic).ToArray ();  		accessors [2] = acs.ToArray ();  		acs.Clear ();  		var fields = UnitySerializer.GetFieldInfo (type).Where (f => f.Name != "hideFlags").Select (p => new {  			priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  			info = p  		}).OrderBy (p => p.priority.Priority).Select (p => p.info);  		foreach (var f in fields) {  			var getSet = new GetSetGeneric (f);  			if (!canGetVanilla) {  				getSet.Vanilla = null;  			}  			else {  				getSet.Vanilla = getSet.Get (vanilla);  			}  			acs.Add (getSet);  		}  		accessors [1] = acs.Where (a => !a.IsStatic).ToArray ();  		accessors [3] = acs.ToArray ();  		collection [index] = accessors;  	}  	return accessors;  }  
Magic Number,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetAccessors,The following statement contains a magic number: lock (PropertyAccess) {  	var index = (UnitySerializer.IsChecksum ? 1 : 0) + (UnitySerializer.IsChecksum && UnitySerializer.IgnoreIds ? 1 : 0);  	GetSet[][][] collection;  	if (!PropertyAccess.TryGetValue (type' out collection)) {  		collection = new GetSet[3][][];  		PropertyAccess [type] = collection;  	}  	var accessors = collection [index];  	if (accessors == null) {  		object vanilla = GetVanilla (type);  		bool canGetVanilla = false;  		if (vanilla != null) {  			canGetVanilla = !vanilla.Equals (null);  		}  		var acs = new List<GetSet> ();  		var props = UnitySerializer.GetPropertyInfo (type).Where (p => p.Name != "hideFlags").Select (p => new {  			priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  			info = p  		}).OrderBy (p => p.priority.Priority).Select (p => p.info);  		foreach (var p in props) {  			var getSet = new GetSetGeneric (p);  			if (!canGetVanilla) {  				getSet.Vanilla = null;  			}  			else {  				getSet.Vanilla = getSet.Get (vanilla);  			}  			acs.Add (getSet);  		}  		accessors = new GetSet[4][];  		accessors [0] = acs.Where (a => !a.IsStatic).ToArray ();  		accessors [2] = acs.ToArray ();  		acs.Clear ();  		var fields = UnitySerializer.GetFieldInfo (type).Where (f => f.Name != "hideFlags").Select (p => new {  			priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  			info = p  		}).OrderBy (p => p.priority.Priority).Select (p => p.info);  		foreach (var f in fields) {  			var getSet = new GetSetGeneric (f);  			if (!canGetVanilla) {  				getSet.Vanilla = null;  			}  			else {  				getSet.Vanilla = getSet.Get (vanilla);  			}  			acs.Add (getSet);  		}  		accessors [1] = acs.Where (a => !a.IsStatic).ToArray ();  		accessors [3] = acs.ToArray ();  		collection [index] = accessors;  	}  	return accessors;  }  
Magic Number,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetAccessors,The following statement contains a magic number: lock (PropertyAccess) {  	var index = (UnitySerializer.IsChecksum ? 1 : 0) + (UnitySerializer.IsChecksum && UnitySerializer.IgnoreIds ? 1 : 0);  	GetSet[][][] collection;  	if (!PropertyAccess.TryGetValue (type' out collection)) {  		collection = new GetSet[3][][];  		PropertyAccess [type] = collection;  	}  	var accessors = collection [index];  	if (accessors == null) {  		object vanilla = GetVanilla (type);  		bool canGetVanilla = false;  		if (vanilla != null) {  			canGetVanilla = !vanilla.Equals (null);  		}  		var acs = new List<GetSet> ();  		var props = UnitySerializer.GetPropertyInfo (type).Where (p => p.Name != "hideFlags").Select (p => new {  			priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  			info = p  		}).OrderBy (p => p.priority.Priority).Select (p => p.info);  		foreach (var p in props) {  			var getSet = new GetSetGeneric (p);  			if (!canGetVanilla) {  				getSet.Vanilla = null;  			}  			else {  				getSet.Vanilla = getSet.Get (vanilla);  			}  			acs.Add (getSet);  		}  		accessors = new GetSet[4][];  		accessors [0] = acs.Where (a => !a.IsStatic).ToArray ();  		accessors [2] = acs.ToArray ();  		acs.Clear ();  		var fields = UnitySerializer.GetFieldInfo (type).Where (f => f.Name != "hideFlags").Select (p => new {  			priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  			info = p  		}).OrderBy (p => p.priority.Priority).Select (p => p.info);  		foreach (var f in fields) {  			var getSet = new GetSetGeneric (f);  			if (!canGetVanilla) {  				getSet.Vanilla = null;  			}  			else {  				getSet.Vanilla = getSet.Get (vanilla);  			}  			acs.Add (getSet);  		}  		accessors [1] = acs.Where (a => !a.IsStatic).ToArray ();  		accessors [3] = acs.ToArray ();  		collection [index] = accessors;  	}  	return accessors;  }  
Magic Number,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetAccessors,The following statement contains a magic number: if (!PropertyAccess.TryGetValue (type' out collection)) {  	collection = new GetSet[3][][];  	PropertyAccess [type] = collection;  }  
Magic Number,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetAccessors,The following statement contains a magic number: collection = new GetSet[3][][];  
Magic Number,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetAccessors,The following statement contains a magic number: if (accessors == null) {  	object vanilla = GetVanilla (type);  	bool canGetVanilla = false;  	if (vanilla != null) {  		canGetVanilla = !vanilla.Equals (null);  	}  	var acs = new List<GetSet> ();  	var props = UnitySerializer.GetPropertyInfo (type).Where (p => p.Name != "hideFlags").Select (p => new {  		priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  		info = p  	}).OrderBy (p => p.priority.Priority).Select (p => p.info);  	foreach (var p in props) {  		var getSet = new GetSetGeneric (p);  		if (!canGetVanilla) {  			getSet.Vanilla = null;  		}  		else {  			getSet.Vanilla = getSet.Get (vanilla);  		}  		acs.Add (getSet);  	}  	accessors = new GetSet[4][];  	accessors [0] = acs.Where (a => !a.IsStatic).ToArray ();  	accessors [2] = acs.ToArray ();  	acs.Clear ();  	var fields = UnitySerializer.GetFieldInfo (type).Where (f => f.Name != "hideFlags").Select (p => new {  		priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  		info = p  	}).OrderBy (p => p.priority.Priority).Select (p => p.info);  	foreach (var f in fields) {  		var getSet = new GetSetGeneric (f);  		if (!canGetVanilla) {  			getSet.Vanilla = null;  		}  		else {  			getSet.Vanilla = getSet.Get (vanilla);  		}  		acs.Add (getSet);  	}  	accessors [1] = acs.Where (a => !a.IsStatic).ToArray ();  	accessors [3] = acs.ToArray ();  	collection [index] = accessors;  }  
Magic Number,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetAccessors,The following statement contains a magic number: if (accessors == null) {  	object vanilla = GetVanilla (type);  	bool canGetVanilla = false;  	if (vanilla != null) {  		canGetVanilla = !vanilla.Equals (null);  	}  	var acs = new List<GetSet> ();  	var props = UnitySerializer.GetPropertyInfo (type).Where (p => p.Name != "hideFlags").Select (p => new {  		priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  		info = p  	}).OrderBy (p => p.priority.Priority).Select (p => p.info);  	foreach (var p in props) {  		var getSet = new GetSetGeneric (p);  		if (!canGetVanilla) {  			getSet.Vanilla = null;  		}  		else {  			getSet.Vanilla = getSet.Get (vanilla);  		}  		acs.Add (getSet);  	}  	accessors = new GetSet[4][];  	accessors [0] = acs.Where (a => !a.IsStatic).ToArray ();  	accessors [2] = acs.ToArray ();  	acs.Clear ();  	var fields = UnitySerializer.GetFieldInfo (type).Where (f => f.Name != "hideFlags").Select (p => new {  		priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  		info = p  	}).OrderBy (p => p.priority.Priority).Select (p => p.info);  	foreach (var f in fields) {  		var getSet = new GetSetGeneric (f);  		if (!canGetVanilla) {  			getSet.Vanilla = null;  		}  		else {  			getSet.Vanilla = getSet.Get (vanilla);  		}  		acs.Add (getSet);  	}  	accessors [1] = acs.Where (a => !a.IsStatic).ToArray ();  	accessors [3] = acs.ToArray ();  	collection [index] = accessors;  }  
Magic Number,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetAccessors,The following statement contains a magic number: if (accessors == null) {  	object vanilla = GetVanilla (type);  	bool canGetVanilla = false;  	if (vanilla != null) {  		canGetVanilla = !vanilla.Equals (null);  	}  	var acs = new List<GetSet> ();  	var props = UnitySerializer.GetPropertyInfo (type).Where (p => p.Name != "hideFlags").Select (p => new {  		priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  		info = p  	}).OrderBy (p => p.priority.Priority).Select (p => p.info);  	foreach (var p in props) {  		var getSet = new GetSetGeneric (p);  		if (!canGetVanilla) {  			getSet.Vanilla = null;  		}  		else {  			getSet.Vanilla = getSet.Get (vanilla);  		}  		acs.Add (getSet);  	}  	accessors = new GetSet[4][];  	accessors [0] = acs.Where (a => !a.IsStatic).ToArray ();  	accessors [2] = acs.ToArray ();  	acs.Clear ();  	var fields = UnitySerializer.GetFieldInfo (type).Where (f => f.Name != "hideFlags").Select (p => new {  		priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  		info = p  	}).OrderBy (p => p.priority.Priority).Select (p => p.info);  	foreach (var f in fields) {  		var getSet = new GetSetGeneric (f);  		if (!canGetVanilla) {  			getSet.Vanilla = null;  		}  		else {  			getSet.Vanilla = getSet.Get (vanilla);  		}  		acs.Add (getSet);  	}  	accessors [1] = acs.Where (a => !a.IsStatic).ToArray ();  	accessors [3] = acs.ToArray ();  	collection [index] = accessors;  }  
Magic Number,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetAccessors,The following statement contains a magic number: if (accessors == null) {  	object vanilla = GetVanilla (type);  	bool canGetVanilla = false;  	if (vanilla != null) {  		canGetVanilla = !vanilla.Equals (null);  	}  	var acs = new List<GetSet> ();  	var props = UnitySerializer.GetPropertyInfo (type).Where (p => p.Name != "hideFlags").Select (p => new {  		priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  		info = p  	}).OrderBy (p => p.priority.Priority).Select (p => p.info);  	foreach (var p in props) {  		var getSet = new GetSetGeneric (p);  		if (!canGetVanilla) {  			getSet.Vanilla = null;  		}  		else {  			getSet.Vanilla = getSet.Get (vanilla);  		}  		acs.Add (getSet);  	}  	accessors = new GetSet[4][];  	accessors [0] = acs.Where (a => !a.IsStatic).ToArray ();  	accessors [2] = acs.ToArray ();  	acs.Clear ();  	var fields = UnitySerializer.GetFieldInfo (type).Where (f => f.Name != "hideFlags").Select (p => new {  		priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  		info = p  	}).OrderBy (p => p.priority.Priority).Select (p => p.info);  	foreach (var f in fields) {  		var getSet = new GetSetGeneric (f);  		if (!canGetVanilla) {  			getSet.Vanilla = null;  		}  		else {  			getSet.Vanilla = getSet.Get (vanilla);  		}  		acs.Add (getSet);  	}  	accessors [1] = acs.Where (a => !a.IsStatic).ToArray ();  	accessors [3] = acs.ToArray ();  	collection [index] = accessors;  }  
Magic Number,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetAccessors,The following statement contains a magic number: if (accessors == null) {  	object vanilla = GetVanilla (type);  	bool canGetVanilla = false;  	if (vanilla != null) {  		canGetVanilla = !vanilla.Equals (null);  	}  	var acs = new List<GetSet> ();  	var props = UnitySerializer.GetPropertyInfo (type).Where (p => p.Name != "hideFlags").Select (p => new {  		priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  		info = p  	}).OrderBy (p => p.priority.Priority).Select (p => p.info);  	foreach (var p in props) {  		var getSet = new GetSetGeneric (p);  		if (!canGetVanilla) {  			getSet.Vanilla = null;  		}  		else {  			getSet.Vanilla = getSet.Get (vanilla);  		}  		acs.Add (getSet);  	}  	accessors = new GetSet[4][];  	accessors [0] = acs.Where (a => !a.IsStatic).ToArray ();  	accessors [2] = acs.ToArray ();  	acs.Clear ();  	var fields = UnitySerializer.GetFieldInfo (type).Where (f => f.Name != "hideFlags").Select (p => new {  		priority = ((SerializationPriorityAttribute)p.GetCustomAttributes (false).FirstOrDefault (a => a is SerializationPriorityAttribute)) ?? new SerializationPriorityAttribute (100)'  		info = p  	}).OrderBy (p => p.priority.Priority).Select (p => p.info);  	foreach (var f in fields) {  		var getSet = new GetSetGeneric (f);  		if (!canGetVanilla) {  			getSet.Vanilla = null;  		}  		else {  			getSet.Vanilla = getSet.Get (vanilla);  		}  		acs.Add (getSet);  	}  	accessors [1] = acs.Where (a => !a.IsStatic).ToArray ();  	accessors [3] = acs.ToArray ();  	collection [index] = accessors;  }  
Magic Number,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetAccessors,The following statement contains a magic number: accessors = new GetSet[4][];  
Magic Number,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetAccessors,The following statement contains a magic number: accessors [2] = acs.ToArray ();  
Magic Number,Serialization,GetWritableAttributes,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\GetWritableAttributes.cs,GetAccessors,The following statement contains a magic number: accessors [3] = acs.ToArray ();  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,BeginWriteProperties,The following statement contains a magic number: if (count > 250) {  	WriteSimpleValue ((byte)255);  	WriteSimpleValue (count);  }  else {  	WriteSimpleValue ((byte)count);  }  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,BeginWriteProperties,The following statement contains a magic number: if (count > 250) {  	WriteSimpleValue ((byte)255);  	WriteSimpleValue (count);  }  else {  	WriteSimpleValue ((byte)count);  }  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,BeginWriteProperties,The following statement contains a magic number: WriteSimpleValue ((byte)255);  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,BeginWriteFields,The following statement contains a magic number: if (count > 250) {  	WriteSimpleValue ((byte)255);  	WriteSimpleValue (count);  }  else {  	WriteSimpleValue ((byte)count);  }  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,BeginWriteFields,The following statement contains a magic number: if (count > 250) {  	WriteSimpleValue ((byte)255);  	WriteSimpleValue (count);  }  else {  	WriteSimpleValue ((byte)count);  }  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,BeginWriteFields,The following statement contains a magic number: WriteSimpleValue ((byte)255);  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,DecodeType,The following statement contains a magic number: try {  	var tid = ReadSimpleValue<ushort> ();  	if (tid == 0xffff)  		return storedType;  	if (tid == 0xFFFE) {  		return null;  	}  	if (tid >= 60000) {  		try {  			return UnitySerializer.PrewarmLookup [tid - 60000];  		}  		catch {  			throw new Exception ("Data stream appears corrupt' found a TYPE ID of " + tid.ToString ());  		}  	}  	storedType = Type.GetTypeFromHandle (UnitySerializer._knownTypesList [tid]);  	return storedType;  }  catch {  	return null;  }  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,DecodeType,The following statement contains a magic number: try {  	var tid = ReadSimpleValue<ushort> ();  	if (tid == 0xffff)  		return storedType;  	if (tid == 0xFFFE) {  		return null;  	}  	if (tid >= 60000) {  		try {  			return UnitySerializer.PrewarmLookup [tid - 60000];  		}  		catch {  			throw new Exception ("Data stream appears corrupt' found a TYPE ID of " + tid.ToString ());  		}  	}  	storedType = Type.GetTypeFromHandle (UnitySerializer._knownTypesList [tid]);  	return storedType;  }  catch {  	return null;  }  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,DecodeType,The following statement contains a magic number: if (tid >= 60000) {  	try {  		return UnitySerializer.PrewarmLookup [tid - 60000];  	}  	catch {  		throw new Exception ("Data stream appears corrupt' found a TYPE ID of " + tid.ToString ());  	}  }  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,DecodeType,The following statement contains a magic number: if (tid >= 60000) {  	try {  		return UnitySerializer.PrewarmLookup [tid - 60000];  	}  	catch {  		throw new Exception ("Data stream appears corrupt' found a TYPE ID of " + tid.ToString ());  	}  }  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,DecodeType,The following statement contains a magic number: try {  	return UnitySerializer.PrewarmLookup [tid - 60000];  }  catch {  	throw new Exception ("Data stream appears corrupt' found a TYPE ID of " + tid.ToString ());  }  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,DecodeType,The following statement contains a magic number: return UnitySerializer.PrewarmLookup [tid - 60000];  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,DeserializeGetName,The following statement contains a magic number: try {  	entry.Name = id >= 50000 ? PreWarm.PrewarmNames [id - 50000] : UnitySerializer._propertyList [id];  }  catch {  	throw new Exception ("Data stream may be corrupt' found an id of " + id + " when looking a property name id");  }  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,DeserializeGetName,The following statement contains a magic number: try {  	entry.Name = id >= 50000 ? PreWarm.PrewarmNames [id - 50000] : UnitySerializer._propertyList [id];  }  catch {  	throw new Exception ("Data stream may be corrupt' found an id of " + id + " when looking a property name id");  }  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,DeserializeGetName,The following statement contains a magic number: entry.Name = id >= 50000 ? PreWarm.PrewarmNames [id - 50000] : UnitySerializer._propertyList [id];  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,DeserializeGetName,The following statement contains a magic number: entry.Name = id >= 50000 ? PreWarm.PrewarmNames [id - 50000] : UnitySerializer._propertyList [id];  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,StartDeserializing,The following statement contains a magic number: UnitySerializer.currentVersion = int.Parse (version.Substring (4));  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,StartDeserializing,The following statement contains a magic number: if (UnitySerializer.currentVersion >= 3) {  	UnitySerializer.Verbose = reader.ReadBoolean ();  }  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,ReadSimpleArray,The following statement contains a magic number: if (elementType.IsPrimitive && UnitySerializer.currentVersion >= 6) {  	var ba = ReadSimpleValue<byte[]> ();  	var a = Array.CreateInstance (elementType' count);  	Buffer.BlockCopy (ba' 0' a' 0' ba.Length);  	return a;  }  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,ReadSimpleArray,The following statement contains a magic number: if (UnitySerializer.currentVersion >= 8) {  	for (var l = 0; l < count; l++) {  		var go = (byte)ReadSimpleValue (typeof(byte));  		result.SetValue (go != 0 ? ReadSimpleValue (elementType) : null' l);  	}  }  else {  	for (var l = 0; l < count; l++) {  		result.SetValue (ReadSimpleValue (elementType)' l);  	}  }  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,BeginReadProperties,The following statement contains a magic number: return count == 255 ? ReadSimpleValue<int> () : count;  
Magic Number,Serialization,BinarySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\SerializationUnits.cs,BeginReadFields,The following statement contains a magic number: return count == 255 ? ReadSimpleValue<int> () : count;  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GetTypeEx,The following statement contains a magic number: if (fullTypeName is string) {  	var type = Type.GetType ((string)fullTypeName);  	if (type != null) {  		return type;  	}  	var assembly = AppDomain.CurrentDomain.GetAssemblies ().FirstOrDefault (a => a.GetType ((string)fullTypeName) != null);  	return assembly != null ? assembly.GetType ((string)fullTypeName) : null;  }  else if (fullTypeName is ushort) {  	if ((ushort)fullTypeName >= 60000)  		return PrewarmLookup [(ushort)fullTypeName - 60000];  	return Type.GetTypeFromHandle (_knownTypesList [(ushort)fullTypeName]);  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GetTypeEx,The following statement contains a magic number: if (fullTypeName is string) {  	var type = Type.GetType ((string)fullTypeName);  	if (type != null) {  		return type;  	}  	var assembly = AppDomain.CurrentDomain.GetAssemblies ().FirstOrDefault (a => a.GetType ((string)fullTypeName) != null);  	return assembly != null ? assembly.GetType ((string)fullTypeName) : null;  }  else if (fullTypeName is ushort) {  	if ((ushort)fullTypeName >= 60000)  		return PrewarmLookup [(ushort)fullTypeName - 60000];  	return Type.GetTypeFromHandle (_knownTypesList [(ushort)fullTypeName]);  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GetTypeEx,The following statement contains a magic number: if (fullTypeName is ushort) {  	if ((ushort)fullTypeName >= 60000)  		return PrewarmLookup [(ushort)fullTypeName - 60000];  	return Type.GetTypeFromHandle (_knownTypesList [(ushort)fullTypeName]);  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GetTypeEx,The following statement contains a magic number: if (fullTypeName is ushort) {  	if ((ushort)fullTypeName >= 60000)  		return PrewarmLookup [(ushort)fullTypeName - 60000];  	return Type.GetTypeFromHandle (_knownTypesList [(ushort)fullTypeName]);  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GetTypeEx,The following statement contains a magic number: if ((ushort)fullTypeName >= 60000)  	return PrewarmLookup [(ushort)fullTypeName - 60000];  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GetTypeEx,The following statement contains a magic number: if ((ushort)fullTypeName >= 60000)  	return PrewarmLookup [(ushort)fullTypeName - 60000];  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GetTypeEx,The following statement contains a magic number: return PrewarmLookup [(ushort)fullTypeName - 60000];  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GetChecksum,The following statement contains a magic number: for (var i = 0; i < toBytes.Length; i++) {  	checksum [i & 15] ^= toBytes [i];  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GetChecksum,The following statement contains a magic number: checksum [i & 15] ^= toBytes [i];  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,Deserialize,The following statement contains a magic number: using (new SerializationScope ()) {  	var v = Verbose;  	CreateStacks ();  	try {  		PushKnownTypes ();  		PushPropertyNames ();  		var rw = new BinaryReader (inputStream);  		var version = rw.ReadString ();  		currentVersion = Int32.Parse (version.Substring (4));  		if (currentVersion >= 5) {  			inputStream.Position = 0;  			var serializer = new BinarySerializer (rw.ReadBytes ((int)inputStream.Length));  			serializer.StartDeserializing ();  			var ob = DeserializeObject (new Entry () {  				Name = "root"'  				Value = instance  			}' serializer);  			serializer.FinishedDeserializing ();  			return ob;  		}  		return null;  	}  	catch (Exception e) {  		Radical.LogError ("Serialization error: " + e.ToString ());  		return null;  	}  	finally {  		PopKnownTypes ();  		PopPropertyNames ();  		Verbose = v;  	}  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,Deserialize,The following statement contains a magic number: using (new SerializationScope ()) {  	var v = Verbose;  	CreateStacks ();  	try {  		PushKnownTypes ();  		PushPropertyNames ();  		var rw = new BinaryReader (inputStream);  		var version = rw.ReadString ();  		currentVersion = Int32.Parse (version.Substring (4));  		if (currentVersion >= 5) {  			inputStream.Position = 0;  			var serializer = new BinarySerializer (rw.ReadBytes ((int)inputStream.Length));  			serializer.StartDeserializing ();  			var ob = DeserializeObject (new Entry () {  				Name = "root"'  				Value = instance  			}' serializer);  			serializer.FinishedDeserializing ();  			return ob;  		}  		return null;  	}  	catch (Exception e) {  		Radical.LogError ("Serialization error: " + e.ToString ());  		return null;  	}  	finally {  		PopKnownTypes ();  		PopPropertyNames ();  		Verbose = v;  	}  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,Deserialize,The following statement contains a magic number: try {  	PushKnownTypes ();  	PushPropertyNames ();  	var rw = new BinaryReader (inputStream);  	var version = rw.ReadString ();  	currentVersion = Int32.Parse (version.Substring (4));  	if (currentVersion >= 5) {  		inputStream.Position = 0;  		var serializer = new BinarySerializer (rw.ReadBytes ((int)inputStream.Length));  		serializer.StartDeserializing ();  		var ob = DeserializeObject (new Entry () {  			Name = "root"'  			Value = instance  		}' serializer);  		serializer.FinishedDeserializing ();  		return ob;  	}  	return null;  }  catch (Exception e) {  	Radical.LogError ("Serialization error: " + e.ToString ());  	return null;  }  finally {  	PopKnownTypes ();  	PopPropertyNames ();  	Verbose = v;  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,Deserialize,The following statement contains a magic number: try {  	PushKnownTypes ();  	PushPropertyNames ();  	var rw = new BinaryReader (inputStream);  	var version = rw.ReadString ();  	currentVersion = Int32.Parse (version.Substring (4));  	if (currentVersion >= 5) {  		inputStream.Position = 0;  		var serializer = new BinarySerializer (rw.ReadBytes ((int)inputStream.Length));  		serializer.StartDeserializing ();  		var ob = DeserializeObject (new Entry () {  			Name = "root"'  			Value = instance  		}' serializer);  		serializer.FinishedDeserializing ();  		return ob;  	}  	return null;  }  catch (Exception e) {  	Radical.LogError ("Serialization error: " + e.ToString ());  	return null;  }  finally {  	PopKnownTypes ();  	PopPropertyNames ();  	Verbose = v;  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,Deserialize,The following statement contains a magic number: currentVersion = Int32.Parse (version.Substring (4));  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,Deserialize,The following statement contains a magic number: if (currentVersion >= 5) {  	inputStream.Position = 0;  	var serializer = new BinarySerializer (rw.ReadBytes ((int)inputStream.Length));  	serializer.StartDeserializing ();  	var ob = DeserializeObject (new Entry () {  		Name = "root"'  		Value = instance  	}' serializer);  	serializer.FinishedDeserializing ();  	return ob;  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,SerializeArrayPart,The following statement contains a magic number: for (var l = 0; l < length; l++) {  	indices [i] = l;  	if (i != item.Rank - 2) {  		SerializeArrayPart (item' i + 1' indices' storage);  	}  	else {  		var arrayType = item.GetType ().GetElementType ();  		var cols = item.GetLength (i + 1);  		var baseArray = Array.CreateInstance (arrayType' cols);  		// Convert the whole multi-dimensional array to be 'row' based  		// and serialize using the existing code  		for (var arrayStartIndex = 0; arrayStartIndex < cols; arrayStartIndex++) {  			indices [i + 1] = arrayStartIndex;  			baseArray.SetValue (item.GetValue (indices)' arrayStartIndex);  		}  		SerializeArray (baseArray' baseArray.GetType ()' storage);  	}  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,SerializeArrayPart,The following statement contains a magic number: if (i != item.Rank - 2) {  	SerializeArrayPart (item' i + 1' indices' storage);  }  else {  	var arrayType = item.GetType ().GetElementType ();  	var cols = item.GetLength (i + 1);  	var baseArray = Array.CreateInstance (arrayType' cols);  	// Convert the whole multi-dimensional array to be 'row' based  	// and serialize using the existing code  	for (var arrayStartIndex = 0; arrayStartIndex < cols; arrayStartIndex++) {  		indices [i + 1] = arrayStartIndex;  		baseArray.SetValue (item.GetValue (indices)' arrayStartIndex);  	}  	SerializeArray (baseArray' baseArray.GetType ()' storage);  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DeserializeArrayPart,The following statement contains a magic number: for (var l = 0; l < length; l++) {  	indices [i] = l;  	if (i != sourceArrays.Rank - 2) {  		DeserializeArrayPart (sourceArrays' i + 1' indices' itemType' storage' objectID);  	}  	else {  		var sourceArray = (Array)DeserializeArray (itemType' storage' -1' objectID);  		var cols = sourceArrays.GetLength (i + 1);  		for (var arrayStartIndex = 0; arrayStartIndex < cols; arrayStartIndex++) {  			indices [i + 1] = arrayStartIndex;  			sourceArrays.SetValue (sourceArray.GetValue (arrayStartIndex)' indices);  		}  	}  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DeserializeArrayPart,The following statement contains a magic number: if (i != sourceArrays.Rank - 2) {  	DeserializeArrayPart (sourceArrays' i + 1' indices' itemType' storage' objectID);  }  else {  	var sourceArray = (Array)DeserializeArray (itemType' storage' -1' objectID);  	var cols = sourceArrays.GetLength (i + 1);  	for (var arrayStartIndex = 0; arrayStartIndex < cols; arrayStartIndex++) {  		indices [i + 1] = arrayStartIndex;  		sourceArrays.SetValue (sourceArray.GetValue (arrayStartIndex)' indices);  	}  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DeserializeDictionary,The following statement contains a magic number: if (currentVersion >= 7 && currentVersion < 9) {  	DeserializeObjectAndProperties (o' itemType' storage);  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DeserializeDictionary,The following statement contains a magic number: if (currentVersion >= 7 && currentVersion < 9) {  	DeserializeObjectAndProperties (o' itemType' storage);  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DeserializeList,The following statement contains a magic number: if (currentVersion >= 7 && currentVersion < 9) {  	DeserializeObjectAndProperties (o' itemType' storage);  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DeserializeList,The following statement contains a magic number: if (currentVersion >= 7 && currentVersion < 9) {  	DeserializeObjectAndProperties (o' itemType' storage);  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,UnitySerializer,The following statement contains a magic number: index = 50000;  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GuidReader,The following statement contains a magic number: if (currentVersion >= 10) {  	return new Guid (reader.ReadBytes (16));  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GuidReader,The following statement contains a magic number: if (currentVersion >= 10) {  	return new Guid (reader.ReadBytes (16));  }  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,GuidReader,The following statement contains a magic number: return new Guid (reader.ReadBytes (16));  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DecimalReader,The following statement contains a magic number: array [2] = (int)reader.ReadInt32 ();  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DecimalReader,The following statement contains a magic number: array [3] = (int)reader.ReadInt32 ();  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DecimalWriter,The following statement contains a magic number: writer.Write (array [2]);  
Magic Number,Serialization,UnitySerializer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\Serialization\UnitySerializer.cs,DecimalWriter,The following statement contains a magic number: writer.Write (array [3]);  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) + s1;  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Checksums\Adler32.cs,Update,The following statement contains a magic number: while (count > 0) {  	// We can defer the modulo operation:  	// s1 maximally grows from 65521 to 65521 + 255 * 3800  	// s2 maximally grows by 3800 * median(s1) = 2090079800 < 2^31  	int n = 3800;  	if (n > count) {  		n = count;  	}  	count -= n;  	while (--n >= 0) {  		s1 = s1 + (uint)(buffer [offset++] & 0xff);  		s2 = s2 + s1;  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) | s1;  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Checksums\CRC32.cs,ComputeCrc32,The following statement contains a magic number: return (uint)(Crc32.CrcTable [(oldCrc ^ value) & 0xFF] ^ (oldCrc >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Checksums\CRC32.cs,Update,The following statement contains a magic number: crc = CrcTable [(crc ^ value) & 0xFF] ^ (crc >> 8);  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Checksums\CRC32.cs,Update,The following statement contains a magic number: while (--count >= 0) {  	crc = CrcTable [(crc ^ buffer [offset++]) & 0xFF] ^ (crc >> 8);  }  
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Checksums\CRC32.cs,Update,The following statement contains a magic number: crc = CrcTable [(crc ^ buffer [offset++]) & 0xFF] ^ (crc >> 8);  
Magic Number,ICSharpCode.SharpZipLib.Checksums,StrangeCRC,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Checksums\StrangeCRC.cs,Update,The following statement contains a magic number: if (temp < 0) {  	temp = 256 + temp;  }  
Magic Number,ICSharpCode.SharpZipLib.Checksums,StrangeCRC,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Checksums\StrangeCRC.cs,Update,The following statement contains a magic number: temp = 256 + temp;  
Magic Number,ICSharpCode.SharpZipLib.Checksums,StrangeCRC,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Checksums\StrangeCRC.cs,Update,The following statement contains a magic number: globalCrc = unchecked((int)((globalCrc << 8) ^ crc32Table [temp]));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflater,The following statement contains a magic number: if (level == DEFAULT_COMPRESSION) {  	level = 6;  }  else if (level < NO_COMPRESSION || level > BEST_COMPRESSION) {  	throw new ArgumentOutOfRangeException ("level");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflater,The following statement contains a magic number: level = 6;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,SetLevel,The following statement contains a magic number: if (level == DEFAULT_COMPRESSION) {  	level = 6;  }  else if (level < NO_COMPRESSION || level > BEST_COMPRESSION) {  	throw new ArgumentOutOfRangeException ("level");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,SetLevel,The following statement contains a magic number: level = 6;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	// output header  	int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		// Dictionary was set  		header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level_flags < 0 || level_flags > 3) {  	level_flags = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level_flags < 0 || level_flags > 3) {  	level_flags = 3;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: level_flags = 3;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: header |= level_flags << 6;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if ((state & IS_SETDICT) != 0) {  	int chksum = engine.Adler;  	engine.ResetAdler ();  	pending.WriteShortMSB (chksum >> 16);  	pending.WriteShortMSB (chksum & 0xffff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteShortMSB (chksum >> 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			// We need more input now  			return origLength - length;  		}  		else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		}  		else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		// We need more input now  		return origLength - length;  	}  	else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	}  	else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	// We need more input now  	return origLength - length;  }  else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  }  else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: while (neededbits > 0) {  	/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  	neededbits -= 10;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: while (neededbits > 0) {  	/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  	neededbits -= 10;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: while (neededbits > 0) {  	/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  	neededbits -= 10;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteBits (2' 10);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteBits (2' 10);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: neededbits -= 10;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!noZlibHeaderOrFooter) {  	int adler = engine.Adler;  	pending.WriteShortMSB (adler >> 16);  	pending.WriteShortMSB (adler & 0xffff);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteShortMSB (adler >> 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflaterEngine,The following statement contains a magic number: window = new byte[2 * WSIZE];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,SetDictionary,The following statement contains a magic number: strstart += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,SetLevel,The following statement contains a magic number: if ((level < 0) || (level > 9)) {  	throw new ArgumentOutOfRangeException ("level");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,FillWindow,The following statement contains a magic number: while (lookahead < DeflaterConstants.MIN_LOOKAHEAD && inputOff < inputEnd) {  	int more = 2 * WSIZE - lookahead - strstart;  	if (more > inputEnd - inputOff) {  		more = inputEnd - inputOff;  	}  	System.Array.Copy (inputBuf' inputOff' window' strstart + lookahead' more);  	adler.Update (inputBuf' inputOff' more);  	inputOff += more;  	totalIn += more;  	lookahead += more;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: if (best_len >= this.goodLength) {  	chainLength >>= 2;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: chainLength >>= 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do {  	#if DebugDeflation  	 				if (DeflaterConstants.DEBUGGING && (curMatch >= strstart) ) 				{ 					throw new InvalidOperationException("no future"); 				} #endif  	if (window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]) {  		continue;  	}  	match = curMatch + 2;  	scan += 2;  	/* We check for insufficient lookahead only every 8th comparison; 				* the 256th check will be made at strstart + 258. 				*/while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && (scan < strend)) {  		// Do nothing  	}  	if (scan > best_end) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && (ins_h == 0) ) 						Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart)); #endif  		matchStart = curMatch;  		best_end = scan;  		best_len = scan - strstart;  		if (best_len >= niceLength) {  			break;  		}  		scan_end1 = window [best_end - 1];  		scan_end = window [best_end];  	}  	scan = strstart;  }  while ((curMatch = (prev [curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do {  	#if DebugDeflation  	 				if (DeflaterConstants.DEBUGGING && (curMatch >= strstart) ) 				{ 					throw new InvalidOperationException("no future"); 				} #endif  	if (window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]) {  		continue;  	}  	match = curMatch + 2;  	scan += 2;  	/* We check for insufficient lookahead only every 8th comparison; 				* the 256th check will be made at strstart + 258. 				*/while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && (scan < strend)) {  		// Do nothing  	}  	if (scan > best_end) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && (ins_h == 0) ) 						Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart)); #endif  		matchStart = curMatch;  		best_end = scan;  		best_len = scan - strstart;  		if (best_len >= niceLength) {  			break;  		}  		scan_end1 = window [best_end - 1];  		scan_end = window [best_end];  	}  	scan = strstart;  }  while ((curMatch = (prev [curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: match = curMatch + 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: scan += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateFast,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		// We are flushing everything  		huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart > 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int hashHead;  	if (lookahead >= MIN_MATCH && (hashHead = InsertString ()) != 0 && strategy != DeflateStrategy.HuffmanOnly && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  		// longestMatch sets matchStart and matchLen  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING)  					{ 						for (int i = 0 ; i < matchLen; i++) { 							if (window[strstart + i] != window[matchStart + i]) { 								throw new SharpZipBaseException("Match failure"); 							} 						} 					} #endif  		bool full = huffman.TallyDist (strstart - matchStart' matchLen);  		lookahead -= matchLen;  		if (matchLen <= max_lazy && lookahead >= MIN_MATCH) {  			while (--matchLen > 0) {  				++strstart;  				InsertString ();  			}  			++strstart;  		}  		else {  			strstart += matchLen;  			if (lookahead >= MIN_MATCH - 1) {  				UpdateHash ();  			}  		}  		matchLen = MIN_MATCH - 1;  		if (!full) {  			continue;  		}  	}  	else {  		// No match found  		huffman.TallyLit (window [strstart] & 0xff);  		++strstart;  		--lookahead;  	}  	if (huffman.IsFull ()) {  		bool lastBlock = finish && (lookahead == 0);  		huffman.FlushBlock (window' blockStart' strstart - blockStart' lastBlock);  		blockStart = strstart;  		return !lastBlock;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateFast,The following statement contains a magic number: if (strstart > 2 * WSIZE - MIN_LOOKAHEAD) {  	/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = false;  		// We are flushing everything  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && !flush)  					{ 						throw new SharpZipBaseException("Not flushing' but no lookahead"); 					} #endif  		huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int prevMatch = matchStart;  	int prevLen = matchLen;  	if (lookahead >= MIN_MATCH) {  		int hashHead = InsertString ();  		if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  			// longestMatch sets matchStart and matchLen  			// Discard match if too small and too far away  			if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  				matchLen = MIN_MATCH - 1;  			}  		}  	}  	// previous match was better  	if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen)) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING)  					{ 					   for (int i = 0 ; i < matchLen; i++) { 						  if (window[strstart-1+i] != window[prevMatch + i]) 							 throw new SharpZipBaseException(); 						} 					} #endif  		huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  		prevLen -= 2;  		do {  			strstart++;  			lookahead--;  			if (lookahead >= MIN_MATCH) {  				InsertString ();  			}  		}  		while (--prevLen > 0);  		strstart++;  		lookahead--;  		prevAvailable = false;  		matchLen = MIN_MATCH - 1;  	}  	else {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = true;  		strstart++;  		lookahead--;  	}  	if (huffman.IsFull ()) {  		int len = strstart - blockStart;  		if (prevAvailable) {  			len--;  		}  		bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);  		huffman.FlushBlock (window' blockStart' len' lastBlock);  		blockStart += len;  		return !lastBlock;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = false;  		// We are flushing everything  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && !flush)  					{ 						throw new SharpZipBaseException("Not flushing' but no lookahead"); 					} #endif  		huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int prevMatch = matchStart;  	int prevLen = matchLen;  	if (lookahead >= MIN_MATCH) {  		int hashHead = InsertString ();  		if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  			// longestMatch sets matchStart and matchLen  			// Discard match if too small and too far away  			if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  				matchLen = MIN_MATCH - 1;  			}  		}  	}  	// previous match was better  	if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen)) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING)  					{ 					   for (int i = 0 ; i < matchLen; i++) { 						  if (window[strstart-1+i] != window[prevMatch + i]) 							 throw new SharpZipBaseException(); 						} 					} #endif  		huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  		prevLen -= 2;  		do {  			strstart++;  			lookahead--;  			if (lookahead >= MIN_MATCH) {  				InsertString ();  			}  		}  		while (--prevLen > 0);  		strstart++;  		lookahead--;  		prevAvailable = false;  		matchLen = MIN_MATCH - 1;  	}  	else {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = true;  		strstart++;  		lookahead--;  	}  	if (huffman.IsFull ()) {  		int len = strstart - blockStart;  		if (prevAvailable) {  			len--;  		}  		bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);  		huffman.FlushBlock (window' blockStart' len' lastBlock);  		blockStart += len;  		return !lastBlock;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = false;  		// We are flushing everything  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING && !flush)  					{ 						throw new SharpZipBaseException("Not flushing' but no lookahead"); 					} #endif  		huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int prevMatch = matchStart;  	int prevLen = matchLen;  	if (lookahead >= MIN_MATCH) {  		int hashHead = InsertString ();  		if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  			// longestMatch sets matchStart and matchLen  			// Discard match if too small and too far away  			if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  				matchLen = MIN_MATCH - 1;  			}  		}  	}  	// previous match was better  	if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen)) {  		#if DebugDeflation  							if (DeflaterConstants.DEBUGGING)  					{ 					   for (int i = 0 ; i < matchLen; i++) { 						  if (window[strstart-1+i] != window[prevMatch + i]) 							 throw new SharpZipBaseException(); 						} 					} #endif  		huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  		prevLen -= 2;  		do {  			strstart++;  			lookahead--;  			if (lookahead >= MIN_MATCH) {  				InsertString ();  			}  		}  		while (--prevLen > 0);  		strstart++;  		lookahead--;  		prevAvailable = false;  		matchLen = MIN_MATCH - 1;  	}  	else {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = true;  		strstart++;  		lookahead--;  	}  	if (huffman.IsFull ()) {  		int len = strstart - blockStart;  		if (prevAvailable) {  			len--;  		}  		bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);  		huffman.FlushBlock (window' blockStart' len' lastBlock);  		blockStart += len;  		return !lastBlock;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  	/* slide window' as FindLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (lookahead >= MIN_MATCH) {  	int hashHead = InsertString ();  	if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  		// longestMatch sets matchStart and matchLen  		// Discard match if too small and too far away  		if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  			matchLen = MIN_MATCH - 1;  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  	// longestMatch sets matchStart and matchLen  	// Discard match if too small and too far away  	if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  		matchLen = MIN_MATCH - 1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  	matchLen = MIN_MATCH - 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen)) {  	#if DebugDeflation  						if (DeflaterConstants.DEBUGGING)  					{ 					   for (int i = 0 ; i < matchLen; i++) { 						  if (window[strstart-1+i] != window[prevMatch + i]) 							 throw new SharpZipBaseException(); 						} 					} #endif  	huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  	prevLen -= 2;  	do {  		strstart++;  		lookahead--;  		if (lookahead >= MIN_MATCH) {  			InsertString ();  		}  	}  	while (--prevLen > 0);  	strstart++;  	lookahead--;  	prevAvailable = false;  	matchLen = MIN_MATCH - 1;  }  else {  	if (prevAvailable) {  		huffman.TallyLit (window [strstart - 1] & 0xff);  	}  	prevAvailable = true;  	strstart++;  	lookahead--;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: prevLen -= 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  	staticLCodes [i] = BitReverse ((0x030 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  	staticLCodes [i] = BitReverse ((0x030 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  	staticLCodes [i] = BitReverse ((0x030 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x030 + i) << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 9;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 7;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  	staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  	staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  	staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++) {  	staticDCodes [i] = BitReverse (i << 11);  	staticDLength [i] = 5;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++) {  	staticDCodes [i] = BitReverse (i << 11);  	staticDLength [i] = 5;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticDCodes [i] = BitReverse (i << 11);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticDLength [i] = 5;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree (this' LITERAL_NUM' 257' 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree (this' LITERAL_NUM' 257' 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: distTree = new Tree (this' DIST_NUM' 1' 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree (this' BITLEN_NUM' 4' 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree (this' BITLEN_NUM' 4' 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (literalTree.numCodes - 257' 5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (literalTree.numCodes - 257' 5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (distTree.numCodes - 1' 5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (blTreeCodes - 4' 4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (blTreeCodes - 4' 4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: for (int rank = 0; rank < blTreeCodes; rank++) {  	pending.WriteBits (blTree.length [BL_ORDER [rank]]' 3);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (blTree.length [BL_ORDER [rank]]' 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	}  	else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  }  else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (bits > 0 && bits <= 5) {  	pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: bits = dc / 2 - 1;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,FlushStoredBlock,The following statement contains a magic number: pending.WriteBits ((DeflaterConstants.STORED_BLOCK << 1) + (lastBlock ? 1 : 0)' 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: for (int i = 18; i > blTreeCodes; i--) {  	if (blTree.length [BL_ORDER [i]] > 0) {  		blTreeCodes = i + 1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	// Store Block  	//				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	// Store Block  	//				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	// Store Block  	//				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  	// Store Block  	//				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  }  else if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (opt_len == static_len) {  	// Encode with static tree  	pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  }  else {  	// Encode with dynamic tree  	pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: l_buf [last_lit++] = (byte)(length - 3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: extra_bits += (lc - 261) / 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: extra_bits += (lc - 261) / 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (dc >= 4) {  	extra_bits += dc / 2 - 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (dc >= 4) {  	extra_bits += dc / 2 - 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: extra_bits += dc / 2 - 1;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: if (length == 255) {  	return 285;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: if (length == 255) {  	return 285;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: return 285;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: while (length >= 8) {  	code += 4;  	length >>= 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: while (length >= 8) {  	code += 4;  	length >>= 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: code += 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: while (distance >= 4) {  	code += 2;  	distance >>= 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: while (distance >= 4) {  	code += 2;  	distance >>= 1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: code += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: input.DropBits (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if (header % 31 != 0) {  	throw new SharpZipBaseException ("Header checksum illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0f00) != (Deflater.DEFLATED << 8)) {  	throw new SharpZipBaseException ("Compression Method unknown");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0020) == 0) {  	// Dictionary flag?  	mode = DECODE_BLOCKS;  }  else {  	mode = DECODE_DICT;  	neededBits = 32;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: neededBits = 32;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: input.DropBits (8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: readAdler = (readAdler << 8) | dictByte;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: neededBits -= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		// This is the inner loop so it is optimized a bit  		while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			}  			else {  				// symbol == 256: end of block  				distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	// fall through  	case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	// fall through  	case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		}  		catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	// fall through  	case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	// This is the inner loop so it is optimized a bit  	while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		}  		else {  			// symbol == 256: end of block  			distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  // fall through  case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  // fall through  case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	}  	catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  // fall through  case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  	outputWindow.Write (symbol);  	if (--free < 258) {  		return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: if (--free < 258) {  	return true;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: if (symbol < 257) {  	if (symbol < 0) {  		return false;  	}  	else {  		// symbol == 256: end of block  		distTree = null;  		litlenTree = null;  		mode = DECODE_BLOCKS;  		return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: try {  	repLength = CPLENS [symbol - 257];  	neededBits = CPLEXT [symbol - 257];  }  catch (Exception) {  	throw new SharpZipBaseException ("Illegal rep length code");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: try {  	repLength = CPLENS [symbol - 257];  	neededBits = CPLEXT [symbol - 257];  }  catch (Exception) {  	throw new SharpZipBaseException ("Illegal rep length code");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: repLength = CPLENS [symbol - 257];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: neededBits = CPLEXT [symbol - 257];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: input.DropBits (8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: readAdler = (readAdler << 8) | chkByte;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: neededBits -= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		}  		else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  // fall through  case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  // fall through  case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  // fall through  case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,Decode,The following statement contains a magic number: if (isLastBlock) {  	if (noHeader) {  		mode = FINISHED;  		return false;  	}  	else {  		input.SkipToByteBoundary ();  		neededBits = 32;  		mode = DECODE_CHKSUM;  		return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,Decode,The following statement contains a magic number: if (noHeader) {  	mode = FINISHED;  	return false;  }  else {  	input.SkipToByteBoundary ();  	neededBits = 32;  	mode = DECODE_CHKSUM;  	return true;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,Decode,The following statement contains a magic number: neededBits = 32;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,Decode,The following statement contains a magic number: input.DropBits (3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,Decode,The following statement contains a magic number: if ((uncomprLen = input.PeekBits (16)) < 0) {  	return false;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,Decode,The following statement contains a magic number: input.DropBits (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Inflater.cs,Decode,The following statement contains a magic number: input.DropBits (16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			}  			else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: lnum = input.PeekBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: lnum += 257;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: dnum = input.PeekBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (5);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blnum = input.PeekBits (4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blnum += 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blLens = new byte[19];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (ptr < blnum) {  	int len = input.PeekBits (3);  	if (len < 0) {  		return false;  	}  	input.DropBits (3);  	//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  	blLens [BL_ORDER [ptr]] = (byte)len;  	ptr++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (ptr < blnum) {  	int len = input.PeekBits (3);  	if (len < 0) {  		return false;  	}  	input.DropBits (3);  	//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  	blLens [BL_ORDER [ptr]] = (byte)len;  	ptr++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (3);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  	/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  	litdistLens [ptr++] = lastLen = (byte)symbol;  	if (ptr == num) {  		/* Finished */return true;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: if (symbol >= 17) {  	/* repeat zero *///  		  System.err.println("repeating zero");  	lastLen = 0;  }  else {  	if (ptr == 0) {  		throw new SharpZipBaseException ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: repSymbol = symbol - 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  }  catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 144) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 144) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 256) {  	codeLengths [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 256) {  	codeLengths [i++] = 9;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 9;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 280) {  	codeLengths [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 280) {  	codeLengths [i++] = 7;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 7;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 288) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 288) {  	codeLengths [i++] = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths = new byte[32];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 32) {  	codeLengths [i++] = 5;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 32) {  	codeLengths [i++] = 5;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 5;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: code += blCount [bits] << (16 - bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits >= 10) {  	/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  	int end = code & 0x1ff80;  	treeSize += (end - start) >> (16 - bits);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits >= 10) {  	/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  	int end = code & 0x1ff80;  	treeSize += (end - start) >> (16 - bits);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: treeSize += (end - start) >> (16 - bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: code -= blCount [bits] << (16 - bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: i += 1 << 7
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: treePtr += 1 << (bits - 9);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < 512);  	}  	else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		}  		while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < 512);  }  else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	}  	while (revcode < treeLen);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [revcode] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < 512);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [revcode] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < 512);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [revcode] = (short)((i << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: subTree = -(subTree >> 4);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < treeLen);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  	revcode += 1 << bits;  }  while (revcode < treeLen);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: nextCode [bits] = code + (1 << (16 - bits));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		}  		else {  			return -1;  		}  	}  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol = tree [lookahead]) >= 0) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol = tree [lookahead]) >= 0) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	else {  		return -1;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: symbol = tree [subtree | (lookahead >> 9)];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: symbol = tree [subtree | (lookahead >> 9)];  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  else {  	return -1;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,WriteShort,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(value >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(value >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(value >> 16));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(value >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0) {  	buffer_ [end++] = unchecked((byte)bits);  	if (bitCount > 8) {  		buffer_ [end++] = unchecked((byte)(bits >> 8));  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0) {  	buffer_ [end++] = unchecked((byte)bits);  	if (bitCount > 8) {  		buffer_ [end++] = unchecked((byte)(bits >> 8));  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 8) {  	buffer_ [end++] = unchecked((byte)(bits >> 8));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 8) {  	buffer_ [end++] = unchecked((byte)(bits >> 8));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(bits >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buffer_ [end++] = unchecked((byte)bits);  	buffer_ [end++] = unchecked((byte)(bits >> 8));  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buffer_ [end++] = unchecked((byte)bits);  	buffer_ [end++] = unchecked((byte)(bits >> 8));  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buffer_ [end++] = unchecked((byte)bits);  	buffer_ [end++] = unchecked((byte)(bits >> 8));  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buffer_ [end++] = unchecked((byte)bits);  	buffer_ [end++] = unchecked((byte)(bits >> 8));  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(bits >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: bits >>= 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: bitCount -= 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,WriteShortMSB,The following statement contains a magic number: buffer_ [end++] = unchecked((byte)(s >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  	buffer_ [end++] = unchecked((byte)bits);  	bits >>= 8;  	bitCount -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  	buffer_ [end++] = unchecked((byte)bits);  	bits >>= 8;  	bitCount -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  	buffer_ [end++] = unchecked((byte)bits);  	bits >>= 8;  	bitCount -= 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: bits >>= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: bitCount -= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\DeflaterOutputStream.cs,DeflaterOutputStream,The following statement contains a magic number: if (bufferSize < 512) {  	throw new ArgumentOutOfRangeException ("bufferSize");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\InflaterInputStream.cs,InflaterInputBuffer,The following statement contains a magic number: if (bufferSize < 1024) {  	bufferSize = 1024;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\InflaterInputStream.cs,InflaterInputBuffer,The following statement contains a magic number: if (bufferSize < 1024) {  	bufferSize = 1024;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\InflaterInputStream.cs,InflaterInputBuffer,The following statement contains a magic number: bufferSize = 1024;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\InflaterInputStream.cs,ReadLeShort,The following statement contains a magic number: return ReadLeByte () | (ReadLeByte () << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\InflaterInputStream.cs,ReadLeInt,The following statement contains a magic number: return ReadLeShort () | (ReadLeShort () << 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\InflaterInputStream.cs,ReadLeLong,The following statement contains a magic number: return (uint)ReadLeInt () | ((long)ReadLeInt () << 32);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\InflaterInputStream.cs,Skip,The following statement contains a magic number: if (baseInputStream.CanSeek) {  	baseInputStream.Seek (count' SeekOrigin.Current);  	return count;  }  else {  	int length = 2048;  	if (count < length) {  		length = (int)count;  	}  	byte[] tmp = new byte[length];  	int readCount = 1;  	long toSkip = count;  	while ((toSkip > 0) && (readCount > 0)) {  		if (toSkip < length) {  			length = (int)toSkip;  		}  		readCount = baseInputStream.Read (tmp' 0' length);  		toSkip -= readCount;  	}  	return count - toSkip;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount) {  	if (windowStart_ == windowEnd_) {  		return -1;  		// ok  	}  	buffer_ |= (uint)((window_ [windowStart_++] & 0xff | (window_ [windowStart_++] & 0xff) << 8) << bitsInBuffer_);  	bitsInBuffer_ += 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount) {  	if (windowStart_ == windowEnd_) {  		return -1;  		// ok  	}  	buffer_ |= (uint)((window_ [windowStart_++] & 0xff | (window_ [windowStart_++] & 0xff) << 8) << bitsInBuffer_);  	bitsInBuffer_ += 16;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: buffer_ |= (uint)((window_ [windowStart_++] & 0xff | (window_ [windowStart_++] & 0xff) << 8) << bitsInBuffer_);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: bitsInBuffer_ += 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: buffer_ >>= (bitsInBuffer_ & 7);  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: bitsInBuffer_ &= ~7;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if ((bitsInBuffer_ & 7) != 0) {  	// bits_in_buffer may only be 0 or a multiple of 8  	throw new InvalidOperationException ("Bit buffer is not byte aligned!");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0)) {  	output [offset++] = (byte)buffer_;  	buffer_ >>= 8;  	bitsInBuffer_ -= 8;  	length--;  	count++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0)) {  	output [offset++] = (byte)buffer_;  	buffer_ >>= 8;  	bitsInBuffer_ -= 8;  	length--;  	count++;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: buffer_ >>= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: bitsInBuffer_ -= 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if (((windowStart_ - windowEnd_) & 1) != 0) {  	// We always want an even number of bytes in input' see peekBits  	buffer_ = (uint)(window_ [windowStart_++] & 0xff);  	bitsInBuffer_ = 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: bitsInBuffer_ = 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\StreamManipulator.cs,SetInput,The following statement contains a magic number: if ((count & 1) != 0) {  	// We always want an even number of bytes in input' see PeekBits  	buffer_ |= (uint)((buffer [offset++] & 0xff) << bitsInBuffer_);  	bitsInBuffer_ += 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\Streams\StreamManipulator.cs,SetInput,The following statement contains a magic number: bitsInBuffer_ += 8;  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  	newKeys [0] = Crc32.ComputeCrc32 (newKeys [0]' seed [i]);  	newKeys [1] = newKeys [1] + (byte)newKeys [0];  	newKeys [1] = newKeys [1] * 134775813 + 1;  	newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  	newKeys [0] = Crc32.ComputeCrc32 (newKeys [0]' seed [i]);  	newKeys [1] = newKeys [1] + (byte)newKeys [0];  	newKeys [1] = newKeys [1] * 134775813 + 1;  	newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  	newKeys [0] = Crc32.ComputeCrc32 (newKeys [0]' seed [i]);  	newKeys [1] = newKeys [1] + (byte)newKeys [0];  	newKeys [1] = newKeys [1] * 134775813 + 1;  	newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i) {  	newKeys [0] = Crc32.ComputeCrc32 (newKeys [0]' seed [i]);  	newKeys [1] = newKeys [1] + (byte)newKeys [0];  	newKeys [1] = newKeys [1] * 134775813 + 1;  	newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: newKeys [1] = newKeys [1] * 134775813 + 1;  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: newKeys [2] = Crc32.ComputeCrc32 (newKeys [2]' (byte)(newKeys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [1] = (byte)((newKeys [0] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [2] = (byte)((newKeys [0] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [2] = (byte)((newKeys [0] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [3] = (byte)((newKeys [0] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [3] = (byte)((newKeys [0] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [4] = (byte)(newKeys [1] & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [5] = (byte)((newKeys [1] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [5] = (byte)((newKeys [1] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [6] = (byte)((newKeys [1] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [6] = (byte)((newKeys [1] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [7] = (byte)((newKeys [1] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [7] = (byte)((newKeys [1] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [8] = (byte)(newKeys [2] & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [8] = (byte)(newKeys [2] & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [9] = (byte)((newKeys [2] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [9] = (byte)((newKeys [2] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [9] = (byte)((newKeys [2] >> 8) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [10] = (byte)((newKeys [2] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [10] = (byte)((newKeys [2] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [10] = (byte)((newKeys [2] >> 16) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [11] = (byte)((newKeys [2] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [11] = (byte)((newKeys [2] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result [11] = (byte)((newKeys [2] >> 24) & 0xff);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,TransformByte,The following statement contains a magic number: return (byte)((temp * (temp ^ 1)) >> 8);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: if (keyData.Length != 12) {  	throw new InvalidOperationException ("Key length is not valid");  }  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys = new uint[3];  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [0] = (uint)((keyData [3] << 24) | (keyData [2] << 16) | (keyData [1] << 8) | keyData [0]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [1] = (uint)((keyData [7] << 24) | (keyData [6] << 16) | (keyData [5] << 8) | keyData [4]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys [2] = (uint)((keyData [11] << 24) | (keyData [10] << 16) | (keyData [9] << 8) | keyData [8]);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys [1] = keys [1] * 134775813 + 1;  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys [2] = Crc32.ComputeCrc32 (keys [2]' (byte)(keys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys [2] = Crc32.ComputeCrc32 (keys [2]' (byte)(keys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys [2] = Crc32.ComputeCrc32 (keys [2]' (byte)(keys [1] >> 24));  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,Reset,The following statement contains a magic number: keys [2] = 0;  
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicManaged,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\PkzipClassic.cs,GenerateKey,The following statement contains a magic number: key_ = new byte[12];  
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\ZipAESStream.cs,ZipAESStream,The following statement contains a magic number: _slideBuffer = new byte[1024];  
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (blockSize != 16 && blockSize != 32)  	// 24 valid for AES but not supported by Winzip  	throw new Exception ("Invalid blocksize " + blockSize + ". Must be 16 or 32.");  
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (blockSize != 16 && blockSize != 32)  	// 24 valid for AES but not supported by Winzip  	throw new Exception ("Invalid blocksize " + blockSize + ". Must be 16 or 32.");  
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (saltBytes.Length != blockSize / 2)  	throw new Exception ("Invalid salt len. Must be " + blockSize / 2 + " for blocksize " + blockSize);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: if (saltBytes.Length != blockSize / 2)  	throw new Exception ("Invalid salt len. Must be " + blockSize / 2 + " for blocksize " + blockSize);  
Magic Number,ICSharpCode.SharpZipLib.Encryption,ZipAESTransform,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Encryption\ZipAESTransform.cs,ZipAESTransform,The following statement contains a magic number: throw new Exception ("Invalid salt len. Must be " + blockSize / 2 + " for blocksize " + blockSize);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ZipEntry,The following statement contains a magic number: if ((versionRequiredToExtract != 0) && (versionRequiredToExtract < 10)) {  	throw new ArgumentOutOfRangeException ("versionRequiredToExtract");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (0x0001)) {  	// Version required to extract is ignored here as some archivers dont set it correctly  	// in theory it should be version 45 or higher  	// The recorded size will change but remember that this is zip64.  	forceZip64_ = true;  	if (extraData.ValueLength < 4) {  		throw new Exception ("Extra data extended Zip64 information length is invalid");  	}  	if (localHeader || (size == uint.MaxValue)) {  		size = (ulong)extraData.ReadLong ();  	}  	if (localHeader || (compressedSize == uint.MaxValue)) {  		compressedSize = (ulong)extraData.ReadLong ();  	}  	if (!localHeader && (offset == uint.MaxValue)) {  		offset = extraData.ReadLong ();  	}  	// Disk number on which file starts is ignored  }  else {  	if (((versionToExtract & 0xff) >= ZipConstants.VersionZip64) && ((size == uint.MaxValue) || (compressedSize == uint.MaxValue))) {  		throw new Exception ("Zip64 Extended information required but is missing.");  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.ValueLength < 4) {  	throw new Exception ("Extra data extended Zip64 information length is invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new Exception ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				extraData.ReadLong ();  				extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new Exception ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				extraData.ReadLong ();  				extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new Exception ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				extraData.ReadLong ();  				extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new Exception ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				extraData.ReadLong ();  				extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new Exception ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				extraData.ReadLong ();  				extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (10)) {  	// No room for any tags.  	if (extraData.ValueLength < 4) {  		throw new Exception ("NTFS Extra data invalid");  	}  	extraData.ReadInt ();  	// Reserved  	while (extraData.UnreadCount >= 4) {  		int ntfsTag = extraData.ReadShort ();  		int ntfsLength = extraData.ReadShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModification = extraData.ReadLong ();  				extraData.ReadLong ();  				extraData.ReadLong ();  				DateTime = System.DateTime.FromFileTime (lastModification);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			extraData.Skip (ntfsLength);  		}  	}  }  else if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.ValueLength < 4) {  	throw new Exception ("NTFS Extra data invalid");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: while (extraData.UnreadCount >= 4) {  	int ntfsTag = extraData.ReadShort ();  	int ntfsLength = extraData.ReadShort ();  	if (ntfsTag == 1) {  		if (ntfsLength >= 24) {  			long lastModification = extraData.ReadLong ();  			extraData.ReadLong ();  			extraData.ReadLong ();  			DateTime = System.DateTime.FromFileTime (lastModification);  		}  		break;  	}  	else {  		// An unknown NTFS tag so simply skip it.  		extraData.Skip (ntfsLength);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: while (extraData.UnreadCount >= 4) {  	int ntfsTag = extraData.ReadShort ();  	int ntfsLength = extraData.ReadShort ();  	if (ntfsTag == 1) {  		if (ntfsLength >= 24) {  			long lastModification = extraData.ReadLong ();  			extraData.ReadLong ();  			extraData.ReadLong ();  			DateTime = System.DateTime.FromFileTime (lastModification);  		}  		break;  	}  	else {  		// An unknown NTFS tag so simply skip it.  		extraData.Skip (ntfsLength);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (ntfsTag == 1) {  	if (ntfsLength >= 24) {  		long lastModification = extraData.ReadLong ();  		extraData.ReadLong ();  		extraData.ReadLong ();  		DateTime = System.DateTime.FromFileTime (lastModification);  	}  	break;  }  else {  	// An unknown NTFS tag so simply skip it.  	extraData.Skip (ntfsLength);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (ntfsLength >= 24) {  	long lastModification = extraData.ReadLong ();  	extraData.ReadLong ();  	extraData.ReadLong ();  	DateTime = System.DateTime.FromFileTime (lastModification);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (extraData.Find (0x5455)) {  	int length = extraData.ValueLength;  	int flags = extraData.ReadByte ();  	// Can include other times but these are ignored.  Length of data should  	// actually be 1 + 4 * no of bits in flags.  	if (((flags & 1) != 0) && (length >= 5)) {  		int iTime = extraData.ReadInt ();  		DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (((flags & 1) != 0) && (length >= 5)) {  	int iTime = extraData.ReadInt ();  	DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if (((flags & 1) != 0) && (length >= 5)) {  	int iTime = extraData.ReadInt ();  	DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: DateTime = (new System.DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessAESExtraData,The following statement contains a magic number: if (extraData.Find (0x9901)) {  	// Set version and flag for Zipfile.CreateAndInitDecryptionStream  	versionToExtract = ZipConstants.VERSION_AES;  	// Ver 5.1 = AES see "Version" getter  	// Set StrongEncryption flag for ZipFile.CreateAndInitDecryptionStream  	Flags = Flags | (int)GeneralBitFlags.StrongEncryption;  	//  	// Unpack AES extra data field see http://www.winzip.com/aes_info.htm  	int length = extraData.ValueLength;  	// Data size currently 7  	if (length < 7)  		throw new Exception ("AES Extra Data Length " + length + " invalid.");  	extraData.ReadShort ();  	// Version number (1=AE-1 2=AE-2)  	extraData.ReadShort ();  	// 2-character vendor ID 0x4541 = "AE"  	extraData.ReadByte ();  	// encryption strength 1 = 128 2 = 192 3 = 256  	int actualCompress = extraData.ReadShort ();  	// The actual compression method used to compress the file  	//_aesVer = ver;  	//_aesEncryptionStrength = encrStrength;  	method = (CompressionMethod)actualCompress;  }  else  	throw new Exception ("AES Extra Data missing");  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipEntry.cs,ProcessAESExtraData,The following statement contains a magic number: if (length < 7)  	throw new Exception ("AES Extra Data Length " + length + " invalid.");  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		// bit 0           if set' modification time is present  		// bit 1           if set' access time is present  		// bit 2           if set' creation time is present  		_flags = (Flags)helperStream.ReadByte ();  		if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  			int iTime = helperStream.ReadLEInt ();  			_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.AccessTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.CreateTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		// bit 0           if set' modification time is present  		// bit 1           if set' access time is present  		// bit 2           if set' creation time is present  		_flags = (Flags)helperStream.ReadByte ();  		if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  			int iTime = helperStream.ReadLEInt ();  			_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.AccessTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.CreateTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		// bit 0           if set' modification time is present  		// bit 1           if set' access time is present  		// bit 2           if set' creation time is present  		_flags = (Flags)helperStream.ReadByte ();  		if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  			int iTime = helperStream.ReadLEInt ();  			_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.AccessTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.CreateTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		// bit 0           if set' modification time is present  		// bit 1           if set' access time is present  		// bit 2           if set' creation time is present  		_flags = (Flags)helperStream.ReadByte ();  		if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  			int iTime = helperStream.ReadLEInt ();  			_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.AccessTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  		if ((_flags & Flags.CreateTime) != 0) {  			int iTime = helperStream.ReadLEInt ();  			_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	// bit 0           if set' modification time is present  	// bit 1           if set' access time is present  	// bit 2           if set' creation time is present  	_flags = (Flags)helperStream.ReadByte ();  	if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  		int iTime = helperStream.ReadLEInt ();  		_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.AccessTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.CreateTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	// bit 0           if set' modification time is present  	// bit 1           if set' access time is present  	// bit 2           if set' creation time is present  	_flags = (Flags)helperStream.ReadByte ();  	if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  		int iTime = helperStream.ReadLEInt ();  		_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.AccessTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.CreateTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	// bit 0           if set' modification time is present  	// bit 1           if set' access time is present  	// bit 2           if set' creation time is present  	_flags = (Flags)helperStream.ReadByte ();  	if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  		int iTime = helperStream.ReadLEInt ();  		_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.AccessTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.CreateTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	// bit 0           if set' modification time is present  	// bit 1           if set' access time is present  	// bit 2           if set' creation time is present  	_flags = (Flags)helperStream.ReadByte ();  	if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  		int iTime = helperStream.ReadLEInt ();  		_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.AccessTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  	if ((_flags & Flags.CreateTime) != 0) {  		int iTime = helperStream.ReadLEInt ();  		_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  	int iTime = helperStream.ReadLEInt ();  	_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: if (((_flags & Flags.ModificationTime) != 0) && (count >= 5)) {  	int iTime = helperStream.ReadLEInt ();  	_modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: _modificationTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: if ((_flags & Flags.AccessTime) != 0) {  	int iTime = helperStream.ReadLEInt ();  	_lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: _lastAccessTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: if ((_flags & Flags.CreateTime) != 0) {  	int iTime = helperStream.ReadLEInt ();  	_createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: _createTime = (new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime () + new TimeSpan (0' 0' 0' iTime' 0)).ToLocalTime ();  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ())  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.IsStreamOwner = false;  		helperStream.WriteByte ((byte)_flags);  		// Flags  		if ((_flags & Flags.ModificationTime) != 0) {  			TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.AccessTime) != 0) {  			TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.CreateTime) != 0) {  			TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		return ms.ToArray ();  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ())  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.IsStreamOwner = false;  		helperStream.WriteByte ((byte)_flags);  		// Flags  		if ((_flags & Flags.ModificationTime) != 0) {  			TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.AccessTime) != 0) {  			TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.CreateTime) != 0) {  			TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		return ms.ToArray ();  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ())  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.IsStreamOwner = false;  		helperStream.WriteByte ((byte)_flags);  		// Flags  		if ((_flags & Flags.ModificationTime) != 0) {  			TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.AccessTime) != 0) {  			TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		if ((_flags & Flags.CreateTime) != 0) {  			TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  			int seconds = (int)span.TotalSeconds;  			helperStream.WriteLEInt (seconds);  		}  		return ms.ToArray ();  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,GetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.IsStreamOwner = false;  	helperStream.WriteByte ((byte)_flags);  	// Flags  	if ((_flags & Flags.ModificationTime) != 0) {  		TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.AccessTime) != 0) {  		TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.CreateTime) != 0) {  		TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	return ms.ToArray ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,GetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.IsStreamOwner = false;  	helperStream.WriteByte ((byte)_flags);  	// Flags  	if ((_flags & Flags.ModificationTime) != 0) {  		TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.AccessTime) != 0) {  		TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.CreateTime) != 0) {  		TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	return ms.ToArray ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,GetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.IsStreamOwner = false;  	helperStream.WriteByte ((byte)_flags);  	// Flags  	if ((_flags & Flags.ModificationTime) != 0) {  		TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.AccessTime) != 0) {  		TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	if ((_flags & Flags.CreateTime) != 0) {  		TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  		int seconds = (int)span.TotalSeconds;  		helperStream.WriteLEInt (seconds);  	}  	return ms.ToArray ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,GetData,The following statement contains a magic number: if ((_flags & Flags.ModificationTime) != 0) {  	TimeSpan span = _modificationTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  	int seconds = (int)span.TotalSeconds;  	helperStream.WriteLEInt (seconds);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,GetData,The following statement contains a magic number: if ((_flags & Flags.AccessTime) != 0) {  	TimeSpan span = _lastAccessTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  	int seconds = (int)span.TotalSeconds;  	helperStream.WriteLEInt (seconds);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,GetData,The following statement contains a magic number: if ((_flags & Flags.CreateTime) != 0) {  	TimeSpan span = _createTime.ToUniversalTime () - new DateTime (1970' 1' 1' 0' 0' 0).ToUniversalTime ();  	int seconds = (int)span.TotalSeconds;  	helperStream.WriteLEInt (seconds);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return ((value >= new DateTime (1901' 12' 13' 20' 45' 52)) || (value <= new DateTime (2038' 1' 19' 03' 14' 07)));  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data' index' count' false))  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.ReadLEInt ();  		// Reserved  		while (helperStream.Position < helperStream.Length) {  			int ntfsTag = helperStream.ReadLEShort ();  			int ntfsLength = helperStream.ReadLEShort ();  			if (ntfsTag == 1) {  				if (ntfsLength >= 24) {  					long lastModificationTicks = helperStream.ReadLELong ();  					_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  					long lastAccessTicks = helperStream.ReadLELong ();  					_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  					long createTimeTicks = helperStream.ReadLELong ();  					_createTime = DateTime.FromFileTime (createTimeTicks);  				}  				break;  			}  			else {  				// An unknown NTFS tag so simply skip it.  				helperStream.Seek (ntfsLength' SeekOrigin.Current);  			}  		}  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.ReadLEInt ();  	// Reserved  	while (helperStream.Position < helperStream.Length) {  		int ntfsTag = helperStream.ReadLEShort ();  		int ntfsLength = helperStream.ReadLEShort ();  		if (ntfsTag == 1) {  			if (ntfsLength >= 24) {  				long lastModificationTicks = helperStream.ReadLELong ();  				_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  				long lastAccessTicks = helperStream.ReadLELong ();  				_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  				long createTimeTicks = helperStream.ReadLELong ();  				_createTime = DateTime.FromFileTime (createTimeTicks);  			}  			break;  		}  		else {  			// An unknown NTFS tag so simply skip it.  			helperStream.Seek (ntfsLength' SeekOrigin.Current);  		}  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: while (helperStream.Position < helperStream.Length) {  	int ntfsTag = helperStream.ReadLEShort ();  	int ntfsLength = helperStream.ReadLEShort ();  	if (ntfsTag == 1) {  		if (ntfsLength >= 24) {  			long lastModificationTicks = helperStream.ReadLELong ();  			_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  			long lastAccessTicks = helperStream.ReadLELong ();  			_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  			long createTimeTicks = helperStream.ReadLELong ();  			_createTime = DateTime.FromFileTime (createTimeTicks);  		}  		break;  	}  	else {  		// An unknown NTFS tag so simply skip it.  		helperStream.Seek (ntfsLength' SeekOrigin.Current);  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: if (ntfsTag == 1) {  	if (ntfsLength >= 24) {  		long lastModificationTicks = helperStream.ReadLELong ();  		_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  		long lastAccessTicks = helperStream.ReadLELong ();  		_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  		long createTimeTicks = helperStream.ReadLELong ();  		_createTime = DateTime.FromFileTime (createTimeTicks);  	}  	break;  }  else {  	// An unknown NTFS tag so simply skip it.  	helperStream.Seek (ntfsLength' SeekOrigin.Current);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetData,The following statement contains a magic number: if (ntfsLength >= 24) {  	long lastModificationTicks = helperStream.ReadLELong ();  	_lastModificationTime = DateTime.FromFileTime (lastModificationTicks);  	long lastAccessTicks = helperStream.ReadLELong ();  	_lastAccessTime = DateTime.FromFileTime (lastAccessTicks);  	long createTimeTicks = helperStream.ReadLELong ();  	_createTime = DateTime.FromFileTime (createTimeTicks);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ())  	using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  		helperStream.IsStreamOwner = false;  		helperStream.WriteLEInt (0);  		// Reserved  		helperStream.WriteLEShort (1);  		// Tag  		helperStream.WriteLEShort (24);  		// Length = 3 x 8.  		helperStream.WriteLELong (_lastModificationTime.ToFileTime ());  		helperStream.WriteLELong (_lastAccessTime.ToFileTime ());  		helperStream.WriteLELong (_createTime.ToFileTime ());  		return ms.ToArray ();  	}  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,GetData,The following statement contains a magic number: using (ZipHelperStream helperStream = new ZipHelperStream (ms)) {  	helperStream.IsStreamOwner = false;  	helperStream.WriteLEInt (0);  	// Reserved  	helperStream.WriteLEShort (1);  	// Tag  	helperStream.WriteLEShort (24);  	// Length = 3 x 8.  	helperStream.WriteLELong (_lastModificationTime.ToFileTime ());  	helperStream.WriteLELong (_lastAccessTime.ToFileTime ());  	helperStream.WriteLELong (_createTime.ToFileTime ());  	return ms.ToArray ();  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,GetData,The following statement contains a magic number: helperStream.WriteLEShort (24);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,Find,The following statement contains a magic number: while ((localTag != headerID) && (_index < _data.Length - 3)) {  	localTag = ReadShortInternal ();  	localLength = ReadShortInternal ();  	if (localTag != headerID) {  		_index += localLength;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,AddEntry,The following statement contains a magic number: if (Find (headerID)) {  	newLength -= (ValueLength + 4);  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,AddEntry,The following statement contains a magic number: newLength -= (ValueLength + 4);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,AddLeShort,The following statement contains a magic number: unchecked {  	_newEntry.WriteByte ((byte)toAdd);  	_newEntry.WriteByte ((byte)(toAdd >> 8));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,AddLeShort,The following statement contains a magic number: _newEntry.WriteByte ((byte)(toAdd >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,AddLeInt,The following statement contains a magic number: unchecked {  	AddLeShort ((short)toAdd);  	AddLeShort ((short)(toAdd >> 16));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,AddLeInt,The following statement contains a magic number: AddLeShort ((short)(toAdd >> 16));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,AddLeLong,The following statement contains a magic number: unchecked {  	AddLeInt ((int)(toAdd & 0xffffffff));  	AddLeInt ((int)(toAdd >> 32));  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,AddLeLong,The following statement contains a magic number: AddLeInt ((int)(toAdd >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,Delete,The following statement contains a magic number: if (Find (headerID)) {  	result = true;  	int trueStart = _readValueStart - 4;  	byte[] newData = new byte[_data.Length - (ValueLength + 4)];  	Array.Copy (_data' 0' newData' 0' trueStart);  	int trueEnd = trueStart + ValueLength + 4;  	Array.Copy (_data' trueEnd' newData' trueStart' _data.Length - trueEnd);  	_data = newData;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,Delete,The following statement contains a magic number: if (Find (headerID)) {  	result = true;  	int trueStart = _readValueStart - 4;  	byte[] newData = new byte[_data.Length - (ValueLength + 4)];  	Array.Copy (_data' 0' newData' 0' trueStart);  	int trueEnd = trueStart + ValueLength + 4;  	Array.Copy (_data' trueEnd' newData' trueStart' _data.Length - trueEnd);  	_data = newData;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,Delete,The following statement contains a magic number: if (Find (headerID)) {  	result = true;  	int trueStart = _readValueStart - 4;  	byte[] newData = new byte[_data.Length - (ValueLength + 4)];  	Array.Copy (_data' 0' newData' 0' trueStart);  	int trueEnd = trueStart + ValueLength + 4;  	Array.Copy (_data' trueEnd' newData' trueStart' _data.Length - trueEnd);  	_data = newData;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,ReadLong,The following statement contains a magic number: ReadCheck (8);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,ReadLong,The following statement contains a magic number: return (ReadInt () & 0xffffffff) | (((long)ReadInt ()) << 32);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,ReadInt,The following statement contains a magic number: ReadCheck (4);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,ReadInt,The following statement contains a magic number: _index += 4;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,ReadShort,The following statement contains a magic number: ReadCheck (2);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,ReadShort,The following statement contains a magic number: _index += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,ReadCheck,The following statement contains a magic number: if ((_readValueStart > _data.Length) || (_readValueStart < 4)) {  	throw new Exception ("Find must be called before calling a Read method");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,ReadCheck,The following statement contains a magic number: if (_index + length < 4) {  	throw new Exception ("Cannot read before start of tag");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,ReadShortInternal,The following statement contains a magic number: if (_index > _data.Length - 2) {  	throw new Exception ("End of extra data");  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,ReadShortInternal,The following statement contains a magic number: _index += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetShort,The following statement contains a magic number: _data [index + 1] = (byte)(source >> 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipExtraData.cs,SetShort,The following statement contains a magic number: index += 2;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipHelperStream.cs,WriteZip64EndOfCentralDirectory,The following statement contains a magic number: WriteLELong (44);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipHelperStream.cs,ReadLEShort,The following statement contains a magic number: return byteValue1 | (byteValue2 << 8);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipHelperStream.cs,ReadLEInt,The following statement contains a magic number: return ReadLEShort () | (ReadLEShort () << 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipHelperStream.cs,ReadLELong,The following statement contains a magic number: return (uint)ReadLEInt () | ((long)ReadLEInt () << 32);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipHelperStream.cs,WriteLEShort,The following statement contains a magic number: stream_.WriteByte ((byte)((value >> 8) & 0xff));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipHelperStream.cs,WriteLEUshort,The following statement contains a magic number: stream_.WriteByte ((byte)(value >> 8));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipHelperStream.cs,WriteLEInt,The following statement contains a magic number: WriteLEShort (value >> 16);  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipHelperStream.cs,WriteLEUint,The following statement contains a magic number: WriteLEUshort ((ushort)(value >> 16));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipHelperStream.cs,WriteLELong,The following statement contains a magic number: WriteLEInt ((int)(value >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipHelperStream.cs,WriteLEUlong,The following statement contains a magic number: WriteLEUint ((uint)(value >> 32));  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  	// The signature is not PKZIP originally but is now described as optional  	// in the PKZIP Appnote documenting trhe format.  	WriteLEInt (ZipConstants.DataDescriptorSignature);  	WriteLEInt (unchecked((int)(entry.Crc)));  	result += 8;  	if (entry.LocalHeaderRequiresZip64) {  		WriteLELong (entry.CompressedSize);  		WriteLELong (entry.Size);  		result += 16;  	}  	else {  		WriteLEInt ((int)entry.CompressedSize);  		WriteLEInt ((int)entry.Size);  		result += 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  	// The signature is not PKZIP originally but is now described as optional  	// in the PKZIP Appnote documenting trhe format.  	WriteLEInt (ZipConstants.DataDescriptorSignature);  	WriteLEInt (unchecked((int)(entry.Crc)));  	result += 8;  	if (entry.LocalHeaderRequiresZip64) {  		WriteLELong (entry.CompressedSize);  		WriteLELong (entry.Size);  		result += 16;  	}  	else {  		WriteLEInt ((int)entry.CompressedSize);  		WriteLEInt ((int)entry.Size);  		result += 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  	// The signature is not PKZIP originally but is now described as optional  	// in the PKZIP Appnote documenting trhe format.  	WriteLEInt (ZipConstants.DataDescriptorSignature);  	WriteLEInt (unchecked((int)(entry.Crc)));  	result += 8;  	if (entry.LocalHeaderRequiresZip64) {  		WriteLELong (entry.CompressedSize);  		WriteLELong (entry.Size);  		result += 16;  	}  	else {  		WriteLEInt ((int)entry.CompressedSize);  		WriteLEInt ((int)entry.Size);  		result += 8;  	}  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: result += 8;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if (entry.LocalHeaderRequiresZip64) {  	WriteLELong (entry.CompressedSize);  	WriteLELong (entry.Size);  	result += 16;  }  else {  	WriteLEInt ((int)entry.CompressedSize);  	WriteLEInt ((int)entry.Size);  	result += 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if (entry.LocalHeaderRequiresZip64) {  	WriteLELong (entry.CompressedSize);  	WriteLELong (entry.Size);  	result += 16;  }  else {  	WriteLEInt ((int)entry.CompressedSize);  	WriteLEInt ((int)entry.Size);  	result += 8;  }  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: result += 16;  
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: result += 8;  
Missing Default,LitJson,JsonData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonData.cs,Equals,The following switch statement is missing a default case: switch (this.type) {  case JsonType.None:  	return true;  case JsonType.Object:  	return this.inst_object.Equals (x.inst_object);  case JsonType.Array:  	return this.inst_array.Equals (x.inst_array);  case JsonType.String:  	return this.inst_string.Equals (x.inst_string);  case JsonType.Int:  	return this.inst_int.Equals (x.inst_int);  case JsonType.Long:  	return this.inst_long.Equals (x.inst_long);  case JsonType.Double:  	return this.inst_double.Equals (x.inst_double);  case JsonType.Boolean:  	return this.inst_boolean.Equals (x.inst_boolean);  }  
Missing Default,LitJson,JsonData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonData.cs,SetJsonType,The following switch statement is missing a default case: switch (type) {  case JsonType.None:  	break;  case JsonType.Object:  	inst_object = new Dictionary<string' JsonData> ();  	object_list = new List<KeyValuePair<string' JsonData>> ();  	break;  case JsonType.Array:  	inst_array = new List<JsonData> ();  	break;  case JsonType.String:  	inst_string = default(String);  	break;  case JsonType.Int:  	inst_int = default(Int32);  	break;  case JsonType.Long:  	inst_long = default(Int64);  	break;  case JsonType.Double:  	inst_double = default(Double);  	break;  case JsonType.Boolean:  	inst_boolean = default(Boolean);  	break;  }  
Missing Default,LitJson,JsonData,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonData.cs,ToString,The following switch statement is missing a default case: switch (type) {  case JsonType.Array:  	return "JsonData array";  case JsonType.Boolean:  	return inst_boolean.ToString ();  case JsonType.Double:  	return inst_double.ToString ();  case JsonType.Int:  	return inst_int.ToString ();  case JsonType.Long:  	return inst_long.ToString ();  case JsonType.Object:  	return "JsonData object";  case JsonType.String:  	return inst_string;  }  
Missing Default,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,DoValidation,The following switch statement is missing a default case: switch (cond) {  case Condition.InArray:  	if (!context.InArray)  		throw new JsonException ("Can't close an array here");  	break;  case Condition.InObject:  	if (!context.InObject || context.ExpectingValue)  		throw new JsonException ("Can't close an object here");  	break;  case Condition.NotAProperty:  	if (context.InObject && !context.ExpectingValue)  		throw new JsonException ("Expected a property");  	break;  case Condition.Property:  	if (!context.InObject || context.ExpectingValue)  		throw new JsonException ("Can't add a property here");  	break;  case Condition.Value:  	if (!context.InArray && (!context.InObject || !context.ExpectingValue))  		throw new JsonException ("Can't add a value here");  	break;  }  
Missing Default,LitJson,JsonWriter,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\LitJson\JsonWriter.cs,PutString,The following switch statement is missing a default case: switch (str [i]) {  case '\n':  	writer.Write ("\\n");  	continue;  case '\r':  	writer.Write ("\\r");  	continue;  case '\t':  	writer.Write ("\\t");  	continue;  case '"':  case '\\':  	writer.Write ('\\');  	writer.Write (str [i]);  	continue;  case '\f':  	writer.Write ("\\f");  	continue;  case '\b':  	writer.Write ("\\b");  	continue;  }  
Missing Default,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\DeflaterEngine.cs,SetLevel,The following switch statement is missing a default case: switch (compressionFunction) {  case DEFLATE_STORED:  	if (strstart > blockStart) {  		huffman.FlushStoredBlock (window' blockStart' strstart - blockStart' false);  		blockStart = strstart;  	}  	UpdateHash ();  	break;  case DEFLATE_FAST:  	if (strstart > blockStart) {  		huffman.FlushBlock (window' blockStart' strstart - blockStart' false);  		blockStart = strstart;  	}  	break;  case DEFLATE_SLOW:  	if (prevAvailable) {  		huffman.TallyLit (window [strstart - 1] & 0xff);  	}  	if (strstart > blockStart) {  		huffman.FlushBlock (window' blockStart' strstart - blockStart' false);  		blockStart = strstart;  	}  	prevAvailable = false;  	matchLen = MIN_MATCH - 1;  	break;  }  
Missing Default,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\theoneandonlysteve_Hawk-Z\Assets\Plugins\whydoidoit.com\SharpZIP\src\Compression\InflaterDynHeader.cs,Decode,The following switch statement is missing a default case: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		}  		else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
