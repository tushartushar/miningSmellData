Implementation smell,Namespace,Class,File,Method,Description
Long Method,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The method has 113 lines of code.
Long Method,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,Draw,The method has 103 lines of code.
Long Method,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The method has 296 lines of code.
Complex Method,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,getBitmapFont,Cyclomatic complexity of the method is 24
Complex Method,nzy3D.Plot3D.Builder.Concrete,RingExtrapolator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingExtrapolator.cs,extrapolate,Cyclomatic complexity of the method is 14
Complex Method,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,Cyclomatic complexity of the method is 18
Complex Method,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,findPoint,Cyclomatic complexity of the method is 15
Complex Method,nzy3D.Plot3D.Builder.Delaunay.Jdt,Delaunay_Triangulation,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Delaunay_Triangulation.cs,insertPointSimple,Cyclomatic complexity of the method is 26
Complex Method,nzy3D.Plot3D.Builder.Delaunay.Jdt,Delaunay_Triangulation,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Delaunay_Triangulation.cs,insertCollinear,Cyclomatic complexity of the method is 51
Complex Method,nzy3D.Plot3D.Builder.Delaunay.Jdt,Delaunay_Triangulation,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Delaunay_Triangulation.cs,updateBoundingBox,Cyclomatic complexity of the method is 8
Complex Method,nzy3D.Plot3D.Builder.Delaunay.Jdt,Delaunay_Triangulation,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Delaunay_Triangulation.cs,initTriangles,Cyclomatic complexity of the method is 8
Complex Method,nzy3D.Plot3D.Builder.Delaunay.Jdt,Point_dt,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Point_dt.cs,pointLineTest,Cyclomatic complexity of the method is 15
Complex Method,nzy3D.Plot3D.Builder.Delaunay.Jdt,Point_dt_Compare,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Point_dt.cs,Compare,Cyclomatic complexity of the method is 9
Complex Method,nzy3D.Plot3D.Builder.Delaunay.Jdt,Triangle_dt,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Triangle_dt.cs,nextNeighbor,Cyclomatic complexity of the method is 8
Complex Method,nzy3D.Plot3D.Builder.Delaunay.Jdt,Triangle_dt,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Triangle_dt.cs,z_value,Cyclomatic complexity of the method is 11
Complex Method,nzy3D.Plot3D.Primitives,Polygon,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Polygon.cs,Draw,Cyclomatic complexity of the method is 11
Complex Method,nzy3D.Plot3D.Primitives,Polygon,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Polygon.cs,ApplyPolygonModeLine,Cyclomatic complexity of the method is 11
Complex Method,nzy3D.Plot3D.Primitives,Polygon,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Polygon.cs,ApplyPolygonModeFill,Cyclomatic complexity of the method is 11
Complex Method,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,Draw,Cyclomatic complexity of the method is 13
Complex Method,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,Cyclomatic complexity of the method is 8
Complex Method,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawTicks,Cyclomatic complexity of the method is 33
Complex Method,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,getAxisTicks,Cyclomatic complexity of the method is 11
Complex Method,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawAxisTicks,Cyclomatic complexity of the method is 25
Complex Method,nzy3D.Plot3D.Rendering.Lights,LightSwitch,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Lights\LightSwitch.cs,Enable,Cyclomatic complexity of the method is 26
Complex Method,nzy3D.Plot3D.Rendering.Lights,LightSwitch,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Lights\LightSwitch.cs,Disable,Cyclomatic complexity of the method is 26
Complex Method,nzy3D.Plot3D.Rendering.View,View,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\View.cs,updateBounds,Cyclomatic complexity of the method is 8
Complex Method,nzy3D.Plot3D.Rendering.View,View,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\View.cs,Squarify,Cyclomatic complexity of the method is 12
Complex Method,nzy3D.Plot3D.Rendering.View,View,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\View.cs,UpdateCamera,Cyclomatic complexity of the method is 21
Complex Method,nzy3D.Plot3D.Text.Renderers,TextBillboardRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\Renderer\TextBillboardRenderer.cs,printString,Cyclomatic complexity of the method is 26
Complex Method,nzy3D.Plot3D.Text.Renderers,TextBitmapRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\Renderer\TextBitmapRenderer.cs,drawText,Cyclomatic complexity of the method is 25
Long Parameter List,nzy3D.Colors.ColorMaps,ColorMapGrayscale,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapGrayscale.cs,GetColor,The method has 5 parameters.
Long Parameter List,nzy3D.Colors.ColorMaps,ColorMapHotCold,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapHotCold.cs,GetColor,The method has 5 parameters.
Long Parameter List,nzy3D.Colors.ColorMaps,ColorMapHotCold,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapHotCold.cs,colorComponentAbsolute,The method has 5 parameters.
Long Parameter List,nzy3D.Colors.ColorMaps,ColorMapRBG,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapRBG.cs,GetColor,The method has 5 parameters.
Long Parameter List,nzy3D.Colors.ColorMaps,ColorMapRBG,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapRBG.cs,colorComponentAbsolute,The method has 5 parameters.
Long Parameter List,nzy3D.Colors.ColorMaps,ColorMapRedAndGreen,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapRedAndGreen.cs,GetColor,The method has 5 parameters.
Long Parameter List,nzy3D.Colors.ColorMaps,ColorMapRedAndGreen,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapRedAndGreen.cs,colorComponentAbsolute,The method has 5 parameters.
Long Parameter List,nzy3D.Colors.ColorMaps,ColorMapWhiteBlue,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapWhiteBlue.cs,GetColor,The method has 5 parameters.
Long Parameter List,nzy3D.Colors.ColorMaps,ColorMapWhiteGreen,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapWhiteGreen.cs,GetColor,The method has 5 parameters.
Long Parameter List,nzy3D.Colors.ColorMaps,ColorMapWhiteRed,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapWhiteRed.cs,GetColor,The method has 5 parameters.
Long Parameter List,nzy3D.Glut,BitmapCharRec,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\BitmapCharRec.cs,BitmapCharRec,The method has 6 parameters.
Long Parameter List,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,UnProject,The method has 5 parameters.
Long Parameter List,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,Project,The method has 5 parameters.
Long Parameter List,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,LookAt,The method has 9 parameters.
Long Parameter List,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,beginBitmap,The method has 6 parameters.
Long Parameter List,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,endBitmap,The method has 6 parameters.
Long Parameter List,nzy3D.Glut,StrokeFontRec,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\StrokeFontRec.cs,StrokeFontRec,The method has 5 parameters.
Long Parameter List,nzy3D.Maths,Angle2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Angle2d.cs,Angle2d,The method has 6 parameters.
Long Parameter List,nzy3D.Maths,Angle3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Angle3d.cs,Angle3d,The method has 9 parameters.
Long Parameter List,nzy3D.Maths,BoundingBox3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\BoundingBox3d.cs,BoundingBox3d,The method has 6 parameters.
Long Parameter List,nzy3D.Maths,Vector3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Vector3d.cs,Vector3d,The method has 6 parameters.
Long Parameter List,nzy3D.Plot2D.Primitive,ColorbarImageGenerator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot2D\Primitives\ColorbarImageGenerator.cs,ColorbarImageGenerator,The method has 5 parameters.
Long Parameter List,nzy3D.Plot3D.Builder,Builder,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Builder.cs,buildRing,The method has 6 parameters.
Long Parameter List,nzy3D.Plot3D.Builder.Delaunay.Jdt,GridIndex,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\GridIndex.cs,updateCellValues,The method has 5 parameters.
Long Parameter List,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The method has 6 parameters.
Long Parameter List,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawTicks,The method has 6 parameters.
Long Parameter List,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawAxisLabel,The method has 8 parameters.
Long Parameter List,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawAxisTicks,The method has 14 parameters.
Long Parameter List,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawAxisTickNumericLabel,The method has 8 parameters.
Long Parameter List,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawTickLine,The method has 7 parameters.
Long Parameter List,nzy3D.Plot3D.Rendering.Canvas,Quality,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Canvas\Quality.cs,Quality,The method has 7 parameters.
Long Parameter List,nzy3D.Plot3D.Rendering.Legends.Colorbars,ColorbarLegend,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Legends\Colorbars\ColorbarLegend.cs,ColorbarLegend,The method has 5 parameters.
Long Parameter List,nzy3D.Plot3D.Rendering.View,ImageRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\ImageRenderer.cs,RenderImage,The method has 5 parameters.
Long Parameter List,nzy3D.Plot3D.Rendering.View,ImageRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\ImageRenderer.cs,RenderImage,The method has 6 parameters.
Long Parameter List,nzy3D.Plot3D.Text,AbstractTextRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\AbstractTextRenderer.cs,drawText,The method has 6 parameters.
Long Parameter List,nzy3D.Plot3D.Text,AbstractTextRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\AbstractTextRenderer.cs,drawText,The method has 7 parameters.
Long Parameter List,nzy3D.Plot3D.Text,AbstractTextRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\AbstractTextRenderer.cs,drawText,The method has 8 parameters.
Long Parameter List,nzy3D.Plot3D.Text,AbstractTextRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\AbstractTextRenderer.cs,drawText,The method has 7 parameters.
Long Parameter List,nzy3D.Plot3D.Text,ITextRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\ITextRenderer.cs,drawText,The method has 6 parameters.
Long Parameter List,nzy3D.Plot3D.Text,ITextRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\ITextRenderer.cs,drawText,The method has 8 parameters.
Long Parameter List,nzy3D.Plot3D.Text,ITextRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\ITextRenderer.cs,drawText,The method has 7 parameters.
Long Parameter List,nzy3D.Plot3D.Text,ITextRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\ITextRenderer.cs,drawText,The method has 7 parameters.
Long Parameter List,nzy3D.Plot3D.Text.Renderers,TextBillboardRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\Renderer\TextBillboardRenderer.cs,drawText,The method has 8 parameters.
Long Parameter List,nzy3D.Plot3D.Text.Renderers,TextBitmapRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\Renderer\TextBitmapRenderer.cs,drawText,The method has 8 parameters.
Long Statement,nzy3D.Colors.ColorMaps,ColorMapRBG,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapRBG.cs,colorComponentRelative,The length of the statement  "	return colorComponentAbsolute (value' center - (bottomWidth / 2)' center + (bottomWidth / 2)' center - (topWidth / 2)' center + (topWidth / 2)); " is 144.
Long Statement,nzy3D.Colors.ColorMaps,ColorMapRedAndGreen,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapRedAndGreen.cs,colorComponentRelative,The length of the statement  "	return colorComponentAbsolute (value' center - (bottomWidth / 2)' center + (bottomWidth / 2)' center - (topWidth / 2)' center + (topWidth / 2)); " is 144.
Long Statement,nzy3D.Maths.Algorithms.Interpolation.Bernstein,Spline3D,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Algorithms\Interpolation\Bernstein\Spline3D.cs,findCPoints,The length of the statement  "	coeffA [1].setvalues ((points [2].x - points [0].x - delta [0].x) * Tightness' (points [2].y - points [0].y - delta [0].y) * Tightness' (points [2].z - points [0].z - delta [0].z) * Tightness); " is 193.
Long Statement,nzy3D.Maths.Algorithms.Interpolation.Bernstein,Spline3D,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Algorithms\Interpolation\Bernstein\Spline3D.cs,findCPoints,The length of the statement  "		coeffA [i].setvalues (-(points [i + 1].x - points [i - 1].x - coeffA [i - 1].x) * bi [i]' -(points [i + 1].y - points [i - 1].y - coeffA [i - 1].y) * bi [i]' -(points [i + 1].z - points [i - 1].z - coeffA [i - 1].z) * bi [i]); " is 226.
Long Statement,nzy3D.Maths.Algorithms.Interpolation.Bernstein,Spline3D,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Algorithms\Interpolation\Bernstein\Spline3D.cs,findCPoints,The length of the statement  "		delta [i].setvalues (coeffA [i].x + delta [i + 1].x * bi [i]' coeffA [i].y + delta [i + 1].y * bi [i]' coeffA [i].z + delta [i + 1].z * bi [i]); " is 144.
Long Statement,nzy3D.Maths,BoundingBox2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\BoundingBox2d.cs,contains,The length of the statement  "	return m_xmin <= anotherBox.m_xmin & anotherBox.m_xmax <= m_xmax & m_ymin <= anotherBox.m_ymin & anotherBox.m_ymax <= m_ymax; " is 125.
Long Statement,nzy3D.Maths,BoundingBox2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\BoundingBox2d.cs,intersect,The length of the statement  "	return (m_xmin <= anotherBox.m_xmin & anotherBox.m_xmin <= m_xmax) | (m_xmin <= anotherBox.m_xmax & anotherBox.m_xmax <= m_xmax) & (m_ymin <= anotherBox.m_ymin & anotherBox.m_ymin <= m_ymax) | (m_ymin <= anotherBox.m_ymax & anotherBox.m_ymax <= m_ymax); " is 253.
Long Statement,nzy3D.Maths,BoundingBox3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\BoundingBox3d.cs,contains,The length of the statement  "	return m_xmin <= anotherBox.m_xmin & anotherBox.m_xmax <= m_xmax & m_ymin <= anotherBox.m_ymin & anotherBox.m_ymax <= m_ymax & m_zmin <= anotherBox.m_zmin & anotherBox.m_zmax <= m_zmax; " is 185.
Long Statement,nzy3D.Maths,BoundingBox3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\BoundingBox3d.cs,contains,The length of the statement  "	return m_xmin <= aPoint.x & aPoint.x <= m_xmax & m_ymin <= aPoint.y & aPoint.y <= m_ymax & m_zmin <= aPoint.z & aPoint.z <= m_zmax; " is 131.
Long Statement,nzy3D.Maths,BoundingBox3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\BoundingBox3d.cs,intersect,The length of the statement  "	return (m_xmin <= anotherBox.m_xmin & anotherBox.m_xmin <= m_xmax) | (m_xmin <= anotherBox.m_xmax & anotherBox.m_xmax <= m_xmax) & (m_ymin <= anotherBox.m_ymin & anotherBox.m_ymin <= m_ymax) | (m_ymin <= anotherBox.m_ymax & anotherBox.m_ymax <= m_ymax) & (m_zmin <= anotherBox.m_zmin & anotherBox.m_zmin <= m_zmax) | (m_zmin <= anotherBox.m_zmax & anotherBox.m_zmax <= m_zmax); " is 377.
Long Statement,nzy3D.Maths,Coord3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord3d.cs,distance,The length of the statement  "	return Math.Sqrt (Math.Pow ((this.x - coord.x)' 2) + Math.Pow ((this.y - coord.y)' 2) + Math.Pow ((this.z - coord.z)' 2)); " is 122.
Long Statement,nzy3D.Maths,Grid,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Grid.cs,getBounds,The length of the statement  "	return new BoundingBox3d (Statistics.Min (x)' Statistics.Max (x)' Statistics.Min (y)' Statistics.Max (y)' Statistics.Min (z)' Statistics.Max (z)); " is 146.
Long Statement,nzy3D.Maths,Statistics,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Statistics.cs,Quantile,The length of the statement  "				quantiles [i] = sorted [Convert.ToInt32 (quantileIdxFloor)] * (quantileIdxCeil - quantileIdx) + sorted [Convert.ToInt32 (quantileIdxCeil)] * (quantileIdx - quantileIdxFloor); " is 174.
Long Statement,nzy3D.Plot2D.Primitive,ColorbarImageGenerator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot2D\Primitives\ColorbarImageGenerator.cs,toImage,The length of the statement  "	System.Drawing.Bitmap image = new System.Drawing.Bitmap (width' height' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 124.
Long Statement,nzy3D.Plot2D.Primitive,ColorbarImageGenerator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot2D\Primitives\ColorbarImageGenerator.cs,toImage,The length of the statement  "		graphic.DrawLine (new System.Drawing.Pen (new System.Drawing.SolidBrush (c.toColor ()))' 0' height - h' barWidth' height - h); " is 126.
Long Statement,nzy3D.Plot2D.Primitive,ColorbarImageGenerator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot2D\Primitives\ColorbarImageGenerator.cs,toImage,The length of the statement  "	graphic.FillRectangle (new System.Drawing.SolidBrush (_foregroundColor.toColor ())' 0' Convert.ToSingle (txtSize / 2)' barWidth' height - txtSize); " is 147.
Long Statement,nzy3D.Plot2D.Primitive,ColorbarImageGenerator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot2D\Primitives\ColorbarImageGenerator.cs,toImage,The length of the statement  "			graphic.DrawString (txt' new System.Drawing.Font ("Arial"' txtSize' System.Drawing.GraphicsUnit.Pixel)' new System.Drawing.SolidBrush (_foregroundColor.toColor ())' barWidth + 1' ypos); " is 185.
Long Statement,nzy3D.Plot3D.Builder,Builder,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Builder.cs,buildRing,The length of the statement  "	RingTessellator tesselator = new RingTessellator (ringMin' ringMax' new ColorMapper (new ColorMapRainbow ()' 0' 1)' Color.BLACK); " is 129.
Long Statement,nzy3D.Plot3D.Builder,Mapper,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Mapper.cs,f,The length of the statement  "		throw new ArgumentException ("Input xy array must be have a length of 2 in second dimension. Current array second dimension has a lenght of " + xy.GetLength (1)' "xy"); " is 168.
Long Statement,nzy3D.Plot3D.Builder,Mapper,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Mapper.cs,fAsSingle,The length of the statement  "		throw new ArgumentException ("Input xy array must be have a length of 2 in second dimension. Current array second dimension has a lenght of " + xy.GetLength (1)' "xy"); " is 168.
Long Statement,nzy3D.Plot3D.Builder,Mapper,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Mapper.cs,fAsSingle,The length of the statement  "		throw new ArgumentException ("Input xy array must be have a length of 2 in second dimension. Current array second dimension has a lenght of " + xy.GetLength (1)' "xy"); " is 168.
Long Statement,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getEstimatedQuadSurroundingPoint,The length of the statement  "	p [0] = new Point (new Coord3d ((x [xi - 1] + x [xi]) / 2' (y [yi + 1] + y [yi]) / 2' (z [xi - 1' yi + 1] + z [xi - 1' yi] + z [xi' yi] + z [xi' yi + 1]) / 4)); " is 160.
Long Statement,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getEstimatedQuadSurroundingPoint,The length of the statement  "	p [1] = new Point (new Coord3d ((x [xi - 1] + x [xi]) / 2' (y [yi - 1] + y [yi]) / 2' (z [xi - 1' yi] + z [xi - 1' yi - 1] + z [xi' yi - 1] + z [xi' yi]) / 4)); " is 160.
Long Statement,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getEstimatedQuadSurroundingPoint,The length of the statement  "	p [2] = new Point (new Coord3d ((x [xi + 1] + x [xi]) / 2' (y [yi - 1] + y [yi]) / 2' (z [xi' yi] + z [xi' yi - 1] + z [xi + 1' yi - 1] + z [xi + 1' yi]) / 4)); " is 160.
Long Statement,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getEstimatedQuadSurroundingPoint,The length of the statement  "	p [3] = new Point (new Coord3d ((x [xi + 1] + x [xi]) / 2' (y [yi + 1] + y [yi]) / 2' (z [xi' yi + 1] + z [xi' yi] + z [xi + 1' yi] + z [xi + 1' yi + 1]) / 4)); " is 160.
Long Statement,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,findPoint,The length of the statement  "			throw new ArithmeticException (("no alignement between p1(" + p1.xyz.x + "'" + p1.xyz.y + "'" + p1.xyz.z + ") and p2(" + p2.xyz.x + "'" + p2.xyz.y + "'" + p2.xyz.z + ")")); " is 172.
Long Statement,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,findPoint,The length of the statement  "			w2 = (Math.Sqrt ((x3 - p1.xyz.x) * (x3 - p1.xyz.x) + (y3 - p1.xyz.y) * (y3 - p1.xyz.y)) / Math.Sqrt ((p2.xyz.x - p1.xyz.x) * (p2.xyz.x - p1.xyz.x) + (p2.xyz.y - p1.xyz.y) * (p2.xyz.y - p1.xyz.y))); " is 197.
Long Statement,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,findPoint,The length of the statement  "			throw new ArithmeticException (("can't compute z3 with p1(" + p1.xyz.x + "'" + p1.xyz.y + ") and p2(" + p2.xyz.x + "'" + p2.xyz.y + ")")); " is 138.
Long Statement,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,findPoint,The length of the statement  "			throw new ArithmeticException (("no alignement between p1(" + p1.xyz.x + "'" + p1.xyz.y + "'" + p1.xyz.z + ") and p2(" + p2.xyz.x + "'" + p2.xyz.y + "'" + p2.xyz.z + ")")); " is 172.
Long Statement,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,findPoint,The length of the statement  "			w2 = (Math.Sqrt ((x3 - p1.xyz.x) * (x3 - p1.xyz.x) + (y3 - p1.xyz.y) * (y3 - p1.xyz.y)) / Math.Sqrt ((p2.xyz.x - p1.xyz.x) * (p2.xyz.x - p1.xyz.x) + (p2.xyz.y - p1.xyz.y) * (p2.xyz.y - p1.xyz.y))); " is 197.
Long Statement,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,findPoint,The length of the statement  "			throw new ArithmeticException (("can't compute z3 with p1(" + p1.xyz.x + "'" + p1.xyz.y + ") and p2(" + p2.xyz.x + "'" + p2.xyz.y + ")")); " is 138.
Long Statement,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,findPoint,The length of the statement  "		throw new ArithmeticException (("no alignement between p1(" + p1.xyz.x + "'" + p1.xyz.y + ") and p2(" + p2.xyz.x + "'" + p2.xyz.y + ")")); " is 138.
Long Statement,nzy3D.Plot3D.Builder.Delaunay.Jdt,BoundingBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\BoundingBox.cs,contains,The length of the statement  "	return (!(this.isNull | other.isNull)) & other.minX >= this.minX & other.maxX <= this.maxX & other.minY >= this.minY & other.maxY <= this.maxY; " is 143.
Long Statement,nzy3D.Plot3D.Builder.Delaunay.Jdt,BoundingBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\BoundingBox.cs,UnionWith,The length of the statement  "		return new BoundingBox (Math.Min (minX' other.minX)' Math.Max (maxX' other.maxX)' Math.Min (minY' other.minY)' Math.Max (maxY' other.maxY)); " is 140.
Long Statement,nzy3D.Plot3D.Builder.Delaunay.Jdt,GridIndex,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\GridIndex.cs,updateIndex,The length of the statement  "		init (indexDelaunay' Convert.ToInt32 (indexRegion.Width / x_size)' Convert.ToInt32 (indexRegion.Height / y_size)' indexRegion.UnionWith (updatedRegion)); " is 153.
Long Statement,nzy3D.Plot3D.Builder.Delaunay.Jdt,GridIndex,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\GridIndex.cs,updateIndex,The length of the statement  "		updateCellValues ((int)minInvalidCell.x' (int)minInvalidCell.y' (int)maxInvalidCell.x' (int)maxInvalidCell.y' adjacentValidTriangle); " is 133.
Long Statement,nzy3D.Plot3D.Builder.Delaunay.Jdt,Triangle_dt,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Triangle_dt.cs,circumcircle,The length of the statement  "		Point_dt cen = new Point_dt ((u * (_b.y - _c.y) - v * (_a.y - _b.y)) / den' (v * (_a.x - _b.x) - u * (_b.x - _c.x)) / den); " is 123.
Long Statement,nzy3D.Plot3D.Builder.Delaunay.Jdt,Triangle_dt,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Triangle_dt.cs,contains,The length of the statement  "	if ((a12 == Point_dt.LEFT && a23 == Point_dt.LEFT && a31 == Point_dt.LEFT) || (a12 == Point_dt.RIGHT && a23 == Point_dt.RIGHT && a31 == Point_dt.RIGHT) || (a12 == Point_dt.ONSEGMENT || a23 == Point_dt.ONSEGMENT || a31 == Point_dt.ONSEGMENT)) " is 241.
Long Statement,nzy3D.Plot3D.Builder.Delaunay.Jdt,Triangle_dt,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Triangle_dt.cs,contains_BoundaryIsOutside,The length of the statement  "	if ((a12 == Point_dt.LEFT && a23 == Point_dt.LEFT && a31 == Point_dt.LEFT) || (a12 == Point_dt.RIGHT && a23 == Point_dt.RIGHT && a31 == Point_dt.RIGHT)) " is 152.
Long Statement,nzy3D.Plot3D.Primitives,AbstractComposite,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\AbstractComposite.cs,toString,The length of the statement  "	string output = Utils.blanks (depth) + "(Composite3d) #elements:" + _components.Count + " | isDisplayed=" + this.Displayed; " is 123.
Long Statement,nzy3D.Plot3D.Primitives,CompileableComposite,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\CompileableComposite.cs,ToString,The length of the statement  "	string output = Utils.blanks (depth) + "(Composite3d) #elements:" + _components.Count + " | isDisplayed=" + this.Displayed; " is 123.
Long Statement,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawTicks,The length of the statement  "	drawAxisTicks (cam' direction' color' hal' val' tickLength' ticksTxtBounds' xpos' ypos' zpos' xdir' ydir' zdir' getAxisTicks (direction)); " is 138.
Long Statement,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawAxisLabel,The length of the statement  "	if ((direction == AxeDirection.AxeX && _layout.XAxeLabelDisplayed) || (direction == AxeDirection.AxeY && _layout.YAxeLabelDisplayed) || (direction == AxeDirection.AxeZ && _layout.ZAxeLabelDisplayed)) { " is 201.
Long Statement,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,findClosestXaxe,The length of the statement  "			distAxeX [a] = new Vector3d (_axeXx [a' 0]' _axeXy [a' 0]' _axeXz [a' 0]' _axeXx [a' 1]' _axeXy [a' 1]' _axeXz [a' 1]).distance (cam.Eye); " is 138.
Long Statement,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,findClosestYaxe,The length of the statement  "			distAxeY [a] = new Vector3d (_axeYx [a' 0]' _axeYy [a' 0]' _axeYz [a' 0]' _axeYx [a' 1]' _axeYy [a' 1]' _axeYz [a' 1]).distance (cam.Eye); " is 138.
Long Statement,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,findClosestZaxe,The length of the statement  "			distAxeZ [a] = new Vector3d (_axeZx [a' 0]' _axeZy [a' 0]' _axeZz [a' 0]' _axeZx [a' 1]' _axeZy [a' 1]' _axeZz [a' 1]).distance (cam.Eye); " is 138.
Long Statement,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,findClosestZaxe,The length of the statement  "			Coord3d axeCEnter = new Coord3d ((_axeZx [a' 0] + _axeZx [a' 1]) / 2' (_axeZy [a' 0] + _axeZy [a' 1]) / 2' (_axeZz [a' 0] + _axeZz [a' 1]) / 2); " is 144.
Long Statement,nzy3D.Plot3D.Rendering.View,Camera,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\Camera.cs,ScreenToModel,The length of the statement  "	bool s = Glut.Glut.UnProject (new Vector4d (screen.x' screen.y' screen.z' 0)' getModelViewAsMatrix4d ()' getProjectionAsMatrix4d ()' getViewPortAsDouble ()' ref worldcoord); " is 173.
Long Statement,nzy3D.Plot3D.Rendering.View,Camera,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\Camera.cs,ModelToScreen,The length of the statement  "	if (!Glut.Glut.Project (new Vector4d (point.x' point.y' point.z' 0)' getModelViewAsMatrix4d ()' getProjectionAsMatrix4d ()' getViewPortAsDouble ()' ref screencoord)) { " is 167.
Long Statement,nzy3D.Plot3D.Rendering.View,Camera,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\Camera.cs,ModelToScreen,The length of the statement  "		if (!Glut.Glut.Project (new Vector4d (points [i].x' points [i].y' points [i].z' 0)' modelMatrix' projectionMatrix' viewport' ref screenCoord)) { " is 144.
Long Statement,nzy3D.Plot3D.Rendering.View,Camera,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\Camera.cs,ModelToScreen,The length of the statement  "			FailedProjection ("Could not retrieve model coordinates in screen for point #" + i + " " + points [i].ToString () + "."); " is 121.
Long Statement,nzy3D.Plot3D.Rendering.View,Camera,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\Camera.cs,ModelToScreen,The length of the statement  "			if (!Glut.Glut.Project (new Vector4d (points [i' j].x' points [i' j].y' points [i' j].z' 0)' modelMatrix' projectionMatrix' viewport' ref screenCoord)) { " is 153.
Long Statement,nzy3D.Plot3D.Rendering.View,Camera,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\Camera.cs,ModelToScreen,The length of the statement  "				FailedProjection ("Could not retrieve model coordinates in screen for point #" + i + " " + points [i' j].ToString () + "."); " is 124.
Long Statement,nzy3D.Plot3D.Rendering.View,Camera,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\Camera.cs,ModelToScreen,The length of the statement  "		if (!Glut.Glut.Project (new Vector4d (aPoint.x' aPoint.y' aPoint.z' 0)' modelMatrix' projectionMatrix' viewport' ref screenCoord)) { " is 132.
Long Statement,nzy3D.Plot3D.Rendering.View,Camera,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\Camera.cs,ModelToScreen,The length of the statement  "		if (!Glut.Glut.Project (new Vector4d (polygon.X [i]' polygon.Y [i]' polygon.Z [i]' 0)' modelMatrix' projectionMatrix' viewport' ref screenCoord)) { " is 147.
Long Statement,nzy3D.Plot3D.Rendering.View,Camera,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\Camera.cs,ModelToScreen,The length of the statement  "			if (!Glut.Glut.Project (new Vector4d (grid.x [i]' grid.y [j]' grid.z [i' j]' 0)' modelMatrix' projectionMatrix' viewport' ref screenCoord)) { " is 141.
Long Statement,nzy3D.Plot3D.Rendering.View,Camera,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\Camera.cs,ModelToScreen,The length of the statement  "				if (!Glut.Glut.Project (new Vector4d (polygon.X [k]' polygon.Y [k]' polygon.Z [k]' 0)' modelMatrix' projectionMatrix' viewport' ref screenCoord)) { " is 147.
Long Statement,nzy3D.Plot3D.Rendering.View,Camera,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\Camera.cs,ModelToScreen,The length of the statement  "					FailedProjection ("Could not retrieve model coordinates in screen for point #" + k + " of polygon (" + i + "'" + j + ")."); " is 123.
Long Statement,nzy3D.Plot3D.Rendering.View,Camera,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\Camera.cs,doShoot,The length of the statement  "		Glut.Glut.Perspective (computeFieldOfView (RenderingSphereRadius * 2' Eye.distance (Target))' (StretchToFill ? _screenWidth / _screenHeight : 1)' Near' Far); " is 157.
Long Statement,nzy3D.Plot3D.Rendering.View,Renderer3D,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\Renderer3D.cs,GrabScreenshot2,The length of the statement  "	System.Drawing.Imaging.BitmapData data = _image.LockBits (this.ClientRectangle' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb); " is 179.
Long Statement,nzy3D.Plot3D.Rendering.View,Renderer3D,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\Renderer3D.cs,GrabScreenshot2,The length of the statement  "	//OpenTK.Graphics.OpenGL.GL.ReadPixels(0' 0' ClientSize.Width' ClientSize.Height' OpenTK.Graphics.PixelFormat.Bgr' OpenTK.Graphics.PixelType.UnsignedByte' data.Scan0) " is 166.
Long Statement,nzy3D.Plot3D.Rendering.View,View,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\View.cs,UpdateCamera,The length of the statement  "		_cam.RenderingSphereRadius = (float)(Math.Max (boundsScaled.xmax - boundsScaled.xmin' boundsScaled.ymax - boundsScaled.ymin) / 2); " is 130.
Long Statement,nzy3D.Plot3D.Text.Renderers,TextBitmapRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\Renderer\TextBitmapRenderer.cs,drawText,The length of the statement  "		Console.WriteLine ("TextBitmap.drawText(): could not process text position: " + posScreen.ToString () + " " + posScreenShifted.ToString ()); " is 140.
Complex Conditional,nzy3D.Plot3D.Builder.Delaunay.Jdt,Triangle_dt,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Triangle_dt.cs,contains,The conditional expression  "(a12 == Point_dt.LEFT && a23 == Point_dt.LEFT && a31 == Point_dt.LEFT) || (a12 == Point_dt.RIGHT && a23 == Point_dt.RIGHT && a31 == Point_dt.RIGHT) || (a12 == Point_dt.ONSEGMENT || a23 == Point_dt.ONSEGMENT || a31 == Point_dt.ONSEGMENT)"  is complex.
Complex Conditional,nzy3D.Plot3D.Builder.Delaunay.Jdt,Triangle_dt,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Triangle_dt.cs,contains_BoundaryIsOutside,The conditional expression  "(a12 == Point_dt.LEFT && a23 == Point_dt.LEFT && a31 == Point_dt.LEFT) || (a12 == Point_dt.RIGHT && a23 == Point_dt.RIGHT && a31 == Point_dt.RIGHT)"  is complex.
Complex Conditional,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawAxisLabel,The conditional expression  "(direction == AxeDirection.AxeX && _layout.XAxeLabelDisplayed) || (direction == AxeDirection.AxeY && _layout.YAxeLabelDisplayed) || (direction == AxeDirection.AxeZ && _layout.ZAxeLabelDisplayed)"  is complex.
Virtual Method Call from Constructor,nzy3D.Chart.Controllers,AbstractController,C:\repos\benoit74_nzy3d-api\nzy3d-api\Chart\Controllers\AbstractController.cs,AbstractController,The constructor "AbstractController" calls a virtual method "Register".
Magic Number,nzy3D.Chart.Controllers.Mouse.Camera,CameraMouseController,C:\repos\benoit74_nzy3d-api\nzy3d-api\Chart\Controllers\Mouse\Camera\CameraMouseController.cs,MouseMoved,The following statement contains a magic number: if (e.Button != System.Windows.Forms.MouseButtons.None) {  	Coord2d mouse = new Coord2d (e.X' e.Y);  	// Rotate  	if (e.Button == System.Windows.Forms.MouseButtons.Left) {  		Coord2d move = mouse.substract (_prevMouse).divide (100);  		Rotate (move);  	}  	if (e.Button == System.Windows.Forms.MouseButtons.Right) {  		Coord2d move = mouse.substract (_prevMouse);  		if (move.y != 0) {  			Shift ((float)(move.y / 250));  		}  	}  	_prevMouse = mouse;  }  
Magic Number,nzy3D.Chart.Controllers.Mouse.Camera,CameraMouseController,C:\repos\benoit74_nzy3d-api\nzy3d-api\Chart\Controllers\Mouse\Camera\CameraMouseController.cs,MouseMoved,The following statement contains a magic number: if (e.Button != System.Windows.Forms.MouseButtons.None) {  	Coord2d mouse = new Coord2d (e.X' e.Y);  	// Rotate  	if (e.Button == System.Windows.Forms.MouseButtons.Left) {  		Coord2d move = mouse.substract (_prevMouse).divide (100);  		Rotate (move);  	}  	if (e.Button == System.Windows.Forms.MouseButtons.Right) {  		Coord2d move = mouse.substract (_prevMouse);  		if (move.y != 0) {  			Shift ((float)(move.y / 250));  		}  	}  	_prevMouse = mouse;  }  
Magic Number,nzy3D.Chart.Controllers.Mouse.Camera,CameraMouseController,C:\repos\benoit74_nzy3d-api\nzy3d-api\Chart\Controllers\Mouse\Camera\CameraMouseController.cs,MouseMoved,The following statement contains a magic number: if (e.Button == System.Windows.Forms.MouseButtons.Left) {  	Coord2d move = mouse.substract (_prevMouse).divide (100);  	Rotate (move);  }  
Magic Number,nzy3D.Chart.Controllers.Mouse.Camera,CameraMouseController,C:\repos\benoit74_nzy3d-api\nzy3d-api\Chart\Controllers\Mouse\Camera\CameraMouseController.cs,MouseMoved,The following statement contains a magic number: if (e.Button == System.Windows.Forms.MouseButtons.Right) {  	Coord2d move = mouse.substract (_prevMouse);  	if (move.y != 0) {  		Shift ((float)(move.y / 250));  	}  }  
Magic Number,nzy3D.Chart.Controllers.Mouse.Camera,CameraMouseController,C:\repos\benoit74_nzy3d-api\nzy3d-api\Chart\Controllers\Mouse\Camera\CameraMouseController.cs,MouseMoved,The following statement contains a magic number: if (move.y != 0) {  	Shift ((float)(move.y / 250));  }  
Magic Number,nzy3D.Chart.Controllers.Mouse.Camera,CameraMouseController,C:\repos\benoit74_nzy3d-api\nzy3d-api\Chart\Controllers\Mouse\Camera\CameraMouseController.cs,MouseMoved,The following statement contains a magic number: Shift ((float)(move.y / 250));  
Magic Number,nzy3D.Colors.ColorMaps,ColorMapRBG,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapRBG.cs,colorComponentRelative,The following statement contains a magic number: return colorComponentAbsolute (value' center - (bottomWidth / 2)' center + (bottomWidth / 2)' center - (topWidth / 2)' center + (topWidth / 2));  
Magic Number,nzy3D.Colors.ColorMaps,ColorMapRBG,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapRBG.cs,colorComponentRelative,The following statement contains a magic number: return colorComponentAbsolute (value' center - (bottomWidth / 2)' center + (bottomWidth / 2)' center - (topWidth / 2)' center + (topWidth / 2));  
Magic Number,nzy3D.Colors.ColorMaps,ColorMapRBG,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapRBG.cs,colorComponentRelative,The following statement contains a magic number: return colorComponentAbsolute (value' center - (bottomWidth / 2)' center + (bottomWidth / 2)' center - (topWidth / 2)' center + (topWidth / 2));  
Magic Number,nzy3D.Colors.ColorMaps,ColorMapRBG,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapRBG.cs,colorComponentRelative,The following statement contains a magic number: return colorComponentAbsolute (value' center - (bottomWidth / 2)' center + (bottomWidth / 2)' center - (topWidth / 2)' center + (topWidth / 2));  
Magic Number,nzy3D.Colors.ColorMaps,ColorMapRedAndGreen,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapRedAndGreen.cs,colorComponentRelative,The following statement contains a magic number: return colorComponentAbsolute (value' center - (bottomWidth / 2)' center + (bottomWidth / 2)' center - (topWidth / 2)' center + (topWidth / 2));  
Magic Number,nzy3D.Colors.ColorMaps,ColorMapRedAndGreen,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapRedAndGreen.cs,colorComponentRelative,The following statement contains a magic number: return colorComponentAbsolute (value' center - (bottomWidth / 2)' center + (bottomWidth / 2)' center - (topWidth / 2)' center + (topWidth / 2));  
Magic Number,nzy3D.Colors.ColorMaps,ColorMapRedAndGreen,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapRedAndGreen.cs,colorComponentRelative,The following statement contains a magic number: return colorComponentAbsolute (value' center - (bottomWidth / 2)' center + (bottomWidth / 2)' center - (topWidth / 2)' center + (topWidth / 2));  
Magic Number,nzy3D.Colors.ColorMaps,ColorMapRedAndGreen,C:\repos\benoit74_nzy3d-api\nzy3d-api\Colors\ColorsMaps\ColorMapRedAndGreen.cs,colorComponentRelative,The following statement contains a magic number: return colorComponentAbsolute (value' center - (bottomWidth / 2)' center + (bottomWidth / 2)' center - (topWidth / 2)' center + (topWidth / 2));  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: if (boxVertices == null) {  	float['] v = new float[8' 3];  	v [0' 0] = -0.5F;  	v [1' 0] = -0.5F;  	v [2' 0] = -0.5F;  	v [3' 0] = -0.5F;  	v [4' 0] = 0.5F;  	v [5' 0] = 0.5F;  	v [6' 0] = 0.5F;  	v [7' 0] = 0.5F;  	v [0' 1] = -0.5F;  	v [1' 1] = -0.5F;  	v [4' 1] = -0.5F;  	v [5' 1] = -0.5F;  	v [2' 1] = 0.5F;  	v [3' 1] = 0.5F;  	v [6' 1] = 0.5F;  	v [7' 1] = 0.5F;  	v [0' 2] = -0.5F;  	v [3' 2] = -0.5F;  	v [4' 2] = -0.5F;  	v [7' 2] = -0.5F;  	v [1' 2] = 0.5F;  	v [2' 2] = 0.5F;  	v [5' 2] = 0.5F;  	v [6' 2] = 0.5F;  	boxVertices = v;  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [2' 0] = -0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [3' 0] = -0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [4' 0] = 0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [5' 0] = 0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [6' 0] = 0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [7' 0] = 0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [4' 1] = -0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [5' 1] = -0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [2' 1] = 0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [3' 1] = 0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [6' 1] = 0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [7' 1] = 0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [0' 2] = -0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [3' 2] = -0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [3' 2] = -0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [4' 2] = -0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [4' 2] = -0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [7' 2] = -0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [7' 2] = -0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [1' 2] = 0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [2' 2] = 0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [2' 2] = 0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [5' 2] = 0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [5' 2] = 0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [6' 2] = 0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: v [6' 2] = 0.5F;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: for (int i = 5; i >= 0; i += -1) {  	GL.Begin (type);  	GL.Normal3 (boxVertices [i' 0]' boxVertices [i' 1]' boxVertices [i' 2]);  	int faceN = 0;  	faceN = boxFaces [i' 0];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 1];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 2];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 3];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	GL.End ();  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: for (int i = 5; i >= 0; i += -1) {  	GL.Begin (type);  	GL.Normal3 (boxVertices [i' 0]' boxVertices [i' 1]' boxVertices [i' 2]);  	int faceN = 0;  	faceN = boxFaces [i' 0];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 1];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 2];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 3];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	GL.End ();  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: for (int i = 5; i >= 0; i += -1) {  	GL.Begin (type);  	GL.Normal3 (boxVertices [i' 0]' boxVertices [i' 1]' boxVertices [i' 2]);  	int faceN = 0;  	faceN = boxFaces [i' 0];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 1];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 2];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 3];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	GL.End ();  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: for (int i = 5; i >= 0; i += -1) {  	GL.Begin (type);  	GL.Normal3 (boxVertices [i' 0]' boxVertices [i' 1]' boxVertices [i' 2]);  	int faceN = 0;  	faceN = boxFaces [i' 0];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 1];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 2];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 3];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	GL.End ();  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: for (int i = 5; i >= 0; i += -1) {  	GL.Begin (type);  	GL.Normal3 (boxVertices [i' 0]' boxVertices [i' 1]' boxVertices [i' 2]);  	int faceN = 0;  	faceN = boxFaces [i' 0];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 1];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 2];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 3];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	GL.End ();  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: for (int i = 5; i >= 0; i += -1) {  	GL.Begin (type);  	GL.Normal3 (boxVertices [i' 0]' boxVertices [i' 1]' boxVertices [i' 2]);  	int faceN = 0;  	faceN = boxFaces [i' 0];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 1];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 2];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 3];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	GL.End ();  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: for (int i = 5; i >= 0; i += -1) {  	GL.Begin (type);  	GL.Normal3 (boxVertices [i' 0]' boxVertices [i' 1]' boxVertices [i' 2]);  	int faceN = 0;  	faceN = boxFaces [i' 0];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 1];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 2];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 3];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	GL.End ();  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: for (int i = 5; i >= 0; i += -1) {  	GL.Begin (type);  	GL.Normal3 (boxVertices [i' 0]' boxVertices [i' 1]' boxVertices [i' 2]);  	int faceN = 0;  	faceN = boxFaces [i' 0];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 1];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 2];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	faceN = boxFaces [i' 3];  	GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  	GL.End ();  }  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: GL.Normal3 (boxVertices [i' 0]' boxVertices [i' 1]' boxVertices [i' 2]);  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: faceN = boxFaces [i' 2];  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: faceN = boxFaces [i' 3];  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,drawBox,The following statement contains a magic number: GL.Vertex3 (boxVertices [faceN' 0] * size' boxVertices [faceN' 1] * size' boxVertices [faceN' 2] * size);  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,UnProject,The following statement contains a magic number: @in.X = (@in.X - viewport [0]) / viewport [2];  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,UnProject,The following statement contains a magic number: @in.Y = (@in.Y - viewport [1]) / viewport [3];  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,UnProject,The following statement contains a magic number: @in.X = @in.X * 2.0 - 1.0;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,UnProject,The following statement contains a magic number: @in.Y = @in.Y * 2.0 - 1.0;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,UnProject,The following statement contains a magic number: @in.Z = @in.Z * 2.0 - 1.0;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,Project,The following statement contains a magic number: @out.W = (1 / @out.W) * 0.5;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,Project,The following statement contains a magic number: @out.X = @out.X * @out.W + 0.5;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,Project,The following statement contains a magic number: @out.Y = @out.Y * @out.W + 0.5;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,Project,The following statement contains a magic number: @out.Z = @out.Z * @out.W + 0.5;  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,Project,The following statement contains a magic number: winPos.X = @out.X * viewport [2] + viewport [0];  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,Project,The following statement contains a magic number: winPos.Y = @out.Y * viewport [3] + viewport [1];  
Magic Number,nzy3D.Glut,Glut,C:\repos\benoit74_nzy3d-api\nzy3d-api\Glut\Glut.cs,Perspective,The following statement contains a magic number: matrix.M43 = -2 * zNear * zFar / deltaZ;  
Magic Number,nzy3D.Maths.Algorithms.Interpolation.Bernstein,BernsteinPolynomial,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Algorithms\Interpolation\Bernstein\BernsteinPolynomial.cs,BernsteinPolynomial,The following statement contains a magic number: if (res < 2) {  	throw new ArgumentException ("Resolution must be at least 2"' "res");  }  
Magic Number,nzy3D.Maths.Algorithms.Interpolation.Bernstein,BernsteinPolynomial,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Algorithms\Interpolation\Bernstein\BernsteinPolynomial.cs,BernsteinPolynomial,The following statement contains a magic number: for (int i = 0; i <= resolution - 1; i++) {  	double t1 = 1 - t;  	double t12 = t1 * t1;  	double t2 = t * t;  	b0 [i] = t1 * t12;  	b1 [i] = 3 * t * t12;  	b2 [i] = 3 * t2 * t1;  	b3 [i] = t * t2;  	t = +dt;  }  
Magic Number,nzy3D.Maths.Algorithms.Interpolation.Bernstein,BernsteinPolynomial,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Algorithms\Interpolation\Bernstein\BernsteinPolynomial.cs,BernsteinPolynomial,The following statement contains a magic number: for (int i = 0; i <= resolution - 1; i++) {  	double t1 = 1 - t;  	double t12 = t1 * t1;  	double t2 = t * t;  	b0 [i] = t1 * t12;  	b1 [i] = 3 * t * t12;  	b2 [i] = 3 * t2 * t1;  	b3 [i] = t * t2;  	t = +dt;  }  
Magic Number,nzy3D.Maths.Algorithms.Interpolation.Bernstein,BernsteinPolynomial,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Algorithms\Interpolation\Bernstein\BernsteinPolynomial.cs,BernsteinPolynomial,The following statement contains a magic number: b1 [i] = 3 * t * t12;  
Magic Number,nzy3D.Maths.Algorithms.Interpolation.Bernstein,BernsteinPolynomial,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Algorithms\Interpolation\Bernstein\BernsteinPolynomial.cs,BernsteinPolynomial,The following statement contains a magic number: b2 [i] = 3 * t2 * t1;  
Magic Number,nzy3D.Maths.Algorithms.Interpolation.Bernstein,Spline3D,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Algorithms\Interpolation\Bernstein\Spline3D.cs,ComputeVertices,The following statement contains a magic number: for (int i = 0; i <= numP - 2; i++) {  	Coord3d p = points [i];  	Coord3d q = points [i + 1];  	deltaP = delta [i].@add (p);  	deltaQ = q.substract (delta [i + 1]);  	for (int k = 0; k <= resolution - 1; k++) {  		double x = p.x * bernstein.b0 [k] + deltaP.x * bernstein.b1 [k] + deltaQ.x * bernstein.b2 [k] + q.x * bernstein.b3 [k];  		double y = p.y * bernstein.b0 [k] + deltaP.y * bernstein.b1 [k] + deltaQ.y * bernstein.b2 [k] + q.y * bernstein.b3 [k];  		double z = p.z * bernstein.b0 [k] + deltaP.z * bernstein.b1 [k] + deltaQ.z * bernstein.b2 [k] + q.z * bernstein.b3 [k];  		vertices.Add (new Coord3d (x' y' z));  	}  }  
Magic Number,nzy3D.Maths.Algorithms.Interpolation.Bernstein,Spline3D,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Algorithms\Interpolation\Bernstein\Spline3D.cs,findCPoints,The following statement contains a magic number: coeffA [1].setvalues ((points [2].x - points [0].x - delta [0].x) * Tightness' (points [2].y - points [0].y - delta [0].y) * Tightness' (points [2].z - points [0].z - delta [0].z) * Tightness);  
Magic Number,nzy3D.Maths.Algorithms.Interpolation.Bernstein,Spline3D,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Algorithms\Interpolation\Bernstein\Spline3D.cs,findCPoints,The following statement contains a magic number: coeffA [1].setvalues ((points [2].x - points [0].x - delta [0].x) * Tightness' (points [2].y - points [0].y - delta [0].y) * Tightness' (points [2].z - points [0].z - delta [0].z) * Tightness);  
Magic Number,nzy3D.Maths.Algorithms.Interpolation.Bernstein,Spline3D,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Algorithms\Interpolation\Bernstein\Spline3D.cs,findCPoints,The following statement contains a magic number: coeffA [1].setvalues ((points [2].x - points [0].x - delta [0].x) * Tightness' (points [2].y - points [0].y - delta [0].y) * Tightness' (points [2].z - points [0].z - delta [0].z) * Tightness);  
Magic Number,nzy3D.Maths.Algorithms.Interpolation.Bernstein,Spline3D,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Algorithms\Interpolation\Bernstein\Spline3D.cs,findCPoints,The following statement contains a magic number: for (int i = 2; i <= numP - 2; i++) {  	bi [i] = -1 / (invTightness + bi [i - 1]);  	coeffA [i].setvalues (-(points [i + 1].x - points [i - 1].x - coeffA [i - 1].x) * bi [i]' -(points [i + 1].y - points [i - 1].y - coeffA [i - 1].y) * bi [i]' -(points [i + 1].z - points [i - 1].z - coeffA [i - 1].z) * bi [i]);  }  
Magic Number,nzy3D.Maths.Algorithms.Interpolation.Bernstein,Spline3D,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Algorithms\Interpolation\Bernstein\Spline3D.cs,findCPoints,The following statement contains a magic number: for (int i = 2; i <= numP - 2; i++) {  	bi [i] = -1 / (invTightness + bi [i - 1]);  	coeffA [i].setvalues (-(points [i + 1].x - points [i - 1].x - coeffA [i - 1].x) * bi [i]' -(points [i + 1].y - points [i - 1].y - coeffA [i - 1].y) * bi [i]' -(points [i + 1].z - points [i - 1].z - coeffA [i - 1].z) * bi [i]);  }  
Magic Number,nzy3D.Maths.Algorithms.Interpolation.Bernstein,Spline3D,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Algorithms\Interpolation\Bernstein\Spline3D.cs,findCPoints,The following statement contains a magic number: for (int i = numP - 2; i >= 1; i += -1) {  	delta [i].setvalues (coeffA [i].x + delta [i + 1].x * bi [i]' coeffA [i].y + delta [i + 1].y * bi [i]' coeffA [i].z + delta [i + 1].z * bi [i]);  }  
Magic Number,nzy3D.Maths,Angle3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Angle3d.cs,angle,The following statement contains a magic number: if ((sin () > 0)) {  	return Math.Acos (cos ());  }  else {  	return Math.PI * 2 - Math.Acos (cos ());  }  
Magic Number,nzy3D.Maths,Angle3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Angle3d.cs,angle,The following statement contains a magic number: return Math.PI * 2 - Math.Acos (cos ());  
Magic Number,nzy3D.Maths,BoundingBox2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\BoundingBox2d.cs,getCenter,The following statement contains a magic number: return new Coord2d ((m_xmax + m_xmin) / 2' (m_ymax + m_ymin) / 2);  
Magic Number,nzy3D.Maths,BoundingBox2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\BoundingBox2d.cs,getCenter,The following statement contains a magic number: return new Coord2d ((m_xmax + m_xmin) / 2' (m_ymax + m_ymin) / 2);  
Magic Number,nzy3D.Maths,BoundingBox3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\BoundingBox3d.cs,getCenter,The following statement contains a magic number: return new Coord3d ((m_xmax + m_xmin) / 2' (m_ymax + m_ymin) / 2' (m_zmax + m_zmin) / 2);  
Magic Number,nzy3D.Maths,BoundingBox3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\BoundingBox3d.cs,getCenter,The following statement contains a magic number: return new Coord3d ((m_xmax + m_xmin) / 2' (m_ymax + m_ymin) / 2' (m_zmax + m_zmin) / 2);  
Magic Number,nzy3D.Maths,BoundingBox3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\BoundingBox3d.cs,getCenter,The following statement contains a magic number: return new Coord3d ((m_xmax + m_xmin) / 2' (m_ymax + m_ymin) / 2' (m_zmax + m_zmin) / 2);  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,fullPolar,The following statement contains a magic number: if (x < 0) {  	return new Coord2d (Math.Atan (y / x)' radius);  }  else if (x > 0) {  	if (y >= 0) {  		return new Coord2d (Math.Atan (y / x)' radius);  	}  	else {  		return new Coord2d (Math.Atan (y / x) + 2 * Math.PI' radius);  	}  	//x=0  }  else {  	if (y > 0) {  		return new Coord2d (Math.PI / 2' radius);  	}  	else if (y > 0) {  		return new Coord2d (3 * Math.PI / 2' radius);  		//y=0  	}  	else {  		return new Coord2d (0' 0);  	}  }  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,fullPolar,The following statement contains a magic number: if (x < 0) {  	return new Coord2d (Math.Atan (y / x)' radius);  }  else if (x > 0) {  	if (y >= 0) {  		return new Coord2d (Math.Atan (y / x)' radius);  	}  	else {  		return new Coord2d (Math.Atan (y / x) + 2 * Math.PI' radius);  	}  	//x=0  }  else {  	if (y > 0) {  		return new Coord2d (Math.PI / 2' radius);  	}  	else if (y > 0) {  		return new Coord2d (3 * Math.PI / 2' radius);  		//y=0  	}  	else {  		return new Coord2d (0' 0);  	}  }  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,fullPolar,The following statement contains a magic number: if (x < 0) {  	return new Coord2d (Math.Atan (y / x)' radius);  }  else if (x > 0) {  	if (y >= 0) {  		return new Coord2d (Math.Atan (y / x)' radius);  	}  	else {  		return new Coord2d (Math.Atan (y / x) + 2 * Math.PI' radius);  	}  	//x=0  }  else {  	if (y > 0) {  		return new Coord2d (Math.PI / 2' radius);  	}  	else if (y > 0) {  		return new Coord2d (3 * Math.PI / 2' radius);  		//y=0  	}  	else {  		return new Coord2d (0' 0);  	}  }  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,fullPolar,The following statement contains a magic number: if (x < 0) {  	return new Coord2d (Math.Atan (y / x)' radius);  }  else if (x > 0) {  	if (y >= 0) {  		return new Coord2d (Math.Atan (y / x)' radius);  	}  	else {  		return new Coord2d (Math.Atan (y / x) + 2 * Math.PI' radius);  	}  	//x=0  }  else {  	if (y > 0) {  		return new Coord2d (Math.PI / 2' radius);  	}  	else if (y > 0) {  		return new Coord2d (3 * Math.PI / 2' radius);  		//y=0  	}  	else {  		return new Coord2d (0' 0);  	}  }  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,fullPolar,The following statement contains a magic number: if (x > 0) {  	if (y >= 0) {  		return new Coord2d (Math.Atan (y / x)' radius);  	}  	else {  		return new Coord2d (Math.Atan (y / x) + 2 * Math.PI' radius);  	}  	//x=0  }  else {  	if (y > 0) {  		return new Coord2d (Math.PI / 2' radius);  	}  	else if (y > 0) {  		return new Coord2d (3 * Math.PI / 2' radius);  		//y=0  	}  	else {  		return new Coord2d (0' 0);  	}  }  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,fullPolar,The following statement contains a magic number: if (x > 0) {  	if (y >= 0) {  		return new Coord2d (Math.Atan (y / x)' radius);  	}  	else {  		return new Coord2d (Math.Atan (y / x) + 2 * Math.PI' radius);  	}  	//x=0  }  else {  	if (y > 0) {  		return new Coord2d (Math.PI / 2' radius);  	}  	else if (y > 0) {  		return new Coord2d (3 * Math.PI / 2' radius);  		//y=0  	}  	else {  		return new Coord2d (0' 0);  	}  }  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,fullPolar,The following statement contains a magic number: if (x > 0) {  	if (y >= 0) {  		return new Coord2d (Math.Atan (y / x)' radius);  	}  	else {  		return new Coord2d (Math.Atan (y / x) + 2 * Math.PI' radius);  	}  	//x=0  }  else {  	if (y > 0) {  		return new Coord2d (Math.PI / 2' radius);  	}  	else if (y > 0) {  		return new Coord2d (3 * Math.PI / 2' radius);  		//y=0  	}  	else {  		return new Coord2d (0' 0);  	}  }  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,fullPolar,The following statement contains a magic number: if (x > 0) {  	if (y >= 0) {  		return new Coord2d (Math.Atan (y / x)' radius);  	}  	else {  		return new Coord2d (Math.Atan (y / x) + 2 * Math.PI' radius);  	}  	//x=0  }  else {  	if (y > 0) {  		return new Coord2d (Math.PI / 2' radius);  	}  	else if (y > 0) {  		return new Coord2d (3 * Math.PI / 2' radius);  		//y=0  	}  	else {  		return new Coord2d (0' 0);  	}  }  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,fullPolar,The following statement contains a magic number: if (y >= 0) {  	return new Coord2d (Math.Atan (y / x)' radius);  }  else {  	return new Coord2d (Math.Atan (y / x) + 2 * Math.PI' radius);  }  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,fullPolar,The following statement contains a magic number: return new Coord2d (Math.Atan (y / x) + 2 * Math.PI' radius);  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,fullPolar,The following statement contains a magic number: if (y > 0) {  	return new Coord2d (Math.PI / 2' radius);  }  else if (y > 0) {  	return new Coord2d (3 * Math.PI / 2' radius);  	//y=0  }  else {  	return new Coord2d (0' 0);  }  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,fullPolar,The following statement contains a magic number: if (y > 0) {  	return new Coord2d (Math.PI / 2' radius);  }  else if (y > 0) {  	return new Coord2d (3 * Math.PI / 2' radius);  	//y=0  }  else {  	return new Coord2d (0' 0);  }  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,fullPolar,The following statement contains a magic number: if (y > 0) {  	return new Coord2d (Math.PI / 2' radius);  }  else if (y > 0) {  	return new Coord2d (3 * Math.PI / 2' radius);  	//y=0  }  else {  	return new Coord2d (0' 0);  }  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,fullPolar,The following statement contains a magic number: return new Coord2d (Math.PI / 2' radius);  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,fullPolar,The following statement contains a magic number: if (y > 0) {  	return new Coord2d (3 * Math.PI / 2' radius);  	//y=0  }  else {  	return new Coord2d (0' 0);  }  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,fullPolar,The following statement contains a magic number: if (y > 0) {  	return new Coord2d (3 * Math.PI / 2' radius);  	//y=0  }  else {  	return new Coord2d (0' 0);  }  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,fullPolar,The following statement contains a magic number: return new Coord2d (3 * Math.PI / 2' radius);  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,fullPolar,The following statement contains a magic number: return new Coord2d (3 * Math.PI / 2' radius);  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,distance,The following statement contains a magic number: return Math.Sqrt (Math.Pow ((this.x - coord.x)' 2) + Math.Pow ((this.y - coord.y)' 2));  
Magic Number,nzy3D.Maths,Coord2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord2d.cs,distance,The following statement contains a magic number: return Math.Sqrt (Math.Pow ((this.x - coord.x)' 2) + Math.Pow ((this.y - coord.y)' 2));  
Magic Number,nzy3D.Maths,Coord3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord3d.cs,Coord3d,The following statement contains a magic number: if (values.Length != 3) {  	throw new Exception ("When creating a Coord3d from an array of double' the array must contain 3 elements (" + values.Length + " elements found here)");  }  
Magic Number,nzy3D.Maths,Coord3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord3d.cs,polar,The following statement contains a magic number: if (d == 0 & z > 0) {  	return new Coord3d (0' Math.PI / 2' r);  }  else if (d == 0 & z == 0) {  	return new Coord3d (0' 0' 0);  }  else if (d == 0 & z < 0) {  	return new Coord3d (0' -Math.PI / 2' r);  }  else {  	if (Math.Abs (x / d) < 1) {  		// Classical case for azimuth  		a = Math.Acos (x / d) * (y > 0 ? 1 : -1);  	}  	else if (y == 0 & x > 0) {  		a = 0;  	}  	else if (y == 0 & x < 0) {  		a = Math.PI;  	}  	else {  		a = 0;  	}  	e = Math.Atan (z / d);  }  
Magic Number,nzy3D.Maths,Coord3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord3d.cs,polar,The following statement contains a magic number: if (d == 0 & z > 0) {  	return new Coord3d (0' Math.PI / 2' r);  }  else if (d == 0 & z == 0) {  	return new Coord3d (0' 0' 0);  }  else if (d == 0 & z < 0) {  	return new Coord3d (0' -Math.PI / 2' r);  }  else {  	if (Math.Abs (x / d) < 1) {  		// Classical case for azimuth  		a = Math.Acos (x / d) * (y > 0 ? 1 : -1);  	}  	else if (y == 0 & x > 0) {  		a = 0;  	}  	else if (y == 0 & x < 0) {  		a = Math.PI;  	}  	else {  		a = 0;  	}  	e = Math.Atan (z / d);  }  
Magic Number,nzy3D.Maths,Coord3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord3d.cs,polar,The following statement contains a magic number: return new Coord3d (0' Math.PI / 2' r);  
Magic Number,nzy3D.Maths,Coord3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord3d.cs,polar,The following statement contains a magic number: if (d == 0 & z == 0) {  	return new Coord3d (0' 0' 0);  }  else if (d == 0 & z < 0) {  	return new Coord3d (0' -Math.PI / 2' r);  }  else {  	if (Math.Abs (x / d) < 1) {  		// Classical case for azimuth  		a = Math.Acos (x / d) * (y > 0 ? 1 : -1);  	}  	else if (y == 0 & x > 0) {  		a = 0;  	}  	else if (y == 0 & x < 0) {  		a = Math.PI;  	}  	else {  		a = 0;  	}  	e = Math.Atan (z / d);  }  
Magic Number,nzy3D.Maths,Coord3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord3d.cs,polar,The following statement contains a magic number: if (d == 0 & z < 0) {  	return new Coord3d (0' -Math.PI / 2' r);  }  else {  	if (Math.Abs (x / d) < 1) {  		// Classical case for azimuth  		a = Math.Acos (x / d) * (y > 0 ? 1 : -1);  	}  	else if (y == 0 & x > 0) {  		a = 0;  	}  	else if (y == 0 & x < 0) {  		a = Math.PI;  	}  	else {  		a = 0;  	}  	e = Math.Atan (z / d);  }  
Magic Number,nzy3D.Maths,Coord3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord3d.cs,polar,The following statement contains a magic number: return new Coord3d (0' -Math.PI / 2' r);  
Magic Number,nzy3D.Maths,Coord3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord3d.cs,distance,The following statement contains a magic number: return Math.Sqrt (Math.Pow ((this.x - coord.x)' 2) + Math.Pow ((this.y - coord.y)' 2) + Math.Pow ((this.z - coord.z)' 2));  
Magic Number,nzy3D.Maths,Coord3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord3d.cs,distance,The following statement contains a magic number: return Math.Sqrt (Math.Pow ((this.x - coord.x)' 2) + Math.Pow ((this.y - coord.y)' 2) + Math.Pow ((this.z - coord.z)' 2));  
Magic Number,nzy3D.Maths,Coord3d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Coord3d.cs,distance,The following statement contains a magic number: return Math.Sqrt (Math.Pow ((this.x - coord.x)' 2) + Math.Pow ((this.y - coord.y)' 2) + Math.Pow ((this.z - coord.z)' 2));  
Magic Number,nzy3D.Maths,Mapper,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Mapper.cs,getCoordinates,The following statement contains a magic number: if (xy.GetLength (1) != 2) {  	throw new ArgumentException ("Input array must have a length of 2 in second dimension"' "xy");  }  
Magic Number,nzy3D.Maths,Mapper,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Mapper.cs,getCoordinates,The following statement contains a magic number: if (xy.GetLength (1) != 2) {  	throw new ArgumentException ("Input array must have a length of 2 in second dimension"' "xy");  }  
Magic Number,nzy3D.Maths,Mapper,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Mapper.cs,getCoordinates,The following statement contains a magic number: if (xy.GetLength (0) != 2) {  	throw new ArgumentException ("Input array must have a length of 2"' "xy");  }  
Magic Number,nzy3D.Maths,Mapper,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Mapper.cs,getCoordinates,The following statement contains a magic number: if (xy.GetLength (0) != 2) {  	throw new ArgumentException ("Input array must have a length of 2"' "xy");  }  
Magic Number,nzy3D.Maths,Statistics,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Statistics.cs,Variance,The following statement contains a magic number: for (int i = 0; i <= values.Length - 1; i++) {  	if (!double.IsNaN (values [i])) {  		sum += Math.Pow (values [i] - mean' 2);  		count += 1;  	}  }  
Magic Number,nzy3D.Maths,Statistics,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Statistics.cs,Variance,The following statement contains a magic number: if (!double.IsNaN (values [i])) {  	sum += Math.Pow (values [i] - mean' 2);  	count += 1;  }  
Magic Number,nzy3D.Maths,Statistics,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Statistics.cs,Variance,The following statement contains a magic number: sum += Math.Pow (values [i] - mean' 2);  
Magic Number,nzy3D.Maths,Statistics,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Statistics.cs,Quantile,The following statement contains a magic number: for (int i = 0; i <= levels.Length - 1; i++) {  	if (levels [i] > 100 | levels [i] < 0) {  		throw new ArgumentException ("Input level [" + i + "]=" + levels [i] + "is out of bounds [0;100]"' "levels");  	}  	quantileIdx = (sorted.Length - 1) * levels [i] / 100;  	if (quantileIdx == Convert.ToInt32 (quantileIdx)) {  		// quantile exactly fond  		quantiles [i] = sorted [Convert.ToInt32 (quantileIdx)];  	}  	else {  		quantileIdxCeil = Math.Ceiling (quantileIdx);  		quantileIdxFloor = Math.Floor (quantileIdx);  		if (interpolated) {  			quantiles [i] = sorted [Convert.ToInt32 (quantileIdxFloor)] * (quantileIdxCeil - quantileIdx) + sorted [Convert.ToInt32 (quantileIdxCeil)] * (quantileIdx - quantileIdxFloor);  		}  		else {  			if ((quantileIdx - quantileIdxFloor < quantileIdxCeil - quantileIdx)) {  				quantiles [i] = sorted [Convert.ToInt32 (quantileIdxFloor)];  			}  			else {  				quantiles [i] = sorted [Convert.ToInt32 (quantileIdxCeil)];  			}  		}  	}  }  
Magic Number,nzy3D.Maths,Statistics,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Statistics.cs,Quantile,The following statement contains a magic number: for (int i = 0; i <= levels.Length - 1; i++) {  	if (levels [i] > 100 | levels [i] < 0) {  		throw new ArgumentException ("Input level [" + i + "]=" + levels [i] + "is out of bounds [0;100]"' "levels");  	}  	quantileIdx = (sorted.Length - 1) * levels [i] / 100;  	if (quantileIdx == Convert.ToInt32 (quantileIdx)) {  		// quantile exactly fond  		quantiles [i] = sorted [Convert.ToInt32 (quantileIdx)];  	}  	else {  		quantileIdxCeil = Math.Ceiling (quantileIdx);  		quantileIdxFloor = Math.Floor (quantileIdx);  		if (interpolated) {  			quantiles [i] = sorted [Convert.ToInt32 (quantileIdxFloor)] * (quantileIdxCeil - quantileIdx) + sorted [Convert.ToInt32 (quantileIdxCeil)] * (quantileIdx - quantileIdxFloor);  		}  		else {  			if ((quantileIdx - quantileIdxFloor < quantileIdxCeil - quantileIdx)) {  				quantiles [i] = sorted [Convert.ToInt32 (quantileIdxFloor)];  			}  			else {  				quantiles [i] = sorted [Convert.ToInt32 (quantileIdxCeil)];  			}  		}  	}  }  
Magic Number,nzy3D.Maths,Statistics,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Statistics.cs,Quantile,The following statement contains a magic number: if (levels [i] > 100 | levels [i] < 0) {  	throw new ArgumentException ("Input level [" + i + "]=" + levels [i] + "is out of bounds [0;100]"' "levels");  }  
Magic Number,nzy3D.Maths,Statistics,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Statistics.cs,Quantile,The following statement contains a magic number: quantileIdx = (sorted.Length - 1) * levels [i] / 100;  
Magic Number,nzy3D.Maths,Utils,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Utils.cs,vector,The following statement contains a magic number: for (int i = 0; i <= nstep - 2; i++) {  	grid [i] = min + i * dstep;  }  
Magic Number,nzy3D.Maths,Utils,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Utils.cs,vector,The following statement contains a magic number: for (int i = 0; i <= nstep - 2; i++) {  	grid [i] = min + i * dstep;  }  
Magic Number,nzy3D.Maths,Vector2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Vector2d.cs,norm,The following statement contains a magic number: return Math.Sqrt (Math.Pow (x2 - x1' 2) + Math.Pow (y2 - y1' 2));  
Magic Number,nzy3D.Maths,Vector2d,C:\repos\benoit74_nzy3d-api\nzy3d-api\Maths\Vector2d.cs,norm,The following statement contains a magic number: return Math.Sqrt (Math.Pow (x2 - x1' 2) + Math.Pow (y2 - y1' 2));  
Magic Number,nzy3D.Plot2D.Primitive,ColorbarImageGenerator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot2D\Primitives\ColorbarImageGenerator.cs,toImage,The following statement contains a magic number: return toImage (width' height' 20);  
Magic Number,nzy3D.Plot2D.Primitive,ColorbarImageGenerator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot2D\Primitives\ColorbarImageGenerator.cs,toImage,The following statement contains a magic number: for (int h = txtSize / 2; h <= (height - txtSize / 2); h++) {  	// Compute value & color  	float v = _min + (_max - _min) * h / (height - txtSize);  	//			Color c = mapper.getColor(new Coord3d(0'0'v));  	Color c = _mapper.Color (v);  	//To allow the Color to be a variable independent of the coordinates  	// Draw line  	graphic.DrawLine (new System.Drawing.Pen (new System.Drawing.SolidBrush (c.toColor ()))' 0' height - h' barWidth' height - h);  }  
Magic Number,nzy3D.Plot2D.Primitive,ColorbarImageGenerator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot2D\Primitives\ColorbarImageGenerator.cs,toImage,The following statement contains a magic number: for (int h = txtSize / 2; h <= (height - txtSize / 2); h++) {  	// Compute value & color  	float v = _min + (_max - _min) * h / (height - txtSize);  	//			Color c = mapper.getColor(new Coord3d(0'0'v));  	Color c = _mapper.Color (v);  	//To allow the Color to be a variable independent of the coordinates  	// Draw line  	graphic.DrawLine (new System.Drawing.Pen (new System.Drawing.SolidBrush (c.toColor ()))' 0' height - h' barWidth' height - h);  }  
Magic Number,nzy3D.Plot2D.Primitive,ColorbarImageGenerator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot2D\Primitives\ColorbarImageGenerator.cs,toImage,The following statement contains a magic number: graphic.FillRectangle (new System.Drawing.SolidBrush (_foregroundColor.toColor ())' 0' Convert.ToSingle (txtSize / 2)' barWidth' height - txtSize);  
Magic Number,nzy3D.Plot3D.Builder,Mapper,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Mapper.cs,f,The following statement contains a magic number: if (xy.GetLength (1) != 2) {  	throw new ArgumentException ("Input xy array must be have a length of 2 in second dimension. Current array second dimension has a lenght of " + xy.GetLength (1)' "xy");  }  
Magic Number,nzy3D.Plot3D.Builder,Mapper,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Mapper.cs,fAsSingle,The following statement contains a magic number: if (xy.GetLength (1) != 2) {  	throw new ArgumentException ("Input xy array must be have a length of 2 in second dimension. Current array second dimension has a lenght of " + xy.GetLength (1)' "xy");  }  
Magic Number,nzy3D.Plot3D.Builder,Mapper,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Mapper.cs,fAsSingle,The following statement contains a magic number: if (xy.GetLength (1) != 2) {  	throw new ArgumentException ("Input xy array must be have a length of 2 in second dimension. Current array second dimension has a lenght of " + xy.GetLength (1)' "xy");  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,BufferedImageMapper,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\BufferedImageMapper.cs,f,The following statement contains a magic number: return (rgbColor.R / 255 * 0.3) + (rgbColor.G / 255 * 0.59) + (rgbColor.B / 255 * 0.11);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,BufferedImageMapper,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\BufferedImageMapper.cs,f,The following statement contains a magic number: return (rgbColor.R / 255 * 0.3) + (rgbColor.G / 255 * 0.59) + (rgbColor.B / 255 * 0.11);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,BufferedImageMapper,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\BufferedImageMapper.cs,f,The following statement contains a magic number: return (rgbColor.R / 255 * 0.3) + (rgbColor.G / 255 * 0.59) + (rgbColor.B / 255 * 0.11);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,BufferedImageMapper,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\BufferedImageMapper.cs,f,The following statement contains a magic number: return (rgbColor.R / 255 * 0.3) + (rgbColor.G / 255 * 0.59) + (rgbColor.B / 255 * 0.11);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,BufferedImageMapper,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\BufferedImageMapper.cs,f,The following statement contains a magic number: return (rgbColor.R / 255 * 0.3) + (rgbColor.G / 255 * 0.59) + (rgbColor.B / 255 * 0.11);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,BufferedImageMapper,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\BufferedImageMapper.cs,f,The following statement contains a magic number: return (rgbColor.R / 255 * 0.3) + (rgbColor.G / 255 * 0.59) + (rgbColor.B / 255 * 0.11);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,CustomGrid,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\CustomGrid.cs,CustomGrid,The following statement contains a magic number: if (coordinates.GetLength (1) != 2) {  	throw new ArgumentException ("Input coordinates array must be have a length of 2 in second dimension. Current array second dimension has a lenght of " + coordinates.GetLength (1)' "coordinates");  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute quad making a polygon  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		if ((!validZ (p))) {  			continue;  			// ignore non valid set of points  		}  		if (((cmap != null))) {  			p [0].Color = cmap.Color (p [0].xyz);  			p [1].Color = cmap.Color (p [1].xyz);  			p [2].Color = cmap.Color (p [2].xyz);  			p [3].Color = cmap.Color (p [3].xyz);  		}  		if (((colorFactor != null))) {  			p [0].rgb.mul (colorFactor);  			p [1].rgb.mul (colorFactor);  			p [2].rgb.mul (colorFactor);  			p [3].rgb.mul (colorFactor);  		}  		// Store quad  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute quad making a polygon  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		if ((!validZ (p))) {  			continue;  			// ignore non valid set of points  		}  		if (((cmap != null))) {  			p [0].Color = cmap.Color (p [0].xyz);  			p [1].Color = cmap.Color (p [1].xyz);  			p [2].Color = cmap.Color (p [2].xyz);  			p [3].Color = cmap.Color (p [3].xyz);  		}  		if (((colorFactor != null))) {  			p [0].rgb.mul (colorFactor);  			p [1].rgb.mul (colorFactor);  			p [2].rgb.mul (colorFactor);  			p [3].rgb.mul (colorFactor);  		}  		// Store quad  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute quad making a polygon  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		if ((!validZ (p))) {  			continue;  			// ignore non valid set of points  		}  		if (((cmap != null))) {  			p [0].Color = cmap.Color (p [0].xyz);  			p [1].Color = cmap.Color (p [1].xyz);  			p [2].Color = cmap.Color (p [2].xyz);  			p [3].Color = cmap.Color (p [3].xyz);  		}  		if (((colorFactor != null))) {  			p [0].rgb.mul (colorFactor);  			p [1].rgb.mul (colorFactor);  			p [2].rgb.mul (colorFactor);  			p [3].rgb.mul (colorFactor);  		}  		// Store quad  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute quad making a polygon  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		if ((!validZ (p))) {  			continue;  			// ignore non valid set of points  		}  		if (((cmap != null))) {  			p [0].Color = cmap.Color (p [0].xyz);  			p [1].Color = cmap.Color (p [1].xyz);  			p [2].Color = cmap.Color (p [2].xyz);  			p [3].Color = cmap.Color (p [3].xyz);  		}  		if (((colorFactor != null))) {  			p [0].rgb.mul (colorFactor);  			p [1].rgb.mul (colorFactor);  			p [2].rgb.mul (colorFactor);  			p [3].rgb.mul (colorFactor);  		}  		// Store quad  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute quad making a polygon  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		if ((!validZ (p))) {  			continue;  			// ignore non valid set of points  		}  		if (((cmap != null))) {  			p [0].Color = cmap.Color (p [0].xyz);  			p [1].Color = cmap.Color (p [1].xyz);  			p [2].Color = cmap.Color (p [2].xyz);  			p [3].Color = cmap.Color (p [3].xyz);  		}  		if (((colorFactor != null))) {  			p [0].rgb.mul (colorFactor);  			p [1].rgb.mul (colorFactor);  			p [2].rgb.mul (colorFactor);  			p [3].rgb.mul (colorFactor);  		}  		// Store quad  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute quad making a polygon  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		if ((!validZ (p))) {  			continue;  			// ignore non valid set of points  		}  		if (((cmap != null))) {  			p [0].Color = cmap.Color (p [0].xyz);  			p [1].Color = cmap.Color (p [1].xyz);  			p [2].Color = cmap.Color (p [2].xyz);  			p [3].Color = cmap.Color (p [3].xyz);  		}  		if (((colorFactor != null))) {  			p [0].rgb.mul (colorFactor);  			p [1].rgb.mul (colorFactor);  			p [2].rgb.mul (colorFactor);  			p [3].rgb.mul (colorFactor);  		}  		// Store quad  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute quad making a polygon  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		if ((!validZ (p))) {  			continue;  			// ignore non valid set of points  		}  		if (((cmap != null))) {  			p [0].Color = cmap.Color (p [0].xyz);  			p [1].Color = cmap.Color (p [1].xyz);  			p [2].Color = cmap.Color (p [2].xyz);  			p [3].Color = cmap.Color (p [3].xyz);  		}  		if (((colorFactor != null))) {  			p [0].rgb.mul (colorFactor);  			p [1].rgb.mul (colorFactor);  			p [2].rgb.mul (colorFactor);  			p [3].rgb.mul (colorFactor);  		}  		// Store quad  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute quad making a polygon  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		if ((!validZ (p))) {  			continue;  			// ignore non valid set of points  		}  		if (((cmap != null))) {  			p [0].Color = cmap.Color (p [0].xyz);  			p [1].Color = cmap.Color (p [1].xyz);  			p [2].Color = cmap.Color (p [2].xyz);  			p [3].Color = cmap.Color (p [3].xyz);  		}  		if (((colorFactor != null))) {  			p [0].rgb.mul (colorFactor);  			p [1].rgb.mul (colorFactor);  			p [2].rgb.mul (colorFactor);  			p [3].rgb.mul (colorFactor);  		}  		// Store quad  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute quad making a polygon  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	if ((!validZ (p))) {  		continue;  		// ignore non valid set of points  	}  	if (((cmap != null))) {  		p [0].Color = cmap.Color (p [0].xyz);  		p [1].Color = cmap.Color (p [1].xyz);  		p [2].Color = cmap.Color (p [2].xyz);  		p [3].Color = cmap.Color (p [3].xyz);  	}  	if (((colorFactor != null))) {  		p [0].rgb.mul (colorFactor);  		p [1].rgb.mul (colorFactor);  		p [2].rgb.mul (colorFactor);  		p [3].rgb.mul (colorFactor);  	}  	// Store quad  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute quad making a polygon  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	if ((!validZ (p))) {  		continue;  		// ignore non valid set of points  	}  	if (((cmap != null))) {  		p [0].Color = cmap.Color (p [0].xyz);  		p [1].Color = cmap.Color (p [1].xyz);  		p [2].Color = cmap.Color (p [2].xyz);  		p [3].Color = cmap.Color (p [3].xyz);  	}  	if (((colorFactor != null))) {  		p [0].rgb.mul (colorFactor);  		p [1].rgb.mul (colorFactor);  		p [2].rgb.mul (colorFactor);  		p [3].rgb.mul (colorFactor);  	}  	// Store quad  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute quad making a polygon  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	if ((!validZ (p))) {  		continue;  		// ignore non valid set of points  	}  	if (((cmap != null))) {  		p [0].Color = cmap.Color (p [0].xyz);  		p [1].Color = cmap.Color (p [1].xyz);  		p [2].Color = cmap.Color (p [2].xyz);  		p [3].Color = cmap.Color (p [3].xyz);  	}  	if (((colorFactor != null))) {  		p [0].rgb.mul (colorFactor);  		p [1].rgb.mul (colorFactor);  		p [2].rgb.mul (colorFactor);  		p [3].rgb.mul (colorFactor);  	}  	// Store quad  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute quad making a polygon  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	if ((!validZ (p))) {  		continue;  		// ignore non valid set of points  	}  	if (((cmap != null))) {  		p [0].Color = cmap.Color (p [0].xyz);  		p [1].Color = cmap.Color (p [1].xyz);  		p [2].Color = cmap.Color (p [2].xyz);  		p [3].Color = cmap.Color (p [3].xyz);  	}  	if (((colorFactor != null))) {  		p [0].rgb.mul (colorFactor);  		p [1].rgb.mul (colorFactor);  		p [2].rgb.mul (colorFactor);  		p [3].rgb.mul (colorFactor);  	}  	// Store quad  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute quad making a polygon  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	if ((!validZ (p))) {  		continue;  		// ignore non valid set of points  	}  	if (((cmap != null))) {  		p [0].Color = cmap.Color (p [0].xyz);  		p [1].Color = cmap.Color (p [1].xyz);  		p [2].Color = cmap.Color (p [2].xyz);  		p [3].Color = cmap.Color (p [3].xyz);  	}  	if (((colorFactor != null))) {  		p [0].rgb.mul (colorFactor);  		p [1].rgb.mul (colorFactor);  		p [2].rgb.mul (colorFactor);  		p [3].rgb.mul (colorFactor);  	}  	// Store quad  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute quad making a polygon  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	if ((!validZ (p))) {  		continue;  		// ignore non valid set of points  	}  	if (((cmap != null))) {  		p [0].Color = cmap.Color (p [0].xyz);  		p [1].Color = cmap.Color (p [1].xyz);  		p [2].Color = cmap.Color (p [2].xyz);  		p [3].Color = cmap.Color (p [3].xyz);  	}  	if (((colorFactor != null))) {  		p [0].rgb.mul (colorFactor);  		p [1].rgb.mul (colorFactor);  		p [2].rgb.mul (colorFactor);  		p [3].rgb.mul (colorFactor);  	}  	// Store quad  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute quad making a polygon  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	if ((!validZ (p))) {  		continue;  		// ignore non valid set of points  	}  	if (((cmap != null))) {  		p [0].Color = cmap.Color (p [0].xyz);  		p [1].Color = cmap.Color (p [1].xyz);  		p [2].Color = cmap.Color (p [2].xyz);  		p [3].Color = cmap.Color (p [3].xyz);  	}  	if (((colorFactor != null))) {  		p [0].rgb.mul (colorFactor);  		p [1].rgb.mul (colorFactor);  		p [2].rgb.mul (colorFactor);  		p [3].rgb.mul (colorFactor);  	}  	// Store quad  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: if (((cmap != null))) {  	p [0].Color = cmap.Color (p [0].xyz);  	p [1].Color = cmap.Color (p [1].xyz);  	p [2].Color = cmap.Color (p [2].xyz);  	p [3].Color = cmap.Color (p [3].xyz);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: if (((cmap != null))) {  	p [0].Color = cmap.Color (p [0].xyz);  	p [1].Color = cmap.Color (p [1].xyz);  	p [2].Color = cmap.Color (p [2].xyz);  	p [3].Color = cmap.Color (p [3].xyz);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: if (((cmap != null))) {  	p [0].Color = cmap.Color (p [0].xyz);  	p [1].Color = cmap.Color (p [1].xyz);  	p [2].Color = cmap.Color (p [2].xyz);  	p [3].Color = cmap.Color (p [3].xyz);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: if (((cmap != null))) {  	p [0].Color = cmap.Color (p [0].xyz);  	p [1].Color = cmap.Color (p [1].xyz);  	p [2].Color = cmap.Color (p [2].xyz);  	p [3].Color = cmap.Color (p [3].xyz);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: p [2].Color = cmap.Color (p [2].xyz);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: p [2].Color = cmap.Color (p [2].xyz);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: p [3].Color = cmap.Color (p [3].xyz);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: p [3].Color = cmap.Color (p [3].xyz);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: if (((colorFactor != null))) {  	p [0].rgb.mul (colorFactor);  	p [1].rgb.mul (colorFactor);  	p [2].rgb.mul (colorFactor);  	p [3].rgb.mul (colorFactor);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: if (((colorFactor != null))) {  	p [0].rgb.mul (colorFactor);  	p [1].rgb.mul (colorFactor);  	p [2].rgb.mul (colorFactor);  	p [3].rgb.mul (colorFactor);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: p [2].rgb.mul (colorFactor);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsOnCoordinates,The following statement contains a magic number: p [3].rgb.mul (colorFactor);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute quad making a polygon  		Point[] p = getEstimatedQuadSurroundingPoint (xi' yi);  		if ((!validZ (p))) {  			continue;  			// ignore non valid set of points  		}  		if (((cmap != null))) {  			p [0].Color = cmap.Color (p [0].xyz);  			p [1].Color = cmap.Color (p [1].xyz);  			p [2].Color = cmap.Color (p [2].xyz);  			p [3].Color = cmap.Color (p [3].xyz);  		}  		if (((colorFactor != null))) {  			p [0].rgb.mul (colorFactor);  			p [1].rgb.mul (colorFactor);  			p [2].rgb.mul (colorFactor);  			p [3].rgb.mul (colorFactor);  		}  		// Store quad  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute quad making a polygon  		Point[] p = getEstimatedQuadSurroundingPoint (xi' yi);  		if ((!validZ (p))) {  			continue;  			// ignore non valid set of points  		}  		if (((cmap != null))) {  			p [0].Color = cmap.Color (p [0].xyz);  			p [1].Color = cmap.Color (p [1].xyz);  			p [2].Color = cmap.Color (p [2].xyz);  			p [3].Color = cmap.Color (p [3].xyz);  		}  		if (((colorFactor != null))) {  			p [0].rgb.mul (colorFactor);  			p [1].rgb.mul (colorFactor);  			p [2].rgb.mul (colorFactor);  			p [3].rgb.mul (colorFactor);  		}  		// Store quad  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute quad making a polygon  		Point[] p = getEstimatedQuadSurroundingPoint (xi' yi);  		if ((!validZ (p))) {  			continue;  			// ignore non valid set of points  		}  		if (((cmap != null))) {  			p [0].Color = cmap.Color (p [0].xyz);  			p [1].Color = cmap.Color (p [1].xyz);  			p [2].Color = cmap.Color (p [2].xyz);  			p [3].Color = cmap.Color (p [3].xyz);  		}  		if (((colorFactor != null))) {  			p [0].rgb.mul (colorFactor);  			p [1].rgb.mul (colorFactor);  			p [2].rgb.mul (colorFactor);  			p [3].rgb.mul (colorFactor);  		}  		// Store quad  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute quad making a polygon  		Point[] p = getEstimatedQuadSurroundingPoint (xi' yi);  		if ((!validZ (p))) {  			continue;  			// ignore non valid set of points  		}  		if (((cmap != null))) {  			p [0].Color = cmap.Color (p [0].xyz);  			p [1].Color = cmap.Color (p [1].xyz);  			p [2].Color = cmap.Color (p [2].xyz);  			p [3].Color = cmap.Color (p [3].xyz);  		}  		if (((colorFactor != null))) {  			p [0].rgb.mul (colorFactor);  			p [1].rgb.mul (colorFactor);  			p [2].rgb.mul (colorFactor);  			p [3].rgb.mul (colorFactor);  		}  		// Store quad  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute quad making a polygon  		Point[] p = getEstimatedQuadSurroundingPoint (xi' yi);  		if ((!validZ (p))) {  			continue;  			// ignore non valid set of points  		}  		if (((cmap != null))) {  			p [0].Color = cmap.Color (p [0].xyz);  			p [1].Color = cmap.Color (p [1].xyz);  			p [2].Color = cmap.Color (p [2].xyz);  			p [3].Color = cmap.Color (p [3].xyz);  		}  		if (((colorFactor != null))) {  			p [0].rgb.mul (colorFactor);  			p [1].rgb.mul (colorFactor);  			p [2].rgb.mul (colorFactor);  			p [3].rgb.mul (colorFactor);  		}  		// Store quad  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute quad making a polygon  		Point[] p = getEstimatedQuadSurroundingPoint (xi' yi);  		if ((!validZ (p))) {  			continue;  			// ignore non valid set of points  		}  		if (((cmap != null))) {  			p [0].Color = cmap.Color (p [0].xyz);  			p [1].Color = cmap.Color (p [1].xyz);  			p [2].Color = cmap.Color (p [2].xyz);  			p [3].Color = cmap.Color (p [3].xyz);  		}  		if (((colorFactor != null))) {  			p [0].rgb.mul (colorFactor);  			p [1].rgb.mul (colorFactor);  			p [2].rgb.mul (colorFactor);  			p [3].rgb.mul (colorFactor);  		}  		// Store quad  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute quad making a polygon  		Point[] p = getEstimatedQuadSurroundingPoint (xi' yi);  		if ((!validZ (p))) {  			continue;  			// ignore non valid set of points  		}  		if (((cmap != null))) {  			p [0].Color = cmap.Color (p [0].xyz);  			p [1].Color = cmap.Color (p [1].xyz);  			p [2].Color = cmap.Color (p [2].xyz);  			p [3].Color = cmap.Color (p [3].xyz);  		}  		if (((colorFactor != null))) {  			p [0].rgb.mul (colorFactor);  			p [1].rgb.mul (colorFactor);  			p [2].rgb.mul (colorFactor);  			p [3].rgb.mul (colorFactor);  		}  		// Store quad  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute quad making a polygon  		Point[] p = getEstimatedQuadSurroundingPoint (xi' yi);  		if ((!validZ (p))) {  			continue;  			// ignore non valid set of points  		}  		if (((cmap != null))) {  			p [0].Color = cmap.Color (p [0].xyz);  			p [1].Color = cmap.Color (p [1].xyz);  			p [2].Color = cmap.Color (p [2].xyz);  			p [3].Color = cmap.Color (p [3].xyz);  		}  		if (((colorFactor != null))) {  			p [0].rgb.mul (colorFactor);  			p [1].rgb.mul (colorFactor);  			p [2].rgb.mul (colorFactor);  			p [3].rgb.mul (colorFactor);  		}  		// Store quad  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute quad making a polygon  	Point[] p = getEstimatedQuadSurroundingPoint (xi' yi);  	if ((!validZ (p))) {  		continue;  		// ignore non valid set of points  	}  	if (((cmap != null))) {  		p [0].Color = cmap.Color (p [0].xyz);  		p [1].Color = cmap.Color (p [1].xyz);  		p [2].Color = cmap.Color (p [2].xyz);  		p [3].Color = cmap.Color (p [3].xyz);  	}  	if (((colorFactor != null))) {  		p [0].rgb.mul (colorFactor);  		p [1].rgb.mul (colorFactor);  		p [2].rgb.mul (colorFactor);  		p [3].rgb.mul (colorFactor);  	}  	// Store quad  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute quad making a polygon  	Point[] p = getEstimatedQuadSurroundingPoint (xi' yi);  	if ((!validZ (p))) {  		continue;  		// ignore non valid set of points  	}  	if (((cmap != null))) {  		p [0].Color = cmap.Color (p [0].xyz);  		p [1].Color = cmap.Color (p [1].xyz);  		p [2].Color = cmap.Color (p [2].xyz);  		p [3].Color = cmap.Color (p [3].xyz);  	}  	if (((colorFactor != null))) {  		p [0].rgb.mul (colorFactor);  		p [1].rgb.mul (colorFactor);  		p [2].rgb.mul (colorFactor);  		p [3].rgb.mul (colorFactor);  	}  	// Store quad  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute quad making a polygon  	Point[] p = getEstimatedQuadSurroundingPoint (xi' yi);  	if ((!validZ (p))) {  		continue;  		// ignore non valid set of points  	}  	if (((cmap != null))) {  		p [0].Color = cmap.Color (p [0].xyz);  		p [1].Color = cmap.Color (p [1].xyz);  		p [2].Color = cmap.Color (p [2].xyz);  		p [3].Color = cmap.Color (p [3].xyz);  	}  	if (((colorFactor != null))) {  		p [0].rgb.mul (colorFactor);  		p [1].rgb.mul (colorFactor);  		p [2].rgb.mul (colorFactor);  		p [3].rgb.mul (colorFactor);  	}  	// Store quad  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute quad making a polygon  	Point[] p = getEstimatedQuadSurroundingPoint (xi' yi);  	if ((!validZ (p))) {  		continue;  		// ignore non valid set of points  	}  	if (((cmap != null))) {  		p [0].Color = cmap.Color (p [0].xyz);  		p [1].Color = cmap.Color (p [1].xyz);  		p [2].Color = cmap.Color (p [2].xyz);  		p [3].Color = cmap.Color (p [3].xyz);  	}  	if (((colorFactor != null))) {  		p [0].rgb.mul (colorFactor);  		p [1].rgb.mul (colorFactor);  		p [2].rgb.mul (colorFactor);  		p [3].rgb.mul (colorFactor);  	}  	// Store quad  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute quad making a polygon  	Point[] p = getEstimatedQuadSurroundingPoint (xi' yi);  	if ((!validZ (p))) {  		continue;  		// ignore non valid set of points  	}  	if (((cmap != null))) {  		p [0].Color = cmap.Color (p [0].xyz);  		p [1].Color = cmap.Color (p [1].xyz);  		p [2].Color = cmap.Color (p [2].xyz);  		p [3].Color = cmap.Color (p [3].xyz);  	}  	if (((colorFactor != null))) {  		p [0].rgb.mul (colorFactor);  		p [1].rgb.mul (colorFactor);  		p [2].rgb.mul (colorFactor);  		p [3].rgb.mul (colorFactor);  	}  	// Store quad  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute quad making a polygon  	Point[] p = getEstimatedQuadSurroundingPoint (xi' yi);  	if ((!validZ (p))) {  		continue;  		// ignore non valid set of points  	}  	if (((cmap != null))) {  		p [0].Color = cmap.Color (p [0].xyz);  		p [1].Color = cmap.Color (p [1].xyz);  		p [2].Color = cmap.Color (p [2].xyz);  		p [3].Color = cmap.Color (p [3].xyz);  	}  	if (((colorFactor != null))) {  		p [0].rgb.mul (colorFactor);  		p [1].rgb.mul (colorFactor);  		p [2].rgb.mul (colorFactor);  		p [3].rgb.mul (colorFactor);  	}  	// Store quad  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute quad making a polygon  	Point[] p = getEstimatedQuadSurroundingPoint (xi' yi);  	if ((!validZ (p))) {  		continue;  		// ignore non valid set of points  	}  	if (((cmap != null))) {  		p [0].Color = cmap.Color (p [0].xyz);  		p [1].Color = cmap.Color (p [1].xyz);  		p [2].Color = cmap.Color (p [2].xyz);  		p [3].Color = cmap.Color (p [3].xyz);  	}  	if (((colorFactor != null))) {  		p [0].rgb.mul (colorFactor);  		p [1].rgb.mul (colorFactor);  		p [2].rgb.mul (colorFactor);  		p [3].rgb.mul (colorFactor);  	}  	// Store quad  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: if (((cmap != null))) {  	p [0].Color = cmap.Color (p [0].xyz);  	p [1].Color = cmap.Color (p [1].xyz);  	p [2].Color = cmap.Color (p [2].xyz);  	p [3].Color = cmap.Color (p [3].xyz);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: if (((cmap != null))) {  	p [0].Color = cmap.Color (p [0].xyz);  	p [1].Color = cmap.Color (p [1].xyz);  	p [2].Color = cmap.Color (p [2].xyz);  	p [3].Color = cmap.Color (p [3].xyz);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: if (((cmap != null))) {  	p [0].Color = cmap.Color (p [0].xyz);  	p [1].Color = cmap.Color (p [1].xyz);  	p [2].Color = cmap.Color (p [2].xyz);  	p [3].Color = cmap.Color (p [3].xyz);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: if (((cmap != null))) {  	p [0].Color = cmap.Color (p [0].xyz);  	p [1].Color = cmap.Color (p [1].xyz);  	p [2].Color = cmap.Color (p [2].xyz);  	p [3].Color = cmap.Color (p [3].xyz);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: p [2].Color = cmap.Color (p [2].xyz);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: p [2].Color = cmap.Color (p [2].xyz);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: p [3].Color = cmap.Color (p [3].xyz);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: p [3].Color = cmap.Color (p [3].xyz);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: if (((colorFactor != null))) {  	p [0].rgb.mul (colorFactor);  	p [1].rgb.mul (colorFactor);  	p [2].rgb.mul (colorFactor);  	p [3].rgb.mul (colorFactor);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: if (((colorFactor != null))) {  	p [0].rgb.mul (colorFactor);  	p [1].rgb.mul (colorFactor);  	p [2].rgb.mul (colorFactor);  	p [3].rgb.mul (colorFactor);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: p [2].rgb.mul (colorFactor);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getSquarePolygonsAroundCoordinates,The following statement contains a magic number: p [3].rgb.mul (colorFactor);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getRealQuadStandingOnPoint,The following statement contains a magic number: p [2] = new Point (new Coord3d (x [xi + 1]' y [yi + 1]' z [xi + 1' yi + 1]));  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getRealQuadStandingOnPoint,The following statement contains a magic number: p [3] = new Point (new Coord3d (x [xi]' y [yi + 1]' z [xi' yi + 1]));  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getEstimatedQuadSurroundingPoint,The following statement contains a magic number: p [0] = new Point (new Coord3d ((x [xi - 1] + x [xi]) / 2' (y [yi + 1] + y [yi]) / 2' (z [xi - 1' yi + 1] + z [xi - 1' yi] + z [xi' yi] + z [xi' yi + 1]) / 4));  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getEstimatedQuadSurroundingPoint,The following statement contains a magic number: p [0] = new Point (new Coord3d ((x [xi - 1] + x [xi]) / 2' (y [yi + 1] + y [yi]) / 2' (z [xi - 1' yi + 1] + z [xi - 1' yi] + z [xi' yi] + z [xi' yi + 1]) / 4));  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getEstimatedQuadSurroundingPoint,The following statement contains a magic number: p [0] = new Point (new Coord3d ((x [xi - 1] + x [xi]) / 2' (y [yi + 1] + y [yi]) / 2' (z [xi - 1' yi + 1] + z [xi - 1' yi] + z [xi' yi] + z [xi' yi + 1]) / 4));  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getEstimatedQuadSurroundingPoint,The following statement contains a magic number: p [1] = new Point (new Coord3d ((x [xi - 1] + x [xi]) / 2' (y [yi - 1] + y [yi]) / 2' (z [xi - 1' yi] + z [xi - 1' yi - 1] + z [xi' yi - 1] + z [xi' yi]) / 4));  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getEstimatedQuadSurroundingPoint,The following statement contains a magic number: p [1] = new Point (new Coord3d ((x [xi - 1] + x [xi]) / 2' (y [yi - 1] + y [yi]) / 2' (z [xi - 1' yi] + z [xi - 1' yi - 1] + z [xi' yi - 1] + z [xi' yi]) / 4));  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getEstimatedQuadSurroundingPoint,The following statement contains a magic number: p [1] = new Point (new Coord3d ((x [xi - 1] + x [xi]) / 2' (y [yi - 1] + y [yi]) / 2' (z [xi - 1' yi] + z [xi - 1' yi - 1] + z [xi' yi - 1] + z [xi' yi]) / 4));  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getEstimatedQuadSurroundingPoint,The following statement contains a magic number: p [2] = new Point (new Coord3d ((x [xi + 1] + x [xi]) / 2' (y [yi - 1] + y [yi]) / 2' (z [xi' yi] + z [xi' yi - 1] + z [xi + 1' yi - 1] + z [xi + 1' yi]) / 4));  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getEstimatedQuadSurroundingPoint,The following statement contains a magic number: p [2] = new Point (new Coord3d ((x [xi + 1] + x [xi]) / 2' (y [yi - 1] + y [yi]) / 2' (z [xi' yi] + z [xi' yi - 1] + z [xi + 1' yi - 1] + z [xi + 1' yi]) / 4));  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getEstimatedQuadSurroundingPoint,The following statement contains a magic number: p [2] = new Point (new Coord3d ((x [xi + 1] + x [xi]) / 2' (y [yi - 1] + y [yi]) / 2' (z [xi' yi] + z [xi' yi - 1] + z [xi + 1' yi - 1] + z [xi + 1' yi]) / 4));  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getEstimatedQuadSurroundingPoint,The following statement contains a magic number: p [2] = new Point (new Coord3d ((x [xi + 1] + x [xi]) / 2' (y [yi - 1] + y [yi]) / 2' (z [xi' yi] + z [xi' yi - 1] + z [xi + 1' yi - 1] + z [xi + 1' yi]) / 4));  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getEstimatedQuadSurroundingPoint,The following statement contains a magic number: p [3] = new Point (new Coord3d ((x [xi + 1] + x [xi]) / 2' (y [yi + 1] + y [yi]) / 2' (z [xi' yi + 1] + z [xi' yi] + z [xi + 1' yi] + z [xi + 1' yi + 1]) / 4));  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getEstimatedQuadSurroundingPoint,The following statement contains a magic number: p [3] = new Point (new Coord3d ((x [xi + 1] + x [xi]) / 2' (y [yi + 1] + y [yi]) / 2' (z [xi' yi + 1] + z [xi' yi] + z [xi + 1' yi] + z [xi + 1' yi + 1]) / 4));  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getEstimatedQuadSurroundingPoint,The following statement contains a magic number: p [3] = new Point (new Coord3d ((x [xi + 1] + x [xi]) / 2' (y [yi + 1] + y [yi]) / 2' (z [xi' yi + 1] + z [xi' yi] + z [xi + 1' yi] + z [xi + 1' yi + 1]) / 4));  
Magic Number,nzy3D.Plot3D.Builder.Concrete,OrthonormalTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\OrthonormalTessellator.cs,getEstimatedQuadSurroundingPoint,The following statement contains a magic number: p [3] = new Point (new Coord3d ((x [xi + 1] + x [xi]) / 2' (y [yi + 1] + y [yi]) / 2' (z [xi' yi + 1] + z [xi' yi] + z [xi + 1' yi] + z [xi + 1' yi + 1]) / 4));  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingExtrapolator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingExtrapolator.cs,extrapolate,The following statement contains a magic number: for (int i = xmiddle; i <= xnew.Length - 1; i++) {  	for (int j = ymiddle; j <= ynew.Length - 1; j++) {  		float sqrad = xnew [i] * xnew [i] + ynew [j] * ynew [j];  		// distance to center  		if ((sqrad < olddiameter)) {  			// ignore existing values  			continue;  		}  		else if ((sqrad < newdiameter & sqrad >= olddiameter)) {  			// ignore existing values  			int xopp = i - 2 * (i - xmiddle);  			int yopp = j - 2 * (j - ymiddle);  			znew [i' j] = getExtrapolatedZ (znew' i' j);  			// right up quadrant  			znew [xopp' j] = getExtrapolatedZ (znew' xopp' j);  			// left  up  			znew [i' yopp] = getExtrapolatedZ (znew' i' yopp);  			// right down  			znew [xopp' yopp] = getExtrapolatedZ (znew' xopp' yopp);  			// left  down  			//if(sqrad > newdiameter)  		}  		else {  			// ignore values standing outside desired diameter  			znew [i' j] = float.NaN;  		}  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingExtrapolator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingExtrapolator.cs,extrapolate,The following statement contains a magic number: for (int i = xmiddle; i <= xnew.Length - 1; i++) {  	for (int j = ymiddle; j <= ynew.Length - 1; j++) {  		float sqrad = xnew [i] * xnew [i] + ynew [j] * ynew [j];  		// distance to center  		if ((sqrad < olddiameter)) {  			// ignore existing values  			continue;  		}  		else if ((sqrad < newdiameter & sqrad >= olddiameter)) {  			// ignore existing values  			int xopp = i - 2 * (i - xmiddle);  			int yopp = j - 2 * (j - ymiddle);  			znew [i' j] = getExtrapolatedZ (znew' i' j);  			// right up quadrant  			znew [xopp' j] = getExtrapolatedZ (znew' xopp' j);  			// left  up  			znew [i' yopp] = getExtrapolatedZ (znew' i' yopp);  			// right down  			znew [xopp' yopp] = getExtrapolatedZ (znew' xopp' yopp);  			// left  down  			//if(sqrad > newdiameter)  		}  		else {  			// ignore values standing outside desired diameter  			znew [i' j] = float.NaN;  		}  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingExtrapolator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingExtrapolator.cs,extrapolate,The following statement contains a magic number: for (int j = ymiddle; j <= ynew.Length - 1; j++) {  	float sqrad = xnew [i] * xnew [i] + ynew [j] * ynew [j];  	// distance to center  	if ((sqrad < olddiameter)) {  		// ignore existing values  		continue;  	}  	else if ((sqrad < newdiameter & sqrad >= olddiameter)) {  		// ignore existing values  		int xopp = i - 2 * (i - xmiddle);  		int yopp = j - 2 * (j - ymiddle);  		znew [i' j] = getExtrapolatedZ (znew' i' j);  		// right up quadrant  		znew [xopp' j] = getExtrapolatedZ (znew' xopp' j);  		// left  up  		znew [i' yopp] = getExtrapolatedZ (znew' i' yopp);  		// right down  		znew [xopp' yopp] = getExtrapolatedZ (znew' xopp' yopp);  		// left  down  		//if(sqrad > newdiameter)  	}  	else {  		// ignore values standing outside desired diameter  		znew [i' j] = float.NaN;  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingExtrapolator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingExtrapolator.cs,extrapolate,The following statement contains a magic number: for (int j = ymiddle; j <= ynew.Length - 1; j++) {  	float sqrad = xnew [i] * xnew [i] + ynew [j] * ynew [j];  	// distance to center  	if ((sqrad < olddiameter)) {  		// ignore existing values  		continue;  	}  	else if ((sqrad < newdiameter & sqrad >= olddiameter)) {  		// ignore existing values  		int xopp = i - 2 * (i - xmiddle);  		int yopp = j - 2 * (j - ymiddle);  		znew [i' j] = getExtrapolatedZ (znew' i' j);  		// right up quadrant  		znew [xopp' j] = getExtrapolatedZ (znew' xopp' j);  		// left  up  		znew [i' yopp] = getExtrapolatedZ (znew' i' yopp);  		// right down  		znew [xopp' yopp] = getExtrapolatedZ (znew' xopp' yopp);  		// left  down  		//if(sqrad > newdiameter)  	}  	else {  		// ignore values standing outside desired diameter  		znew [i' j] = float.NaN;  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingExtrapolator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingExtrapolator.cs,extrapolate,The following statement contains a magic number: if ((sqrad < olddiameter)) {  	// ignore existing values  	continue;  }  else if ((sqrad < newdiameter & sqrad >= olddiameter)) {  	// ignore existing values  	int xopp = i - 2 * (i - xmiddle);  	int yopp = j - 2 * (j - ymiddle);  	znew [i' j] = getExtrapolatedZ (znew' i' j);  	// right up quadrant  	znew [xopp' j] = getExtrapolatedZ (znew' xopp' j);  	// left  up  	znew [i' yopp] = getExtrapolatedZ (znew' i' yopp);  	// right down  	znew [xopp' yopp] = getExtrapolatedZ (znew' xopp' yopp);  	// left  down  	//if(sqrad > newdiameter)  }  else {  	// ignore values standing outside desired diameter  	znew [i' j] = float.NaN;  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingExtrapolator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingExtrapolator.cs,extrapolate,The following statement contains a magic number: if ((sqrad < olddiameter)) {  	// ignore existing values  	continue;  }  else if ((sqrad < newdiameter & sqrad >= olddiameter)) {  	// ignore existing values  	int xopp = i - 2 * (i - xmiddle);  	int yopp = j - 2 * (j - ymiddle);  	znew [i' j] = getExtrapolatedZ (znew' i' j);  	// right up quadrant  	znew [xopp' j] = getExtrapolatedZ (znew' xopp' j);  	// left  up  	znew [i' yopp] = getExtrapolatedZ (znew' i' yopp);  	// right down  	znew [xopp' yopp] = getExtrapolatedZ (znew' xopp' yopp);  	// left  down  	//if(sqrad > newdiameter)  }  else {  	// ignore values standing outside desired diameter  	znew [i' j] = float.NaN;  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingExtrapolator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingExtrapolator.cs,extrapolate,The following statement contains a magic number: if ((sqrad < newdiameter & sqrad >= olddiameter)) {  	// ignore existing values  	int xopp = i - 2 * (i - xmiddle);  	int yopp = j - 2 * (j - ymiddle);  	znew [i' j] = getExtrapolatedZ (znew' i' j);  	// right up quadrant  	znew [xopp' j] = getExtrapolatedZ (znew' xopp' j);  	// left  up  	znew [i' yopp] = getExtrapolatedZ (znew' i' yopp);  	// right down  	znew [xopp' yopp] = getExtrapolatedZ (znew' xopp' yopp);  	// left  down  	//if(sqrad > newdiameter)  }  else {  	// ignore values standing outside desired diameter  	znew [i' j] = float.NaN;  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingExtrapolator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingExtrapolator.cs,extrapolate,The following statement contains a magic number: if ((sqrad < newdiameter & sqrad >= olddiameter)) {  	// ignore existing values  	int xopp = i - 2 * (i - xmiddle);  	int yopp = j - 2 * (j - ymiddle);  	znew [i' j] = getExtrapolatedZ (znew' i' j);  	// right up quadrant  	znew [xopp' j] = getExtrapolatedZ (znew' xopp' j);  	// left  up  	znew [i' yopp] = getExtrapolatedZ (znew' i' yopp);  	// right down  	znew [xopp' yopp] = getExtrapolatedZ (znew' xopp' yopp);  	// left  down  	//if(sqrad > newdiameter)  }  else {  	// ignore values standing outside desired diameter  	znew [i' j] = float.NaN;  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingGrid,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingGrid.cs,Apply,The following statement contains a magic number: for (int xi = -(xsteps - 1) / 2; xi <= (xsteps - 1) / 2; xi++) {  	for (int yi = -(ysteps - 1) / 2; yi <= (ysteps - 1) / 2; yi++) {  		double x = 0;  		double y = 0;  		x = xi * xstep;  		y = yi * ystep;  		if (sqradius > x * x + y * y) {  			output.Add (new Coord3d (x' y' mapper.f (x' y)));  		}  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingGrid,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingGrid.cs,Apply,The following statement contains a magic number: for (int xi = -(xsteps - 1) / 2; xi <= (xsteps - 1) / 2; xi++) {  	for (int yi = -(ysteps - 1) / 2; yi <= (ysteps - 1) / 2; yi++) {  		double x = 0;  		double y = 0;  		x = xi * xstep;  		y = yi * ystep;  		if (sqradius > x * x + y * y) {  			output.Add (new Coord3d (x' y' mapper.f (x' y)));  		}  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingGrid,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingGrid.cs,Apply,The following statement contains a magic number: for (int xi = -(xsteps - 1) / 2; xi <= (xsteps - 1) / 2; xi++) {  	for (int yi = -(ysteps - 1) / 2; yi <= (ysteps - 1) / 2; yi++) {  		double x = 0;  		double y = 0;  		x = xi * xstep;  		y = yi * ystep;  		if (sqradius > x * x + y * y) {  			output.Add (new Coord3d (x' y' mapper.f (x' y)));  		}  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingGrid,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingGrid.cs,Apply,The following statement contains a magic number: for (int xi = -(xsteps - 1) / 2; xi <= (xsteps - 1) / 2; xi++) {  	for (int yi = -(ysteps - 1) / 2; yi <= (ysteps - 1) / 2; yi++) {  		double x = 0;  		double y = 0;  		x = xi * xstep;  		y = yi * ystep;  		if (sqradius > x * x + y * y) {  			output.Add (new Coord3d (x' y' mapper.f (x' y)));  		}  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingGrid,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingGrid.cs,Apply,The following statement contains a magic number: for (int yi = -(ysteps - 1) / 2; yi <= (ysteps - 1) / 2; yi++) {  	double x = 0;  	double y = 0;  	x = xi * xstep;  	y = yi * ystep;  	if (sqradius > x * x + y * y) {  		output.Add (new Coord3d (x' y' mapper.f (x' y)));  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingGrid,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingGrid.cs,Apply,The following statement contains a magic number: for (int yi = -(ysteps - 1) / 2; yi <= (ysteps - 1) / 2; yi++) {  	double x = 0;  	double y = 0;  	x = xi * xstep;  	y = yi * ystep;  	if (sqradius > x * x + y * y) {  		output.Add (new Coord3d (x' y' mapper.f (x' y)));  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute points surrounding current point  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		p [0].Color = _cmap.Color (p [0].xyz);  		p [1].Color = _cmap.Color (p [1].xyz);  		p [2].Color = _cmap.Color (p [2].xyz);  		p [3].Color = _cmap.Color (p [3].xyz);  		p [0].rgb.mul (_factor);  		p [1].rgb.mul (_factor);  		p [2].rgb.mul (_factor);  		p [3].rgb.mul (_factor);  		float[] radius = new float[p.Length];  		for (int i = 0; i <= p.Length - 1; i++) {  			radius [i] = radius2d (p [i]);  		}  		// Compute status of each point according to there radius' or NaN status  		isIn = isInside (p' radius' _ringMin' _ringMax);  		// Ignore polygons that are out  		if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  			continue;  		}  		if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  			// Directly store polygons that have non NaN values for all points  			Polygon quad = new Polygon ();  			for (int pi = 0; pi <= p.Length - 1; pi++) {  				quad.Add (p [pi]);  			}  			polygons.Add (quad);  		}  		else {  			// Partly inside: generate points that intersect a radius  			Polygon polygon = new Polygon ();  			Point intersection = default(Point);  			// generated point  			float ringRadius = 0;  			int[] seq =  {  				0'  				1'  				2'  				3'  				0  			};  			bool[] done = new bool[4];  			for (int pi = 0; pi <= done.Length - 1; pi++) {  				done [pi] = false;  			}  			// Handle all square edges and shift "out" points  			for (int s = 0; s <= seq.Length - 2; s++) {  				// Case of point s "in" and point s+1 "in"  				if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  					// Case of point s "in" and point s+1 "out"  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s+1  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  				}  				else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  					//Case of point s "out" and point s+1 "in"  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				// end case 3  			}  			// end polygon construction loop  			polygons.Add (polygon);  		}  		// end switch quad/polygon  	}  	// end for y  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute points surrounding current point  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		p [0].Color = _cmap.Color (p [0].xyz);  		p [1].Color = _cmap.Color (p [1].xyz);  		p [2].Color = _cmap.Color (p [2].xyz);  		p [3].Color = _cmap.Color (p [3].xyz);  		p [0].rgb.mul (_factor);  		p [1].rgb.mul (_factor);  		p [2].rgb.mul (_factor);  		p [3].rgb.mul (_factor);  		float[] radius = new float[p.Length];  		for (int i = 0; i <= p.Length - 1; i++) {  			radius [i] = radius2d (p [i]);  		}  		// Compute status of each point according to there radius' or NaN status  		isIn = isInside (p' radius' _ringMin' _ringMax);  		// Ignore polygons that are out  		if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  			continue;  		}  		if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  			// Directly store polygons that have non NaN values for all points  			Polygon quad = new Polygon ();  			for (int pi = 0; pi <= p.Length - 1; pi++) {  				quad.Add (p [pi]);  			}  			polygons.Add (quad);  		}  		else {  			// Partly inside: generate points that intersect a radius  			Polygon polygon = new Polygon ();  			Point intersection = default(Point);  			// generated point  			float ringRadius = 0;  			int[] seq =  {  				0'  				1'  				2'  				3'  				0  			};  			bool[] done = new bool[4];  			for (int pi = 0; pi <= done.Length - 1; pi++) {  				done [pi] = false;  			}  			// Handle all square edges and shift "out" points  			for (int s = 0; s <= seq.Length - 2; s++) {  				// Case of point s "in" and point s+1 "in"  				if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  					// Case of point s "in" and point s+1 "out"  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s+1  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  				}  				else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  					//Case of point s "out" and point s+1 "in"  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				// end case 3  			}  			// end polygon construction loop  			polygons.Add (polygon);  		}  		// end switch quad/polygon  	}  	// end for y  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute points surrounding current point  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		p [0].Color = _cmap.Color (p [0].xyz);  		p [1].Color = _cmap.Color (p [1].xyz);  		p [2].Color = _cmap.Color (p [2].xyz);  		p [3].Color = _cmap.Color (p [3].xyz);  		p [0].rgb.mul (_factor);  		p [1].rgb.mul (_factor);  		p [2].rgb.mul (_factor);  		p [3].rgb.mul (_factor);  		float[] radius = new float[p.Length];  		for (int i = 0; i <= p.Length - 1; i++) {  			radius [i] = radius2d (p [i]);  		}  		// Compute status of each point according to there radius' or NaN status  		isIn = isInside (p' radius' _ringMin' _ringMax);  		// Ignore polygons that are out  		if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  			continue;  		}  		if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  			// Directly store polygons that have non NaN values for all points  			Polygon quad = new Polygon ();  			for (int pi = 0; pi <= p.Length - 1; pi++) {  				quad.Add (p [pi]);  			}  			polygons.Add (quad);  		}  		else {  			// Partly inside: generate points that intersect a radius  			Polygon polygon = new Polygon ();  			Point intersection = default(Point);  			// generated point  			float ringRadius = 0;  			int[] seq =  {  				0'  				1'  				2'  				3'  				0  			};  			bool[] done = new bool[4];  			for (int pi = 0; pi <= done.Length - 1; pi++) {  				done [pi] = false;  			}  			// Handle all square edges and shift "out" points  			for (int s = 0; s <= seq.Length - 2; s++) {  				// Case of point s "in" and point s+1 "in"  				if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  					// Case of point s "in" and point s+1 "out"  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s+1  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  				}  				else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  					//Case of point s "out" and point s+1 "in"  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				// end case 3  			}  			// end polygon construction loop  			polygons.Add (polygon);  		}  		// end switch quad/polygon  	}  	// end for y  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute points surrounding current point  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		p [0].Color = _cmap.Color (p [0].xyz);  		p [1].Color = _cmap.Color (p [1].xyz);  		p [2].Color = _cmap.Color (p [2].xyz);  		p [3].Color = _cmap.Color (p [3].xyz);  		p [0].rgb.mul (_factor);  		p [1].rgb.mul (_factor);  		p [2].rgb.mul (_factor);  		p [3].rgb.mul (_factor);  		float[] radius = new float[p.Length];  		for (int i = 0; i <= p.Length - 1; i++) {  			radius [i] = radius2d (p [i]);  		}  		// Compute status of each point according to there radius' or NaN status  		isIn = isInside (p' radius' _ringMin' _ringMax);  		// Ignore polygons that are out  		if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  			continue;  		}  		if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  			// Directly store polygons that have non NaN values for all points  			Polygon quad = new Polygon ();  			for (int pi = 0; pi <= p.Length - 1; pi++) {  				quad.Add (p [pi]);  			}  			polygons.Add (quad);  		}  		else {  			// Partly inside: generate points that intersect a radius  			Polygon polygon = new Polygon ();  			Point intersection = default(Point);  			// generated point  			float ringRadius = 0;  			int[] seq =  {  				0'  				1'  				2'  				3'  				0  			};  			bool[] done = new bool[4];  			for (int pi = 0; pi <= done.Length - 1; pi++) {  				done [pi] = false;  			}  			// Handle all square edges and shift "out" points  			for (int s = 0; s <= seq.Length - 2; s++) {  				// Case of point s "in" and point s+1 "in"  				if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  					// Case of point s "in" and point s+1 "out"  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s+1  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  				}  				else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  					//Case of point s "out" and point s+1 "in"  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				// end case 3  			}  			// end polygon construction loop  			polygons.Add (polygon);  		}  		// end switch quad/polygon  	}  	// end for y  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute points surrounding current point  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		p [0].Color = _cmap.Color (p [0].xyz);  		p [1].Color = _cmap.Color (p [1].xyz);  		p [2].Color = _cmap.Color (p [2].xyz);  		p [3].Color = _cmap.Color (p [3].xyz);  		p [0].rgb.mul (_factor);  		p [1].rgb.mul (_factor);  		p [2].rgb.mul (_factor);  		p [3].rgb.mul (_factor);  		float[] radius = new float[p.Length];  		for (int i = 0; i <= p.Length - 1; i++) {  			radius [i] = radius2d (p [i]);  		}  		// Compute status of each point according to there radius' or NaN status  		isIn = isInside (p' radius' _ringMin' _ringMax);  		// Ignore polygons that are out  		if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  			continue;  		}  		if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  			// Directly store polygons that have non NaN values for all points  			Polygon quad = new Polygon ();  			for (int pi = 0; pi <= p.Length - 1; pi++) {  				quad.Add (p [pi]);  			}  			polygons.Add (quad);  		}  		else {  			// Partly inside: generate points that intersect a radius  			Polygon polygon = new Polygon ();  			Point intersection = default(Point);  			// generated point  			float ringRadius = 0;  			int[] seq =  {  				0'  				1'  				2'  				3'  				0  			};  			bool[] done = new bool[4];  			for (int pi = 0; pi <= done.Length - 1; pi++) {  				done [pi] = false;  			}  			// Handle all square edges and shift "out" points  			for (int s = 0; s <= seq.Length - 2; s++) {  				// Case of point s "in" and point s+1 "in"  				if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  					// Case of point s "in" and point s+1 "out"  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s+1  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  				}  				else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  					//Case of point s "out" and point s+1 "in"  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				// end case 3  			}  			// end polygon construction loop  			polygons.Add (polygon);  		}  		// end switch quad/polygon  	}  	// end for y  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute points surrounding current point  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		p [0].Color = _cmap.Color (p [0].xyz);  		p [1].Color = _cmap.Color (p [1].xyz);  		p [2].Color = _cmap.Color (p [2].xyz);  		p [3].Color = _cmap.Color (p [3].xyz);  		p [0].rgb.mul (_factor);  		p [1].rgb.mul (_factor);  		p [2].rgb.mul (_factor);  		p [3].rgb.mul (_factor);  		float[] radius = new float[p.Length];  		for (int i = 0; i <= p.Length - 1; i++) {  			radius [i] = radius2d (p [i]);  		}  		// Compute status of each point according to there radius' or NaN status  		isIn = isInside (p' radius' _ringMin' _ringMax);  		// Ignore polygons that are out  		if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  			continue;  		}  		if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  			// Directly store polygons that have non NaN values for all points  			Polygon quad = new Polygon ();  			for (int pi = 0; pi <= p.Length - 1; pi++) {  				quad.Add (p [pi]);  			}  			polygons.Add (quad);  		}  		else {  			// Partly inside: generate points that intersect a radius  			Polygon polygon = new Polygon ();  			Point intersection = default(Point);  			// generated point  			float ringRadius = 0;  			int[] seq =  {  				0'  				1'  				2'  				3'  				0  			};  			bool[] done = new bool[4];  			for (int pi = 0; pi <= done.Length - 1; pi++) {  				done [pi] = false;  			}  			// Handle all square edges and shift "out" points  			for (int s = 0; s <= seq.Length - 2; s++) {  				// Case of point s "in" and point s+1 "in"  				if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  					// Case of point s "in" and point s+1 "out"  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s+1  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  				}  				else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  					//Case of point s "out" and point s+1 "in"  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				// end case 3  			}  			// end polygon construction loop  			polygons.Add (polygon);  		}  		// end switch quad/polygon  	}  	// end for y  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute points surrounding current point  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		p [0].Color = _cmap.Color (p [0].xyz);  		p [1].Color = _cmap.Color (p [1].xyz);  		p [2].Color = _cmap.Color (p [2].xyz);  		p [3].Color = _cmap.Color (p [3].xyz);  		p [0].rgb.mul (_factor);  		p [1].rgb.mul (_factor);  		p [2].rgb.mul (_factor);  		p [3].rgb.mul (_factor);  		float[] radius = new float[p.Length];  		for (int i = 0; i <= p.Length - 1; i++) {  			radius [i] = radius2d (p [i]);  		}  		// Compute status of each point according to there radius' or NaN status  		isIn = isInside (p' radius' _ringMin' _ringMax);  		// Ignore polygons that are out  		if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  			continue;  		}  		if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  			// Directly store polygons that have non NaN values for all points  			Polygon quad = new Polygon ();  			for (int pi = 0; pi <= p.Length - 1; pi++) {  				quad.Add (p [pi]);  			}  			polygons.Add (quad);  		}  		else {  			// Partly inside: generate points that intersect a radius  			Polygon polygon = new Polygon ();  			Point intersection = default(Point);  			// generated point  			float ringRadius = 0;  			int[] seq =  {  				0'  				1'  				2'  				3'  				0  			};  			bool[] done = new bool[4];  			for (int pi = 0; pi <= done.Length - 1; pi++) {  				done [pi] = false;  			}  			// Handle all square edges and shift "out" points  			for (int s = 0; s <= seq.Length - 2; s++) {  				// Case of point s "in" and point s+1 "in"  				if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  					// Case of point s "in" and point s+1 "out"  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s+1  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  				}  				else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  					//Case of point s "out" and point s+1 "in"  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				// end case 3  			}  			// end polygon construction loop  			polygons.Add (polygon);  		}  		// end switch quad/polygon  	}  	// end for y  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute points surrounding current point  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		p [0].Color = _cmap.Color (p [0].xyz);  		p [1].Color = _cmap.Color (p [1].xyz);  		p [2].Color = _cmap.Color (p [2].xyz);  		p [3].Color = _cmap.Color (p [3].xyz);  		p [0].rgb.mul (_factor);  		p [1].rgb.mul (_factor);  		p [2].rgb.mul (_factor);  		p [3].rgb.mul (_factor);  		float[] radius = new float[p.Length];  		for (int i = 0; i <= p.Length - 1; i++) {  			radius [i] = radius2d (p [i]);  		}  		// Compute status of each point according to there radius' or NaN status  		isIn = isInside (p' radius' _ringMin' _ringMax);  		// Ignore polygons that are out  		if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  			continue;  		}  		if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  			// Directly store polygons that have non NaN values for all points  			Polygon quad = new Polygon ();  			for (int pi = 0; pi <= p.Length - 1; pi++) {  				quad.Add (p [pi]);  			}  			polygons.Add (quad);  		}  		else {  			// Partly inside: generate points that intersect a radius  			Polygon polygon = new Polygon ();  			Point intersection = default(Point);  			// generated point  			float ringRadius = 0;  			int[] seq =  {  				0'  				1'  				2'  				3'  				0  			};  			bool[] done = new bool[4];  			for (int pi = 0; pi <= done.Length - 1; pi++) {  				done [pi] = false;  			}  			// Handle all square edges and shift "out" points  			for (int s = 0; s <= seq.Length - 2; s++) {  				// Case of point s "in" and point s+1 "in"  				if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  					// Case of point s "in" and point s+1 "out"  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s+1  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  				}  				else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  					//Case of point s "out" and point s+1 "in"  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				// end case 3  			}  			// end polygon construction loop  			polygons.Add (polygon);  		}  		// end switch quad/polygon  	}  	// end for y  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute points surrounding current point  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		p [0].Color = _cmap.Color (p [0].xyz);  		p [1].Color = _cmap.Color (p [1].xyz);  		p [2].Color = _cmap.Color (p [2].xyz);  		p [3].Color = _cmap.Color (p [3].xyz);  		p [0].rgb.mul (_factor);  		p [1].rgb.mul (_factor);  		p [2].rgb.mul (_factor);  		p [3].rgb.mul (_factor);  		float[] radius = new float[p.Length];  		for (int i = 0; i <= p.Length - 1; i++) {  			radius [i] = radius2d (p [i]);  		}  		// Compute status of each point according to there radius' or NaN status  		isIn = isInside (p' radius' _ringMin' _ringMax);  		// Ignore polygons that are out  		if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  			continue;  		}  		if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  			// Directly store polygons that have non NaN values for all points  			Polygon quad = new Polygon ();  			for (int pi = 0; pi <= p.Length - 1; pi++) {  				quad.Add (p [pi]);  			}  			polygons.Add (quad);  		}  		else {  			// Partly inside: generate points that intersect a radius  			Polygon polygon = new Polygon ();  			Point intersection = default(Point);  			// generated point  			float ringRadius = 0;  			int[] seq =  {  				0'  				1'  				2'  				3'  				0  			};  			bool[] done = new bool[4];  			for (int pi = 0; pi <= done.Length - 1; pi++) {  				done [pi] = false;  			}  			// Handle all square edges and shift "out" points  			for (int s = 0; s <= seq.Length - 2; s++) {  				// Case of point s "in" and point s+1 "in"  				if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  					// Case of point s "in" and point s+1 "out"  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s+1  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  				}  				else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  					//Case of point s "out" and point s+1 "in"  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				// end case 3  			}  			// end polygon construction loop  			polygons.Add (polygon);  		}  		// end switch quad/polygon  	}  	// end for y  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute points surrounding current point  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		p [0].Color = _cmap.Color (p [0].xyz);  		p [1].Color = _cmap.Color (p [1].xyz);  		p [2].Color = _cmap.Color (p [2].xyz);  		p [3].Color = _cmap.Color (p [3].xyz);  		p [0].rgb.mul (_factor);  		p [1].rgb.mul (_factor);  		p [2].rgb.mul (_factor);  		p [3].rgb.mul (_factor);  		float[] radius = new float[p.Length];  		for (int i = 0; i <= p.Length - 1; i++) {  			radius [i] = radius2d (p [i]);  		}  		// Compute status of each point according to there radius' or NaN status  		isIn = isInside (p' radius' _ringMin' _ringMax);  		// Ignore polygons that are out  		if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  			continue;  		}  		if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  			// Directly store polygons that have non NaN values for all points  			Polygon quad = new Polygon ();  			for (int pi = 0; pi <= p.Length - 1; pi++) {  				quad.Add (p [pi]);  			}  			polygons.Add (quad);  		}  		else {  			// Partly inside: generate points that intersect a radius  			Polygon polygon = new Polygon ();  			Point intersection = default(Point);  			// generated point  			float ringRadius = 0;  			int[] seq =  {  				0'  				1'  				2'  				3'  				0  			};  			bool[] done = new bool[4];  			for (int pi = 0; pi <= done.Length - 1; pi++) {  				done [pi] = false;  			}  			// Handle all square edges and shift "out" points  			for (int s = 0; s <= seq.Length - 2; s++) {  				// Case of point s "in" and point s+1 "in"  				if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  					// Case of point s "in" and point s+1 "out"  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s+1  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  				}  				else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  					//Case of point s "out" and point s+1 "in"  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				// end case 3  			}  			// end polygon construction loop  			polygons.Add (polygon);  		}  		// end switch quad/polygon  	}  	// end for y  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute points surrounding current point  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		p [0].Color = _cmap.Color (p [0].xyz);  		p [1].Color = _cmap.Color (p [1].xyz);  		p [2].Color = _cmap.Color (p [2].xyz);  		p [3].Color = _cmap.Color (p [3].xyz);  		p [0].rgb.mul (_factor);  		p [1].rgb.mul (_factor);  		p [2].rgb.mul (_factor);  		p [3].rgb.mul (_factor);  		float[] radius = new float[p.Length];  		for (int i = 0; i <= p.Length - 1; i++) {  			radius [i] = radius2d (p [i]);  		}  		// Compute status of each point according to there radius' or NaN status  		isIn = isInside (p' radius' _ringMin' _ringMax);  		// Ignore polygons that are out  		if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  			continue;  		}  		if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  			// Directly store polygons that have non NaN values for all points  			Polygon quad = new Polygon ();  			for (int pi = 0; pi <= p.Length - 1; pi++) {  				quad.Add (p [pi]);  			}  			polygons.Add (quad);  		}  		else {  			// Partly inside: generate points that intersect a radius  			Polygon polygon = new Polygon ();  			Point intersection = default(Point);  			// generated point  			float ringRadius = 0;  			int[] seq =  {  				0'  				1'  				2'  				3'  				0  			};  			bool[] done = new bool[4];  			for (int pi = 0; pi <= done.Length - 1; pi++) {  				done [pi] = false;  			}  			// Handle all square edges and shift "out" points  			for (int s = 0; s <= seq.Length - 2; s++) {  				// Case of point s "in" and point s+1 "in"  				if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  					// Case of point s "in" and point s+1 "out"  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s+1  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  				}  				else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  					//Case of point s "out" and point s+1 "in"  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				// end case 3  			}  			// end polygon construction loop  			polygons.Add (polygon);  		}  		// end switch quad/polygon  	}  	// end for y  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute points surrounding current point  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		p [0].Color = _cmap.Color (p [0].xyz);  		p [1].Color = _cmap.Color (p [1].xyz);  		p [2].Color = _cmap.Color (p [2].xyz);  		p [3].Color = _cmap.Color (p [3].xyz);  		p [0].rgb.mul (_factor);  		p [1].rgb.mul (_factor);  		p [2].rgb.mul (_factor);  		p [3].rgb.mul (_factor);  		float[] radius = new float[p.Length];  		for (int i = 0; i <= p.Length - 1; i++) {  			radius [i] = radius2d (p [i]);  		}  		// Compute status of each point according to there radius' or NaN status  		isIn = isInside (p' radius' _ringMin' _ringMax);  		// Ignore polygons that are out  		if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  			continue;  		}  		if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  			// Directly store polygons that have non NaN values for all points  			Polygon quad = new Polygon ();  			for (int pi = 0; pi <= p.Length - 1; pi++) {  				quad.Add (p [pi]);  			}  			polygons.Add (quad);  		}  		else {  			// Partly inside: generate points that intersect a radius  			Polygon polygon = new Polygon ();  			Point intersection = default(Point);  			// generated point  			float ringRadius = 0;  			int[] seq =  {  				0'  				1'  				2'  				3'  				0  			};  			bool[] done = new bool[4];  			for (int pi = 0; pi <= done.Length - 1; pi++) {  				done [pi] = false;  			}  			// Handle all square edges and shift "out" points  			for (int s = 0; s <= seq.Length - 2; s++) {  				// Case of point s "in" and point s+1 "in"  				if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  					// Case of point s "in" and point s+1 "out"  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s+1  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  				}  				else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  					//Case of point s "out" and point s+1 "in"  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				// end case 3  			}  			// end polygon construction loop  			polygons.Add (polygon);  		}  		// end switch quad/polygon  	}  	// end for y  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute points surrounding current point  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		p [0].Color = _cmap.Color (p [0].xyz);  		p [1].Color = _cmap.Color (p [1].xyz);  		p [2].Color = _cmap.Color (p [2].xyz);  		p [3].Color = _cmap.Color (p [3].xyz);  		p [0].rgb.mul (_factor);  		p [1].rgb.mul (_factor);  		p [2].rgb.mul (_factor);  		p [3].rgb.mul (_factor);  		float[] radius = new float[p.Length];  		for (int i = 0; i <= p.Length - 1; i++) {  			radius [i] = radius2d (p [i]);  		}  		// Compute status of each point according to there radius' or NaN status  		isIn = isInside (p' radius' _ringMin' _ringMax);  		// Ignore polygons that are out  		if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  			continue;  		}  		if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  			// Directly store polygons that have non NaN values for all points  			Polygon quad = new Polygon ();  			for (int pi = 0; pi <= p.Length - 1; pi++) {  				quad.Add (p [pi]);  			}  			polygons.Add (quad);  		}  		else {  			// Partly inside: generate points that intersect a radius  			Polygon polygon = new Polygon ();  			Point intersection = default(Point);  			// generated point  			float ringRadius = 0;  			int[] seq =  {  				0'  				1'  				2'  				3'  				0  			};  			bool[] done = new bool[4];  			for (int pi = 0; pi <= done.Length - 1; pi++) {  				done [pi] = false;  			}  			// Handle all square edges and shift "out" points  			for (int s = 0; s <= seq.Length - 2; s++) {  				// Case of point s "in" and point s+1 "in"  				if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  					// Case of point s "in" and point s+1 "out"  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s+1  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  				}  				else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  					//Case of point s "out" and point s+1 "in"  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				// end case 3  			}  			// end polygon construction loop  			polygons.Add (polygon);  		}  		// end switch quad/polygon  	}  	// end for y  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute points surrounding current point  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		p [0].Color = _cmap.Color (p [0].xyz);  		p [1].Color = _cmap.Color (p [1].xyz);  		p [2].Color = _cmap.Color (p [2].xyz);  		p [3].Color = _cmap.Color (p [3].xyz);  		p [0].rgb.mul (_factor);  		p [1].rgb.mul (_factor);  		p [2].rgb.mul (_factor);  		p [3].rgb.mul (_factor);  		float[] radius = new float[p.Length];  		for (int i = 0; i <= p.Length - 1; i++) {  			radius [i] = radius2d (p [i]);  		}  		// Compute status of each point according to there radius' or NaN status  		isIn = isInside (p' radius' _ringMin' _ringMax);  		// Ignore polygons that are out  		if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  			continue;  		}  		if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  			// Directly store polygons that have non NaN values for all points  			Polygon quad = new Polygon ();  			for (int pi = 0; pi <= p.Length - 1; pi++) {  				quad.Add (p [pi]);  			}  			polygons.Add (quad);  		}  		else {  			// Partly inside: generate points that intersect a radius  			Polygon polygon = new Polygon ();  			Point intersection = default(Point);  			// generated point  			float ringRadius = 0;  			int[] seq =  {  				0'  				1'  				2'  				3'  				0  			};  			bool[] done = new bool[4];  			for (int pi = 0; pi <= done.Length - 1; pi++) {  				done [pi] = false;  			}  			// Handle all square edges and shift "out" points  			for (int s = 0; s <= seq.Length - 2; s++) {  				// Case of point s "in" and point s+1 "in"  				if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  					// Case of point s "in" and point s+1 "out"  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s+1  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  				}  				else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  					//Case of point s "out" and point s+1 "in"  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				// end case 3  			}  			// end polygon construction loop  			polygons.Add (polygon);  		}  		// end switch quad/polygon  	}  	// end for y  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute points surrounding current point  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		p [0].Color = _cmap.Color (p [0].xyz);  		p [1].Color = _cmap.Color (p [1].xyz);  		p [2].Color = _cmap.Color (p [2].xyz);  		p [3].Color = _cmap.Color (p [3].xyz);  		p [0].rgb.mul (_factor);  		p [1].rgb.mul (_factor);  		p [2].rgb.mul (_factor);  		p [3].rgb.mul (_factor);  		float[] radius = new float[p.Length];  		for (int i = 0; i <= p.Length - 1; i++) {  			radius [i] = radius2d (p [i]);  		}  		// Compute status of each point according to there radius' or NaN status  		isIn = isInside (p' radius' _ringMin' _ringMax);  		// Ignore polygons that are out  		if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  			continue;  		}  		if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  			// Directly store polygons that have non NaN values for all points  			Polygon quad = new Polygon ();  			for (int pi = 0; pi <= p.Length - 1; pi++) {  				quad.Add (p [pi]);  			}  			polygons.Add (quad);  		}  		else {  			// Partly inside: generate points that intersect a radius  			Polygon polygon = new Polygon ();  			Point intersection = default(Point);  			// generated point  			float ringRadius = 0;  			int[] seq =  {  				0'  				1'  				2'  				3'  				0  			};  			bool[] done = new bool[4];  			for (int pi = 0; pi <= done.Length - 1; pi++) {  				done [pi] = false;  			}  			// Handle all square edges and shift "out" points  			for (int s = 0; s <= seq.Length - 2; s++) {  				// Case of point s "in" and point s+1 "in"  				if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  					// Case of point s "in" and point s+1 "out"  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s+1  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  				}  				else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  					//Case of point s "out" and point s+1 "in"  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				// end case 3  			}  			// end polygon construction loop  			polygons.Add (polygon);  		}  		// end switch quad/polygon  	}  	// end for y  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int xi = 0; xi <= x.Length - 2; xi++) {  	for (int yi = 0; yi <= y.Length - 2; yi++) {  		// Compute points surrounding current point  		Point[] p = getRealQuadStandingOnPoint (xi' yi);  		p [0].Color = _cmap.Color (p [0].xyz);  		p [1].Color = _cmap.Color (p [1].xyz);  		p [2].Color = _cmap.Color (p [2].xyz);  		p [3].Color = _cmap.Color (p [3].xyz);  		p [0].rgb.mul (_factor);  		p [1].rgb.mul (_factor);  		p [2].rgb.mul (_factor);  		p [3].rgb.mul (_factor);  		float[] radius = new float[p.Length];  		for (int i = 0; i <= p.Length - 1; i++) {  			radius [i] = radius2d (p [i]);  		}  		// Compute status of each point according to there radius' or NaN status  		isIn = isInside (p' radius' _ringMin' _ringMax);  		// Ignore polygons that are out  		if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  			continue;  		}  		if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  			// Directly store polygons that have non NaN values for all points  			Polygon quad = new Polygon ();  			for (int pi = 0; pi <= p.Length - 1; pi++) {  				quad.Add (p [pi]);  			}  			polygons.Add (quad);  		}  		else {  			// Partly inside: generate points that intersect a radius  			Polygon polygon = new Polygon ();  			Point intersection = default(Point);  			// generated point  			float ringRadius = 0;  			int[] seq =  {  				0'  				1'  				2'  				3'  				0  			};  			bool[] done = new bool[4];  			for (int pi = 0; pi <= done.Length - 1; pi++) {  				done [pi] = false;  			}  			// Handle all square edges and shift "out" points  			for (int s = 0; s <= seq.Length - 2; s++) {  				// Case of point s "in" and point s+1 "in"  				if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  					// Case of point s "in" and point s+1 "out"  					if ((!done [seq [s]])) {  						polygon.Add (p [seq [s]]);  						done [seq [s]] = true;  					}  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s+1  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  				}  				else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  					//Case of point s "out" and point s+1 "in"  					// Select the radius on which the point is supposed to stand  					if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  						ringRadius = _ringMin;  					}  					else {  						ringRadius = _ringMax;  					}  					// Generate a point on the circle that replaces s  					intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  					intersection.Color = _cmap.Color (intersection.xyz);  					intersection.rgb.mul (_factor);  					polygon.Add (intersection);  					if ((!done [seq [s + 1]])) {  						polygon.Add (p [seq [s + 1]]);  						done [seq [s + 1]] = true;  					}  				}  				// end case 3  			}  			// end polygon construction loop  			polygons.Add (polygon);  		}  		// end switch quad/polygon  	}  	// end for y  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute points surrounding current point  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	p [0].Color = _cmap.Color (p [0].xyz);  	p [1].Color = _cmap.Color (p [1].xyz);  	p [2].Color = _cmap.Color (p [2].xyz);  	p [3].Color = _cmap.Color (p [3].xyz);  	p [0].rgb.mul (_factor);  	p [1].rgb.mul (_factor);  	p [2].rgb.mul (_factor);  	p [3].rgb.mul (_factor);  	float[] radius = new float[p.Length];  	for (int i = 0; i <= p.Length - 1; i++) {  		radius [i] = radius2d (p [i]);  	}  	// Compute status of each point according to there radius' or NaN status  	isIn = isInside (p' radius' _ringMin' _ringMax);  	// Ignore polygons that are out  	if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  		continue;  	}  	if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  		// Directly store polygons that have non NaN values for all points  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  	else {  		// Partly inside: generate points that intersect a radius  		Polygon polygon = new Polygon ();  		Point intersection = default(Point);  		// generated point  		float ringRadius = 0;  		int[] seq =  {  			0'  			1'  			2'  			3'  			0  		};  		bool[] done = new bool[4];  		for (int pi = 0; pi <= done.Length - 1; pi++) {  			done [pi] = false;  		}  		// Handle all square edges and shift "out" points  		for (int s = 0; s <= seq.Length - 2; s++) {  			// Case of point s "in" and point s+1 "in"  			if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  				// Case of point s "in" and point s+1 "out"  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s+1  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  			}  			else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  				//Case of point s "out" and point s+1 "in"  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			// end case 3  		}  		// end polygon construction loop  		polygons.Add (polygon);  	}  	// end switch quad/polygon  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute points surrounding current point  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	p [0].Color = _cmap.Color (p [0].xyz);  	p [1].Color = _cmap.Color (p [1].xyz);  	p [2].Color = _cmap.Color (p [2].xyz);  	p [3].Color = _cmap.Color (p [3].xyz);  	p [0].rgb.mul (_factor);  	p [1].rgb.mul (_factor);  	p [2].rgb.mul (_factor);  	p [3].rgb.mul (_factor);  	float[] radius = new float[p.Length];  	for (int i = 0; i <= p.Length - 1; i++) {  		radius [i] = radius2d (p [i]);  	}  	// Compute status of each point according to there radius' or NaN status  	isIn = isInside (p' radius' _ringMin' _ringMax);  	// Ignore polygons that are out  	if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  		continue;  	}  	if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  		// Directly store polygons that have non NaN values for all points  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  	else {  		// Partly inside: generate points that intersect a radius  		Polygon polygon = new Polygon ();  		Point intersection = default(Point);  		// generated point  		float ringRadius = 0;  		int[] seq =  {  			0'  			1'  			2'  			3'  			0  		};  		bool[] done = new bool[4];  		for (int pi = 0; pi <= done.Length - 1; pi++) {  			done [pi] = false;  		}  		// Handle all square edges and shift "out" points  		for (int s = 0; s <= seq.Length - 2; s++) {  			// Case of point s "in" and point s+1 "in"  			if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  				// Case of point s "in" and point s+1 "out"  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s+1  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  			}  			else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  				//Case of point s "out" and point s+1 "in"  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			// end case 3  		}  		// end polygon construction loop  		polygons.Add (polygon);  	}  	// end switch quad/polygon  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute points surrounding current point  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	p [0].Color = _cmap.Color (p [0].xyz);  	p [1].Color = _cmap.Color (p [1].xyz);  	p [2].Color = _cmap.Color (p [2].xyz);  	p [3].Color = _cmap.Color (p [3].xyz);  	p [0].rgb.mul (_factor);  	p [1].rgb.mul (_factor);  	p [2].rgb.mul (_factor);  	p [3].rgb.mul (_factor);  	float[] radius = new float[p.Length];  	for (int i = 0; i <= p.Length - 1; i++) {  		radius [i] = radius2d (p [i]);  	}  	// Compute status of each point according to there radius' or NaN status  	isIn = isInside (p' radius' _ringMin' _ringMax);  	// Ignore polygons that are out  	if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  		continue;  	}  	if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  		// Directly store polygons that have non NaN values for all points  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  	else {  		// Partly inside: generate points that intersect a radius  		Polygon polygon = new Polygon ();  		Point intersection = default(Point);  		// generated point  		float ringRadius = 0;  		int[] seq =  {  			0'  			1'  			2'  			3'  			0  		};  		bool[] done = new bool[4];  		for (int pi = 0; pi <= done.Length - 1; pi++) {  			done [pi] = false;  		}  		// Handle all square edges and shift "out" points  		for (int s = 0; s <= seq.Length - 2; s++) {  			// Case of point s "in" and point s+1 "in"  			if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  				// Case of point s "in" and point s+1 "out"  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s+1  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  			}  			else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  				//Case of point s "out" and point s+1 "in"  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			// end case 3  		}  		// end polygon construction loop  		polygons.Add (polygon);  	}  	// end switch quad/polygon  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute points surrounding current point  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	p [0].Color = _cmap.Color (p [0].xyz);  	p [1].Color = _cmap.Color (p [1].xyz);  	p [2].Color = _cmap.Color (p [2].xyz);  	p [3].Color = _cmap.Color (p [3].xyz);  	p [0].rgb.mul (_factor);  	p [1].rgb.mul (_factor);  	p [2].rgb.mul (_factor);  	p [3].rgb.mul (_factor);  	float[] radius = new float[p.Length];  	for (int i = 0; i <= p.Length - 1; i++) {  		radius [i] = radius2d (p [i]);  	}  	// Compute status of each point according to there radius' or NaN status  	isIn = isInside (p' radius' _ringMin' _ringMax);  	// Ignore polygons that are out  	if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  		continue;  	}  	if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  		// Directly store polygons that have non NaN values for all points  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  	else {  		// Partly inside: generate points that intersect a radius  		Polygon polygon = new Polygon ();  		Point intersection = default(Point);  		// generated point  		float ringRadius = 0;  		int[] seq =  {  			0'  			1'  			2'  			3'  			0  		};  		bool[] done = new bool[4];  		for (int pi = 0; pi <= done.Length - 1; pi++) {  			done [pi] = false;  		}  		// Handle all square edges and shift "out" points  		for (int s = 0; s <= seq.Length - 2; s++) {  			// Case of point s "in" and point s+1 "in"  			if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  				// Case of point s "in" and point s+1 "out"  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s+1  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  			}  			else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  				//Case of point s "out" and point s+1 "in"  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			// end case 3  		}  		// end polygon construction loop  		polygons.Add (polygon);  	}  	// end switch quad/polygon  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute points surrounding current point  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	p [0].Color = _cmap.Color (p [0].xyz);  	p [1].Color = _cmap.Color (p [1].xyz);  	p [2].Color = _cmap.Color (p [2].xyz);  	p [3].Color = _cmap.Color (p [3].xyz);  	p [0].rgb.mul (_factor);  	p [1].rgb.mul (_factor);  	p [2].rgb.mul (_factor);  	p [3].rgb.mul (_factor);  	float[] radius = new float[p.Length];  	for (int i = 0; i <= p.Length - 1; i++) {  		radius [i] = radius2d (p [i]);  	}  	// Compute status of each point according to there radius' or NaN status  	isIn = isInside (p' radius' _ringMin' _ringMax);  	// Ignore polygons that are out  	if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  		continue;  	}  	if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  		// Directly store polygons that have non NaN values for all points  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  	else {  		// Partly inside: generate points that intersect a radius  		Polygon polygon = new Polygon ();  		Point intersection = default(Point);  		// generated point  		float ringRadius = 0;  		int[] seq =  {  			0'  			1'  			2'  			3'  			0  		};  		bool[] done = new bool[4];  		for (int pi = 0; pi <= done.Length - 1; pi++) {  			done [pi] = false;  		}  		// Handle all square edges and shift "out" points  		for (int s = 0; s <= seq.Length - 2; s++) {  			// Case of point s "in" and point s+1 "in"  			if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  				// Case of point s "in" and point s+1 "out"  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s+1  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  			}  			else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  				//Case of point s "out" and point s+1 "in"  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			// end case 3  		}  		// end polygon construction loop  		polygons.Add (polygon);  	}  	// end switch quad/polygon  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute points surrounding current point  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	p [0].Color = _cmap.Color (p [0].xyz);  	p [1].Color = _cmap.Color (p [1].xyz);  	p [2].Color = _cmap.Color (p [2].xyz);  	p [3].Color = _cmap.Color (p [3].xyz);  	p [0].rgb.mul (_factor);  	p [1].rgb.mul (_factor);  	p [2].rgb.mul (_factor);  	p [3].rgb.mul (_factor);  	float[] radius = new float[p.Length];  	for (int i = 0; i <= p.Length - 1; i++) {  		radius [i] = radius2d (p [i]);  	}  	// Compute status of each point according to there radius' or NaN status  	isIn = isInside (p' radius' _ringMin' _ringMax);  	// Ignore polygons that are out  	if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  		continue;  	}  	if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  		// Directly store polygons that have non NaN values for all points  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  	else {  		// Partly inside: generate points that intersect a radius  		Polygon polygon = new Polygon ();  		Point intersection = default(Point);  		// generated point  		float ringRadius = 0;  		int[] seq =  {  			0'  			1'  			2'  			3'  			0  		};  		bool[] done = new bool[4];  		for (int pi = 0; pi <= done.Length - 1; pi++) {  			done [pi] = false;  		}  		// Handle all square edges and shift "out" points  		for (int s = 0; s <= seq.Length - 2; s++) {  			// Case of point s "in" and point s+1 "in"  			if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  				// Case of point s "in" and point s+1 "out"  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s+1  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  			}  			else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  				//Case of point s "out" and point s+1 "in"  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			// end case 3  		}  		// end polygon construction loop  		polygons.Add (polygon);  	}  	// end switch quad/polygon  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute points surrounding current point  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	p [0].Color = _cmap.Color (p [0].xyz);  	p [1].Color = _cmap.Color (p [1].xyz);  	p [2].Color = _cmap.Color (p [2].xyz);  	p [3].Color = _cmap.Color (p [3].xyz);  	p [0].rgb.mul (_factor);  	p [1].rgb.mul (_factor);  	p [2].rgb.mul (_factor);  	p [3].rgb.mul (_factor);  	float[] radius = new float[p.Length];  	for (int i = 0; i <= p.Length - 1; i++) {  		radius [i] = radius2d (p [i]);  	}  	// Compute status of each point according to there radius' or NaN status  	isIn = isInside (p' radius' _ringMin' _ringMax);  	// Ignore polygons that are out  	if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  		continue;  	}  	if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  		// Directly store polygons that have non NaN values for all points  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  	else {  		// Partly inside: generate points that intersect a radius  		Polygon polygon = new Polygon ();  		Point intersection = default(Point);  		// generated point  		float ringRadius = 0;  		int[] seq =  {  			0'  			1'  			2'  			3'  			0  		};  		bool[] done = new bool[4];  		for (int pi = 0; pi <= done.Length - 1; pi++) {  			done [pi] = false;  		}  		// Handle all square edges and shift "out" points  		for (int s = 0; s <= seq.Length - 2; s++) {  			// Case of point s "in" and point s+1 "in"  			if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  				// Case of point s "in" and point s+1 "out"  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s+1  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  			}  			else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  				//Case of point s "out" and point s+1 "in"  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			// end case 3  		}  		// end polygon construction loop  		polygons.Add (polygon);  	}  	// end switch quad/polygon  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute points surrounding current point  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	p [0].Color = _cmap.Color (p [0].xyz);  	p [1].Color = _cmap.Color (p [1].xyz);  	p [2].Color = _cmap.Color (p [2].xyz);  	p [3].Color = _cmap.Color (p [3].xyz);  	p [0].rgb.mul (_factor);  	p [1].rgb.mul (_factor);  	p [2].rgb.mul (_factor);  	p [3].rgb.mul (_factor);  	float[] radius = new float[p.Length];  	for (int i = 0; i <= p.Length - 1; i++) {  		radius [i] = radius2d (p [i]);  	}  	// Compute status of each point according to there radius' or NaN status  	isIn = isInside (p' radius' _ringMin' _ringMax);  	// Ignore polygons that are out  	if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  		continue;  	}  	if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  		// Directly store polygons that have non NaN values for all points  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  	else {  		// Partly inside: generate points that intersect a radius  		Polygon polygon = new Polygon ();  		Point intersection = default(Point);  		// generated point  		float ringRadius = 0;  		int[] seq =  {  			0'  			1'  			2'  			3'  			0  		};  		bool[] done = new bool[4];  		for (int pi = 0; pi <= done.Length - 1; pi++) {  			done [pi] = false;  		}  		// Handle all square edges and shift "out" points  		for (int s = 0; s <= seq.Length - 2; s++) {  			// Case of point s "in" and point s+1 "in"  			if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  				// Case of point s "in" and point s+1 "out"  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s+1  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  			}  			else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  				//Case of point s "out" and point s+1 "in"  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			// end case 3  		}  		// end polygon construction loop  		polygons.Add (polygon);  	}  	// end switch quad/polygon  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute points surrounding current point  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	p [0].Color = _cmap.Color (p [0].xyz);  	p [1].Color = _cmap.Color (p [1].xyz);  	p [2].Color = _cmap.Color (p [2].xyz);  	p [3].Color = _cmap.Color (p [3].xyz);  	p [0].rgb.mul (_factor);  	p [1].rgb.mul (_factor);  	p [2].rgb.mul (_factor);  	p [3].rgb.mul (_factor);  	float[] radius = new float[p.Length];  	for (int i = 0; i <= p.Length - 1; i++) {  		radius [i] = radius2d (p [i]);  	}  	// Compute status of each point according to there radius' or NaN status  	isIn = isInside (p' radius' _ringMin' _ringMax);  	// Ignore polygons that are out  	if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  		continue;  	}  	if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  		// Directly store polygons that have non NaN values for all points  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  	else {  		// Partly inside: generate points that intersect a radius  		Polygon polygon = new Polygon ();  		Point intersection = default(Point);  		// generated point  		float ringRadius = 0;  		int[] seq =  {  			0'  			1'  			2'  			3'  			0  		};  		bool[] done = new bool[4];  		for (int pi = 0; pi <= done.Length - 1; pi++) {  			done [pi] = false;  		}  		// Handle all square edges and shift "out" points  		for (int s = 0; s <= seq.Length - 2; s++) {  			// Case of point s "in" and point s+1 "in"  			if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  				// Case of point s "in" and point s+1 "out"  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s+1  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  			}  			else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  				//Case of point s "out" and point s+1 "in"  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			// end case 3  		}  		// end polygon construction loop  		polygons.Add (polygon);  	}  	// end switch quad/polygon  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute points surrounding current point  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	p [0].Color = _cmap.Color (p [0].xyz);  	p [1].Color = _cmap.Color (p [1].xyz);  	p [2].Color = _cmap.Color (p [2].xyz);  	p [3].Color = _cmap.Color (p [3].xyz);  	p [0].rgb.mul (_factor);  	p [1].rgb.mul (_factor);  	p [2].rgb.mul (_factor);  	p [3].rgb.mul (_factor);  	float[] radius = new float[p.Length];  	for (int i = 0; i <= p.Length - 1; i++) {  		radius [i] = radius2d (p [i]);  	}  	// Compute status of each point according to there radius' or NaN status  	isIn = isInside (p' radius' _ringMin' _ringMax);  	// Ignore polygons that are out  	if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  		continue;  	}  	if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  		// Directly store polygons that have non NaN values for all points  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  	else {  		// Partly inside: generate points that intersect a radius  		Polygon polygon = new Polygon ();  		Point intersection = default(Point);  		// generated point  		float ringRadius = 0;  		int[] seq =  {  			0'  			1'  			2'  			3'  			0  		};  		bool[] done = new bool[4];  		for (int pi = 0; pi <= done.Length - 1; pi++) {  			done [pi] = false;  		}  		// Handle all square edges and shift "out" points  		for (int s = 0; s <= seq.Length - 2; s++) {  			// Case of point s "in" and point s+1 "in"  			if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  				// Case of point s "in" and point s+1 "out"  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s+1  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  			}  			else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  				//Case of point s "out" and point s+1 "in"  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			// end case 3  		}  		// end polygon construction loop  		polygons.Add (polygon);  	}  	// end switch quad/polygon  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute points surrounding current point  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	p [0].Color = _cmap.Color (p [0].xyz);  	p [1].Color = _cmap.Color (p [1].xyz);  	p [2].Color = _cmap.Color (p [2].xyz);  	p [3].Color = _cmap.Color (p [3].xyz);  	p [0].rgb.mul (_factor);  	p [1].rgb.mul (_factor);  	p [2].rgb.mul (_factor);  	p [3].rgb.mul (_factor);  	float[] radius = new float[p.Length];  	for (int i = 0; i <= p.Length - 1; i++) {  		radius [i] = radius2d (p [i]);  	}  	// Compute status of each point according to there radius' or NaN status  	isIn = isInside (p' radius' _ringMin' _ringMax);  	// Ignore polygons that are out  	if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  		continue;  	}  	if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  		// Directly store polygons that have non NaN values for all points  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  	else {  		// Partly inside: generate points that intersect a radius  		Polygon polygon = new Polygon ();  		Point intersection = default(Point);  		// generated point  		float ringRadius = 0;  		int[] seq =  {  			0'  			1'  			2'  			3'  			0  		};  		bool[] done = new bool[4];  		for (int pi = 0; pi <= done.Length - 1; pi++) {  			done [pi] = false;  		}  		// Handle all square edges and shift "out" points  		for (int s = 0; s <= seq.Length - 2; s++) {  			// Case of point s "in" and point s+1 "in"  			if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  				// Case of point s "in" and point s+1 "out"  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s+1  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  			}  			else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  				//Case of point s "out" and point s+1 "in"  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			// end case 3  		}  		// end polygon construction loop  		polygons.Add (polygon);  	}  	// end switch quad/polygon  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute points surrounding current point  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	p [0].Color = _cmap.Color (p [0].xyz);  	p [1].Color = _cmap.Color (p [1].xyz);  	p [2].Color = _cmap.Color (p [2].xyz);  	p [3].Color = _cmap.Color (p [3].xyz);  	p [0].rgb.mul (_factor);  	p [1].rgb.mul (_factor);  	p [2].rgb.mul (_factor);  	p [3].rgb.mul (_factor);  	float[] radius = new float[p.Length];  	for (int i = 0; i <= p.Length - 1; i++) {  		radius [i] = radius2d (p [i]);  	}  	// Compute status of each point according to there radius' or NaN status  	isIn = isInside (p' radius' _ringMin' _ringMax);  	// Ignore polygons that are out  	if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  		continue;  	}  	if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  		// Directly store polygons that have non NaN values for all points  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  	else {  		// Partly inside: generate points that intersect a radius  		Polygon polygon = new Polygon ();  		Point intersection = default(Point);  		// generated point  		float ringRadius = 0;  		int[] seq =  {  			0'  			1'  			2'  			3'  			0  		};  		bool[] done = new bool[4];  		for (int pi = 0; pi <= done.Length - 1; pi++) {  			done [pi] = false;  		}  		// Handle all square edges and shift "out" points  		for (int s = 0; s <= seq.Length - 2; s++) {  			// Case of point s "in" and point s+1 "in"  			if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  				// Case of point s "in" and point s+1 "out"  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s+1  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  			}  			else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  				//Case of point s "out" and point s+1 "in"  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			// end case 3  		}  		// end polygon construction loop  		polygons.Add (polygon);  	}  	// end switch quad/polygon  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute points surrounding current point  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	p [0].Color = _cmap.Color (p [0].xyz);  	p [1].Color = _cmap.Color (p [1].xyz);  	p [2].Color = _cmap.Color (p [2].xyz);  	p [3].Color = _cmap.Color (p [3].xyz);  	p [0].rgb.mul (_factor);  	p [1].rgb.mul (_factor);  	p [2].rgb.mul (_factor);  	p [3].rgb.mul (_factor);  	float[] radius = new float[p.Length];  	for (int i = 0; i <= p.Length - 1; i++) {  		radius [i] = radius2d (p [i]);  	}  	// Compute status of each point according to there radius' or NaN status  	isIn = isInside (p' radius' _ringMin' _ringMax);  	// Ignore polygons that are out  	if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  		continue;  	}  	if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  		// Directly store polygons that have non NaN values for all points  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  	else {  		// Partly inside: generate points that intersect a radius  		Polygon polygon = new Polygon ();  		Point intersection = default(Point);  		// generated point  		float ringRadius = 0;  		int[] seq =  {  			0'  			1'  			2'  			3'  			0  		};  		bool[] done = new bool[4];  		for (int pi = 0; pi <= done.Length - 1; pi++) {  			done [pi] = false;  		}  		// Handle all square edges and shift "out" points  		for (int s = 0; s <= seq.Length - 2; s++) {  			// Case of point s "in" and point s+1 "in"  			if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  				// Case of point s "in" and point s+1 "out"  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s+1  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  			}  			else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  				//Case of point s "out" and point s+1 "in"  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			// end case 3  		}  		// end polygon construction loop  		polygons.Add (polygon);  	}  	// end switch quad/polygon  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute points surrounding current point  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	p [0].Color = _cmap.Color (p [0].xyz);  	p [1].Color = _cmap.Color (p [1].xyz);  	p [2].Color = _cmap.Color (p [2].xyz);  	p [3].Color = _cmap.Color (p [3].xyz);  	p [0].rgb.mul (_factor);  	p [1].rgb.mul (_factor);  	p [2].rgb.mul (_factor);  	p [3].rgb.mul (_factor);  	float[] radius = new float[p.Length];  	for (int i = 0; i <= p.Length - 1; i++) {  		radius [i] = radius2d (p [i]);  	}  	// Compute status of each point according to there radius' or NaN status  	isIn = isInside (p' radius' _ringMin' _ringMax);  	// Ignore polygons that are out  	if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  		continue;  	}  	if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  		// Directly store polygons that have non NaN values for all points  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  	else {  		// Partly inside: generate points that intersect a radius  		Polygon polygon = new Polygon ();  		Point intersection = default(Point);  		// generated point  		float ringRadius = 0;  		int[] seq =  {  			0'  			1'  			2'  			3'  			0  		};  		bool[] done = new bool[4];  		for (int pi = 0; pi <= done.Length - 1; pi++) {  			done [pi] = false;  		}  		// Handle all square edges and shift "out" points  		for (int s = 0; s <= seq.Length - 2; s++) {  			// Case of point s "in" and point s+1 "in"  			if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  				// Case of point s "in" and point s+1 "out"  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s+1  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  			}  			else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  				//Case of point s "out" and point s+1 "in"  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			// end case 3  		}  		// end polygon construction loop  		polygons.Add (polygon);  	}  	// end switch quad/polygon  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int yi = 0; yi <= y.Length - 2; yi++) {  	// Compute points surrounding current point  	Point[] p = getRealQuadStandingOnPoint (xi' yi);  	p [0].Color = _cmap.Color (p [0].xyz);  	p [1].Color = _cmap.Color (p [1].xyz);  	p [2].Color = _cmap.Color (p [2].xyz);  	p [3].Color = _cmap.Color (p [3].xyz);  	p [0].rgb.mul (_factor);  	p [1].rgb.mul (_factor);  	p [2].rgb.mul (_factor);  	p [3].rgb.mul (_factor);  	float[] radius = new float[p.Length];  	for (int i = 0; i <= p.Length - 1; i++) {  		radius [i] = radius2d (p [i]);  	}  	// Compute status of each point according to there radius' or NaN status  	isIn = isInside (p' radius' _ringMin' _ringMax);  	// Ignore polygons that are out  	if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  		continue;  	}  	if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  		// Directly store polygons that have non NaN values for all points  		Polygon quad = new Polygon ();  		for (int pi = 0; pi <= p.Length - 1; pi++) {  			quad.Add (p [pi]);  		}  		polygons.Add (quad);  	}  	else {  		// Partly inside: generate points that intersect a radius  		Polygon polygon = new Polygon ();  		Point intersection = default(Point);  		// generated point  		float ringRadius = 0;  		int[] seq =  {  			0'  			1'  			2'  			3'  			0  		};  		bool[] done = new bool[4];  		for (int pi = 0; pi <= done.Length - 1; pi++) {  			done [pi] = false;  		}  		// Handle all square edges and shift "out" points  		for (int s = 0; s <= seq.Length - 2; s++) {  			// Case of point s "in" and point s+1 "in"  			if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  				// Case of point s "in" and point s+1 "out"  				if ((!done [seq [s]])) {  					polygon.Add (p [seq [s]]);  					done [seq [s]] = true;  				}  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s+1  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  			}  			else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  				//Case of point s "out" and point s+1 "in"  				// Select the radius on which the point is supposed to stand  				if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  					ringRadius = _ringMin;  				}  				else {  					ringRadius = _ringMax;  				}  				// Generate a point on the circle that replaces s  				intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  				intersection.Color = _cmap.Color (intersection.xyz);  				intersection.rgb.mul (_factor);  				polygon.Add (intersection);  				if ((!done [seq [s + 1]])) {  					polygon.Add (p [seq [s + 1]]);  					done [seq [s + 1]] = true;  				}  			}  			// end case 3  		}  		// end polygon construction loop  		polygons.Add (polygon);  	}  	// end switch quad/polygon  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: p [2].Color = _cmap.Color (p [2].xyz);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: p [2].Color = _cmap.Color (p [2].xyz);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: p [3].Color = _cmap.Color (p [3].xyz);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: p [3].Color = _cmap.Color (p [3].xyz);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: p [2].rgb.mul (_factor);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: p [3].rgb.mul (_factor);  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  	continue;  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: if (((!isIn [0]) & (!isIn [1]) & (!isIn [2]) & (!isIn [3]))) {  	continue;  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  	// Directly store polygons that have non NaN values for all points  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  else {  	// Partly inside: generate points that intersect a radius  	Polygon polygon = new Polygon ();  	Point intersection = default(Point);  	// generated point  	float ringRadius = 0;  	int[] seq =  {  		0'  		1'  		2'  		3'  		0  	};  	bool[] done = new bool[4];  	for (int pi = 0; pi <= done.Length - 1; pi++) {  		done [pi] = false;  	}  	// Handle all square edges and shift "out" points  	for (int s = 0; s <= seq.Length - 2; s++) {  		// Case of point s "in" and point s+1 "in"  		if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  			if ((!done [seq [s]])) {  				polygon.Add (p [seq [s]]);  				done [seq [s]] = true;  			}  			if ((!done [seq [s + 1]])) {  				polygon.Add (p [seq [s + 1]]);  				done [seq [s + 1]] = true;  			}  		}  		else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  			// Case of point s "in" and point s+1 "out"  			if ((!done [seq [s]])) {  				polygon.Add (p [seq [s]]);  				done [seq [s]] = true;  			}  			// Select the radius on which the point is supposed to stand  			if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  				ringRadius = _ringMin;  			}  			else {  				ringRadius = _ringMax;  			}  			// Generate a point on the circle that replaces s+1  			intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  			intersection.Color = _cmap.Color (intersection.xyz);  			intersection.rgb.mul (_factor);  			polygon.Add (intersection);  		}  		else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  			//Case of point s "out" and point s+1 "in"  			// Select the radius on which the point is supposed to stand  			if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  				ringRadius = _ringMin;  			}  			else {  				ringRadius = _ringMax;  			}  			// Generate a point on the circle that replaces s  			intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  			intersection.Color = _cmap.Color (intersection.xyz);  			intersection.rgb.mul (_factor);  			polygon.Add (intersection);  			if ((!done [seq [s + 1]])) {  				polygon.Add (p [seq [s + 1]]);  				done [seq [s + 1]] = true;  			}  		}  		// end case 3  	}  	// end polygon construction loop  	polygons.Add (polygon);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  	// Directly store polygons that have non NaN values for all points  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  else {  	// Partly inside: generate points that intersect a radius  	Polygon polygon = new Polygon ();  	Point intersection = default(Point);  	// generated point  	float ringRadius = 0;  	int[] seq =  {  		0'  		1'  		2'  		3'  		0  	};  	bool[] done = new bool[4];  	for (int pi = 0; pi <= done.Length - 1; pi++) {  		done [pi] = false;  	}  	// Handle all square edges and shift "out" points  	for (int s = 0; s <= seq.Length - 2; s++) {  		// Case of point s "in" and point s+1 "in"  		if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  			if ((!done [seq [s]])) {  				polygon.Add (p [seq [s]]);  				done [seq [s]] = true;  			}  			if ((!done [seq [s + 1]])) {  				polygon.Add (p [seq [s + 1]]);  				done [seq [s + 1]] = true;  			}  		}  		else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  			// Case of point s "in" and point s+1 "out"  			if ((!done [seq [s]])) {  				polygon.Add (p [seq [s]]);  				done [seq [s]] = true;  			}  			// Select the radius on which the point is supposed to stand  			if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  				ringRadius = _ringMin;  			}  			else {  				ringRadius = _ringMax;  			}  			// Generate a point on the circle that replaces s+1  			intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  			intersection.Color = _cmap.Color (intersection.xyz);  			intersection.rgb.mul (_factor);  			polygon.Add (intersection);  		}  		else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  			//Case of point s "out" and point s+1 "in"  			// Select the radius on which the point is supposed to stand  			if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  				ringRadius = _ringMin;  			}  			else {  				ringRadius = _ringMax;  			}  			// Generate a point on the circle that replaces s  			intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  			intersection.Color = _cmap.Color (intersection.xyz);  			intersection.rgb.mul (_factor);  			polygon.Add (intersection);  			if ((!done [seq [s + 1]])) {  				polygon.Add (p [seq [s + 1]]);  				done [seq [s + 1]] = true;  			}  		}  		// end case 3  	}  	// end polygon construction loop  	polygons.Add (polygon);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  	// Directly store polygons that have non NaN values for all points  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  else {  	// Partly inside: generate points that intersect a radius  	Polygon polygon = new Polygon ();  	Point intersection = default(Point);  	// generated point  	float ringRadius = 0;  	int[] seq =  {  		0'  		1'  		2'  		3'  		0  	};  	bool[] done = new bool[4];  	for (int pi = 0; pi <= done.Length - 1; pi++) {  		done [pi] = false;  	}  	// Handle all square edges and shift "out" points  	for (int s = 0; s <= seq.Length - 2; s++) {  		// Case of point s "in" and point s+1 "in"  		if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  			if ((!done [seq [s]])) {  				polygon.Add (p [seq [s]]);  				done [seq [s]] = true;  			}  			if ((!done [seq [s + 1]])) {  				polygon.Add (p [seq [s + 1]]);  				done [seq [s + 1]] = true;  			}  		}  		else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  			// Case of point s "in" and point s+1 "out"  			if ((!done [seq [s]])) {  				polygon.Add (p [seq [s]]);  				done [seq [s]] = true;  			}  			// Select the radius on which the point is supposed to stand  			if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  				ringRadius = _ringMin;  			}  			else {  				ringRadius = _ringMax;  			}  			// Generate a point on the circle that replaces s+1  			intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  			intersection.Color = _cmap.Color (intersection.xyz);  			intersection.rgb.mul (_factor);  			polygon.Add (intersection);  		}  		else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  			//Case of point s "out" and point s+1 "in"  			// Select the radius on which the point is supposed to stand  			if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  				ringRadius = _ringMin;  			}  			else {  				ringRadius = _ringMax;  			}  			// Generate a point on the circle that replaces s  			intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  			intersection.Color = _cmap.Color (intersection.xyz);  			intersection.rgb.mul (_factor);  			polygon.Add (intersection);  			if ((!done [seq [s + 1]])) {  				polygon.Add (p [seq [s + 1]]);  				done [seq [s + 1]] = true;  			}  		}  		// end case 3  	}  	// end polygon construction loop  	polygons.Add (polygon);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  	// Directly store polygons that have non NaN values for all points  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  else {  	// Partly inside: generate points that intersect a radius  	Polygon polygon = new Polygon ();  	Point intersection = default(Point);  	// generated point  	float ringRadius = 0;  	int[] seq =  {  		0'  		1'  		2'  		3'  		0  	};  	bool[] done = new bool[4];  	for (int pi = 0; pi <= done.Length - 1; pi++) {  		done [pi] = false;  	}  	// Handle all square edges and shift "out" points  	for (int s = 0; s <= seq.Length - 2; s++) {  		// Case of point s "in" and point s+1 "in"  		if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  			if ((!done [seq [s]])) {  				polygon.Add (p [seq [s]]);  				done [seq [s]] = true;  			}  			if ((!done [seq [s + 1]])) {  				polygon.Add (p [seq [s + 1]]);  				done [seq [s + 1]] = true;  			}  		}  		else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  			// Case of point s "in" and point s+1 "out"  			if ((!done [seq [s]])) {  				polygon.Add (p [seq [s]]);  				done [seq [s]] = true;  			}  			// Select the radius on which the point is supposed to stand  			if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  				ringRadius = _ringMin;  			}  			else {  				ringRadius = _ringMax;  			}  			// Generate a point on the circle that replaces s+1  			intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  			intersection.Color = _cmap.Color (intersection.xyz);  			intersection.rgb.mul (_factor);  			polygon.Add (intersection);  		}  		else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  			//Case of point s "out" and point s+1 "in"  			// Select the radius on which the point is supposed to stand  			if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  				ringRadius = _ringMin;  			}  			else {  				ringRadius = _ringMax;  			}  			// Generate a point on the circle that replaces s  			intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  			intersection.Color = _cmap.Color (intersection.xyz);  			intersection.rgb.mul (_factor);  			polygon.Add (intersection);  			if ((!done [seq [s + 1]])) {  				polygon.Add (p [seq [s + 1]]);  				done [seq [s + 1]] = true;  			}  		}  		// end case 3  	}  	// end polygon construction loop  	polygons.Add (polygon);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  	// Directly store polygons that have non NaN values for all points  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  else {  	// Partly inside: generate points that intersect a radius  	Polygon polygon = new Polygon ();  	Point intersection = default(Point);  	// generated point  	float ringRadius = 0;  	int[] seq =  {  		0'  		1'  		2'  		3'  		0  	};  	bool[] done = new bool[4];  	for (int pi = 0; pi <= done.Length - 1; pi++) {  		done [pi] = false;  	}  	// Handle all square edges and shift "out" points  	for (int s = 0; s <= seq.Length - 2; s++) {  		// Case of point s "in" and point s+1 "in"  		if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  			if ((!done [seq [s]])) {  				polygon.Add (p [seq [s]]);  				done [seq [s]] = true;  			}  			if ((!done [seq [s + 1]])) {  				polygon.Add (p [seq [s + 1]]);  				done [seq [s + 1]] = true;  			}  		}  		else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  			// Case of point s "in" and point s+1 "out"  			if ((!done [seq [s]])) {  				polygon.Add (p [seq [s]]);  				done [seq [s]] = true;  			}  			// Select the radius on which the point is supposed to stand  			if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  				ringRadius = _ringMin;  			}  			else {  				ringRadius = _ringMax;  			}  			// Generate a point on the circle that replaces s+1  			intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  			intersection.Color = _cmap.Color (intersection.xyz);  			intersection.rgb.mul (_factor);  			polygon.Add (intersection);  		}  		else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  			//Case of point s "out" and point s+1 "in"  			// Select the radius on which the point is supposed to stand  			if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  				ringRadius = _ringMin;  			}  			else {  				ringRadius = _ringMax;  			}  			// Generate a point on the circle that replaces s  			intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  			intersection.Color = _cmap.Color (intersection.xyz);  			intersection.rgb.mul (_factor);  			polygon.Add (intersection);  			if ((!done [seq [s + 1]])) {  				polygon.Add (p [seq [s + 1]]);  				done [seq [s + 1]] = true;  			}  		}  		// end case 3  	}  	// end polygon construction loop  	polygons.Add (polygon);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: if ((isIn [0] & isIn [1] & isIn [2] & isIn [3])) {  	// Directly store polygons that have non NaN values for all points  	Polygon quad = new Polygon ();  	for (int pi = 0; pi <= p.Length - 1; pi++) {  		quad.Add (p [pi]);  	}  	polygons.Add (quad);  }  else {  	// Partly inside: generate points that intersect a radius  	Polygon polygon = new Polygon ();  	Point intersection = default(Point);  	// generated point  	float ringRadius = 0;  	int[] seq =  {  		0'  		1'  		2'  		3'  		0  	};  	bool[] done = new bool[4];  	for (int pi = 0; pi <= done.Length - 1; pi++) {  		done [pi] = false;  	}  	// Handle all square edges and shift "out" points  	for (int s = 0; s <= seq.Length - 2; s++) {  		// Case of point s "in" and point s+1 "in"  		if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  			if ((!done [seq [s]])) {  				polygon.Add (p [seq [s]]);  				done [seq [s]] = true;  			}  			if ((!done [seq [s + 1]])) {  				polygon.Add (p [seq [s + 1]]);  				done [seq [s + 1]] = true;  			}  		}  		else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  			// Case of point s "in" and point s+1 "out"  			if ((!done [seq [s]])) {  				polygon.Add (p [seq [s]]);  				done [seq [s]] = true;  			}  			// Select the radius on which the point is supposed to stand  			if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  				ringRadius = _ringMin;  			}  			else {  				ringRadius = _ringMax;  			}  			// Generate a point on the circle that replaces s+1  			intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  			intersection.Color = _cmap.Color (intersection.xyz);  			intersection.rgb.mul (_factor);  			polygon.Add (intersection);  		}  		else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  			//Case of point s "out" and point s+1 "in"  			// Select the radius on which the point is supposed to stand  			if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  				ringRadius = _ringMin;  			}  			else {  				ringRadius = _ringMax;  			}  			// Generate a point on the circle that replaces s  			intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  			intersection.Color = _cmap.Color (intersection.xyz);  			intersection.rgb.mul (_factor);  			polygon.Add (intersection);  			if ((!done [seq [s + 1]])) {  				polygon.Add (p [seq [s + 1]]);  				done [seq [s + 1]] = true;  			}  		}  		// end case 3  	}  	// end polygon construction loop  	polygons.Add (polygon);  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,getInterpolatedRingPolygons,The following statement contains a magic number: for (int s = 0; s <= seq.Length - 2; s++) {  	// Case of point s "in" and point s+1 "in"  	if ((isIn [seq [s]] & isIn [seq [s + 1]])) {  		if ((!done [seq [s]])) {  			polygon.Add (p [seq [s]]);  			done [seq [s]] = true;  		}  		if ((!done [seq [s + 1]])) {  			polygon.Add (p [seq [s + 1]]);  			done [seq [s + 1]] = true;  		}  	}  	else if ((isIn [seq [s]] & (!isIn [seq [s + 1]]))) {  		// Case of point s "in" and point s+1 "out"  		if ((!done [seq [s]])) {  			polygon.Add (p [seq [s]]);  			done [seq [s]] = true;  		}  		// Select the radius on which the point is supposed to stand  		if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  			ringRadius = _ringMin;  		}  		else {  			ringRadius = _ringMax;  		}  		// Generate a point on the circle that replaces s+1  		intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  		intersection.Color = _cmap.Color (intersection.xyz);  		intersection.rgb.mul (_factor);  		polygon.Add (intersection);  	}  	else if (((!isIn [seq [s]]) & isIn [seq [s + 1]])) {  		//Case of point s "out" and point s+1 "in"  		// Select the radius on which the point is supposed to stand  		if ((Math.Abs (radius [seq [s + 1]] - _ringMin) < Math.Abs (radius [seq [s + 1]] - _ringMax))) {  			ringRadius = _ringMin;  		}  		else {  			ringRadius = _ringMax;  		}  		// Generate a point on the circle that replaces s  		intersection = findPoint (p [seq [s]]' p [seq [s + 1]]' ringRadius);  		intersection.Color = _cmap.Color (intersection.xyz);  		intersection.rgb.mul (_factor);  		polygon.Add (intersection);  		if ((!done [seq [s + 1]])) {  			polygon.Add (p [seq [s + 1]]);  			done [seq [s + 1]] = true;  		}  	}  	// end case 3  }  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,isInside,The following statement contains a magic number: isIn [2] = (!double.IsNaN (p [2].xyz.z)) & radius [2] < maxRadius & radius [2] >= minRadius;  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,isInside,The following statement contains a magic number: isIn [2] = (!double.IsNaN (p [2].xyz.z)) & radius [2] < maxRadius & radius [2] >= minRadius;  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,isInside,The following statement contains a magic number: isIn [2] = (!double.IsNaN (p [2].xyz.z)) & radius [2] < maxRadius & radius [2] >= minRadius;  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,isInside,The following statement contains a magic number: isIn [2] = (!double.IsNaN (p [2].xyz.z)) & radius [2] < maxRadius & radius [2] >= minRadius;  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,isInside,The following statement contains a magic number: isIn [3] = (!double.IsNaN (p [3].xyz.z)) & radius [3] < maxRadius & radius [3] >= minRadius;  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,isInside,The following statement contains a magic number: isIn [3] = (!double.IsNaN (p [3].xyz.z)) & radius [3] < maxRadius & radius [3] >= minRadius;  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,isInside,The following statement contains a magic number: isIn [3] = (!double.IsNaN (p [3].xyz.z)) & radius [3] < maxRadius & radius [3] >= minRadius;  
Magic Number,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,isInside,The following statement contains a magic number: isIn [3] = (!double.IsNaN (p [3].xyz.z)) & radius [3] < maxRadius & radius [3] >= minRadius;  
Magic Number,nzy3D.Plot3D.Builder.Concrete,SphereScatterGenerator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\SphereScatterGenerator.cs,Generate,The following statement contains a magic number: while (i < (2 * Math.PI)) {  	double j = 0;  	while (j < (jrat * Math.PI)) {  		Coord3d c = (new Coord3d (i' j' radius)).cartesian ();  		if ((center != null)) {  			c.x += center.x;  			c.y += center.y;  			c.z += center.z;  		}  		coords.Add (c);  		j += inc;  	}  	i += inc;  }  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Delaunay_Triangulation,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Delaunay_Triangulation.cs,insertPointSimple,The following statement contains a magic number: if (nPoints == 2) {  	startTriangulation (firstP' p);  	return null;  }  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Delaunay_Triangulation,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Delaunay_Triangulation.cs,trianglesIterator,The following statement contains a magic number: if (this.Size () <= 2) {  	_triangles = new List<Triangle_dt> ();  }  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Delaunay_Triangulation,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Delaunay_Triangulation.cs,initTriangles,The following statement contains a magic number: if (this.Size () > 2) {  	_modCount2 = _modCount;  	List<Triangle_dt> front = new List<Triangle_dt> ();  	_triangles = new List<Triangle_dt> ();  	front.Add (this.startTriangle);  	while ((front.Count > 0)) {  		Triangle_dt t = front [0];  		front.RemoveAt (0);  		if ((t.mark == false)) {  			t.mark = true;  			_triangles.Add (t);  			if (((t.abnext != null)) && (!t.abnext.mark)) {  				front.Add (t.abnext);  			}  			if (((t.bcnext != null)) && (!t.bcnext.mark)) {  				front.Add (t.bcnext);  			}  			if (((t.canext != null)) && (!t.canext.mark)) {  				front.Add (t.bcnext);  			}  		}  	}  	foreach (Triangle_dt aTriangle in _triangles) {  		aTriangle.mark = false;  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Point_dt_Compare,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Point_dt.cs,Compare,The following statement contains a magic number: if (!(o1 == null | o2 == null)) {  	if ((m_flag == 0)) {  		if ((o1.x > o2.x))  			return 1;  		if ((o1.x < o2.x))  			return -1;  		// x1 == x2  		if ((o1.y > o2.y))  			return 1;  		if ((o1.y < o2.y))  			return -1;  	}  	else if ((m_flag == 1)) {  		if ((o1.x > o2.x))  			return -1;  		if ((o1.x < o2.x))  			return 1;  		// x1 == x2  		if ((o1.y > o2.y))  			return -1;  		if ((o1.y < o2.y))  			return 1;  	}  	else if ((m_flag == 2)) {  		if ((o1.y > o2.y))  			return 1;  		if ((o1.y < o2.y))  			return -1;  		// y1 == y2  		if ((o1.x > o2.x))  			return 1;  		if ((o1.x < o2.x))  			return -1;  	}  	else if ((m_flag == 3)) {  		if ((o1.y > o2.y))  			return -1;  		if ((o1.y < o2.y))  			return 1;  		// y1 == y2  		if ((o1.x > o2.x))  			return -1;  		if ((o1.x < o2.x))  			return 1;  	}  }  else {  	if (o1 == null & o2 == null) {  		return 0;  	}  	if (o1 == null & ((o2 != null))) {  		return 1;  	}  	if (((o1 != null)) & o2 == null) {  		return -1;  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Point_dt_Compare,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Point_dt.cs,Compare,The following statement contains a magic number: if (!(o1 == null | o2 == null)) {  	if ((m_flag == 0)) {  		if ((o1.x > o2.x))  			return 1;  		if ((o1.x < o2.x))  			return -1;  		// x1 == x2  		if ((o1.y > o2.y))  			return 1;  		if ((o1.y < o2.y))  			return -1;  	}  	else if ((m_flag == 1)) {  		if ((o1.x > o2.x))  			return -1;  		if ((o1.x < o2.x))  			return 1;  		// x1 == x2  		if ((o1.y > o2.y))  			return -1;  		if ((o1.y < o2.y))  			return 1;  	}  	else if ((m_flag == 2)) {  		if ((o1.y > o2.y))  			return 1;  		if ((o1.y < o2.y))  			return -1;  		// y1 == y2  		if ((o1.x > o2.x))  			return 1;  		if ((o1.x < o2.x))  			return -1;  	}  	else if ((m_flag == 3)) {  		if ((o1.y > o2.y))  			return -1;  		if ((o1.y < o2.y))  			return 1;  		// y1 == y2  		if ((o1.x > o2.x))  			return -1;  		if ((o1.x < o2.x))  			return 1;  	}  }  else {  	if (o1 == null & o2 == null) {  		return 0;  	}  	if (o1 == null & ((o2 != null))) {  		return 1;  	}  	if (((o1 != null)) & o2 == null) {  		return -1;  	}  }  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Point_dt_Compare,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Point_dt.cs,Compare,The following statement contains a magic number: if ((m_flag == 0)) {  	if ((o1.x > o2.x))  		return 1;  	if ((o1.x < o2.x))  		return -1;  	// x1 == x2  	if ((o1.y > o2.y))  		return 1;  	if ((o1.y < o2.y))  		return -1;  }  else if ((m_flag == 1)) {  	if ((o1.x > o2.x))  		return -1;  	if ((o1.x < o2.x))  		return 1;  	// x1 == x2  	if ((o1.y > o2.y))  		return -1;  	if ((o1.y < o2.y))  		return 1;  }  else if ((m_flag == 2)) {  	if ((o1.y > o2.y))  		return 1;  	if ((o1.y < o2.y))  		return -1;  	// y1 == y2  	if ((o1.x > o2.x))  		return 1;  	if ((o1.x < o2.x))  		return -1;  }  else if ((m_flag == 3)) {  	if ((o1.y > o2.y))  		return -1;  	if ((o1.y < o2.y))  		return 1;  	// y1 == y2  	if ((o1.x > o2.x))  		return -1;  	if ((o1.x < o2.x))  		return 1;  }  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Point_dt_Compare,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Point_dt.cs,Compare,The following statement contains a magic number: if ((m_flag == 0)) {  	if ((o1.x > o2.x))  		return 1;  	if ((o1.x < o2.x))  		return -1;  	// x1 == x2  	if ((o1.y > o2.y))  		return 1;  	if ((o1.y < o2.y))  		return -1;  }  else if ((m_flag == 1)) {  	if ((o1.x > o2.x))  		return -1;  	if ((o1.x < o2.x))  		return 1;  	// x1 == x2  	if ((o1.y > o2.y))  		return -1;  	if ((o1.y < o2.y))  		return 1;  }  else if ((m_flag == 2)) {  	if ((o1.y > o2.y))  		return 1;  	if ((o1.y < o2.y))  		return -1;  	// y1 == y2  	if ((o1.x > o2.x))  		return 1;  	if ((o1.x < o2.x))  		return -1;  }  else if ((m_flag == 3)) {  	if ((o1.y > o2.y))  		return -1;  	if ((o1.y < o2.y))  		return 1;  	// y1 == y2  	if ((o1.x > o2.x))  		return -1;  	if ((o1.x < o2.x))  		return 1;  }  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Point_dt_Compare,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Point_dt.cs,Compare,The following statement contains a magic number: if ((m_flag == 1)) {  	if ((o1.x > o2.x))  		return -1;  	if ((o1.x < o2.x))  		return 1;  	// x1 == x2  	if ((o1.y > o2.y))  		return -1;  	if ((o1.y < o2.y))  		return 1;  }  else if ((m_flag == 2)) {  	if ((o1.y > o2.y))  		return 1;  	if ((o1.y < o2.y))  		return -1;  	// y1 == y2  	if ((o1.x > o2.x))  		return 1;  	if ((o1.x < o2.x))  		return -1;  }  else if ((m_flag == 3)) {  	if ((o1.y > o2.y))  		return -1;  	if ((o1.y < o2.y))  		return 1;  	// y1 == y2  	if ((o1.x > o2.x))  		return -1;  	if ((o1.x < o2.x))  		return 1;  }  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Point_dt_Compare,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Point_dt.cs,Compare,The following statement contains a magic number: if ((m_flag == 1)) {  	if ((o1.x > o2.x))  		return -1;  	if ((o1.x < o2.x))  		return 1;  	// x1 == x2  	if ((o1.y > o2.y))  		return -1;  	if ((o1.y < o2.y))  		return 1;  }  else if ((m_flag == 2)) {  	if ((o1.y > o2.y))  		return 1;  	if ((o1.y < o2.y))  		return -1;  	// y1 == y2  	if ((o1.x > o2.x))  		return 1;  	if ((o1.x < o2.x))  		return -1;  }  else if ((m_flag == 3)) {  	if ((o1.y > o2.y))  		return -1;  	if ((o1.y < o2.y))  		return 1;  	// y1 == y2  	if ((o1.x > o2.x))  		return -1;  	if ((o1.x < o2.x))  		return 1;  }  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Point_dt_Compare,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Point_dt.cs,Compare,The following statement contains a magic number: if ((m_flag == 2)) {  	if ((o1.y > o2.y))  		return 1;  	if ((o1.y < o2.y))  		return -1;  	// y1 == y2  	if ((o1.x > o2.x))  		return 1;  	if ((o1.x < o2.x))  		return -1;  }  else if ((m_flag == 3)) {  	if ((o1.y > o2.y))  		return -1;  	if ((o1.y < o2.y))  		return 1;  	// y1 == y2  	if ((o1.x > o2.x))  		return -1;  	if ((o1.x < o2.x))  		return 1;  }  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Point_dt_Compare,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Point_dt.cs,Compare,The following statement contains a magic number: if ((m_flag == 2)) {  	if ((o1.y > o2.y))  		return 1;  	if ((o1.y < o2.y))  		return -1;  	// y1 == y2  	if ((o1.x > o2.x))  		return 1;  	if ((o1.x < o2.x))  		return -1;  }  else if ((m_flag == 3)) {  	if ((o1.y > o2.y))  		return -1;  	if ((o1.y < o2.y))  		return 1;  	// y1 == y2  	if ((o1.x > o2.x))  		return -1;  	if ((o1.x < o2.x))  		return 1;  }  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Point_dt_Compare,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Point_dt.cs,Compare,The following statement contains a magic number: if ((m_flag == 3)) {  	if ((o1.y > o2.y))  		return -1;  	if ((o1.y < o2.y))  		return 1;  	// y1 == y2  	if ((o1.x > o2.x))  		return -1;  	if ((o1.x < o2.x))  		return 1;  }  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Triangle_dt,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Triangle_dt.cs,z_value,The following statement contains a magic number: if (x0 != x1) {  	m01 = (y0 - y1) / (x0 - x1);  	k01 = y0 - m01 * x0;  	if (m01 == 0)  		flag01 = 1;  	//2-vertical  }  else {  	flag01 = 2;  	//x01 = x0  }  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Triangle_dt,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Triangle_dt.cs,z_value,The following statement contains a magic number: flag01 = 2;  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Triangle_dt,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Triangle_dt.cs,z_value,The following statement contains a magic number: if (x2 != x3) {  	m23 = (y2 - y3) / (x2 - x3);  	k23 = y2 - m23 * x2;  	if (m23 == 0)  		flag23 = 1;  	//2-vertical  }  else {  	flag23 = 2;  	//x01 = x0  }  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Triangle_dt,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Triangle_dt.cs,z_value,The following statement contains a magic number: flag23 = 2;  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Triangle_dt,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Triangle_dt.cs,z_value,The following statement contains a magic number: if (flag01 == 2) {  	X = x0;  	Y = m23 * X + k23;  }  else if (flag23 == 2) {  	X = x2;  	Y = m01 * X + k01;  }  else {  	X = (k23 - k01) / (m01 - m23);  	Y = m01 * X + k01;  }  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Triangle_dt,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Triangle_dt.cs,z_value,The following statement contains a magic number: if (flag01 == 2) {  	X = x0;  	Y = m23 * X + k23;  }  else if (flag23 == 2) {  	X = x2;  	Y = m01 * X + k01;  }  else {  	X = (k23 - k01) / (m01 - m23);  	Y = m01 * X + k01;  }  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Triangle_dt,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Triangle_dt.cs,z_value,The following statement contains a magic number: if (flag23 == 2) {  	X = x2;  	Y = m01 * X + k01;  }  else {  	X = (k23 - k01) / (m01 - m23);  	Y = m01 * X + k01;  }  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Triangle_dt,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Triangle_dt.cs,z_value,The following statement contains a magic number: if (flag23 == 2) {  	r = (y2 - Y) / (y2 - y3);  }  else {  	r = (x2 - X) / (x2 - x3);  }  
Magic Number,nzy3D.Plot3D.Builder.Delaunay.Jdt,Triangle_dt,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Triangle_dt.cs,z_value,The following statement contains a magic number: if (flag01 == 2) {  	r = (y1 - y0) / (y1 - Y);  }  else {  	r = (x1 - x0) / (x1 - X);  }  
Magic Number,nzy3D.Plot3D.Primitives,Parallelepiped,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Parallelepiped.cs,Parallelepiped,The following statement contains a magic number: _quads = new List<Polygon> (6);  
Magic Number,nzy3D.Plot3D.Primitives,Parallelepiped,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Parallelepiped.cs,setData,The following statement contains a magic number: _quads = new List<Polygon> (6);  
Magic Number,nzy3D.Plot3D.Primitives,Parallelepiped,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Parallelepiped.cs,setData,The following statement contains a magic number: for (int i = 0; i <= 5; i++) {  	_quads.Add (new Polygon ());  }  
Magic Number,nzy3D.Plot3D.Primitives,Parallelepiped,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Parallelepiped.cs,setData,The following statement contains a magic number: _quads [2].Add (new Point (new Coord3d (_bbox.xmax' _bbox.ymax' _bbox.zmax)));  
Magic Number,nzy3D.Plot3D.Primitives,Parallelepiped,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Parallelepiped.cs,setData,The following statement contains a magic number: _quads [2].Add (new Point (new Coord3d (_bbox.xmax' _bbox.ymax' _bbox.zmin)));  
Magic Number,nzy3D.Plot3D.Primitives,Parallelepiped,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Parallelepiped.cs,setData,The following statement contains a magic number: _quads [2].Add (new Point (new Coord3d (_bbox.xmin' _bbox.ymax' _bbox.zmin)));  
Magic Number,nzy3D.Plot3D.Primitives,Parallelepiped,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Parallelepiped.cs,setData,The following statement contains a magic number: _quads [2].Add (new Point (new Coord3d (_bbox.xmin' _bbox.ymax' _bbox.zmax)));  
Magic Number,nzy3D.Plot3D.Primitives,Parallelepiped,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Parallelepiped.cs,setData,The following statement contains a magic number: _quads [3].Add (new Point (new Coord3d (_bbox.xmin' _bbox.ymin' _bbox.zmax)));  
Magic Number,nzy3D.Plot3D.Primitives,Parallelepiped,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Parallelepiped.cs,setData,The following statement contains a magic number: _quads [3].Add (new Point (new Coord3d (_bbox.xmin' _bbox.ymin' _bbox.zmin)));  
Magic Number,nzy3D.Plot3D.Primitives,Parallelepiped,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Parallelepiped.cs,setData,The following statement contains a magic number: _quads [3].Add (new Point (new Coord3d (_bbox.xmax' _bbox.ymin' _bbox.zmin)));  
Magic Number,nzy3D.Plot3D.Primitives,Parallelepiped,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Parallelepiped.cs,setData,The following statement contains a magic number: _quads [3].Add (new Point (new Coord3d (_bbox.xmax' _bbox.ymin' _bbox.zmax)));  
Magic Number,nzy3D.Plot3D.Primitives,Parallelepiped,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Parallelepiped.cs,setData,The following statement contains a magic number: _quads [4].Add (new Point (new Coord3d (_bbox.xmin' _bbox.ymin' _bbox.zmax)));  
Magic Number,nzy3D.Plot3D.Primitives,Parallelepiped,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Parallelepiped.cs,setData,The following statement contains a magic number: _quads [4].Add (new Point (new Coord3d (_bbox.xmax' _bbox.ymin' _bbox.zmax)));  
Magic Number,nzy3D.Plot3D.Primitives,Parallelepiped,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Parallelepiped.cs,setData,The following statement contains a magic number: _quads [4].Add (new Point (new Coord3d (_bbox.xmax' _bbox.ymax' _bbox.zmax)));  
Magic Number,nzy3D.Plot3D.Primitives,Parallelepiped,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Parallelepiped.cs,setData,The following statement contains a magic number: _quads [4].Add (new Point (new Coord3d (_bbox.xmin' _bbox.ymax' _bbox.zmax)));  
Magic Number,nzy3D.Plot3D.Primitives,Parallelepiped,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Parallelepiped.cs,setData,The following statement contains a magic number: _quads [5].Add (new Point (new Coord3d (_bbox.xmax' _bbox.ymin' _bbox.zmin)));  
Magic Number,nzy3D.Plot3D.Primitives,Parallelepiped,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Parallelepiped.cs,setData,The following statement contains a magic number: _quads [5].Add (new Point (new Coord3d (_bbox.xmin' _bbox.ymin' _bbox.zmin)));  
Magic Number,nzy3D.Plot3D.Primitives,Parallelepiped,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Parallelepiped.cs,setData,The following statement contains a magic number: _quads [5].Add (new Point (new Coord3d (_bbox.xmin' _bbox.ymax' _bbox.zmin)));  
Magic Number,nzy3D.Plot3D.Primitives,Parallelepiped,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Parallelepiped.cs,setData,The following statement contains a magic number: _quads [5].Add (new Point (new Coord3d (_bbox.xmax' _bbox.ymax' _bbox.zmin)));  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBase,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBase.cs,Draw,The following statement contains a magic number: GL.LineWidth (2);  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,Draw,The following statement contains a magic number: for (int quad = 0; quad <= 5; quad++) {  	if ((!_quadIsHidden [quad])) {  		drawGridOnQuad (quad);  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,Draw,The following statement contains a magic number: if ((_xrange > 0 & _layout.XTickLabelDisplayed)) {  	// If we are on top' we make direct axe placement  	if ((((_view != null) && _view.ViewMode == nzy3D.Plot3D.Rendering.View.Modes.ViewPositionMode.TOP))) {  		BoundingBox3d bbox = drawTicks (camera' 1' AxeDirection.AxeX' _layout.XTickColor' Halign.LEFT' Valign.TOP);  		// setup tick labels for X on the bottom  		_wholeBounds.Add (bbox);  	}  	else {  		// otherwise computed placement  		int xselect = findClosestXaxe (camera);  		if ((xselect >= 0)) {  			BoundingBox3d bbox = drawTicks (camera' xselect' AxeDirection.AxeX' _layout.XTickColor);  			_wholeBounds.Add (bbox);  		}  		else {  			//System.err.println("no x axe selected: " + Arrays.toString(quadIsHidden));  			// HACK: handles "on top" view' when all face of cube are drawn' which forbid to select an axe automatically  			BoundingBox3d bbox = drawTicks (camera' 2' AxeDirection.AxeX' _layout.XTickColor' Halign.CENTER' Valign.TOP);  			_wholeBounds.Add (bbox);  		}  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,Draw,The following statement contains a magic number: if ((((_view != null) && _view.ViewMode == nzy3D.Plot3D.Rendering.View.Modes.ViewPositionMode.TOP))) {  	BoundingBox3d bbox = drawTicks (camera' 1' AxeDirection.AxeX' _layout.XTickColor' Halign.LEFT' Valign.TOP);  	// setup tick labels for X on the bottom  	_wholeBounds.Add (bbox);  }  else {  	// otherwise computed placement  	int xselect = findClosestXaxe (camera);  	if ((xselect >= 0)) {  		BoundingBox3d bbox = drawTicks (camera' xselect' AxeDirection.AxeX' _layout.XTickColor);  		_wholeBounds.Add (bbox);  	}  	else {  		//System.err.println("no x axe selected: " + Arrays.toString(quadIsHidden));  		// HACK: handles "on top" view' when all face of cube are drawn' which forbid to select an axe automatically  		BoundingBox3d bbox = drawTicks (camera' 2' AxeDirection.AxeX' _layout.XTickColor' Halign.CENTER' Valign.TOP);  		_wholeBounds.Add (bbox);  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,Draw,The following statement contains a magic number: if ((xselect >= 0)) {  	BoundingBox3d bbox = drawTicks (camera' xselect' AxeDirection.AxeX' _layout.XTickColor);  	_wholeBounds.Add (bbox);  }  else {  	//System.err.println("no x axe selected: " + Arrays.toString(quadIsHidden));  	// HACK: handles "on top" view' when all face of cube are drawn' which forbid to select an axe automatically  	BoundingBox3d bbox = drawTicks (camera' 2' AxeDirection.AxeX' _layout.XTickColor' Halign.CENTER' Valign.TOP);  	_wholeBounds.Add (bbox);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,Draw,The following statement contains a magic number: if ((_yrange > 0 & _layout.YTickLabelDisplayed)) {  	if ((((_view != null)) && _view.ViewMode == nzy3D.Plot3D.Rendering.View.Modes.ViewPositionMode.TOP)) {  		BoundingBox3d bbox = drawTicks (camera' 2' AxeDirection.AxeY' _layout.YTickColor' Halign.LEFT' Valign.GROUND);  		// setup tick labels for Y on the left  		_wholeBounds.Add (bbox);  	}  	else {  		int yselect = findClosestYaxe (camera);  		if ((yselect >= 0)) {  			BoundingBox3d bbox = drawTicks (camera' yselect' AxeDirection.AxeY' _layout.YTickColor);  			_wholeBounds.Add (bbox);  		}  		else {  			//System.err.println("no y axe selected: " + Arrays.toString(quadIsHidden));  			// HACK: handles "on top" view' when all face of cube are drawn' which forbid to select an axe automatically  			BoundingBox3d bbox = drawTicks (camera' 1' AxeDirection.AxeY' _layout.YTickColor' Halign.RIGHT' Valign.GROUND);  			_wholeBounds.Add (bbox);  		}  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,Draw,The following statement contains a magic number: if ((((_view != null)) && _view.ViewMode == nzy3D.Plot3D.Rendering.View.Modes.ViewPositionMode.TOP)) {  	BoundingBox3d bbox = drawTicks (camera' 2' AxeDirection.AxeY' _layout.YTickColor' Halign.LEFT' Valign.GROUND);  	// setup tick labels for Y on the left  	_wholeBounds.Add (bbox);  }  else {  	int yselect = findClosestYaxe (camera);  	if ((yselect >= 0)) {  		BoundingBox3d bbox = drawTicks (camera' yselect' AxeDirection.AxeY' _layout.YTickColor);  		_wholeBounds.Add (bbox);  	}  	else {  		//System.err.println("no y axe selected: " + Arrays.toString(quadIsHidden));  		// HACK: handles "on top" view' when all face of cube are drawn' which forbid to select an axe automatically  		BoundingBox3d bbox = drawTicks (camera' 1' AxeDirection.AxeY' _layout.YTickColor' Halign.RIGHT' Valign.GROUND);  		_wholeBounds.Add (bbox);  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _center = new Coord3d ((xmax + xmin) / 2' (ymax + ymin) / 2' (zmax + zmin) / 2);  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _center = new Coord3d ((xmax + xmin) / 2' (ymax + ymin) / 2' (zmax + zmin) / 2);  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _center = new Coord3d ((xmax + xmin) / 2' (ymax + ymin) / 2' (zmax + zmin) / 2);  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx = new float[6' 4];  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx = new float[6' 4];  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady = new float[6' 4];  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady = new float[6' 4];  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz = new float[6' 4];  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz = new float[6' 4];  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [0' 2] = xmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [0' 2] = ymax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [0' 2] = zmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [0' 3] = xmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [0' 3] = ymax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [0' 3] = zmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [1' 2] = xmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [1' 2] = ymin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [1' 2] = zmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [1' 3] = xmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [1' 3] = ymin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [1' 3] = zmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [2' 0] = xmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [2' 0] = ymax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [2' 0] = zmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [2' 1] = xmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [2' 1] = ymax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [2' 1] = zmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [2' 2] = xmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [2' 2] = xmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [2' 2] = ymax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [2' 2] = ymax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [2' 2] = zmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [2' 2] = zmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [2' 3] = xmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [2' 3] = xmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [2' 3] = ymax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [2' 3] = ymax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [2' 3] = zmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [2' 3] = zmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [3' 0] = xmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [3' 0] = ymin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [3' 0] = zmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [3' 1] = xmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [3' 1] = ymin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [3' 1] = zmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [3' 2] = xmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [3' 2] = xmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [3' 2] = ymin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [3' 2] = ymin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [3' 2] = zmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [3' 2] = zmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [3' 3] = xmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [3' 3] = xmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [3' 3] = ymin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [3' 3] = ymin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [3' 3] = zmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [3' 3] = zmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [4' 0] = xmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [4' 0] = ymin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [4' 0] = zmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [4' 1] = xmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [4' 1] = ymin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [4' 1] = zmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [4' 2] = xmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [4' 2] = xmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [4' 2] = ymax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [4' 2] = ymax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [4' 2] = zmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [4' 2] = zmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [4' 3] = xmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [4' 3] = xmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [4' 3] = ymax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [4' 3] = ymax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [4' 3] = zmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [4' 3] = zmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [5' 0] = xmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [5' 0] = ymin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [5' 0] = zmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [5' 1] = xmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [5' 1] = ymin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [5' 1] = zmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [5' 2] = xmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [5' 2] = xmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [5' 2] = ymax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [5' 2] = ymax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [5' 2] = zmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [5' 2] = zmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [5' 3] = xmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadx [5' 3] = xmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [5' 3] = ymax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quady [5' 3] = ymax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [5' 3] = zmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _quadz [5' 3] = zmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _normx = new float[6];  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _normy = new float[6];  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _normz = new float[6];  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _normx [2] = 0;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _normy [2] = ymax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _normz [2] = 0;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _normx [3] = 0;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _normy [3] = ymin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _normz [3] = 0;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _normx [4] = 0;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _normy [4] = 0;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _normz [4] = zmax;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _normx [5] = 0;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _normy [5] = 0;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _normz [5] = zmin;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _axeXquads [i' 0] = 4;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _axeXquads [i' 1] = 3;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _axeXquads [i' 0] = 3;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _axeXquads [i' 1] = 5;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: i = 2;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _axeXquads [i' 0] = 5;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _axeXquads [i' 1] = 2;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: i = 3;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _axeXquads [i' 0] = 2;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _axeXquads [i' 1] = 4;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _axeYquads [i' 0] = 4;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _axeYquads [i' 1] = 5;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: i = 2;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _axeYquads [i' 0] = 5;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: i = 3;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _axeYquads [i' 1] = 4;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _axeZquads [i' 0] = 3;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _axeZquads [i' 1] = 2;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: i = 2;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _axeZquads [i' 0] = 2;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: i = 3;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: _axeZquads [i' 1] = 3;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: i = 2;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: i = 3;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: i = 2;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: i = 3;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: i = 2;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,setAxeBox,The following statement contains a magic number: i = 3;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawCube,The following statement contains a magic number: for (int q = 0; q <= 5; q++) {  	if (mode == OpenTK.Graphics.RenderingMode.Feedback) {  		GL.PassThrough (q);  	}  	GL.Begin (BeginMode.Quads);  	for (int v = 0; v <= 3; v++) {  		GL.Vertex3 (_quadx [q' v]' _quady [q' v]' _quadz [q' v]);  	}  	GL.End ();  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawCube,The following statement contains a magic number: for (int q = 0; q <= 5; q++) {  	if (mode == OpenTK.Graphics.RenderingMode.Feedback) {  		GL.PassThrough (q);  	}  	GL.Begin (BeginMode.Quads);  	for (int v = 0; v <= 3; v++) {  		GL.Vertex3 (_quadx [q' v]' _quady [q' v]' _quadz [q' v]);  	}  	GL.End ();  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawCube,The following statement contains a magic number: for (int v = 0; v <= 3; v++) {  	GL.Vertex3 (_quadx [q' v]' _quady [q' v]' _quadz [q' v]);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: if (((quad != 0) & (quad != 1))) {  	float[] xticks = _layout.XTicks ();  	for (int t = 0; t <= xticks.Length - 1; t++) {  		GL.Begin (BeginMode.Lines);  		GL.Vertex3 (xticks [t]' _quady [quad' 0]' _quadz [quad' 0]);  		GL.Vertex3 (xticks [t]' _quady [quad' 2]' _quadz [quad' 2]);  		GL.End ();  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: if (((quad != 0) & (quad != 1))) {  	float[] xticks = _layout.XTicks ();  	for (int t = 0; t <= xticks.Length - 1; t++) {  		GL.Begin (BeginMode.Lines);  		GL.Vertex3 (xticks [t]' _quady [quad' 0]' _quadz [quad' 0]);  		GL.Vertex3 (xticks [t]' _quady [quad' 2]' _quadz [quad' 2]);  		GL.End ();  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: for (int t = 0; t <= xticks.Length - 1; t++) {  	GL.Begin (BeginMode.Lines);  	GL.Vertex3 (xticks [t]' _quady [quad' 0]' _quadz [quad' 0]);  	GL.Vertex3 (xticks [t]' _quady [quad' 2]' _quadz [quad' 2]);  	GL.End ();  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: for (int t = 0; t <= xticks.Length - 1; t++) {  	GL.Begin (BeginMode.Lines);  	GL.Vertex3 (xticks [t]' _quady [quad' 0]' _quadz [quad' 0]);  	GL.Vertex3 (xticks [t]' _quady [quad' 2]' _quadz [quad' 2]);  	GL.End ();  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: GL.Vertex3 (xticks [t]' _quady [quad' 2]' _quadz [quad' 2]);  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: GL.Vertex3 (xticks [t]' _quady [quad' 2]' _quadz [quad' 2]);  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: if (((quad != 2) & (quad != 3))) {  	float[] yticks = _layout.YTicks ();  	for (int t = 0; t <= yticks.Length - 1; t++) {  		GL.Begin (BeginMode.Lines);  		GL.Vertex3 (_quadx [quad' 0]' yticks [t]' _quadz [quad' 0]);  		GL.Vertex3 (_quadx [quad' 2]' yticks [t]' _quadz [quad' 2]);  		GL.End ();  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: if (((quad != 2) & (quad != 3))) {  	float[] yticks = _layout.YTicks ();  	for (int t = 0; t <= yticks.Length - 1; t++) {  		GL.Begin (BeginMode.Lines);  		GL.Vertex3 (_quadx [quad' 0]' yticks [t]' _quadz [quad' 0]);  		GL.Vertex3 (_quadx [quad' 2]' yticks [t]' _quadz [quad' 2]);  		GL.End ();  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: if (((quad != 2) & (quad != 3))) {  	float[] yticks = _layout.YTicks ();  	for (int t = 0; t <= yticks.Length - 1; t++) {  		GL.Begin (BeginMode.Lines);  		GL.Vertex3 (_quadx [quad' 0]' yticks [t]' _quadz [quad' 0]);  		GL.Vertex3 (_quadx [quad' 2]' yticks [t]' _quadz [quad' 2]);  		GL.End ();  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: if (((quad != 2) & (quad != 3))) {  	float[] yticks = _layout.YTicks ();  	for (int t = 0; t <= yticks.Length - 1; t++) {  		GL.Begin (BeginMode.Lines);  		GL.Vertex3 (_quadx [quad' 0]' yticks [t]' _quadz [quad' 0]);  		GL.Vertex3 (_quadx [quad' 2]' yticks [t]' _quadz [quad' 2]);  		GL.End ();  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: for (int t = 0; t <= yticks.Length - 1; t++) {  	GL.Begin (BeginMode.Lines);  	GL.Vertex3 (_quadx [quad' 0]' yticks [t]' _quadz [quad' 0]);  	GL.Vertex3 (_quadx [quad' 2]' yticks [t]' _quadz [quad' 2]);  	GL.End ();  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: for (int t = 0; t <= yticks.Length - 1; t++) {  	GL.Begin (BeginMode.Lines);  	GL.Vertex3 (_quadx [quad' 0]' yticks [t]' _quadz [quad' 0]);  	GL.Vertex3 (_quadx [quad' 2]' yticks [t]' _quadz [quad' 2]);  	GL.End ();  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: GL.Vertex3 (_quadx [quad' 2]' yticks [t]' _quadz [quad' 2]);  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: GL.Vertex3 (_quadx [quad' 2]' yticks [t]' _quadz [quad' 2]);  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: if (((quad != 4) & (quad != 5))) {  	float[] zticks = _layout.ZTicks ();  	if ((zticks != null)) {  		for (int t = 0; t <= zticks.Length - 1; t++) {  			GL.Begin (BeginMode.Lines);  			GL.Vertex3 (_quadx [quad' 0]' _quady [quad' 0]' zticks [t]);  			GL.Vertex3 (_quadx [quad' 2]' _quady [quad' 2]' zticks [t]);  			GL.End ();  		}  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: if (((quad != 4) & (quad != 5))) {  	float[] zticks = _layout.ZTicks ();  	if ((zticks != null)) {  		for (int t = 0; t <= zticks.Length - 1; t++) {  			GL.Begin (BeginMode.Lines);  			GL.Vertex3 (_quadx [quad' 0]' _quady [quad' 0]' zticks [t]);  			GL.Vertex3 (_quadx [quad' 2]' _quady [quad' 2]' zticks [t]);  			GL.End ();  		}  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: if (((quad != 4) & (quad != 5))) {  	float[] zticks = _layout.ZTicks ();  	if ((zticks != null)) {  		for (int t = 0; t <= zticks.Length - 1; t++) {  			GL.Begin (BeginMode.Lines);  			GL.Vertex3 (_quadx [quad' 0]' _quady [quad' 0]' zticks [t]);  			GL.Vertex3 (_quadx [quad' 2]' _quady [quad' 2]' zticks [t]);  			GL.End ();  		}  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: if (((quad != 4) & (quad != 5))) {  	float[] zticks = _layout.ZTicks ();  	if ((zticks != null)) {  		for (int t = 0; t <= zticks.Length - 1; t++) {  			GL.Begin (BeginMode.Lines);  			GL.Vertex3 (_quadx [quad' 0]' _quady [quad' 0]' zticks [t]);  			GL.Vertex3 (_quadx [quad' 2]' _quady [quad' 2]' zticks [t]);  			GL.End ();  		}  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: if ((zticks != null)) {  	for (int t = 0; t <= zticks.Length - 1; t++) {  		GL.Begin (BeginMode.Lines);  		GL.Vertex3 (_quadx [quad' 0]' _quady [quad' 0]' zticks [t]);  		GL.Vertex3 (_quadx [quad' 2]' _quady [quad' 2]' zticks [t]);  		GL.End ();  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: if ((zticks != null)) {  	for (int t = 0; t <= zticks.Length - 1; t++) {  		GL.Begin (BeginMode.Lines);  		GL.Vertex3 (_quadx [quad' 0]' _quady [quad' 0]' zticks [t]);  		GL.Vertex3 (_quadx [quad' 2]' _quady [quad' 2]' zticks [t]);  		GL.End ();  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: for (int t = 0; t <= zticks.Length - 1; t++) {  	GL.Begin (BeginMode.Lines);  	GL.Vertex3 (_quadx [quad' 0]' _quady [quad' 0]' zticks [t]);  	GL.Vertex3 (_quadx [quad' 2]' _quady [quad' 2]' zticks [t]);  	GL.End ();  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: for (int t = 0; t <= zticks.Length - 1; t++) {  	GL.Begin (BeginMode.Lines);  	GL.Vertex3 (_quadx [quad' 0]' _quady [quad' 0]' zticks [t]);  	GL.Vertex3 (_quadx [quad' 2]' _quady [quad' 2]' zticks [t]);  	GL.End ();  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: GL.Vertex3 (_quadx [quad' 2]' _quady [quad' 2]' zticks [t]);  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,drawGridOnQuad,The following statement contains a magic number: GL.Vertex3 (_quadx [quad' 2]' _quady [quad' 2]' zticks [t]);  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,findClosestXaxe,The following statement contains a magic number: for (int a = 0; a <= na - 1; a++) {  	if ((distAxeX [a] < double.MaxValue)) {  		if ((Center.z > (_axeXz [a' 0] + _axeXz [a' 1]) / 2)) {  			distAxeX [a] *= -1;  		}  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,findClosestXaxe,The following statement contains a magic number: if ((distAxeX [a] < double.MaxValue)) {  	if ((Center.z > (_axeXz [a' 0] + _axeXz [a' 1]) / 2)) {  		distAxeX [a] *= -1;  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,findClosestXaxe,The following statement contains a magic number: if ((Center.z > (_axeXz [a' 0] + _axeXz [a' 1]) / 2)) {  	distAxeX [a] *= -1;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,findClosestYaxe,The following statement contains a magic number: for (int a = 0; a <= na - 1; a++) {  	if ((distAxeY [a] < double.MaxValue)) {  		if ((Center.z > (_axeYz [a' 0] + _axeYz [a' 1]) / 2)) {  			distAxeY [a] *= -1;  		}  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,findClosestYaxe,The following statement contains a magic number: if ((distAxeY [a] < double.MaxValue)) {  	if ((Center.z > (_axeYz [a' 0] + _axeYz [a' 1]) / 2)) {  		distAxeY [a] *= -1;  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,findClosestYaxe,The following statement contains a magic number: if ((Center.z > (_axeYz [a' 0] + _axeYz [a' 1]) / 2)) {  	distAxeY [a] *= -1;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,findClosestZaxe,The following statement contains a magic number: for (int a = 0; a <= na - 1; a++) {  	if ((distAxeZ [a] < double.MaxValue)) {  		Coord3d axeCEnter = new Coord3d ((_axeZx [a' 0] + _axeZx [a' 1]) / 2' (_axeZy [a' 0] + _axeZy [a' 1]) / 2' (_axeZz [a' 0] + _axeZz [a' 1]) / 2);  		if (!cam.side (axeCEnter)) {  			distAxeZ [a] *= -1;  		}  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,findClosestZaxe,The following statement contains a magic number: for (int a = 0; a <= na - 1; a++) {  	if ((distAxeZ [a] < double.MaxValue)) {  		Coord3d axeCEnter = new Coord3d ((_axeZx [a' 0] + _axeZx [a' 1]) / 2' (_axeZy [a' 0] + _axeZy [a' 1]) / 2' (_axeZz [a' 0] + _axeZz [a' 1]) / 2);  		if (!cam.side (axeCEnter)) {  			distAxeZ [a] *= -1;  		}  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,findClosestZaxe,The following statement contains a magic number: for (int a = 0; a <= na - 1; a++) {  	if ((distAxeZ [a] < double.MaxValue)) {  		Coord3d axeCEnter = new Coord3d ((_axeZx [a' 0] + _axeZx [a' 1]) / 2' (_axeZy [a' 0] + _axeZy [a' 1]) / 2' (_axeZz [a' 0] + _axeZz [a' 1]) / 2);  		if (!cam.side (axeCEnter)) {  			distAxeZ [a] *= -1;  		}  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,findClosestZaxe,The following statement contains a magic number: if ((distAxeZ [a] < double.MaxValue)) {  	Coord3d axeCEnter = new Coord3d ((_axeZx [a' 0] + _axeZx [a' 1]) / 2' (_axeZy [a' 0] + _axeZy [a' 1]) / 2' (_axeZz [a' 0] + _axeZz [a' 1]) / 2);  	if (!cam.side (axeCEnter)) {  		distAxeZ [a] *= -1;  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,findClosestZaxe,The following statement contains a magic number: if ((distAxeZ [a] < double.MaxValue)) {  	Coord3d axeCEnter = new Coord3d ((_axeZx [a' 0] + _axeZx [a' 1]) / 2' (_axeZy [a' 0] + _axeZy [a' 1]) / 2' (_axeZz [a' 0] + _axeZz [a' 1]) / 2);  	if (!cam.side (axeCEnter)) {  		distAxeZ [a] *= -1;  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,findClosestZaxe,The following statement contains a magic number: if ((distAxeZ [a] < double.MaxValue)) {  	Coord3d axeCEnter = new Coord3d ((_axeZx [a' 0] + _axeZx [a' 1]) / 2' (_axeZy [a' 0] + _axeZy [a' 1]) / 2' (_axeZz [a' 0] + _axeZz [a' 1]) / 2);  	if (!cam.side (axeCEnter)) {  		distAxeZ [a] *= -1;  	}  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,getHiddenQuads,The following statement contains a magic number: if (se.y <= _center.y) {  	status [2] = false;  	status [3] = true;  }  else {  	status [2] = true;  	status [3] = false;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,getHiddenQuads,The following statement contains a magic number: if (se.y <= _center.y) {  	status [2] = false;  	status [3] = true;  }  else {  	status [2] = true;  	status [3] = false;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,getHiddenQuads,The following statement contains a magic number: if (se.y <= _center.y) {  	status [2] = false;  	status [3] = true;  }  else {  	status [2] = true;  	status [3] = false;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,getHiddenQuads,The following statement contains a magic number: if (se.y <= _center.y) {  	status [2] = false;  	status [3] = true;  }  else {  	status [2] = true;  	status [3] = false;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,getHiddenQuads,The following statement contains a magic number: status [2] = false;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,getHiddenQuads,The following statement contains a magic number: status [3] = true;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,getHiddenQuads,The following statement contains a magic number: status [2] = true;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,getHiddenQuads,The following statement contains a magic number: status [3] = false;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,getHiddenQuads,The following statement contains a magic number: if (se.z <= _center.z) {  	status [4] = false;  	status [5] = true;  }  else {  	status [4] = true;  	status [5] = false;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,getHiddenQuads,The following statement contains a magic number: if (se.z <= _center.z) {  	status [4] = false;  	status [5] = true;  }  else {  	status [4] = true;  	status [5] = false;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,getHiddenQuads,The following statement contains a magic number: if (se.z <= _center.z) {  	status [4] = false;  	status [5] = true;  }  else {  	status [4] = true;  	status [5] = false;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,getHiddenQuads,The following statement contains a magic number: if (se.z <= _center.z) {  	status [4] = false;  	status [5] = true;  }  else {  	status [4] = true;  	status [5] = false;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,getHiddenQuads,The following statement contains a magic number: status [4] = false;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,getHiddenQuads,The following statement contains a magic number: status [5] = true;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,getHiddenQuads,The following statement contains a magic number: status [4] = true;  
Magic Number,nzy3D.Plot3D.Primitives.Axes,AxeBox,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\AxeBox.cs,getHiddenQuads,The following statement contains a magic number: status [5] = false;  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout,AxeBoxLayout,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\AxeBoxLayout.cs,AxeBoxLayout,The following statement contains a magic number: XTickProvider = new SmartTickProvider (5);  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout,AxeBoxLayout,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\AxeBoxLayout.cs,AxeBoxLayout,The following statement contains a magic number: YTickProvider = new SmartTickProvider (5);  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout,AxeBoxLayout,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\AxeBoxLayout.cs,AxeBoxLayout,The following statement contains a magic number: ZTickProvider = new SmartTickProvider (6);  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout,AxeBoxLayout,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\AxeBoxLayout.cs,AxeBoxLayout,The following statement contains a magic number: XTickRenderer = new DefaultDecimalTickRenderer (4);  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout,AxeBoxLayout,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\AxeBoxLayout.cs,AxeBoxLayout,The following statement contains a magic number: YTickRenderer = new DefaultDecimalTickRenderer (4);  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout,AxeBoxLayout,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\AxeBoxLayout.cs,AxeBoxLayout,The following statement contains a magic number: ZTickRenderer = new DefaultDecimalTickRenderer (6);  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,RegularTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\RegularTickProvider.cs,generateTicks,The following statement contains a magic number: for (int t = 1; t <= steps - 2; t++) {  	ticks [t] = min + t * lstep;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((min == max)) {  	float[] ticks = new float[1];  	ticks [0] = min;  	return ticks;  }  else if ((min > max)) {  	return null;  }  else {  	double absscale = Math.Floor (Math.Log10 (max - min));  	double relscale = Math.Log10 (max - min) - absscale;  	float ticksize = 0;  	if ((relscale < Math.Log10 (0.2 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  	}  	else if ((relscale < Math.Log10 (0.5 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  	}  	else if ((relscale < Math.Log10 (1 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  	}  	else {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  	}  	int starti = Convert.ToInt32 (Math.Ceiling (min / ticksize));  	int stopi = Convert.ToInt32 (Math.Floor (max / ticksize));  	float[] ticks = new float[stopi - starti + 1];  	for (int t = starti; t <= stopi; t++) {  		ticks [t - starti] = (t * ticksize);  	}  	return ticks;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((min == max)) {  	float[] ticks = new float[1];  	ticks [0] = min;  	return ticks;  }  else if ((min > max)) {  	return null;  }  else {  	double absscale = Math.Floor (Math.Log10 (max - min));  	double relscale = Math.Log10 (max - min) - absscale;  	float ticksize = 0;  	if ((relscale < Math.Log10 (0.2 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  	}  	else if ((relscale < Math.Log10 (0.5 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  	}  	else if ((relscale < Math.Log10 (1 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  	}  	else {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  	}  	int starti = Convert.ToInt32 (Math.Ceiling (min / ticksize));  	int stopi = Convert.ToInt32 (Math.Floor (max / ticksize));  	float[] ticks = new float[stopi - starti + 1];  	for (int t = starti; t <= stopi; t++) {  		ticks [t - starti] = (t * ticksize);  	}  	return ticks;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((min == max)) {  	float[] ticks = new float[1];  	ticks [0] = min;  	return ticks;  }  else if ((min > max)) {  	return null;  }  else {  	double absscale = Math.Floor (Math.Log10 (max - min));  	double relscale = Math.Log10 (max - min) - absscale;  	float ticksize = 0;  	if ((relscale < Math.Log10 (0.2 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  	}  	else if ((relscale < Math.Log10 (0.5 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  	}  	else if ((relscale < Math.Log10 (1 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  	}  	else {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  	}  	int starti = Convert.ToInt32 (Math.Ceiling (min / ticksize));  	int stopi = Convert.ToInt32 (Math.Floor (max / ticksize));  	float[] ticks = new float[stopi - starti + 1];  	for (int t = starti; t <= stopi; t++) {  		ticks [t - starti] = (t * ticksize);  	}  	return ticks;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((min == max)) {  	float[] ticks = new float[1];  	ticks [0] = min;  	return ticks;  }  else if ((min > max)) {  	return null;  }  else {  	double absscale = Math.Floor (Math.Log10 (max - min));  	double relscale = Math.Log10 (max - min) - absscale;  	float ticksize = 0;  	if ((relscale < Math.Log10 (0.2 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  	}  	else if ((relscale < Math.Log10 (0.5 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  	}  	else if ((relscale < Math.Log10 (1 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  	}  	else {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  	}  	int starti = Convert.ToInt32 (Math.Ceiling (min / ticksize));  	int stopi = Convert.ToInt32 (Math.Floor (max / ticksize));  	float[] ticks = new float[stopi - starti + 1];  	for (int t = starti; t <= stopi; t++) {  		ticks [t - starti] = (t * ticksize);  	}  	return ticks;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((min == max)) {  	float[] ticks = new float[1];  	ticks [0] = min;  	return ticks;  }  else if ((min > max)) {  	return null;  }  else {  	double absscale = Math.Floor (Math.Log10 (max - min));  	double relscale = Math.Log10 (max - min) - absscale;  	float ticksize = 0;  	if ((relscale < Math.Log10 (0.2 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  	}  	else if ((relscale < Math.Log10 (0.5 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  	}  	else if ((relscale < Math.Log10 (1 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  	}  	else {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  	}  	int starti = Convert.ToInt32 (Math.Ceiling (min / ticksize));  	int stopi = Convert.ToInt32 (Math.Floor (max / ticksize));  	float[] ticks = new float[stopi - starti + 1];  	for (int t = starti; t <= stopi; t++) {  		ticks [t - starti] = (t * ticksize);  	}  	return ticks;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((min == max)) {  	float[] ticks = new float[1];  	ticks [0] = min;  	return ticks;  }  else if ((min > max)) {  	return null;  }  else {  	double absscale = Math.Floor (Math.Log10 (max - min));  	double relscale = Math.Log10 (max - min) - absscale;  	float ticksize = 0;  	if ((relscale < Math.Log10 (0.2 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  	}  	else if ((relscale < Math.Log10 (0.5 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  	}  	else if ((relscale < Math.Log10 (1 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  	}  	else {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  	}  	int starti = Convert.ToInt32 (Math.Ceiling (min / ticksize));  	int stopi = Convert.ToInt32 (Math.Floor (max / ticksize));  	float[] ticks = new float[stopi - starti + 1];  	for (int t = starti; t <= stopi; t++) {  		ticks [t - starti] = (t * ticksize);  	}  	return ticks;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((min == max)) {  	float[] ticks = new float[1];  	ticks [0] = min;  	return ticks;  }  else if ((min > max)) {  	return null;  }  else {  	double absscale = Math.Floor (Math.Log10 (max - min));  	double relscale = Math.Log10 (max - min) - absscale;  	float ticksize = 0;  	if ((relscale < Math.Log10 (0.2 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  	}  	else if ((relscale < Math.Log10 (0.5 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  	}  	else if ((relscale < Math.Log10 (1 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  	}  	else {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  	}  	int starti = Convert.ToInt32 (Math.Ceiling (min / ticksize));  	int stopi = Convert.ToInt32 (Math.Floor (max / ticksize));  	float[] ticks = new float[stopi - starti + 1];  	for (int t = starti; t <= stopi; t++) {  		ticks [t - starti] = (t * ticksize);  	}  	return ticks;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((min == max)) {  	float[] ticks = new float[1];  	ticks [0] = min;  	return ticks;  }  else if ((min > max)) {  	return null;  }  else {  	double absscale = Math.Floor (Math.Log10 (max - min));  	double relscale = Math.Log10 (max - min) - absscale;  	float ticksize = 0;  	if ((relscale < Math.Log10 (0.2 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  	}  	else if ((relscale < Math.Log10 (0.5 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  	}  	else if ((relscale < Math.Log10 (1 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  	}  	else {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  	}  	int starti = Convert.ToInt32 (Math.Ceiling (min / ticksize));  	int stopi = Convert.ToInt32 (Math.Floor (max / ticksize));  	float[] ticks = new float[stopi - starti + 1];  	for (int t = starti; t <= stopi; t++) {  		ticks [t - starti] = (t * ticksize);  	}  	return ticks;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((min == max)) {  	float[] ticks = new float[1];  	ticks [0] = min;  	return ticks;  }  else if ((min > max)) {  	return null;  }  else {  	double absscale = Math.Floor (Math.Log10 (max - min));  	double relscale = Math.Log10 (max - min) - absscale;  	float ticksize = 0;  	if ((relscale < Math.Log10 (0.2 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  	}  	else if ((relscale < Math.Log10 (0.5 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  	}  	else if ((relscale < Math.Log10 (1 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  	}  	else {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  	}  	int starti = Convert.ToInt32 (Math.Ceiling (min / ticksize));  	int stopi = Convert.ToInt32 (Math.Floor (max / ticksize));  	float[] ticks = new float[stopi - starti + 1];  	for (int t = starti; t <= stopi; t++) {  		ticks [t - starti] = (t * ticksize);  	}  	return ticks;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((min > max)) {  	return null;  }  else {  	double absscale = Math.Floor (Math.Log10 (max - min));  	double relscale = Math.Log10 (max - min) - absscale;  	float ticksize = 0;  	if ((relscale < Math.Log10 (0.2 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  	}  	else if ((relscale < Math.Log10 (0.5 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  	}  	else if ((relscale < Math.Log10 (1 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  	}  	else {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  	}  	int starti = Convert.ToInt32 (Math.Ceiling (min / ticksize));  	int stopi = Convert.ToInt32 (Math.Floor (max / ticksize));  	float[] ticks = new float[stopi - starti + 1];  	for (int t = starti; t <= stopi; t++) {  		ticks [t - starti] = (t * ticksize);  	}  	return ticks;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((min > max)) {  	return null;  }  else {  	double absscale = Math.Floor (Math.Log10 (max - min));  	double relscale = Math.Log10 (max - min) - absscale;  	float ticksize = 0;  	if ((relscale < Math.Log10 (0.2 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  	}  	else if ((relscale < Math.Log10 (0.5 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  	}  	else if ((relscale < Math.Log10 (1 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  	}  	else {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  	}  	int starti = Convert.ToInt32 (Math.Ceiling (min / ticksize));  	int stopi = Convert.ToInt32 (Math.Floor (max / ticksize));  	float[] ticks = new float[stopi - starti + 1];  	for (int t = starti; t <= stopi; t++) {  		ticks [t - starti] = (t * ticksize);  	}  	return ticks;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((min > max)) {  	return null;  }  else {  	double absscale = Math.Floor (Math.Log10 (max - min));  	double relscale = Math.Log10 (max - min) - absscale;  	float ticksize = 0;  	if ((relscale < Math.Log10 (0.2 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  	}  	else if ((relscale < Math.Log10 (0.5 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  	}  	else if ((relscale < Math.Log10 (1 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  	}  	else {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  	}  	int starti = Convert.ToInt32 (Math.Ceiling (min / ticksize));  	int stopi = Convert.ToInt32 (Math.Floor (max / ticksize));  	float[] ticks = new float[stopi - starti + 1];  	for (int t = starti; t <= stopi; t++) {  		ticks [t - starti] = (t * ticksize);  	}  	return ticks;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((min > max)) {  	return null;  }  else {  	double absscale = Math.Floor (Math.Log10 (max - min));  	double relscale = Math.Log10 (max - min) - absscale;  	float ticksize = 0;  	if ((relscale < Math.Log10 (0.2 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  	}  	else if ((relscale < Math.Log10 (0.5 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  	}  	else if ((relscale < Math.Log10 (1 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  	}  	else {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  	}  	int starti = Convert.ToInt32 (Math.Ceiling (min / ticksize));  	int stopi = Convert.ToInt32 (Math.Floor (max / ticksize));  	float[] ticks = new float[stopi - starti + 1];  	for (int t = starti; t <= stopi; t++) {  		ticks [t - starti] = (t * ticksize);  	}  	return ticks;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((min > max)) {  	return null;  }  else {  	double absscale = Math.Floor (Math.Log10 (max - min));  	double relscale = Math.Log10 (max - min) - absscale;  	float ticksize = 0;  	if ((relscale < Math.Log10 (0.2 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  	}  	else if ((relscale < Math.Log10 (0.5 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  	}  	else if ((relscale < Math.Log10 (1 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  	}  	else {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  	}  	int starti = Convert.ToInt32 (Math.Ceiling (min / ticksize));  	int stopi = Convert.ToInt32 (Math.Floor (max / ticksize));  	float[] ticks = new float[stopi - starti + 1];  	for (int t = starti; t <= stopi; t++) {  		ticks [t - starti] = (t * ticksize);  	}  	return ticks;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((min > max)) {  	return null;  }  else {  	double absscale = Math.Floor (Math.Log10 (max - min));  	double relscale = Math.Log10 (max - min) - absscale;  	float ticksize = 0;  	if ((relscale < Math.Log10 (0.2 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  	}  	else if ((relscale < Math.Log10 (0.5 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  	}  	else if ((relscale < Math.Log10 (1 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  	}  	else {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  	}  	int starti = Convert.ToInt32 (Math.Ceiling (min / ticksize));  	int stopi = Convert.ToInt32 (Math.Floor (max / ticksize));  	float[] ticks = new float[stopi - starti + 1];  	for (int t = starti; t <= stopi; t++) {  		ticks [t - starti] = (t * ticksize);  	}  	return ticks;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((min > max)) {  	return null;  }  else {  	double absscale = Math.Floor (Math.Log10 (max - min));  	double relscale = Math.Log10 (max - min) - absscale;  	float ticksize = 0;  	if ((relscale < Math.Log10 (0.2 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  	}  	else if ((relscale < Math.Log10 (0.5 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  	}  	else if ((relscale < Math.Log10 (1 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  	}  	else {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  	}  	int starti = Convert.ToInt32 (Math.Ceiling (min / ticksize));  	int stopi = Convert.ToInt32 (Math.Floor (max / ticksize));  	float[] ticks = new float[stopi - starti + 1];  	for (int t = starti; t <= stopi; t++) {  		ticks [t - starti] = (t * ticksize);  	}  	return ticks;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((min > max)) {  	return null;  }  else {  	double absscale = Math.Floor (Math.Log10 (max - min));  	double relscale = Math.Log10 (max - min) - absscale;  	float ticksize = 0;  	if ((relscale < Math.Log10 (0.2 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  	}  	else if ((relscale < Math.Log10 (0.5 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  	}  	else if ((relscale < Math.Log10 (1 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  	}  	else {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  	}  	int starti = Convert.ToInt32 (Math.Ceiling (min / ticksize));  	int stopi = Convert.ToInt32 (Math.Floor (max / ticksize));  	float[] ticks = new float[stopi - starti + 1];  	for (int t = starti; t <= stopi; t++) {  		ticks [t - starti] = (t * ticksize);  	}  	return ticks;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((min > max)) {  	return null;  }  else {  	double absscale = Math.Floor (Math.Log10 (max - min));  	double relscale = Math.Log10 (max - min) - absscale;  	float ticksize = 0;  	if ((relscale < Math.Log10 (0.2 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  	}  	else if ((relscale < Math.Log10 (0.5 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  	}  	else if ((relscale < Math.Log10 (1 * steps))) {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  	}  	else {  		ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  	}  	int starti = Convert.ToInt32 (Math.Ceiling (min / ticksize));  	int stopi = Convert.ToInt32 (Math.Floor (max / ticksize));  	float[] ticks = new float[stopi - starti + 1];  	for (int t = starti; t <= stopi; t++) {  		ticks [t - starti] = (t * ticksize);  	}  	return ticks;  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((relscale < Math.Log10 (0.2 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  }  else if ((relscale < Math.Log10 (0.5 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  }  else if ((relscale < Math.Log10 (1 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  }  else {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((relscale < Math.Log10 (0.2 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  }  else if ((relscale < Math.Log10 (0.5 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  }  else if ((relscale < Math.Log10 (1 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  }  else {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((relscale < Math.Log10 (0.2 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  }  else if ((relscale < Math.Log10 (0.5 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  }  else if ((relscale < Math.Log10 (1 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  }  else {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((relscale < Math.Log10 (0.2 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  }  else if ((relscale < Math.Log10 (0.5 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  }  else if ((relscale < Math.Log10 (1 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  }  else {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((relscale < Math.Log10 (0.2 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  }  else if ((relscale < Math.Log10 (0.5 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  }  else if ((relscale < Math.Log10 (1 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  }  else {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((relscale < Math.Log10 (0.2 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  }  else if ((relscale < Math.Log10 (0.5 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  }  else if ((relscale < Math.Log10 (1 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  }  else {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((relscale < Math.Log10 (0.2 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  }  else if ((relscale < Math.Log10 (0.5 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  }  else if ((relscale < Math.Log10 (1 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  }  else {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((relscale < Math.Log10 (0.2 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  }  else if ((relscale < Math.Log10 (0.5 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  }  else if ((relscale < Math.Log10 (1 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  }  else {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((relscale < Math.Log10 (0.2 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  }  else if ((relscale < Math.Log10 (0.5 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  }  else if ((relscale < Math.Log10 (1 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  }  else {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.2);  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((relscale < Math.Log10 (0.5 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  }  else if ((relscale < Math.Log10 (1 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  }  else {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((relscale < Math.Log10 (0.5 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  }  else if ((relscale < Math.Log10 (1 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  }  else {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((relscale < Math.Log10 (0.5 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  }  else if ((relscale < Math.Log10 (1 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  }  else {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((relscale < Math.Log10 (0.5 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  }  else if ((relscale < Math.Log10 (1 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  }  else {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((relscale < Math.Log10 (0.5 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  }  else if ((relscale < Math.Log10 (1 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  }  else {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((relscale < Math.Log10 (0.5 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  }  else if ((relscale < Math.Log10 (1 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  }  else {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 0.5);  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((relscale < Math.Log10 (1 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  }  else {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((relscale < Math.Log10 (1 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  }  else {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: if ((relscale < Math.Log10 (1 * steps))) {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  }  else {  	ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  }  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 1);  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  
Magic Number,nzy3D.Plot3D.Primitives.Axes.Layout.Providers,SmartTickProvider,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Primitives\Axes\Layout\Providers\SmartTickProvider.cs,generateTicks,The following statement contains a magic number: ticksize = Convert.ToSingle (Math.Pow (10' absscale) * 2);  
Magic Number,nzy3D.Plot3D.Rendering.Legends.Colorbars,ColorbarLegend,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Legends\Colorbars\ColorbarLegend.cs,toImage,The following statement contains a magic number: if (mc != null) {  	if (((mc.ColorMapper != null))) {  		// setup generator  		ColorbarImageGenerator bar = new ColorbarImageGenerator (mc.ColorMapper' _provider' _renderer);  		if (((_foreground != null))) {  			bar.ForegroundColor = _foreground;  		}  		else {  			bar.ForegroundColor = Color.BLACK;  		}  		if (((_background != null))) {  			bar.BackgroundColor = _background;  			bar.HasBackground = true;  		}  		else {  			bar.HasBackground = false;  		}  		// render @ given dimensions  		return bar.toImage (Math.Max (width - 25' 1)' Math.Max (height - 25' 1));  	}  }  
Magic Number,nzy3D.Plot3D.Rendering.Legends.Colorbars,ColorbarLegend,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Legends\Colorbars\ColorbarLegend.cs,toImage,The following statement contains a magic number: if (mc != null) {  	if (((mc.ColorMapper != null))) {  		// setup generator  		ColorbarImageGenerator bar = new ColorbarImageGenerator (mc.ColorMapper' _provider' _renderer);  		if (((_foreground != null))) {  			bar.ForegroundColor = _foreground;  		}  		else {  			bar.ForegroundColor = Color.BLACK;  		}  		if (((_background != null))) {  			bar.BackgroundColor = _background;  			bar.HasBackground = true;  		}  		else {  			bar.HasBackground = false;  		}  		// render @ given dimensions  		return bar.toImage (Math.Max (width - 25' 1)' Math.Max (height - 25' 1));  	}  }  
Magic Number,nzy3D.Plot3D.Rendering.Legends.Colorbars,ColorbarLegend,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Legends\Colorbars\ColorbarLegend.cs,toImage,The following statement contains a magic number: if (((mc.ColorMapper != null))) {  	// setup generator  	ColorbarImageGenerator bar = new ColorbarImageGenerator (mc.ColorMapper' _provider' _renderer);  	if (((_foreground != null))) {  		bar.ForegroundColor = _foreground;  	}  	else {  		bar.ForegroundColor = Color.BLACK;  	}  	if (((_background != null))) {  		bar.BackgroundColor = _background;  		bar.HasBackground = true;  	}  	else {  		bar.HasBackground = false;  	}  	// render @ given dimensions  	return bar.toImage (Math.Max (width - 25' 1)' Math.Max (height - 25' 1));  }  
Magic Number,nzy3D.Plot3D.Rendering.Legends.Colorbars,ColorbarLegend,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Legends\Colorbars\ColorbarLegend.cs,toImage,The following statement contains a magic number: if (((mc.ColorMapper != null))) {  	// setup generator  	ColorbarImageGenerator bar = new ColorbarImageGenerator (mc.ColorMapper' _provider' _renderer);  	if (((_foreground != null))) {  		bar.ForegroundColor = _foreground;  	}  	else {  		bar.ForegroundColor = Color.BLACK;  	}  	if (((_background != null))) {  		bar.BackgroundColor = _background;  		bar.HasBackground = true;  	}  	else {  		bar.HasBackground = false;  	}  	// render @ given dimensions  	return bar.toImage (Math.Max (width - 25' 1)' Math.Max (height - 25' 1));  }  
Magic Number,nzy3D.Plot3D.Rendering.Legends.Colorbars,ColorbarLegend,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Legends\Colorbars\ColorbarLegend.cs,toImage,The following statement contains a magic number: return bar.toImage (Math.Max (width - 25' 1)' Math.Max (height - 25' 1));  
Magic Number,nzy3D.Plot3D.Rendering.Legends.Colorbars,ColorbarLegend,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Legends\Colorbars\ColorbarLegend.cs,toImage,The following statement contains a magic number: return bar.toImage (Math.Max (width - 25' 1)' Math.Max (height - 25' 1));  
Magic Number,nzy3D.Plot3D.Rendering.Lights,Light,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Lights\Light.cs,Apply,The following statement contains a magic number: if (_enabled) {  	GL.MatrixMode (MatrixMode.Modelview);  	GL.LoadIdentity ();  	GL.Translate (_position.x * scale.x' _position.y * scale.y' _position.z * scale.z);  	// Light position representation (cube)  	if ((_representationDisplayed)) {  		GL.Disable (EnableCap.Lighting);  		GL.Color3 (0.0' 1.0' 1.0);  		GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  		Glut.Glut.SolidCube (10);  		GL.Enable (EnableCap.Lighting);  	}  	// Actual light source setting	TODO: check we really need to define @ each rendering	  	LightSwitch.Enable (_lightId);  	GL.Light (LightName.Light0' LightParameter.Position' _positionZero);  	GL.Light (LightName.Light0' LightParameter.Ambient' _ambiantColor.OpenTKColor4);  	GL.Light (LightName.Light0' LightParameter.Diffuse' _diffuseColor.OpenTKColor4);  	GL.Light (LightName.Light0' LightParameter.Specular' _specularColor.OpenTKColor4);  }  else {  	GL.Disable (EnableCap.Lighting);  }  
Magic Number,nzy3D.Plot3D.Rendering.Lights,Light,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Lights\Light.cs,Apply,The following statement contains a magic number: if ((_representationDisplayed)) {  	GL.Disable (EnableCap.Lighting);  	GL.Color3 (0.0' 1.0' 1.0);  	GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  	Glut.Glut.SolidCube (10);  	GL.Enable (EnableCap.Lighting);  }  
Magic Number,nzy3D.Plot3D.Rendering.Lights,Light,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Lights\Light.cs,Apply,The following statement contains a magic number: Glut.Glut.SolidCube (10);  
Magic Number,nzy3D.Plot3D.Rendering.Lights,LightSwitch,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Lights\LightSwitch.cs,Enable,The following statement contains a magic number: switch (lightId) {  case 0:  	GL.Enable (EnableCap.Light0);  	break;  case 1:  	GL.Enable (EnableCap.Light1);  	break;  case 2:  	GL.Enable (EnableCap.Light2);  	break;  case 3:  	GL.Enable (EnableCap.Light3);  	break;  case 4:  	GL.Enable (EnableCap.Light4);  	break;  case 5:  	GL.Enable (EnableCap.Light5);  	break;  case 6:  	GL.Enable (EnableCap.Light6);  	break;  case 7:  	GL.Enable (EnableCap.Light7);  	break;  default:  	throw new ArgumentException ("Light id must belong to [0;7]"' "lightId");  }  
Magic Number,nzy3D.Plot3D.Rendering.Lights,LightSwitch,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Lights\LightSwitch.cs,Enable,The following statement contains a magic number: switch (lightId) {  case 0:  	GL.Enable (EnableCap.Light0);  	break;  case 1:  	GL.Enable (EnableCap.Light1);  	break;  case 2:  	GL.Enable (EnableCap.Light2);  	break;  case 3:  	GL.Enable (EnableCap.Light3);  	break;  case 4:  	GL.Enable (EnableCap.Light4);  	break;  case 5:  	GL.Enable (EnableCap.Light5);  	break;  case 6:  	GL.Enable (EnableCap.Light6);  	break;  case 7:  	GL.Enable (EnableCap.Light7);  	break;  default:  	throw new ArgumentException ("Light id must belong to [0;7]"' "lightId");  }  
Magic Number,nzy3D.Plot3D.Rendering.Lights,LightSwitch,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Lights\LightSwitch.cs,Enable,The following statement contains a magic number: switch (lightId) {  case 0:  	GL.Enable (EnableCap.Light0);  	break;  case 1:  	GL.Enable (EnableCap.Light1);  	break;  case 2:  	GL.Enable (EnableCap.Light2);  	break;  case 3:  	GL.Enable (EnableCap.Light3);  	break;  case 4:  	GL.Enable (EnableCap.Light4);  	break;  case 5:  	GL.Enable (EnableCap.Light5);  	break;  case 6:  	GL.Enable (EnableCap.Light6);  	break;  case 7:  	GL.Enable (EnableCap.Light7);  	break;  default:  	throw new ArgumentException ("Light id must belong to [0;7]"' "lightId");  }  
Magic Number,nzy3D.Plot3D.Rendering.Lights,LightSwitch,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Lights\LightSwitch.cs,Enable,The following statement contains a magic number: switch (lightId) {  case 0:  	GL.Enable (EnableCap.Light0);  	break;  case 1:  	GL.Enable (EnableCap.Light1);  	break;  case 2:  	GL.Enable (EnableCap.Light2);  	break;  case 3:  	GL.Enable (EnableCap.Light3);  	break;  case 4:  	GL.Enable (EnableCap.Light4);  	break;  case 5:  	GL.Enable (EnableCap.Light5);  	break;  case 6:  	GL.Enable (EnableCap.Light6);  	break;  case 7:  	GL.Enable (EnableCap.Light7);  	break;  default:  	throw new ArgumentException ("Light id must belong to [0;7]"' "lightId");  }  
Magic Number,nzy3D.Plot3D.Rendering.Lights,LightSwitch,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Lights\LightSwitch.cs,Enable,The following statement contains a magic number: switch (lightId) {  case 0:  	GL.Enable (EnableCap.Light0);  	break;  case 1:  	GL.Enable (EnableCap.Light1);  	break;  case 2:  	GL.Enable (EnableCap.Light2);  	break;  case 3:  	GL.Enable (EnableCap.Light3);  	break;  case 4:  	GL.Enable (EnableCap.Light4);  	break;  case 5:  	GL.Enable (EnableCap.Light5);  	break;  case 6:  	GL.Enable (EnableCap.Light6);  	break;  case 7:  	GL.Enable (EnableCap.Light7);  	break;  default:  	throw new ArgumentException ("Light id must belong to [0;7]"' "lightId");  }  
Magic Number,nzy3D.Plot3D.Rendering.Lights,LightSwitch,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Lights\LightSwitch.cs,Enable,The following statement contains a magic number: switch (lightId) {  case 0:  	GL.Enable (EnableCap.Light0);  	break;  case 1:  	GL.Enable (EnableCap.Light1);  	break;  case 2:  	GL.Enable (EnableCap.Light2);  	break;  case 3:  	GL.Enable (EnableCap.Light3);  	break;  case 4:  	GL.Enable (EnableCap.Light4);  	break;  case 5:  	GL.Enable (EnableCap.Light5);  	break;  case 6:  	GL.Enable (EnableCap.Light6);  	break;  case 7:  	GL.Enable (EnableCap.Light7);  	break;  default:  	throw new ArgumentException ("Light id must belong to [0;7]"' "lightId");  }  
Magic Number,nzy3D.Plot3D.Rendering.Lights,LightSwitch,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Lights\LightSwitch.cs,Disable,The following statement contains a magic number: switch (lightId) {  case 0:  	GL.Disable (EnableCap.Light0);  	break;  case 1:  	GL.Disable (EnableCap.Light1);  	break;  case 2:  	GL.Disable (EnableCap.Light2);  	break;  case 3:  	GL.Disable (EnableCap.Light3);  	break;  case 4:  	GL.Disable (EnableCap.Light4);  	break;  case 5:  	GL.Disable (EnableCap.Light5);  	break;  case 6:  	GL.Disable (EnableCap.Light6);  	break;  case 7:  	GL.Disable (EnableCap.Light7);  	break;  default:  	throw new ArgumentException ("Light id must belong to [0;7]"' "lightId");  }  
Magic Number,nzy3D.Plot3D.Rendering.Lights,LightSwitch,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Lights\LightSwitch.cs,Disable,The following statement contains a magic number: switch (lightId) {  case 0:  	GL.Disable (EnableCap.Light0);  	break;  case 1:  	GL.Disable (EnableCap.Light1);  	break;  case 2:  	GL.Disable (EnableCap.Light2);  	break;  case 3:  	GL.Disable (EnableCap.Light3);  	break;  case 4:  	GL.Disable (EnableCap.Light4);  	break;  case 5:  	GL.Disable (EnableCap.Light5);  	break;  case 6:  	GL.Disable (EnableCap.Light6);  	break;  case 7:  	GL.Disable (EnableCap.Light7);  	break;  default:  	throw new ArgumentException ("Light id must belong to [0;7]"' "lightId");  }  
Magic Number,nzy3D.Plot3D.Rendering.Lights,LightSwitch,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Lights\LightSwitch.cs,Disable,The following statement contains a magic number: switch (lightId) {  case 0:  	GL.Disable (EnableCap.Light0);  	break;  case 1:  	GL.Disable (EnableCap.Light1);  	break;  case 2:  	GL.Disable (EnableCap.Light2);  	break;  case 3:  	GL.Disable (EnableCap.Light3);  	break;  case 4:  	GL.Disable (EnableCap.Light4);  	break;  case 5:  	GL.Disable (EnableCap.Light5);  	break;  case 6:  	GL.Disable (EnableCap.Light6);  	break;  case 7:  	GL.Disable (EnableCap.Light7);  	break;  default:  	throw new ArgumentException ("Light id must belong to [0;7]"' "lightId");  }  
Magic Number,nzy3D.Plot3D.Rendering.Lights,LightSwitch,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Lights\LightSwitch.cs,Disable,The following statement contains a magic number: switch (lightId) {  case 0:  	GL.Disable (EnableCap.Light0);  	break;  case 1:  	GL.Disable (EnableCap.Light1);  	break;  case 2:  	GL.Disable (EnableCap.Light2);  	break;  case 3:  	GL.Disable (EnableCap.Light3);  	break;  case 4:  	GL.Disable (EnableCap.Light4);  	break;  case 5:  	GL.Disable (EnableCap.Light5);  	break;  case 6:  	GL.Disable (EnableCap.Light6);  	break;  case 7:  	GL.Disable (EnableCap.Light7);  	break;  default:  	throw new ArgumentException ("Light id must belong to [0;7]"' "lightId");  }  
Magic Number,nzy3D.Plot3D.Rendering.Lights,LightSwitch,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Lights\LightSwitch.cs,Disable,The following statement contains a magic number: switch (lightId) {  case 0:  	GL.Disable (EnableCap.Light0);  	break;  case 1:  	GL.Disable (EnableCap.Light1);  	break;  case 2:  	GL.Disable (EnableCap.Light2);  	break;  case 3:  	GL.Disable (EnableCap.Light3);  	break;  case 4:  	GL.Disable (EnableCap.Light4);  	break;  case 5:  	GL.Disable (EnableCap.Light5);  	break;  case 6:  	GL.Disable (EnableCap.Light6);  	break;  case 7:  	GL.Disable (EnableCap.Light7);  	break;  default:  	throw new ArgumentException ("Light id must belong to [0;7]"' "lightId");  }  
Magic Number,nzy3D.Plot3D.Rendering.Lights,LightSwitch,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\Lights\LightSwitch.cs,Disable,The following statement contains a magic number: switch (lightId) {  case 0:  	GL.Disable (EnableCap.Light0);  	break;  case 1:  	GL.Disable (EnableCap.Light1);  	break;  case 2:  	GL.Disable (EnableCap.Light2);  	break;  case 3:  	GL.Disable (EnableCap.Light3);  	break;  case 4:  	GL.Disable (EnableCap.Light4);  	break;  case 5:  	GL.Disable (EnableCap.Light5);  	break;  case 6:  	GL.Disable (EnableCap.Light6);  	break;  case 7:  	GL.Disable (EnableCap.Light7);  	break;  default:  	throw new ArgumentException ("Light id must belong to [0;7]"' "lightId");  }  
Magic Number,nzy3D.Plot3D.Rendering.View,AbstractViewport,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\AbstractViewport.cs,ApplyViewPort,The following statement contains a magic number: if (_stretchToFill) {  	_screenXOffset = _screenLeft;  	_screenYOffset = 0;  	GL.Viewport (_screenXOffset' _screenYOffset' _screenWidth' _screenHeight);  	_lastViewPort = new ViewPort (_screenWidth' _screenHeight' _screenXOffset' _screenYOffset);  	//Set the projection into the largest square area centered in the window slice  }  else {  	_screenSquaredDim = Math.Min (_screenWidth' _screenHeight);  	_screenXOffset = _screenLeft + _screenWidth / 2 - _screenSquaredDim / 2;  	_screenYOffset = _screenHeight / 2 - _screenSquaredDim / 2;  	GL.Viewport (_screenXOffset' _screenYOffset' _screenSquaredDim' _screenSquaredDim);  	_lastViewPort = new ViewPort (_screenSquaredDim' _screenSquaredDim' _screenXOffset' _screenYOffset);  }  
Magic Number,nzy3D.Plot3D.Rendering.View,AbstractViewport,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\AbstractViewport.cs,ApplyViewPort,The following statement contains a magic number: if (_stretchToFill) {  	_screenXOffset = _screenLeft;  	_screenYOffset = 0;  	GL.Viewport (_screenXOffset' _screenYOffset' _screenWidth' _screenHeight);  	_lastViewPort = new ViewPort (_screenWidth' _screenHeight' _screenXOffset' _screenYOffset);  	//Set the projection into the largest square area centered in the window slice  }  else {  	_screenSquaredDim = Math.Min (_screenWidth' _screenHeight);  	_screenXOffset = _screenLeft + _screenWidth / 2 - _screenSquaredDim / 2;  	_screenYOffset = _screenHeight / 2 - _screenSquaredDim / 2;  	GL.Viewport (_screenXOffset' _screenYOffset' _screenSquaredDim' _screenSquaredDim);  	_lastViewPort = new ViewPort (_screenSquaredDim' _screenSquaredDim' _screenXOffset' _screenYOffset);  }  
Magic Number,nzy3D.Plot3D.Rendering.View,AbstractViewport,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\AbstractViewport.cs,ApplyViewPort,The following statement contains a magic number: if (_stretchToFill) {  	_screenXOffset = _screenLeft;  	_screenYOffset = 0;  	GL.Viewport (_screenXOffset' _screenYOffset' _screenWidth' _screenHeight);  	_lastViewPort = new ViewPort (_screenWidth' _screenHeight' _screenXOffset' _screenYOffset);  	//Set the projection into the largest square area centered in the window slice  }  else {  	_screenSquaredDim = Math.Min (_screenWidth' _screenHeight);  	_screenXOffset = _screenLeft + _screenWidth / 2 - _screenSquaredDim / 2;  	_screenYOffset = _screenHeight / 2 - _screenSquaredDim / 2;  	GL.Viewport (_screenXOffset' _screenYOffset' _screenSquaredDim' _screenSquaredDim);  	_lastViewPort = new ViewPort (_screenSquaredDim' _screenSquaredDim' _screenXOffset' _screenYOffset);  }  
Magic Number,nzy3D.Plot3D.Rendering.View,AbstractViewport,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\AbstractViewport.cs,ApplyViewPort,The following statement contains a magic number: if (_stretchToFill) {  	_screenXOffset = _screenLeft;  	_screenYOffset = 0;  	GL.Viewport (_screenXOffset' _screenYOffset' _screenWidth' _screenHeight);  	_lastViewPort = new ViewPort (_screenWidth' _screenHeight' _screenXOffset' _screenYOffset);  	//Set the projection into the largest square area centered in the window slice  }  else {  	_screenSquaredDim = Math.Min (_screenWidth' _screenHeight);  	_screenXOffset = _screenLeft + _screenWidth / 2 - _screenSquaredDim / 2;  	_screenYOffset = _screenHeight / 2 - _screenSquaredDim / 2;  	GL.Viewport (_screenXOffset' _screenYOffset' _screenSquaredDim' _screenSquaredDim);  	_lastViewPort = new ViewPort (_screenSquaredDim' _screenSquaredDim' _screenXOffset' _screenYOffset);  }  
Magic Number,nzy3D.Plot3D.Rendering.View,AbstractViewport,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\AbstractViewport.cs,ApplyViewPort,The following statement contains a magic number: _screenXOffset = _screenLeft + _screenWidth / 2 - _screenSquaredDim / 2;  
Magic Number,nzy3D.Plot3D.Rendering.View,AbstractViewport,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\AbstractViewport.cs,ApplyViewPort,The following statement contains a magic number: _screenXOffset = _screenLeft + _screenWidth / 2 - _screenSquaredDim / 2;  
Magic Number,nzy3D.Plot3D.Rendering.View,AbstractViewport,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\AbstractViewport.cs,ApplyViewPort,The following statement contains a magic number: _screenYOffset = _screenHeight / 2 - _screenSquaredDim / 2;  
Magic Number,nzy3D.Plot3D.Rendering.View,AbstractViewport,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\AbstractViewport.cs,ApplyViewPort,The following statement contains a magic number: _screenYOffset = _screenHeight / 2 - _screenSquaredDim / 2;  
Magic Number,nzy3D.Plot3D.Rendering.View,AbstractViewport,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\AbstractViewport.cs,renderSubScreenGrid,The following statement contains a magic number: if (_stretchToFill) {  	GL.Viewport (_screenLeft' 0' _screenWidth' _screenHeight);  	//Set the projection into the largest square area centered in the window slice  }  else {  	int dimension = Math.Min (_screenWidth' _screenHeight);  	int screenXoffset = _screenLeft + _screenWidth / 2 - dimension / 2;  	int screenYoffset = _screenHeight / 2 - dimension / 2;  	GL.Viewport (screenXoffset' screenYoffset' dimension' dimension);  }  
Magic Number,nzy3D.Plot3D.Rendering.View,AbstractViewport,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\AbstractViewport.cs,renderSubScreenGrid,The following statement contains a magic number: if (_stretchToFill) {  	GL.Viewport (_screenLeft' 0' _screenWidth' _screenHeight);  	//Set the projection into the largest square area centered in the window slice  }  else {  	int dimension = Math.Min (_screenWidth' _screenHeight);  	int screenXoffset = _screenLeft + _screenWidth / 2 - dimension / 2;  	int screenYoffset = _screenHeight / 2 - dimension / 2;  	GL.Viewport (screenXoffset' screenYoffset' dimension' dimension);  }  
Magic Number,nzy3D.Plot3D.Rendering.View,AbstractViewport,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\AbstractViewport.cs,renderSubScreenGrid,The following statement contains a magic number: if (_stretchToFill) {  	GL.Viewport (_screenLeft' 0' _screenWidth' _screenHeight);  	//Set the projection into the largest square area centered in the window slice  }  else {  	int dimension = Math.Min (_screenWidth' _screenHeight);  	int screenXoffset = _screenLeft + _screenWidth / 2 - dimension / 2;  	int screenYoffset = _screenHeight / 2 - dimension / 2;  	GL.Viewport (screenXoffset' screenYoffset' dimension' dimension);  }  
Magic Number,nzy3D.Plot3D.Rendering.View,AbstractViewport,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\AbstractViewport.cs,renderSubScreenGrid,The following statement contains a magic number: if (_stretchToFill) {  	GL.Viewport (_screenLeft' 0' _screenWidth' _screenHeight);  	//Set the projection into the largest square area centered in the window slice  }  else {  	int dimension = Math.Min (_screenWidth' _screenHeight);  	int screenXoffset = _screenLeft + _screenWidth / 2 - dimension / 2;  	int screenYoffset = _screenHeight / 2 - dimension / 2;  	GL.Viewport (screenXoffset' screenYoffset' dimension' dimension);  }  
Magic Number,nzy3D.Plot3D.Rendering.View,AbstractViewport,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\AbstractViewport.cs,renderSubScreenGrid,The following statement contains a magic number: GL.Color3 (1' 0.5' 0.5);  
Magic Number,nzy3D.Plot3D.Rendering.View,AbstractViewport,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\AbstractViewport.cs,renderSubScreenGrid,The following statement contains a magic number: GL.Color3 (1' 0.5' 0.5);  
Magic Number,nzy3D.Plot3D.Rendering.View,Camera,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\Camera.cs,doShoot,The following statement contains a magic number: if (projection == CameraMode.PERSPECTIVE) {  	Glut.Glut.Perspective (computeFieldOfView (RenderingSphereRadius * 2' Eye.distance (Target))' (StretchToFill ? _screenWidth / _screenHeight : 1)' Near' Far);  }  else if (projection == CameraMode.ORTHOGONAL) {  	GL.Ortho (-RenderingSphereRadius' +RenderingSphereRadius' -RenderingSphereRadius' +RenderingSphereRadius' Near' Far);  }  else {  	throw new Exception ("Camera.shoot() : unsupported projection mode '" + projection + "'");  }  
Magic Number,nzy3D.Plot3D.Rendering.View,Camera,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\Camera.cs,doShoot,The following statement contains a magic number: Glut.Glut.Perspective (computeFieldOfView (RenderingSphereRadius * 2' Eye.distance (Target))' (StretchToFill ? _screenWidth / _screenHeight : 1)' Near' Far);  
Magic Number,nzy3D.Plot3D.Rendering.View,Camera,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\Camera.cs,computeFieldOfView,The following statement contains a magic number: radtheta = 2 * System.Math.Atan2 (size / 2' distance);  
Magic Number,nzy3D.Plot3D.Rendering.View,Camera,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\Camera.cs,computeFieldOfView,The following statement contains a magic number: radtheta = 2 * System.Math.Atan2 (size / 2' distance);  
Magic Number,nzy3D.Plot3D.Rendering.View,Camera,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\Camera.cs,computeFieldOfView,The following statement contains a magic number: degtheta = (180 * radtheta) / System.Math.PI;  
Magic Number,nzy3D.Plot3D.Rendering.View,ImageRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\ImageRenderer.cs,RenderImage,The following statement contains a magic number: RenderImage (image' imageWidth' imageHeight' screenWidth' screenHeight' 0.75);  
Magic Number,nzy3D.Plot3D.Rendering.View,ImageRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\ImageRenderer.cs,RenderImage,The following statement contains a magic number: if (imageWidth < screenWidth) {  	xpict = Convert.ToInt32 (screenWidth / 2 - imageWidth / 2);  }  else {  	xratio = screenWidth / imageWidth;  }  
Magic Number,nzy3D.Plot3D.Rendering.View,ImageRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\ImageRenderer.cs,RenderImage,The following statement contains a magic number: if (imageWidth < screenWidth) {  	xpict = Convert.ToInt32 (screenWidth / 2 - imageWidth / 2);  }  else {  	xratio = screenWidth / imageWidth;  }  
Magic Number,nzy3D.Plot3D.Rendering.View,ImageRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\ImageRenderer.cs,RenderImage,The following statement contains a magic number: xpict = Convert.ToInt32 (screenWidth / 2 - imageWidth / 2);  
Magic Number,nzy3D.Plot3D.Rendering.View,ImageRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\ImageRenderer.cs,RenderImage,The following statement contains a magic number: xpict = Convert.ToInt32 (screenWidth / 2 - imageWidth / 2);  
Magic Number,nzy3D.Plot3D.Rendering.View,ImageRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\ImageRenderer.cs,RenderImage,The following statement contains a magic number: if (imageHeight < screenHeight) {  	xpict = Convert.ToInt32 (screenHeight / 2 - imageWidth / 2);  }  else {  	xratio = screenHeight / imageHeight;  }  
Magic Number,nzy3D.Plot3D.Rendering.View,ImageRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\ImageRenderer.cs,RenderImage,The following statement contains a magic number: if (imageHeight < screenHeight) {  	xpict = Convert.ToInt32 (screenHeight / 2 - imageWidth / 2);  }  else {  	xratio = screenHeight / imageHeight;  }  
Magic Number,nzy3D.Plot3D.Rendering.View,ImageRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\ImageRenderer.cs,RenderImage,The following statement contains a magic number: xpict = Convert.ToInt32 (screenHeight / 2 - imageWidth / 2);  
Magic Number,nzy3D.Plot3D.Rendering.View,ImageRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\ImageRenderer.cs,RenderImage,The following statement contains a magic number: xpict = Convert.ToInt32 (screenHeight / 2 - imageWidth / 2);  
Magic Number,nzy3D.Plot3D.Rendering.View,View,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\View.cs,UpdateCamera,The following statement contains a magic number: _viewpoint.z = sceneRadiusScaled * 2;  
Magic Number,nzy3D.Plot3D.Rendering.View,View,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\View.cs,UpdateCamera,The following statement contains a magic number: if (_viewmode == Modes.ViewPositionMode.TOP) {  	_cam.RenderingSphereRadius = (float)(Math.Max (boundsScaled.xmax - boundsScaled.xmin' boundsScaled.ymax - boundsScaled.ymin) / 2);  	// correctCameraPositionForIncludingTextLabels(viewport) ' quite experimental !  }  else {  	_cam.RenderingSphereRadius = sceneRadiusScaled;  }  
Magic Number,nzy3D.Plot3D.Rendering.View,View,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Rendering\View\View.cs,UpdateCamera,The following statement contains a magic number: _cam.RenderingSphereRadius = (float)(Math.Max (boundsScaled.xmax - boundsScaled.xmin' boundsScaled.ymax - boundsScaled.ymin) / 2);  
Magic Number,nzy3D.Plot3D.Text.Renderers,TextBillboardRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\Renderer\TextBillboardRenderer.cs,printString,The following statement contains a magic number: switch (halign) {  case Align.Halign.RIGHT:  	xorig = xorig;  	break;  case Align.Halign.CENTER:  	xorig = nchar * xmove / 2;  	break;  case Align.Halign.LEFT:  	xorig = nchar * xmove;  	break;  default:  	throw new Exception ("Horizontal alignement constant unknown: " + halign);  }  
Magic Number,nzy3D.Plot3D.Text.Renderers,TextBillboardRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\Renderer\TextBillboardRenderer.cs,printString,The following statement contains a magic number: xorig = nchar * xmove / 2;  
Magic Number,nzy3D.Plot3D.Text.Renderers,TextBillboardRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\Renderer\TextBillboardRenderer.cs,printString,The following statement contains a magic number: switch (valign) {  case Align.Valign.TOP:  	yorig = 0;  	break;  case Align.Valign.GROUND:  	yorig = yorig;  	break;  case Align.Valign.CENTER:  	yorig = charHeight / 2;  	break;  case Align.Valign.BOTTOM:  	yorig = charHeight;  	break;  default:  	throw new Exception ("Vertical alignement constant unknown: " + valign);  }  
Magic Number,nzy3D.Plot3D.Text.Renderers,TextBillboardRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\Renderer\TextBillboardRenderer.cs,printString,The following statement contains a magic number: yorig = charHeight / 2;  
Magic Number,nzy3D.Plot3D.Text.Renderers,TextBillboardRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\Renderer\TextBillboardRenderer.cs,printString,The following statement contains a magic number: for (int c = 0; c <= acodes.Length - 1; c++) {  	idx = (int)(acodes [c]) - 32;  	if (idx < 0 | idx >= ascii.Length) {  		GL.Bitmap (charWidth' charHeight' xorig' yorig' xmove' ymove' nonascii);  	}  	else {  		GL.Bitmap (charWidth' charHeight' xorig' yorig' xmove' ymove' ascii [idx]);  	}  }  
Magic Number,nzy3D.Plot3D.Text.Renderers,TextBillboardRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\Renderer\TextBillboardRenderer.cs,printString,The following statement contains a magic number: idx = (int)(acodes [c]) - 32;  
Magic Number,nzy3D.Plot3D.Text.Renderers,TextBitmapRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\Renderer\TextBitmapRenderer.cs,TextBitmapRenderer,The following statement contains a magic number: _fontHeight = 10;  
Magic Number,nzy3D.Plot3D.Text.Renderers,TextBitmapRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\Renderer\TextBitmapRenderer.cs,drawText,The following statement contains a magic number: switch (halign) {  case Align.Halign.RIGHT:  	x = (float)posScreen.x;  	break;  case Align.Halign.CENTER:  	x = (float)(posScreen.x - strlen / 2);  	break;  case Align.Halign.LEFT:  	x = (float)(posScreen.x - strlen);  	break;  default:  	throw new Exception ("Unsupported halign value");  }  
Magic Number,nzy3D.Plot3D.Text.Renderers,TextBitmapRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\Renderer\TextBitmapRenderer.cs,drawText,The following statement contains a magic number: x = (float)(posScreen.x - strlen / 2);  
Magic Number,nzy3D.Plot3D.Text.Renderers,TextBitmapRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\Renderer\TextBitmapRenderer.cs,drawText,The following statement contains a magic number: switch (valign) {  case Align.Valign.TOP:  	y = (float)(posScreen.y);  	break;  case Align.Valign.GROUND:  	y = (float)(posScreen.y);  	break;  case Align.Valign.CENTER:  	y = (float)(posScreen.y - _fontHeight / 2);  	break;  case Align.Valign.BOTTOM:  	y = (float)(posScreen.y - _fontHeight);  	break;  default:  	throw new Exception ("Unsupported valign value");  }  
Magic Number,nzy3D.Plot3D.Text.Renderers,TextBitmapRenderer,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Text\Renderer\TextBitmapRenderer.cs,drawText,The following statement contains a magic number: y = (float)(posScreen.y - _fontHeight / 2);  
Duplicate Code,nzy3D.Plot3D.Builder.Concrete,RingTessellator,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Concrete\RingTessellator.cs,findPoint,The method contains a code clone-set at the following line numbers (starting from the method definition): ((21' 40)' (54' 73))
Missing Default,nzy3D.Plot3D.Builder.Delaunay.Jdt,Delaunay_Triangulation,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Delaunay_Triangulation.cs,insertPointSimple,The following switch statement is missing a default case: switch (p.pointLineTest (firstP' lastP)) {  case Point_dt.LEFT:  	startTriangle = extendOutside (firstT.abnext' p);  	allColinear = false;  	break;  	// TODO: might not be correct. Was : Exit Select  	break;  case Point_dt.RIGHT:  	startTriangle = extendOutside (firstT' p);  	allColinear = false;  	break;  	// TODO: might not be correct. Was : Exit Select  	break;  case Point_dt.ONSEGMENT:  	insertCollinear (p' Point_dt.ONSEGMENT);  	break;  	// TODO: might not be correct. Was : Exit Select  	break;  case Point_dt.INFRONTOFA:  	insertCollinear (p' Point_dt.INFRONTOFA);  	break;  	// TODO: might not be correct. Was : Exit Select  	break;  case Point_dt.BEHINDB:  	insertCollinear (p' Point_dt.BEHINDB);  	break;  	// TODO: might not be correct. Was : Exit Select  	break;  }  
Missing Default,nzy3D.Plot3D.Builder.Delaunay.Jdt,Delaunay_Triangulation,C:\repos\benoit74_nzy3d-api\nzy3d-api\Plot3D\Builder\Delaunay\Jdt\Delaunay_Triangulation.cs,insertCollinear,The following switch statement is missing a default case: switch (res) {  case Point_dt.INFRONTOFA:  	t = new Triangle_dt (firstP' p);  	tp = new Triangle_dt (p' firstP);  	t.abnext = tp;  	tp.abnext = t;  	t.bcnext = tp;  	tp.canext = t;  	t.canext = firstT;  	firstT.bcnext = t;  	tp.bcnext = firstT.abnext;  	firstT.abnext.canext = tp;  	firstT = t;  	firstP = p;  	break;  	// TODO: might not be correct. Was : Exit Select  	break;  case Point_dt.BEHINDB:  	t = new Triangle_dt (p' lastP);  	tp = new Triangle_dt (lastP' p);  	t.abnext = tp;  	tp.abnext = t;  	t.bcnext = lastT;  	lastT.canext = t;  	t.canext = tp;  	tp.bcnext = t;  	tp.canext = lastT.abnext;  	lastT.abnext.bcnext = tp;  	lastT = t;  	lastP = p;  	break;  	// TODO: might not be correct. Was : Exit Select  	break;  case Point_dt.ONSEGMENT:  	u = firstT;  	while (p.isGreater (u.a)) {  		u = u.canext;  	}  	t = new Triangle_dt (p' u.b);  	tp = new Triangle_dt (u.b' p);  	u.b = p;  	u.abnext.a = p;  	t.abnext = tp;  	tp.abnext = t;  	t.bcnext = u.bcnext;  	u.bcnext.canext = t;  	t.canext = u;  	u.bcnext = t;  	tp.canext = u.abnext.canext;  	u.abnext.canext.bcnext = tp;  	tp.bcnext = u.abnext;  	u.abnext.canext = tp;  	if ((firstT.Equals (u)))  		firstT = t;  	break;  	// TODO: might not be correct. Was : Exit Select  	break;  }  
