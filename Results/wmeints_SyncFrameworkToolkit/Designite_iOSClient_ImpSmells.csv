Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\HttpCacheRequestHandler.cs,OnUploadGetResponseCompleted,The method has 129 lines of code.
Long Method,Microsoft.Synchronization.ClientServices.IsolatedStorage,IsolatedStorageCollection<T>,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\IsolatedStorageCollection.cs,AddOrUpdateSyncEntity,The method has 154 lines of code.
Long Method,Microsoft.Synchronization.ClientServices.IsolatedStorage,StorageHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\StorageHandler.cs,CleanupTimerCallback,The method has 164 lines of code.
Complex Method,Microsoft.Synchronization.ClientServices,CacheController,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\CacheController.cs,ProcessCacheRequestCompleted,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\HttpCacheRequestHandler.cs,OnUploadGetResponseCompleted,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Synchronization.ClientServices.IsolatedStorage,IsolatedStorageCollection<T>,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\IsolatedStorageCollection.cs,AddOrUpdateSyncEntity,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.Synchronization.ClientServices.IsolatedStorage,IsolatedStorageCollection<T>,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\IsolatedStorageCollection.cs,Rollback,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Synchronization.ClientServices.IsolatedStorage,IsolatedStorageOfflineContext,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\IsolatedStorageOfflineContext.cs,CheckSchemaAndUri,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Synchronization.ClientServices.IsolatedStorage,StorageHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\StorageHandler.cs,ReadFiles,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Synchronization.ClientServices.IsolatedStorage,StorageHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\StorageHandler.cs,GetFileType,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Synchronization.ClientServices.IsolatedStorage,StorageHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\StorageHandler.cs,GetFileName,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Synchronization.ClientServices.IsolatedStorage,StorageHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\StorageHandler.cs,CleanupTimerCallback,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\AtomEntryInfoWrapper.cs,LoadEntryProperties,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\FormatterUtilities.cs,GetEdmType,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.Synchronization.Services.Formatters,JsonEntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\JsonEntryInfoWrapper.cs,LoadTypeName,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataJsonWriter.cs,WriteEntityContentsToElement,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ReflectionUtility.cs,GetObjectForType,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ReflectionUtility.cs,GetValueFromType,Cyclomatic complexity of the method is 10
Long Parameter List,Microsoft.Synchronization.ClientServices,ProcessCacheRequestCompletedEventArgs,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\ProcessCacheRequestCompletedEventArgs.cs,ProcessCacheRequestCompletedEventArgs,The method has 5 parameters. Parameters: id' response' uploadCount' error' state
Long Parameter List,Microsoft.Synchronization.ClientServices.IsolatedStorage,IsolatedStorageOfflineContext,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\IsolatedStorageOfflineContext.cs,IsolatedStorageOfflineContext,The method has 5 parameters. Parameters: schema' scopeName' cachePath' uri' encryptionAlgorithm
Long Parameter List,Microsoft.Synchronization.ClientServices.IsolatedStorage,IsolatedStorageOfflineContext,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\IsolatedStorageOfflineContext.cs,CheckSchemaAndUri,The method has 5 parameters. Parameters: cachePath' schema' uri' scopeName' encryptionAlgorithm
Long Parameter List,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataAtomWriter.cs,WriteItemInternal,The method has 7 parameters. Parameters: live' liveTempId' conflicting' conflictingTempId' desc' isConflict' emitMetadataOnly
Long Parameter List,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataJsonWriter.cs,WriteItemInternal,The method has 7 parameters. Parameters: live' liveTempId' conflicting' conflictingTempId' desc' isConflict' emitMetadataOnly
Long Parameter List,Microsoft.Synchronization.Services.Formatters,SyncWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\SyncWriter.cs,WriteItemInternal,The method has 7 parameters. Parameters: live' liveTempId' conflicting' conflictingTempId' desc' isConflict' emitMetadataOnly
Long Identifier,Microsoft.Synchronization.Services.Formatters,FormatterConstants,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\FormatterConstants.cs,,The length of the parameter AtomDateTimeOffsetLexicalRepresentation is 39.
Long Identifier,Microsoft.Synchronization.Services.Formatters,FormatterConstants,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\FormatterConstants.cs,,The length of the parameter AtomDateTimeLexicalRepresentation is 33.
Long Identifier,Microsoft.Synchronization.Services.Formatters,FormatterConstants,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\FormatterConstants.cs,,The length of the parameter JsonSyncEntryMetadataElementName is 32.
Long Identifier,Microsoft.Synchronization.Services.Formatters,FormatterConstants,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\FormatterConstants.cs,,The length of the parameter JsonDateTimeOffsetLexicalRepresentation is 39.
Long Identifier,Microsoft.Synchronization.Services.Formatters,FormatterConstants,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\FormatterConstants.cs,,The length of the parameter JsonDateTimeLexicalRepresentation is 33.
Long Statement,Microsoft.Synchronization.ClientServices,AsyncWorkerManager,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\AsyncWorkerManager.cs,CompleteWorkRequest,The length of the statement  "            workRequest.AsyncOperation.PostOperationCompleted(new SendOrPostCallback(workRequest.CompletionCallback)' completionArguments); " is 127.
Long Statement,Microsoft.Synchronization.ClientServices,CacheController,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\CacheController.cs,RefreshWorker,The length of the statement  "                this._cacheRequestHandler = CacheRequestHandler.CreateRequestHandler(this._serviceUri' this._controllerBehavior' this._asyncWorkManager); " is 137.
Long Statement,Microsoft.Synchronization.ClientServices,CacheController,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\CacheController.cs,RefreshWorker,The length of the statement  "                this._cacheRequestHandler.ProcessCacheRequestCompleted += new EventHandler<ProcessCacheRequestCompletedEventArgs>(ProcessCacheRequestCompleted); " is 144.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\HttpCacheRequestHandler.cs,ProcessCacheRequestAsync,The length of the statement  "            this._workerManager.AddWorkRequest(new AsyncWorkRequest(ProcessCacheRequestWorker' CacheRequestCompleted' request' state)); " is 123.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\HttpCacheRequestHandler.cs,ProcessRequest,The length of the statement  "                webRequest.Accept = (base.SerializationFormat == SerializationFormat.ODataAtom) ? "application/atom+xml" : "application/json"; " is 126.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\HttpCacheRequestHandler.cs,ProcessRequest,The length of the statement  "                webRequest.ContentType = (base.SerializationFormat == SerializationFormat.ODataAtom) ? "application/atom+xml" : "application/json"; " is 131.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\HttpCacheRequestHandler.cs,OnUploadGetResponseCompleted,The length of the statement  "                                    throw new CacheControllerException(string.Format("Service returned a TempId '{0}' in both live and conflicting entities."'  " is 122.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\HttpCacheRequestHandler.cs,OnUploadGetResponseCompleted,The length of the statement  "                        StringBuilder builder = new StringBuilder("Server did not acknowledge with a permanent Id for the following tempId's: "); " is 121.
Long Statement,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\HttpCacheRequestHandler.cs,CheckEntityServiceMetadataAndTempIds,The length of the statement  "                throw new CacheControllerException("Service returned a response for a tempId which was not uploaded by the client. TempId: " + tempId); " is 135.
Long Statement,Microsoft.Synchronization.ClientServices.IsolatedStorage,CacheData,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\CacheData.cs,AddSyncConflict,The length of the statement  "            IsolatedStorageOfflineEntity entity = Collections[conflict.LiveEntity.GetType()].AddOrUpdateSyncEntity((IsolatedStorageOfflineEntity)conflict.LiveEntity); " is 154.
Long Statement,Microsoft.Synchronization.ClientServices.IsolatedStorage,CacheData,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\CacheData.cs,AddSerializedConflict,The length of the statement  "            IsolatedStorageOfflineEntity entity = Collections[entityType].AddOrUpdateSyncEntity((IsolatedStorageOfflineEntity)conflict.LiveEntity); " is 135.
Long Statement,Microsoft.Synchronization.ClientServices.IsolatedStorage,CacheData,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\CacheData.cs,AddSerializedConflict,The length of the statement  "            IsolatedStorageSyncConflict oldConflict = (IsolatedStorageSyncConflict)Collections[entityType].MapSyncConflict(entity' conflict' context); " is 138.
Long Statement,Microsoft.Synchronization.ClientServices.IsolatedStorage,CacheData,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\CacheData.cs,AddSyncError,The length of the statement  "            IsolatedStorageOfflineEntity entity = Collections[error.LiveEntity.GetType()].AddOrUpdateSyncEntity((IsolatedStorageOfflineEntity)error.LiveEntity); " is 148.
Long Statement,Microsoft.Synchronization.ClientServices.IsolatedStorage,CacheData,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\CacheData.cs,AddSerializedError,The length of the statement  "            IsolatedStorageSyncError oldError = (IsolatedStorageSyncError)Collections[error.ErrorEntity.GetType()].MapSyncError((IsolatedStorageOfflineEntity)error.LiveEntity' error' context); " is 180.
Long Statement,Microsoft.Synchronization.ClientServices.IsolatedStorage,CacheData,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\CacheData.cs,ClearSyncConflicts,The length of the statement  "                Collections[syncConflict.LiveEntity.GetType()].ClearSyncConflict((IsolatedStorageOfflineEntity)syncConflict.LiveEntity); " is 120.
Long Statement,Microsoft.Synchronization.ClientServices.IsolatedStorage,IsolatedStorageCollection<T>,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\IsolatedStorageCollection.cs,DeleteItem,The length of the statement  "                throw new ArgumentException(String.Format("The requested item does not exist in the collection for type {0}"' typeof(T).FullName)); " is 131.
Long Statement,Microsoft.Synchronization.ClientServices.IsolatedStorage,IsolatedStorageCollection<T>,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\IsolatedStorageCollection.cs,AddItem,The length of the statement  "                throw new ArgumentException(String.Format("An item with the same primary keys already exists in the collection for type {0}"' typeof(T).FullName)); " is 147.
Long Statement,Microsoft.Synchronization.ClientServices.IsolatedStorage,IsolatedStorageCollection<T>,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\IsolatedStorageCollection.cs,AddItem,The length of the statement  "            OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add' item' _entityList.Count - 1)); " is 122.
Long Statement,Microsoft.Synchronization.ClientServices.IsolatedStorage,IsolatedStorageOfflineContext,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\IsolatedStorageOfflineContext.cs,SaveChanges,The length of the statement  "                                "One or more modified items has had an update received from the service. The conflicts must be resolved before SaveChanges can complete successfully."); " is 152.
Long Statement,Microsoft.Synchronization.ClientServices.IsolatedStorage,IsolatedStorageOfflineContext,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\IsolatedStorageOfflineContext.cs,OnChangeSetUploaded,The length of the statement  "                IEnumerable<Conflict> conflicts = _storageHandler.UploadSucceeded(state' response.ServerBlob' response.Conflicts' updatedItems); " is 128.
Long Statement,Microsoft.Synchronization.ClientServices.IsolatedStorage,IsolatedStorageOfflineContext,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\IsolatedStorageOfflineContext.cs,CheckSchemaAndUri,The length of the statement  "                                throw new ArgumentException("Specified scope name does not match scope name previously used for the specified cache path"); " is 123.
Long Statement,Microsoft.Synchronization.ClientServices.IsolatedStorage,IsolatedStorageOfflineEntity,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\IsolatedStorageOfflineEntity.cs,RejectChanges,The length of the statement  "                        throw new InvalidOperationException("The item snapshot is a tombstone' so the change can only be rejected by calling CancelChanges on the context"); " is 148.
Long Statement,Microsoft.Synchronization.ClientServices.IsolatedStorage,StorageHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\StorageHandler.cs,UploadSucceeded,The length of the statement  "                    // This approach assumes that there are not duplicates between the conflicts and the updated entities (there shouldn't be) " is 122.
Long Statement,Microsoft.Synchronization.ClientServices.IsolatedStorage,StorageHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\StorageHandler.cs,CleanupTimerCallback,The length of the statement  "                                        ICollection<IsolatedStorageOfflineEntity> entities = ReadFile<ICollection<IsolatedStorageOfflineEntity>>(fi.FileName' isoFile); " is 127.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\AtomEntryInfoWrapper.cs,LoadConflictEntry,The length of the statement  "            XElement conflictElement = entry.Element(FormatterConstants.SyncNamespace + FormatterConstants.SyncConlflictElementName); " is 121.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\AtomEntryInfoWrapper.cs,LoadConflictEntry,The length of the statement  "                XElement resolutionType = conflictElement.Element(FormatterConstants.SyncNamespace + FormatterConstants.ConflictResolutionElementName); " is 135.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\AtomEntryInfoWrapper.cs,LoadConflictEntry,The length of the statement  "                XElement conflictingChangeElement = conflictElement.Element(FormatterConstants.SyncNamespace + FormatterConstants.ConflictEntryElementName); " is 140.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\AtomEntryInfoWrapper.cs,LoadConflictEntry,The length of the statement  "                XElement errorDesc = errorElement.Element(FormatterConstants.SyncNamespace + FormatterConstants.ErrorDescriptionElementName); " is 125.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\AtomEntryInfoWrapper.cs,LoadConflictEntry,The length of the statement  "                XElement errorChangeElement = errorElement.Element(FormatterConstants.SyncNamespace + FormatterConstants.ErrorEntryElementName); " is 128.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\AtomEntryInfoWrapper.cs,GetSubElement,The length of the statement  "            XElement element = entryElement.Element(FormatterConstants.AtomNamespaceUri + FormatterConstants.AtomPubEntryElementName); " is 122.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\AtomEntryInfoWrapper.cs,GetSubElement,The length of the statement  "                element = entryElement.Element(FormatterConstants.AtomDeletedEntryNamespace + FormatterConstants.AtomDeletedEntryElementName); " is 126.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\AtomEntryInfoWrapper.cs,LoadEntryProperties,The length of the statement  "                    throw new InvalidOperationException("A atom:ref element must be present for a tombstone entry. Entity in error: " + entry.ToString(SaveOptions.None)); " is 150.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\AtomEntryInfoWrapper.cs,LoadEntryProperties,The length of the statement  "                    throw new InvalidOperationException("A atom:id or a sync:tempId element must be present. Entity in error: " + entry.ToString(SaveOptions.None)); " is 144.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\AtomEntryInfoWrapper.cs,LoadEntryProperties,The length of the statement  "                foreach (XElement linkElement in entry.Elements(FormatterConstants.AtomXmlNamespace + FormatterConstants.AtomPubLinkElementName)) " is 129.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\AtomEntryInfoWrapper.cs,LoadEntryProperties,The length of the statement  "                                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "Multiple Edit Url's found for atom with {0}: '{1}'"' (this.Id == null) ? "TempId" : "Id"' (this.Id == null) ? this.TempId : this.Id)); " is 215.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\AtomEntryInfoWrapper.cs,LoadEntryProperties,The length of the statement  "                            XAttribute nullableAttr = property.Attribute(FormatterConstants.ODataMetadataNamespace + FormatterConstants.AtomPubIsNullElementName); " is 134.
Long Statement,Microsoft.Synchronization.Services.Formatters,AtomEntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\AtomEntryInfoWrapper.cs,LoadTypeName,The length of the statement  "                    string.Format(CultureInfo.InvariantCulture' "Category element not found in {0} element."' (isTombstone)? FormatterConstants.AtomDeletedEntryElementName : FormatterConstants.AtomPubEntryElementName)); " is 199.
Long Statement,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\FormatterUtilities.cs,ParseDateTimeFromString,The length of the statement  "                throw new InvalidOperationException(string.Format(USCultureInfo' "Invalid Date/Time value received. Unable to parse value {0} to type {1}."' value' type.Name)); " is 160.
Long Statement,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\FormatterUtilities.cs,ParseJsonString,The length of the statement  "                        throw new InvalidOperationException(string.Format("Invalid JSON DateTime value received. Value '{0}' is not a valid DateTime"' ticks)); " is 135.
Long Statement,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\FormatterUtilities.cs,ParseJsonString,The length of the statement  "                    throw new InvalidOperationException(string.Format(USCultureInfo' @"Invalid Json DateTime value received. Value {0} is not in format '\/Date(ticks)\/'."' value)); " is 161.
Long Statement,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\FormatterUtilities.cs,ParseJsonString,The length of the statement  "                    throw new InvalidOperationException(string.Format(USCultureInfo' @"Invalid Json DateTimeOffset value received. Value {0} is not in format 'datetimeoffset'yyyy-MM-ddTHH:mm:ss.fffffffzzz''."' value)); " is 198.
Long Statement,Microsoft.Synchronization.Services.Formatters,FormatterUtilities,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\FormatterUtilities.cs,ParseJsonString,The length of the statement  "                    throw new InvalidOperationException(string.Format(USCultureInfo' @"Invalid Json TimeSpan value received. Value {0} is not in format 'time'HH:mm:ss''."' value)); " is 160.
Long Statement,Microsoft.Synchronization.Services.Formatters,JsonEntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\JsonEntryInfoWrapper.cs,LoadEntryProperties,The length of the statement  "                if (!keyValuePair.Name.LocalName.Equals(FormatterConstants.JsonSyncEntryMetadataElementName' StringComparison.InvariantCulture) && " is 130.
Long Statement,Microsoft.Synchronization.Services.Formatters,JsonEntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\JsonEntryInfoWrapper.cs,LoadTypeName,The length of the statement  "                    throw new InvalidOperationException("A uri or a tempId key must be present in the __metadata object. Entity in error: " + entry.ToString(SaveOptions.None)); " is 156.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataAtomWriter.cs,StartFeed,The length of the statement  "                new XAttribute(XNamespace.Xmlns + FormatterConstants.AtomDeletedEntryPrefix' FormatterConstants.AtomDeletedEntryNamespace)' " is 123.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataAtomWriter.cs,StartFeed,The length of the statement  "            _root.Add(new XElement(atom + FormatterConstants.AtomPubUpdatedElementName' XmlConvert.ToString(DateTime.Now' XmlDateTimeSerializationMode.Utc))); " is 146.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataAtomWriter.cs,WriteItemInternal,The length of the statement  "                XElement conflictElement = new XElement(FormatterConstants.SyncNamespace + ((isConflict) ? FormatterConstants.SyncConlflictElementName : FormatterConstants.SyncErrorElementName)); " is 179.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataAtomWriter.cs,WriteItemInternal,The length of the statement  "                conflictElement.Add(new XElement(FormatterConstants.SyncNamespace + ((isConflict) ? FormatterConstants.ConflictResolutionElementName : FormatterConstants.ErrorDescriptionElementName)' desc)); " is 191.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataAtomWriter.cs,WriteItemInternal,The length of the statement  "                XElement conflictingEntryElement = new XElement(FormatterConstants.SyncNamespace + ((isConflict) ? FormatterConstants.ConflictEntryElementName : FormatterConstants.ErrorEntryElementName)); " is 188.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "                    entryElement.Add(new XAttribute(FormatterConstants.ODataMetadataNamespace + FormatterConstants.EtagElementName' live.ServiceMetadata.ETag)); " is 140.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "                XElement contentElement = new XElement(FormatterConstants.AtomXmlNamespace + FormatterConstants.AtomPubContentElementName); " is 123.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "                XElement tombstoneElement = new XElement(FormatterConstants.AtomDeletedEntryNamespace + FormatterConstants.AtomDeletedEntryElementName); " is 136.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "                tombstoneElement.Add(new XElement(FormatterConstants.AtomNamespaceUri + FormatterConstants.AtomReferenceElementName' live.ServiceMetadata.Id)); " is 143.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataAtomWriter.cs,WriteEntry,The length of the statement  "                tombstoneElement.Add(new XElement(FormatterConstants.SyncNamespace + FormatterConstants.AtomPubCategoryElementName' typeName)); " is 127.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataAtomWriter.cs,WriteEntityContents,The length of the statement  "            XElement contentElement = new XElement(FormatterConstants.ODataMetadataNamespace + FormatterConstants.PropertiesElementName); " is 125.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataAtomWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataAtomWriter.cs,WriteEntityContents,The length of the statement  "                if(fi.PropertyType.IsGenericType && fi.PropertyType.Name.Equals(FormatterConstants.NullableTypeName' StringComparison.InvariantCulture)) " is 136.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataJsonWriter.cs,StartFeed,The length of the statement  "                new XAttribute(FormatterConstants.JsonTypeAttributeName' (serverBlob != null) ? JsonElementTypes.String : JsonElementTypes.Object)' " is 131.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataJsonWriter.cs,WriteItemInternal,The length of the statement  "                XElement conflictElement = new XElement(((isConflict) ? FormatterConstants.JsonSyncConflictElementName : FormatterConstants.JsonSyncErrorElementName)' " is 150.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataJsonWriter.cs,WriteItemInternal,The length of the statement  "                conflictElement.Add(new XElement(((isConflict) ? FormatterConstants.ConflictResolutionElementName : FormatterConstants.ErrorDescriptionElementName)' " is 148.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataJsonWriter.cs,WriteItemInternal,The length of the statement  "                XElement conflictingEntryElement = new XElement(((isConflict) ? FormatterConstants.ConflictEntryElementName : FormatterConstants.ErrorEntryElementName)' " is 152.
Long Statement,Microsoft.Synchronization.Services.Formatters,ODataJsonWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ODataJsonWriter.cs,WriteEntityContentsToElement,The length of the statement  "                else if (fi.PropertyType.IsGenericType && fi.PropertyType.Name.Equals(FormatterConstants.NullableTypeName' StringComparison.InvariantCulture)) " is 142.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ReflectionUtility.cs,GetPropertyInfoMapping,The length of the statement  "                            throw new InvalidOperationException(string.Format("Entity {0} does not have the any property marked with the [KeyAttribute]."' type.Name)); " is 139.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ReflectionUtility.cs,GetPropertyInfoMapping,The length of the statement  "                        SyncEntityTypeAttribute attr = (SyncEntityTypeAttribute)type.GetCustomAttributes(typeof(SyncEntityTypeAttribute)' true).FirstOrDefault(); " is 137.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ReflectionUtility.cs,GetPropertyInfoMapping,The length of the statement  "                            throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "Entity {0} does not have the mandatory SyncEntityTypeAttribute defined."' type.Name)); " is 167.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ReflectionUtility.cs,GetPropertyInfoMapping,The length of the statement  "                            throw new InvalidOperationException(string.Format("Entity {0} does not have the KeyFields defined for the SyncEntityTypeAttribute."' type.Name)); " is 145.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ReflectionUtility.cs,GetPropertyInfoMapping,The length of the statement  "                        ConstructorInfo ctorInfo = type.GetConstructors(BindingFlags.Public | BindingFlags.Instance).Where((e) => e.GetParameters().Count() == 0).FirstOrDefault(); " is 155.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ReflectionUtility.cs,GetPropertyInfoMapping,The length of the statement  "                            throw new InvalidOperationException(string.Format("Type {0} does not have a public parameterless constructor."' type.FullName)); " is 128.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ReflectionUtility.cs,GetObjectForType,The length of the statement  "                    entityType = knownTypes.Where((e) => e.FullName.Equals(wrapper.TypeName' StringComparison.InvariantCulture)).FirstOrDefault(); " is 126.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ReflectionUtility.cs,GetObjectForType,The length of the statement  "                        throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "Unable to find a matching type for entry '{0}' in list of KnownTypes."' wrapper.TypeName)); " is 172.
Long Statement,Microsoft.Synchronization.Services.Formatters,ReflectionUtility,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\ReflectionUtility.cs,GetObjectForType,The length of the statement  "                        throw new InvalidOperationException(string.Format("Unable to find a matching type for entry '{0}' in the loaded assemblies. Specify the type name in the KnownTypes argument to the SyncReader instance."' wrapper.TypeName)); " is 222.
Long Statement,Microsoft.Synchronization.Services.Formatters,SyncReader,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\SyncReader.cs,GetConflict,The length of the statement  "                    Resolution = (SyncConflictResolution)Enum.Parse(FormatterConstants.SyncConflictResolutionType' _currentEntryWrapper.ConflictDesc' true) " is 135.
Long Statement,Microsoft.Synchronization.Services.Formatters,SyncReader,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\SyncReader.cs,CheckItemType,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "{0} is not a valid {1} element."' _reader.Name' type)); " is 136.
Long Statement,Microsoft.Synchronization.Services.Formatters,SyncWriter,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\SyncWriter.cs,AddItem,The length of the statement  "            WriteItemInternal(entry' tempId' null /*conflicting*/' null/*conflictingTempId*/' null /*desc*/' false /*isconflict*/' emitMetadataOnly); " is 137.
Complex Conditional,Microsoft.Synchronization.ClientServices,ExceptionUtility,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\iOSClient\ExceptionUtility.cs,IsFatal,The conditional expression  "exception is OutOfMemoryException || exception is ThreadAbortException || exception is AccessViolationException   #if !WPCLIENT                      || exception is SEHException"  is complex.
Virtual Method Call from Constructor,Microsoft.Synchronization.Services.Formatters,EntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\EntryInfoWrapper.cs,EntryInfoWrapper,The constructor "EntryInfoWrapper" calls a virtual method "LoadTypeName".
Virtual Method Call from Constructor,Microsoft.Synchronization.Services.Formatters,EntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\EntryInfoWrapper.cs,EntryInfoWrapper,The constructor "EntryInfoWrapper" calls a virtual method "LoadEntryProperties".
Virtual Method Call from Constructor,Microsoft.Synchronization.Services.Formatters,EntryInfoWrapper,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\formatters\EntryInfoWrapper.cs,EntryInfoWrapper,The constructor "EntryInfoWrapper" calls a virtual method "LoadConflictEntry".
Empty Catch Block,Microsoft.Synchronization.ClientServices.IsolatedStorage,StorageHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\StorageHandler.cs,ReadFiles,The method has an empty catch block.
Empty Catch Block,Microsoft.Synchronization.ClientServices.IsolatedStorage,StorageHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\StorageHandler.cs,ReadFiles,The method has an empty catch block.
Magic Number,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\HttpCacheRequestHandler.cs,ProcessCacheRequestWorker,The following statement contains a magic number: Debug.Assert(inputParams.Length == 2);
Magic Number,Microsoft.Synchronization.ClientServices.IsolatedStorage,StorageHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\StorageHandler.cs,GetFileType,The following statement contains a magic number: index == fileName.Length - 2
Missing Default,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\HttpCacheRequestHandler.cs,OnUploadGetResponseCompleted,The following switch statement is missing a default case: switch (this._syncReader.ItemType)                          {                              case ReaderItemType.Entry:                                                                  IOfflineEntity entity = this._syncReader.GetItem();                                  IOfflineEntity ackedEntity = entity;                                                                  string tempId = null;                                                                    // If conflict only one temp ID should be set                                  if (this._syncReader.HasTempId() && this._syncReader.HasConflictTempId())                                   {                                      throw new CacheControllerException(string.Format("Service returned a TempId '{0}' in both live and conflicting entities."'                                                                          this._syncReader.GetTempId()));                                  }                                    // Validate the live temp ID if any' before adding anything to the offline context                                  if (this._syncReader.HasTempId())                                   {                                      tempId = this._syncReader.GetTempId();                                      CheckEntityServiceMetadataAndTempIds(wrapper' entity' tempId);                                    }                                                                               //  If conflict                                   if (this._syncReader.HasConflict())                                   {                                                                          Conflict conflict = this._syncReader.GetConflict();                                      IOfflineEntity conflictEntity = (conflict is SyncConflict) ?                                                                       ((SyncConflict)conflict).LosingEntity : ((SyncError)conflict).ErrorEntity;                                        // Validate conflict temp ID if any                                      if (this._syncReader.HasConflictTempId())                                      {                                          tempId = this._syncReader.GetConflictTempId();                                          CheckEntityServiceMetadataAndTempIds(wrapper' conflictEntity' tempId);                                      }                                        // Add conflict                                                                          wrapper.UploadResponse.AddConflict(conflict);                                                                        //                                      // If there is a conflict and the tempId is set in the conflict entity then the client version lost the                                       // conflict and the live entity is the server version (ServerWins)                                      //                                      if (this._syncReader.HasConflictTempId() && entity.ServiceMetadata.IsTombstone)                                      {                                          //                                          // This is a ServerWins conflict' or conflict error. The winning version is a tombstone without temp Id                                          // so there is no way to map the winning entity with a temp Id. The temp Id is in the conflict so we are                                          // using the conflict entity' which has the PK' to build a tombstone entity used to update the offline context                                          //                                          // In theory' we should copy the service metadata but it is the same end result as the service fills in                                          // all the properties in the conflict entity                                          //                                            // Add the conflict entity                                                                                        conflictEntity.ServiceMetadata.IsTombstone = true;                                          ackedEntity = conflictEntity;                                      }                                  }                                                            // Add ackedEntity to storage. If ackedEntity is still equal to entity then add non-conflict entity.                                   if (!String.IsNullOrEmpty(tempId)) {                                      wrapper.UploadResponse.AddUpdatedItem(ackedEntity);                                  }                                                                  break;                                case ReaderItemType.SyncBlob:                                  wrapper.UploadResponse.ServerBlob = this._syncReader.GetServerBlob();                                  break;                          }
Missing Default,Microsoft.Synchronization.ClientServices,HttpCacheRequestHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\HttpCacheRequestHandler.cs,OnDownloadGetResponseCompleted,The following switch statement is missing a default case: switch (this._syncReader.ItemType)                          {                              case ReaderItemType.Entry:                                  wrapper.DownloadResponse.AddItem(this._syncReader.GetItem());                                  break;                              case ReaderItemType.SyncBlob:                                  wrapper.DownloadResponse.ServerBlob = this._syncReader.GetServerBlob();                                  break;                              case ReaderItemType.HasMoreChanges:                                  wrapper.DownloadResponse.IsLastBatch = !this._syncReader.GetHasMoreChangesValue();                                  break;                          }
Missing Default,Microsoft.Synchronization.ClientServices.IsolatedStorage,StorageHandler,D:\research\architectureSmells\repos\wmeints_SyncFrameworkToolkit\src\clientcommon\isolatedstorage\StorageHandler.cs,CleanupTimerCallback,The following switch statement is missing a default case: switch (fi.FileType)                                  {                                      case CacheFileType.DownloadResponse:                                          ResponseData drd = ReadFile<ResponseData>(fi.FileName' isoFile);                                          currentAnchor = drd.Anchor;                                          WriteArchiveEntities(drd.Entities' false' writeStream' serializedItems);                                          break;                                        case CacheFileType.UploadResponse:                                          ResponseData responseData = ReadFile<ResponseData>(fi.FileName' isoFile);                                          currentAnchor = responseData.Anchor;                                          WriteArchiveEntities(responseData.Entities' false' writeStream' serializedItems);                                          break;                                        case CacheFileType.SaveChanges:                                          ICollection<IsolatedStorageOfflineEntity> entities = ReadFile<ICollection<IsolatedStorageOfflineEntity>>(fi.FileName' isoFile);                                          WriteArchiveEntities(entities' !fi.HasUploadFile' writeStream' serializedItems);                                          break;                                        case CacheFileType.Archive:                                          currentAnchor = TransferArchiveFile(isoFile' fi.FileName' writeStream' serializedItems);                                          encounteredArchive = true;                                          break;                                    }
