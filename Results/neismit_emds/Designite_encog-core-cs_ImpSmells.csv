Implementation smell,Namespace,Class,File,Method,Description
Long Method,Encog.App.Analyst.Report,AnalystReport,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Report\AnalystReport.cs,ProduceReport,The method has 105 lines of code.
Long Method,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The method has 196 lines of code.
Long Method,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The method has 104 lines of code.
Long Method,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The method has 211 lines of code.
Long Method,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The method has 115 lines of code.
Long Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tred2,The method has 103 lines of code.
Long Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,The method has 102 lines of code.
Long Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The method has 386 lines of code.
Long Method,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The method has 382 lines of code.
Long Method,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The method has 129 lines of code.
Long Method,Encog.Neural.NEAT.Training,NEATTraining,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATTraining.cs,Crossover,The method has 109 lines of code.
Long Method,Encog.Neural.Networks.Training.NM,NelderMeadTraining,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,Iteration,The method has 223 lines of code.
Long Method,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The method has 136 lines of code.
Long Method,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The method has 146 lines of code.
Long Method,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,FindBestRange,The method has 168 lines of code.
Long Method,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,ComputeDeriv,The method has 153 lines of code.
Long Method,Encog.Neural.Networks.Training.Propagation.SCG,ScaledConjugateGradient,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\Propagation\SCG\ScaledConjugateGradient.cs,Iteration,The method has 107 lines of code.
Long Method,Encog.Neural.RBF.Training,SVD,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,The method has 201 lines of code.
Complex Method,Encog.App.Analyst,EncogAnalyst,C:\repos\neismit_emds\encog-core-cs\App\Analyst\EncogAnalyst.cs,DownloadPage,Cyclomatic complexity of the method is 16
Complex Method,Encog.App.Analyst.CSV,EvaluateRawCSV,C:\repos\neismit_emds\encog-core-cs\App\Analyst\CSV\EvaluateRawCSV.cs,AnalystPrepareOutputFile,Cyclomatic complexity of the method is 9
Complex Method,Encog.App.Analyst.CSV,AnalystEvaluateCSV,C:\repos\neismit_emds\encog-core-cs\App\Analyst\CSV\AnalystEvaluateCSV.cs,Process,Cyclomatic complexity of the method is 11
Complex Method,Encog.App.Analyst.CSV,AnalystEvaluateRawCSV,C:\repos\neismit_emds\encog-core-cs\App\Analyst\CSV\AnalystEvaluateRawCSV.cs,AnalystPrepareOutputFile,Cyclomatic complexity of the method is 10
Complex Method,Encog.App.Analyst.Analyze,AnalyzedField,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Analyze\AnalyzedField.cs,Analyze1,Cyclomatic complexity of the method is 10
Complex Method,Encog.App.Analyst.Analyze,PerformAnalysis,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Analyze\PerformAnalysis.cs,Process,Cyclomatic complexity of the method is 25
Complex Method,Encog.App.Analyst.CSV.Basic,BasicCachedFile,C:\repos\neismit_emds\encog-core-cs\App\Analyst\CSV\Basic\BasicCachedFile.cs,Analyze,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Analyst.CSV.Basic,BasicCachedFile,C:\repos\neismit_emds\encog-core-cs\App\Analyst\CSV\Basic\BasicCachedFile.cs,AttemptResolveName,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Analyst.CSV.Normalize,AnalystNormalizeCSV,C:\repos\neismit_emds\encog-core-cs\App\Analyst\CSV\Normalize\AnalystNormalizeCSV.cs,ExtractFields,Cyclomatic complexity of the method is 10
Complex Method,Encog.App.Analyst.CSV.Sort,RowComparator,C:\repos\neismit_emds\encog-core-cs\App\Analyst\CSV\Sort\RowComparator.cs,Compare,Cyclomatic complexity of the method is 22
Complex Method,Encog.App.Analyst.CSV.Sort,SortCSV,C:\repos\neismit_emds\encog-core-cs\App\Analyst\CSV\Sort\SortCSV.cs,WriteOutputFile,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataClasses,Cyclomatic complexity of the method is 10
Complex Method,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleNormalizeRange,Cyclomatic complexity of the method is 9
Complex Method,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,Cyclomatic complexity of the method is 20
Complex Method,Encog.App.Analyst.Script,ScriptSave,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptSave.cs,SaveNormalize,Cyclomatic complexity of the method is 21
Complex Method,Encog.App.Analyst.Script.Normalize,AnalystField,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\Normalize\AnalystField.cs,DetermineClass,Cyclomatic complexity of the method is 11
Complex Method,Encog.App.Analyst.Script.Normalize,AnalystField,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\Normalize\AnalystField.cs,DetermineClass,Cyclomatic complexity of the method is 12
Complex Method,Encog.App.Analyst.Script.Prop,PropertyConstraints,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\Prop\PropertyConstraints.cs,PropertyConstraints,Cyclomatic complexity of the method is 10
Complex Method,Encog.App.Analyst.Script.Prop,PropertyEntry,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\Prop\PropertyEntry.cs,Validate,Cyclomatic complexity of the method is 22
Complex Method,Encog.App.Analyst.Script.Prop,ScriptProperties,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\Prop\ScriptProperties.cs,SetProperty,Cyclomatic complexity of the method is 9
Complex Method,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,DetermineTargetField,Cyclomatic complexity of the method is 18
Complex Method,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,ExpandTimeSlices,Cyclomatic complexity of the method is 12
Complex Method,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,Cyclomatic complexity of the method is 14
Complex Method,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateGenerate,Cyclomatic complexity of the method is 21
Complex Method,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateNormalizedFields,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateTasks,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Finance.Indicators,TechnicalIndicators,C:\repos\neismit_emds\encog-core-cs\App\Finance\Indicators\Finance.cs,CalculateMovingAverageOfDoubleSerie,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Quant.Indicators,ProcessIndicators,C:\repos\neismit_emds\encog-core-cs\App\Quant\Indicators\ProcessIndicators.cs,WriteCSV,Cyclomatic complexity of the method is 10
Complex Method,Encog.App.Quant.Loader.OpenQuant,DataArray,C:\repos\neismit_emds\encog-core-cs\App\Quant\Loader\OpenQuant\BarSeries.cs,GetIndex,Cyclomatic complexity of the method is 8
Complex Method,Encog.Bot.Browse,Browser,C:\repos\neismit_emds\encog-core-cs\Bot\Browse\Browser.cs,Navigate,Cyclomatic complexity of the method is 9
Complex Method,Encog.Bot.Browse,LoadWebPage,C:\repos\neismit_emds\encog-core-cs\Bot\Browse\LoadWebPage.cs,LoadContents,Cyclomatic complexity of the method is 16
Complex Method,Encog.MathUtil,Equilateral,C:\repos\neismit_emds\encog-core-cs\MathUtil\Equilateral.cs,Equilat,Cyclomatic complexity of the method is 9
Complex Method,Encog.MathUtil.LIBSVM,Cache,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,swap_index,Cyclomatic complexity of the method is 13
Complex Method,Encog.MathUtil.LIBSVM,Kernel,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,k_function,Cyclomatic complexity of the method is 11
Complex Method,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,swap_index,Cyclomatic complexity of the method is 8
Complex Method,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,reconstruct_gradient,Cyclomatic complexity of the method is 8
Complex Method,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,Cyclomatic complexity of the method is 56
Complex Method,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,select_working_set,Cyclomatic complexity of the method is 11
Complex Method,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,do_shrinking,Cyclomatic complexity of the method is 19
Complex Method,Encog.MathUtil.LIBSVM,Solver_NU,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,select_working_set,Cyclomatic complexity of the method is 12
Complex Method,Encog.MathUtil.LIBSVM,Solver_NU,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,do_shrinking,Cyclomatic complexity of the method is 28
Complex Method,Encog.MathUtil.LIBSVM,Solver_NU,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,calculate_rho,Cyclomatic complexity of the method is 9
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_nu_svc,Cyclomatic complexity of the method is 11
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train_one,Cyclomatic complexity of the method is 20
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,Cyclomatic complexity of the method is 16
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,multiclass_probability,Cyclomatic complexity of the method is 14
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,Cyclomatic complexity of the method is 21
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,Cyclomatic complexity of the method is 68
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_cross_validation,Cyclomatic complexity of the method is 13
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict_values,Cyclomatic complexity of the method is 15
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict,Cyclomatic complexity of the method is 10
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict_probability,Cyclomatic complexity of the method is 8
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_save_model,Cyclomatic complexity of the method is 24
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,Cyclomatic complexity of the method is 36
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,Cyclomatic complexity of the method is 13
Complex Method,Encog.MathUtil.Matrices.Decomposition,CholeskyDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\CholeskyDecomposition.cs,Solve,Cyclomatic complexity of the method is 9
Complex Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,EigenvalueDecomposition,Cyclomatic complexity of the method is 8
Complex Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tred2,Cyclomatic complexity of the method is 23
Complex Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,Cyclomatic complexity of the method is 16
Complex Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Orthes,Cyclomatic complexity of the method is 20
Complex Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,Cyclomatic complexity of the method is 69
Complex Method,Encog.MathUtil.Matrices.Decomposition,LUDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\LUDecomposition.cs,LUDecomposition,Cyclomatic complexity of the method is 12
Complex Method,Encog.MathUtil.Matrices.Decomposition,LUDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\LUDecomposition.cs,Solve,Cyclomatic complexity of the method is 10
Complex Method,Encog.MathUtil.Matrices.Decomposition,LUDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\LUDecomposition.cs,Solve,Cyclomatic complexity of the method is 9
Complex Method,Encog.MathUtil.Matrices.Decomposition,LUDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\LUDecomposition.cs,Inverse,Cyclomatic complexity of the method is 10
Complex Method,Encog.MathUtil.Matrices.Decomposition,QRDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\QRDecomposition.cs,QRDecomposition,Cyclomatic complexity of the method is 9
Complex Method,Encog.MathUtil.Matrices.Decomposition,QRDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\QRDecomposition.cs,Solve,Cyclomatic complexity of the method is 11
Complex Method,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,Cyclomatic complexity of the method is 92
Complex Method,Encog.ML.Bayesian,PersistBayes,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\PersistBayes.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,Encog.ML.Bayesian,PersistBayes,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\PersistBayes.cs,Save,Cyclomatic complexity of the method is 12
Complex Method,Encog.ML.Bayesian.Parse,ParsedEvent,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Parse\ParsedEvent.cs,ResolveValue,Cyclomatic complexity of the method is 8
Complex Method,Encog.ML.Bayesian.Parse,ParseProbability,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Parse\ParseProbability.cs,AddEvents,Cyclomatic complexity of the method is 15
Complex Method,Encog.ML.Bayesian.Training,TrainBayesian,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Training\TrainBayesian.cs,IterationInit,Cyclomatic complexity of the method is 9
Complex Method,Encog.ML.Bayesian.Training,TrainBayesian,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Training\TrainBayesian.cs,Iteration,Cyclomatic complexity of the method is 15
Complex Method,Encog.ML.Bayesian.Training.Estimator,SimpleEstimator,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Training\Estimator\SimpleEstimator.cs,CalculateProbability,Cyclomatic complexity of the method is 8
Complex Method,Encog.ML.Data.Market.Loader,CSVLoader,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVLoader.cs,fromStringCSVFormattoCSVFormat,Cyclomatic complexity of the method is 14
Complex Method,Encog.ML.Data.Temporal,TemporalMLDataSet,C:\repos\neismit_emds\encog-core-cs\ML\Data\Temporal\TemporalMLDataSet.cs,FormatData,Cyclomatic complexity of the method is 12
Complex Method,Encog.ML.Factory.Method,SVMFactory,C:\repos\neismit_emds\encog-core-cs\ML\Factory\Method\SVMFactory.cs,Create,Cyclomatic complexity of the method is 16
Complex Method,Encog.ML.Factory.Parse,ArchitectureParse,C:\repos\neismit_emds\encog-core-cs\ML\Factory\Parse\ArchitectureParse.cs,ParseLayer,Cyclomatic complexity of the method is 8
Complex Method,Encog.ML.Factory.Train,NeighborhoodSOMFactory,C:\repos\neismit_emds\encog-core-cs\ML\Factory\Train\NeighborhoodSOMFactory.cs,Create,Cyclomatic complexity of the method is 11
Complex Method,Encog.ML.Factory.Train,TrainBayesianFactory,C:\repos\neismit_emds\encog-core-cs\ML\Factory\Train\TrainBayesianFactory.cs,Create,Cyclomatic complexity of the method is 8
Complex Method,Encog.ML.Genetic.Genome,BasicGenome,C:\repos\neismit_emds\encog-core-cs\ML\Genetic\Genome\BasicGenome.cs,CompareTo,Cyclomatic complexity of the method is 8
Complex Method,Encog.ML.HMM.Alog,ViterbiCalculator,C:\repos\neismit_emds\encog-core-cs\ML\HMM\Alog\ViterbiCalculator.cs,ViterbiCalculator,Cyclomatic complexity of the method is 8
Complex Method,Encog.ML.HMM.Distributions,ContinousDistribution,C:\repos\neismit_emds\encog-core-cs\ML\HMM\Distributions\ContinousDistribution.cs,Fit,Cyclomatic complexity of the method is 8
Complex Method,Encog.ML.HMM,PersistHMM,C:\repos\neismit_emds\encog-core-cs\ML\HMM\PersistHMM.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Encog.ML.HMM.Train.BW,BaseBaumWelch,C:\repos\neismit_emds\encog-core-cs\ML\HMM\Train\BW\BaseBaumWelch.cs,Iteration,Cyclomatic complexity of the method is 17
Complex Method,Encog.ML.HMM.Train.KMeans,TrainKMeans,C:\repos\neismit_emds\encog-core-cs\ML\HMM\Train\KMeans\TrainKMeans.cs,LearnTransition,Cyclomatic complexity of the method is 11
Complex Method,Encog.Neural.CPN,CPNNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\CPN\CPN.cs,ComputeInstar,Cyclomatic complexity of the method is 8
Complex Method,Encog.Neural.NEAT,NEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\NEATNetwork.cs,Compute,Cyclomatic complexity of the method is 8
Complex Method,Encog.Neural.NEAT,NEATNeuron,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\NEATNeuron.cs,ToString,Cyclomatic complexity of the method is 15
Complex Method,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,Cyclomatic complexity of the method is 15
Complex Method,Encog.Neural.NEAT.Training,NEATGenome,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,AddLink,Cyclomatic complexity of the method is 10
Complex Method,Encog.Neural.NEAT.Training,NEATGenome,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,AddNeuron,Cyclomatic complexity of the method is 10
Complex Method,Encog.Neural.NEAT.Training,NEATGenome,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,GetCompatibilityScore,Cyclomatic complexity of the method is 8
Complex Method,Encog.Neural.NEAT.Training,NEATTraining,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATTraining.cs,Iteration,Cyclomatic complexity of the method is 15
Complex Method,Encog.Neural.NEAT.Training,NEATTraining,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATTraining.cs,Crossover,Cyclomatic complexity of the method is 22
Complex Method,Encog.Neural.NEAT.Training,NEATTraining,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATTraining.cs,SpeciateAndCalculateSpawnLevels,Cyclomatic complexity of the method is 8
Complex Method,Encog.Neural.Networks,PersistBasicNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\PersistBasicNetwork.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,Encog.Neural.Networks.Structure,AnalyzeNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Structure\AnalyzeNetwork.cs,AnalyzeNetwork,Cyclomatic complexity of the method is 10
Complex Method,Encog.Neural.Networks.Training.NM,NelderMeadTraining,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,Iteration,Cyclomatic complexity of the method is 47
Complex Method,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,Cyclomatic complexity of the method is 30
Complex Method,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,Cyclomatic complexity of the method is 18
Complex Method,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,FindBestRange,Cyclomatic complexity of the method is 21
Complex Method,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,CalculateError,Cyclomatic complexity of the method is 23
Complex Method,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,ComputeDeriv,Cyclomatic complexity of the method is 35
Complex Method,Encog.Neural.Networks.Training.Propagation.Resilient,ResilientPropagation,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\Propagation\Resilient\ResilientPropagation.cs,UpdateWeight,Cyclomatic complexity of the method is 14
Complex Method,Encog.Neural.Networks.Training.Propagation.SCG,ScaledConjugateGradient,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\Propagation\SCG\ScaledConjugateGradient.cs,Iteration,Cyclomatic complexity of the method is 14
Complex Method,Encog.Neural.PNN,BasicPNN,C:\repos\neismit_emds\encog-core-cs\Neural\PNN\BasicPNN.cs,Compute,Cyclomatic complexity of the method is 21
Complex Method,Encog.Neural.Pnn,PersistBasicPNN,C:\repos\neismit_emds\encog-core-cs\Neural\PNN\PersistBasicPNN.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Encog.Neural.Prune,PruneIncremental,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneIncremental.cs,PerformJobUnit,Cyclomatic complexity of the method is 10
Complex Method,Encog.Neural.Prune,PruneIncremental,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneIncremental.cs,UpdateBest,Cyclomatic complexity of the method is 11
Complex Method,Encog.Neural.Prune,PruneSelective,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneSelective.cs,IncreaseNeuronCount,Cyclomatic complexity of the method is 11
Complex Method,Encog.Neural.Prune,PruneSelective,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneSelective.cs,Prune,Cyclomatic complexity of the method is 10
Complex Method,Encog.Neural.Prune,PruneSelective,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneSelective.cs,RandomizeNeuron,Cyclomatic complexity of the method is 8
Complex Method,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,Cyclomatic complexity of the method is 14
Complex Method,Encog.Neural.RBF.Training,SVD,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdfit,Cyclomatic complexity of the method is 14
Complex Method,Encog.Neural.RBF.Training,SVD,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdbksb,Cyclomatic complexity of the method is 9
Complex Method,Encog.Neural.RBF.Training,SVD,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,Cyclomatic complexity of the method is 71
Complex Method,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,Cyclomatic complexity of the method is 12
Complex Method,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,Cyclomatic complexity of the method is 12
Complex Method,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF1D,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF1D.cs,NeighborhoodRBF1D,Cyclomatic complexity of the method is 14
Complex Method,Encog.Persist,EncogReadHelper,C:\repos\neismit_emds\encog-core-cs\Persist\EncogReadHelper.cs,ReadNextSection,Cyclomatic complexity of the method is 15
Complex Method,Encog.ML.SVM,SupportVectorMachine,C:\repos\neismit_emds\encog-core-cs\ML\SVM\SupportVectorMachine.cs,SupportVectorMachine,Cyclomatic complexity of the method is 30
Complex Method,Encog.ML.SVM.Training,SVMSearchTrain,C:\repos\neismit_emds\encog-core-cs\ML\SVM\Training\SVMSearchTrain.cs,Iteration,Cyclomatic complexity of the method is 8
Complex Method,Encog.Plugin.SystemPlugin,SystemActivationPlugin,C:\repos\neismit_emds\encog-core-cs\Plugin\SystemPlugin\SystemActivationPlugin.cs,AllocateAF,Cyclomatic complexity of the method is 12
Complex Method,Encog.Plugin.SystemPlugin,SystemLoggingPlugin,C:\repos\neismit_emds\encog-core-cs\Plugin\SystemPlugin\SystemLoggingPlugin.cs,Log,Cyclomatic complexity of the method is 18
Complex Method,Encog.Plugin.SystemPlugin,SystemTrainingPlugin,C:\repos\neismit_emds\encog-core-cs\Plugin\SystemPlugin\SystemTrainingPlugin.cs,CreateTraining,Cyclomatic complexity of the method is 19
Complex Method,Encog.Util.Arrayutil,NormalizedField,C:\repos\neismit_emds\encog-core-cs\Util\Arrayutil\NormalizedField.cs,DetermineClass,Cyclomatic complexity of the method is 11
Complex Method,Encog.Util.Arrayutil,NormalizedField,C:\repos\neismit_emds\encog-core-cs\Util\Arrayutil\NormalizedField.cs,EncodeHeaders,Cyclomatic complexity of the method is 15
Complex Method,Encog.Util,YahooSearch,C:\repos\neismit_emds\encog-core-cs\Util\YahooSearch.cs,DoSearch,Cyclomatic complexity of the method is 8
Complex Method,Encog.Util.KMeans,KMeansUtil,C:\repos\neismit_emds\encog-core-cs\Util\KMeans\KMeansUtil.cs,InitRandomClusters,Cyclomatic complexity of the method is 8
Complex Method,Encog.Util.Normalize,DataNormalization,C:\repos\neismit_emds\encog-core-cs\Util\Normalize\DataNormalization.cs,BuildForNetworkInput,Cyclomatic complexity of the method is 10
Complex Method,Encog.Util.Time,NumericDateUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,Cyclomatic complexity of the method is 8
Complex Method,Encog.Util.Time,EnglishTimeUnitNames,C:\repos\neismit_emds\encog-core-cs\Util\Time\EnglishTimeUnitNames.cs,Code,Cyclomatic complexity of the method is 13
Complex Method,Encog.Util.Time,EnglishTimeUnitNames,C:\repos\neismit_emds\encog-core-cs\Util\Time\EnglishTimeUnitNames.cs,Plural,Cyclomatic complexity of the method is 13
Complex Method,Encog.Util.Time,EnglishTimeUnitNames,C:\repos\neismit_emds\encog-core-cs\Util\Time\EnglishTimeUnitNames.cs,Singular,Cyclomatic complexity of the method is 13
Complex Method,Encog.Util.Time,TimeSpanUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpan,Cyclomatic complexity of the method is 13
Complex Method,Encog.Parse.Tags.Read,ReadTags,C:\repos\neismit_emds\encog-core-cs\Parse\Tags\Read\ReadTags.cs,ParseSpecialCharacter,Cyclomatic complexity of the method is 9
Complex Method,Encog.Parse.Tags.Read,ReadTags,C:\repos\neismit_emds\encog-core-cs\Parse\Tags\Read\ReadTags.cs,ParseTag,Cyclomatic complexity of the method is 15
Complex Method,Encog.Parse.Tags.Read,ReadTags,C:\repos\neismit_emds\encog-core-cs\Parse\Tags\Read\ReadTags.cs,PeekEndTag,Cyclomatic complexity of the method is 8
Complex Method,Encog.Util.CSV,ReadCSV,C:\repos\neismit_emds\encog-core-cs\Util\CSV\ReadCSV.cs,ParseCharSep,Cyclomatic complexity of the method is 8
Complex Method,Encog.Util.DownSample,RGBDownsample,C:\repos\neismit_emds\encog-core-cs\Util\DownSample\RGBDownsample.cs,FindBounds,Cyclomatic complexity of the method is 9
Complex Method,Encog.Util.HTTP,URLUtility,C:\repos\neismit_emds\encog-core-cs\Util\HTTP\URLUtility.cs,ConvertFilename,Cyclomatic complexity of the method is 9
Long Parameter List,Encog.App.Analyst.CSV.Normalize,AnalystNormalizeCSV,C:\repos\neismit_emds\encog-core-cs\App\Analyst\CSV\Normalize\AnalystNormalizeCSV.cs,ExtractFields,The method has 5 parameters.
Long Parameter List,Encog.App.Analyst.Script.Normalize,AnalystField,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\Normalize\AnalystField.cs,AnalystField,The method has 6 parameters.
Long Parameter List,Encog.App.Analyst.Script.Normalize,AnalystField,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\Normalize\AnalystField.cs,MakeClass,The method has 5 parameters.
Long Parameter List,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,Wizard,The method has 5 parameters.
Long Parameter List,Encog.App.Quant.Loader.OpenQuant,OpenQuantLoader,C:\repos\neismit_emds\encog-core-cs\App\Quant\Loader\OpenQuant\OpenQuantLoader.cs,OpenquantDataLoader,The method has 5 parameters.
Long Parameter List,Encog.App.Quant.Loader.Yahoo,YahooDownload,C:\repos\neismit_emds\encog-core-cs\App\Quant\Loader\Yahoo\YahooDownload.cs,LoadAllData,The method has 5 parameters.
Long Parameter List,Encog.Bot,BotUtil,C:\repos\neismit_emds\encog-core-cs\Bot\BotUtil.cs,ExtractFromIndex,The method has 5 parameters.
Long Parameter List,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The method has 10 parameters.
Long Parameter List,Encog.MathUtil.LIBSVM,Solver_NU,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The method has 10 parameters.
Long Parameter List,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_c_svc,The method has 6 parameters.
Long Parameter List,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The method has 5 parameters.
Long Parameter List,Encog.MathUtil.Matrices,Matrix,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Matrix.cs,SetMatrix,The method has 5 parameters.
Long Parameter List,Encog.MathUtil.Matrices.Hessian,HessianFD,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Hessian\HessianFD.cs,ComputeDerivative,The method has 8 parameters.
Long Parameter List,Encog.ML.Bayesian,BayesianNetwork,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\BayesianNetwork.cs,IsCondIndependent,The method has 5 parameters.
Long Parameter List,Encog.ML.Bayesian.Training,TrainBayesian,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Training\TrainBayesian.cs,TrainBayesian,The method has 6 parameters.
Long Parameter List,Encog.ML.Bayesian.Training.Search.k2,SearchK2,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Training\Search\k2\SearchK2.cs,CalculateN,The method has 5 parameters.
Long Parameter List,Encog.ML.Data.Buffer.CODEC,CSVDataCODEC,C:\repos\neismit_emds\encog-core-cs\ML\Data\Buffer\CODEC\CSVDataCODEC.cs,CSVDataCODEC,The method has 6 parameters.
Long Parameter List,Encog.ML.Data.Image,ImageMLData,C:\repos\neismit_emds\encog-core-cs\ML\Data\Image\ImageMLData.cs,Downsample,The method has 6 parameters.
Long Parameter List,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The method has 5 parameters.
Long Parameter List,Encog.ML.Data.Market.Loader,CSVLoader,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVLoader.cs,ReadAndCallLoader,The method has 5 parameters.
Long Parameter List,Encog.ML.Data.Market,MarketDataDescription,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\MarketDataDescription.cs,MarketDataDescription,The method has 6 parameters.
Long Parameter List,Encog.ML.Data.Market,MarketDataDescription,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\MarketDataDescription.cs,MarketDataDescription,The method has 5 parameters.
Long Parameter List,Encog.ML.Data.Specific,CSVMLDataSet,C:\repos\neismit_emds\encog-core-cs\ML\Data\Specific\CSVMLDataSet.cs,CSVMLDataSet,The method has 6 parameters.
Long Parameter List,Encog.ML.Data.Temporal,TemporalDataDescription,C:\repos\neismit_emds\encog-core-cs\ML\Data\Temporal\TemporalDataDescription.cs,TemporalDataDescription,The method has 6 parameters.
Long Parameter List,Encog.ML.Train.Strategy,EarlyStoppingStrategy,C:\repos\neismit_emds\encog-core-cs\ML\Train\Strategy\EarlyStoppingStrategy.cs,EarlyStoppingStrategy,The method has 5 parameters.
Long Parameter List,Encog.Neural.Flat,FlatNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The method has 5 parameters.
Long Parameter List,Encog.Neural.NEAT,NEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\NEATNetwork.cs,NEATNetwork,The method has 6 parameters.
Long Parameter List,Encog.Neural.NEAT,NEATNeuron,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\NEATNeuron.cs,NEATNeuron,The method has 5 parameters.
Long Parameter List,Encog.Neural.NEAT.Training,NEATGenome,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,NEATGenome,The method has 5 parameters.
Long Parameter List,Encog.Neural.NEAT.Training,NEATInnovation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATInnovation.cs,NEATInnovation,The method has 7 parameters.
Long Parameter List,Encog.Neural.NEAT.Training,NEATInnovationList,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATInnovationList.cs,CreateNewInnovation,The method has 6 parameters.
Long Parameter List,Encog.Neural.NEAT.Training,NEATLinkGene,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATLinkGene.cs,NEATLinkGene,The method has 6 parameters.
Long Parameter List,Encog.Neural.Neat.Training,NEATNeuronGene,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATNeuronGene.cs,NEATNeuronGene,The method has 6 parameters.
Long Parameter List,Encog.Neural.Networks.Training.Anneal,NeuralSimulatedAnnealing,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\Anneal\NeuralSimulatedAnnealing.cs,NeuralSimulatedAnnealing,The method has 5 parameters.
Long Parameter List,Encog.Neural.Networks.Training.Genetic,NeuralGeneticAlgorithm,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\Genetic\NeuralGeneticAlgorithm.cs,NeuralGeneticAlgorithm,The method has 6 parameters.
Long Parameter List,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The method has 13 parameters.
Long Parameter List,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,FindNewDir,The method has 5 parameters.
Long Parameter List,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The method has 6 parameters.
Long Parameter List,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,FindBestRange,The method has 6 parameters.
Long Parameter List,Encog.Neural.Networks.Training.Propagation,GradientWorker,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\Propagation\GradientWorker.cs,GradientWorker,The method has 7 parameters.
Long Parameter List,Encog.Neural.Prune,PruneIncremental,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneIncremental.cs,PruneIncremental,The method has 6 parameters.
Long Parameter List,Encog.Neural.Prune,PruneSelective,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneSelective.cs,RandomizeNeuron,The method has 7 parameters.
Long Parameter List,Encog.Neural.RBF,RBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\RBFNetwork.cs,SetRBFCentersAndWidthsEqualSpacing,The method has 5 parameters.
Long Parameter List,Encog.Neural.RBF.Training,SVD,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdbksb,The method has 5 parameters.
Long Parameter List,Encog.Neural.SOM.Training.Neighborhood,BasicTrainSOM,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\BasicTrainSOM.cs,SetAutoDecay,The method has 5 parameters.
Long Parameter List,Encog.Plugin.SystemPlugin,SystemLoggingPlugin,C:\repos\neismit_emds\encog-core-cs\Plugin\SystemPlugin\SystemLoggingPlugin.cs,CalculateGradient,The method has 10 parameters.
Long Parameter List,Encog.Plugin.SystemPlugin,SystemLoggingPlugin,C:\repos\neismit_emds\encog-core-cs\Plugin\SystemPlugin\SystemLoggingPlugin.cs,CalculateLayer,The method has 7 parameters.
Long Parameter List,Encog.Util.Arrayutil,NormalizedField,C:\repos\neismit_emds\encog-core-cs\Util\Arrayutil\NormalizedField.cs,NormalizedField,The method has 6 parameters.
Long Parameter List,Encog.Util.Arrayutil,NormalizedField,C:\repos\neismit_emds\encog-core-cs\Util\Arrayutil\NormalizedField.cs,MakeClass,The method has 5 parameters.
Long Parameter List,Encog.Util.Banchmark,EncoderTrainingFactory,C:\repos\neismit_emds\encog-core-cs\Util\Banchmark\EncoderTrainingFactory.cs,GenerateTraining,The method has 6 parameters.
Long Parameter List,Encog.Util.Banchmark,RandomTrainingFactory,C:\repos\neismit_emds\encog-core-cs\Util\Banchmark\RandomTrainingFactory.cs,Generate,The method has 6 parameters.
Long Parameter List,Encog.Util.Banchmark,RandomTrainingFactory,C:\repos\neismit_emds\encog-core-cs\Util\Banchmark\RandomTrainingFactory.cs,Generate,The method has 5 parameters.
Long Parameter List,Encog.Util,EngineArray,C:\repos\neismit_emds\encog-core-cs\Util\EngineArray.cs,ArrayCopy,The method has 5 parameters.
Long Parameter List,Encog.Util.NetworkUtil,NetworkUtility,C:\repos\neismit_emds\encog-core-cs\Util\NetworkUtil\NetworkUtility.cs,BuildTrainNeatNetwork,The method has 5 parameters.
Long Parameter List,Encog.Util.Normalize.Output,BasicOutputField,C:\repos\neismit_emds\encog-core-cs\Util\Normalize\Output\BasicOutputField.cs,Calculate,The method has 5 parameters.
Long Parameter List,Encog.Util.Simple,TrainingSetUtil,C:\repos\neismit_emds\encog-core-cs\Util\Simple\TrainingSetUtil.cs,LoadCSVTOMemory,The method has 5 parameters.
Long Parameter List,Encog.Util.Simple,EncogUtility,C:\repos\neismit_emds\encog-core-cs\Util\Simple\EncogUtility.cs,ConvertCSV2Binary,The method has 7 parameters.
Long Parameter List,Encog.Util.Simple,EncogUtility,C:\repos\neismit_emds\encog-core-cs\Util\Simple\EncogUtility.cs,ConvertCSV2Binary,The method has 6 parameters.
Long Parameter List,Encog.Util.Simple,EncogUtility,C:\repos\neismit_emds\encog-core-cs\Util\Simple\EncogUtility.cs,LoadCSV2Memory,The method has 6 parameters.
Long Parameter List,Encog.Util.Simple,EncogUtility,C:\repos\neismit_emds\encog-core-cs\Util\Simple\EncogUtility.cs,SimpleFeedForward,The method has 5 parameters.
Long Statement,Encog.App.Analyst,ConsoleAnalystListener,C:\repos\neismit_emds\encog-core-cs\App\Analyst\ConsoleAnalystListener.cs,ReportCommandEnd,The length of the statement  "	Console.Out.WriteLine ("Task " + _currentTask + " " + cancelStr + "' task elapsed time " + Format.FormatTimeSpan ((int)(_stopwatch.ElapsedMilliseconds / Format.MiliInSec))); " is 173.
Long Statement,Encog.App.Analyst,ConsoleAnalystListener,C:\repos\neismit_emds\encog-core-cs\App\Analyst\ConsoleAnalystListener.cs,ReportTraining,The length of the statement  "	Console.Out.WriteLine ("Iteration #" + Format.FormatInteger (train.IterationNumber) + " Error:" + Format.FormatPercent (train.Error) + " elapsed time = " + Format.FormatTimeSpan ((int)(_stopwatch.ElapsedMilliseconds / Format.MiliInSec))); " is 238.
Long Statement,Encog.App.Analyst.CSV,EvaluateRawCSV,C:\repos\neismit_emds\encog-core-cs\App\Analyst\CSV\EvaluateRawCSV.cs,Analyze,The length of the statement  "		throw new AnalystError ("Invalid number of columns(" + InputHeadings.Length + ")' must match input(" + _inputCount + ") count or input+output(" + (_inputCount + _outputCount) + ") count."); " is 189.
Long Statement,Encog.App.Analyst.CSV,EvaluateRawCSV,C:\repos\neismit_emds\encog-core-cs\App\Analyst\CSV\EvaluateRawCSV.cs,Process,The length of the statement  "		throw new AnalystError ("This machine learning method has " + method.InputCount + " inputs' however' the data has " + _inputCount + " inputs."); " is 144.
Long Statement,Encog.App.Analyst.CSV,AnalystEvaluateRawCSV,C:\repos\neismit_emds\encog-core-cs\App\Analyst\CSV\AnalystEvaluateRawCSV.cs,Analyze,The length of the statement  "		throw new AnalystError ("Invalid number of columns(" + InputHeadings.Length + ")' must match input(" + _inputCount + ") count or input+output(" + (_inputCount + _outputCount) + ") count."); " is 189.
Long Statement,Encog.App.Analyst.CSV,AnalystEvaluateRawCSV,C:\repos\neismit_emds\encog-core-cs\App\Analyst\CSV\AnalystEvaluateRawCSV.cs,Process,The length of the statement  "		throw new AnalystError ("This machine learning method has " + method.InputCount + " inputs' however' the data has " + _inputCount + " inputs."); " is 144.
Long Statement,Encog.App.Analyst.Commands,CmdSegregate,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Commands\CmdSegregate.cs,ExecuteCommand,The length of the statement  "		EncogLogging.Log (EncogLogging.LevelDebug' "target file:" + target.File + "' Percent: " + Format.FormatPercent (target.Percent)); " is 129.
Long Statement,Encog.App.Analyst.Commands,CmdTrain,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Commands\CmdTrain.cs,PerformTraining,The length of the statement  "		while ((train.Error > targetError) && !Analyst.ShouldStopCommand () && !train.TrainingDone && ((maxIteration == -1) || (train.IterationNumber < maxIteration))); " is 160.
Long Statement,Encog.App.Analyst.Script,AnalystScript,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\AnalystScript.cs,FindNormalizedField,The length of the statement  "	return Normalize.NormalizedFields.FirstOrDefault (field => field.Name.Equals (name' StringComparison.InvariantCultureIgnoreCase) && (field.TimeSlice == slice)); " is 160.
Long Statement,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The length of the statement  "	if (currentSection.Equals ("SETUP") && currentSubsection.Equals ("CONFIG"' StringComparison.InvariantCultureIgnoreCase)) { " is 122.
Long Statement,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The length of the statement  "	else if (currentSection.Equals ("SETUP") && currentSubsection.Equals ("FILENAMES"' StringComparison.InvariantCultureIgnoreCase)) { " is 130.
Long Statement,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The length of the statement  "	else if (currentSection.Equals ("DATA") && currentSubsection.Equals ("CONFIG"' StringComparison.InvariantCultureIgnoreCase)) { " is 126.
Long Statement,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The length of the statement  "	else if (currentSection.Equals ("DATA") && currentSubsection.Equals ("STATS"' StringComparison.InvariantCultureIgnoreCase)) { " is 125.
Long Statement,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The length of the statement  "	else if (currentSection.Equals ("DATA") && currentSubsection.Equals ("CLASSES"' StringComparison.InvariantCultureIgnoreCase)) { " is 127.
Long Statement,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The length of the statement  "	else if (currentSection.Equals ("NORMALIZE") && currentSubsection.Equals ("RANGE"' StringComparison.InvariantCultureIgnoreCase)) { " is 130.
Long Statement,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The length of the statement  "	else if (currentSection.Equals ("NORMALIZE") && currentSubsection.Equals ("CONFIG"' StringComparison.InvariantCultureIgnoreCase)) { " is 131.
Long Statement,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The length of the statement  "	else if (currentSection.Equals ("NORMALIZE") && currentSubsection.Equals ("CONFIG"' StringComparison.InvariantCultureIgnoreCase)) { " is 131.
Long Statement,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The length of the statement  "	else if (currentSection.Equals ("CLUSTER") && currentSubsection.Equals ("CONFIG"' StringComparison.InvariantCultureIgnoreCase)) { " is 129.
Long Statement,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The length of the statement  "	else if (currentSection.Equals ("SERIES") && currentSubsection.Equals ("CONFIG"' StringComparison.InvariantCultureIgnoreCase)) { " is 128.
Long Statement,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The length of the statement  "	else if (currentSection.Equals ("RANDOMIZE") && currentSubsection.Equals ("CONFIG"' StringComparison.InvariantCultureIgnoreCase)) { " is 131.
Long Statement,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The length of the statement  "	else if (currentSection.Equals ("SEGREGATE") && currentSubsection.Equals ("CONFIG"' StringComparison.InvariantCultureIgnoreCase)) { " is 131.
Long Statement,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The length of the statement  "	else if (currentSection.Equals ("SEGREGATE") && currentSubsection.Equals ("FILES"' StringComparison.InvariantCultureIgnoreCase)) { " is 130.
Long Statement,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The length of the statement  "	else if (currentSection.Equals ("GENERATE") && currentSubsection.Equals ("CONFIG"' StringComparison.InvariantCultureIgnoreCase)) { " is 130.
Long Statement,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The length of the statement  "	else if (currentSection.Equals ("HEADER") && currentSubsection.Equals ("DATASOURCE"' StringComparison.InvariantCultureIgnoreCase)) { " is 132.
Long Statement,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The length of the statement  "	else if (currentSection.Equals ("ML") && currentSubsection.Equals ("CONFIG"' StringComparison.InvariantCultureIgnoreCase)) { " is 124.
Long Statement,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The length of the statement  "	else if (currentSection.Equals ("ML") && currentSubsection.Equals ("TRAIN"' StringComparison.InvariantCultureIgnoreCase)) { " is 123.
Long Statement,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The length of the statement  "	else if (currentSection.Equals ("BALANCE") && currentSubsection.Equals ("CONFIG"' StringComparison.InvariantCultureIgnoreCase)) { " is 129.
Long Statement,Encog.App.Analyst.Script,ScriptSave,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptSave.cs,SaveConfig,The length of the statement  "		xout.WriteProperty (key' f.DirectoryName.Equals (_script.BasePath' StringComparison.InvariantCultureIgnoreCase) ? f.Name : v); " is 126.
Long Statement,Encog.App.Analyst.Script.Normalize,AnalystField,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\Normalize\AnalystField.cs,DeNormalize,The length of the statement  "	double result = ((_actualLow - _actualHigh) * v - _normalizedHigh * _actualLow + _actualHigh * _normalizedLow) / (_normalizedLow - _normalizedHigh); " is 148.
Long Statement,Encog.App.Analyst.Script.Normalize,AnalystField,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\Normalize\AnalystField.cs,MakeClass,The length of the statement  "	if ((_action != NormalizationAction.Equilateral) && (_action != NormalizationAction.OneOf) && (_action != NormalizationAction.SingleField)) { " is 141.
Long Statement,Encog.App.Analyst.Script.Normalize,AnalystField,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\Normalize\AnalystField.cs,MakeClass,The length of the statement  "	if ((_action != NormalizationAction.Equilateral) && (_action != NormalizationAction.OneOf) && (_action != NormalizationAction.SingleField)) { " is 141.
Long Statement,Encog.App.Analyst.Script.Normalize,AnalystNormalize,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\Normalize\AnalystNormalize.cs,Init,The length of the statement  "		if ((norm.Action == NormalizationAction.Equilateral) || (norm.Action == NormalizationAction.OneOf) || (norm.Action == NormalizationAction.SingleField)) { " is 153.
Long Statement,Encog.App.Analyst.Util,CSVHeaders,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Util\CSVHeaders.cs,ValidateSameName,The length of the statement  "			if (_headerList.Where ((t' j) => i1 != j).Any (t => _headerList [i2].Equals (t' StringComparison.InvariantCultureIgnoreCase))) { " is 128.
Long Statement,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,DetermineClassification,The length of the statement  "	if ((_methodType == WizardMethodType.SVM) || (_methodType == WizardMethodType.SOM) || (_methodType == WizardMethodType.PNN)) { " is 126.
Long Statement,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,DetermineTargetField,The length of the statement  "			throw new AnalystError ("Can't determine target field automatically' " + "please specify one.\nThis can also happen if you " + "specified the wrong file format."); " is 163.
Long Statement,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The length of the statement  "		_script.Properties.SetProperty (ScriptProperties.MlTrainArguments' "maxParents=1'estimator=simple'search=none'init=naive"); " is 123.
Long Statement,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The length of the statement  "		_script.Properties.SetProperty (ScriptProperties.MlTrainArguments' "maxParents=1'estimator=simple'search=k2'init=naive"); " is 121.
Long Statement,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateNormalizedFields,The length of the statement  "			AnalystField af = _range == NormalizeRange.NegOne2One ? new AnalystField (f.Name' action' 1' -1) : new AnalystField (f.Name' action' 1' 0); " is 139.
Long Statement,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateNormalizedFields,The length of the statement  "			norm.Add (_range == NormalizeRange.NegOne2One ? new AnalystField (f.Name' action' 1' -1) : new AnalystField (f.Name' action' 1' 0)); " is 132.
Long Statement,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateSOM,The length of the statement  "	_script.Properties.SetProperty (ScriptProperties.MlTrainArguments' "ITERATIONS=1000'NEIGHBORHOOD=rbf1d'RBF_TYPE=gaussian"); " is 123.
Long Statement,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,Reanalyze,The length of the statement  "	_analyst.Analyze (rawFilename' _script.Properties.GetPropertyBoolean (ScriptProperties.SetupConfigInputHeaders)' _script.Properties.GetPropertyFormat (ScriptProperties.SetupConfigCSVFormat)); " is 191.
Long Statement,Encog.Engine.Network.Activation,ActivationGaussian,C:\repos\neismit_emds\encog-core-cs\Engine\Network\Activation\ActivationGaussian.cs,ActivationFunction,The length of the statement  "		x [i] = _paras [ParamGaussianPeak] * BoundMath.Exp (-Math.Pow (x [i] - _paras [ParamGaussianCenter]' 2) / (2.0d * _paras [ParamGaussianWidth] * _paras [ParamGaussianWidth])); " is 174.
Long Statement,Encog.Engine.Network.Activation,ActivationRamp,C:\repos\neismit_emds\encog-core-cs\Engine\Network\Activation\ActivationRamp.cs,Clone,The length of the statement  "	return new ActivationRamp (_paras [ParamRampHighThreshold]' _paras [ParamRampLowThreshold]' _paras [ParamRampHigh]' _paras [ParamRampLow]); " is 139.
Long Statement,Encog.Engine.Network.Activation,ActivationRamp,C:\repos\neismit_emds\encog-core-cs\Engine\Network\Activation\ActivationRamp.cs,ActivationFunction,The length of the statement  "	double slope = (_paras [ParamRampHighThreshold] - _paras [ParamRampLowThreshold]) / (_paras [ParamRampHigh] - _paras [ParamRampLow]); " is 133.
Long Statement,Encog.MathUtil.LIBSVM,SVC_Q,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,get_Q,The length of the statement  "			//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,ONE_CLASS_Q,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,get_Q,The length of the statement  "			//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,SVR_Q,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,get_Q,The length of the statement  "			//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_one_class,The length of the statement  "	//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The length of the statement  "		//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_svr_probability,The length of the statement  "                "Prob. model for test data: target value = predicted value + z'\nz: Laplace distribution e^(-|z|/sigma)/(2sigma)'sigma=" +" is 122.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The length of the statement  "	if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR) { " is 137.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The length of the statement  "		if (param.probability == 1 && (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR)) { " is 120.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The length of the statement  "			//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_cross_validation,The length of the statement  "		//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_get_svr_probability,The length of the statement  "	if ((model.param.svm_type == svm_parameter.EPSILON_SVR || model.param.svm_type == svm_parameter.NU_SVR) && model.probA != null) " is 127.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict_values,The length of the statement  "	if (model.param.svm_type == svm_parameter.ONE_CLASS || model.param.svm_type == svm_parameter.EPSILON_SVR || model.param.svm_type == svm_parameter.NU_SVR) { " is 155.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict,The length of the statement  "	if (model.param.svm_type == svm_parameter.ONE_CLASS || model.param.svm_type == svm_parameter.EPSILON_SVR || model.param.svm_type == svm_parameter.NU_SVR) { " is 155.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict_probability,The length of the statement  "	if ((model.param.svm_type == svm_parameter.C_SVC || model.param.svm_type == svm_parameter.NU_SVC) && model.probA != null && model.probB != null) { " is 146.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict_probability,The length of the statement  "				pairwise_prob [i] [j] = Math.Min (Math.Max (sigmoid_predict (dec_values [k]' model.probA [k]' model.probB [k])' min_prob)' 1 - min_prob); " is 137.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_save_model,The length of the statement  "	if (param.kernel_type == svm_parameter.POLY || param.kernel_type == svm_parameter.RBF || param.kernel_type == svm_parameter.SIGMOID) " is 132.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The length of the statement  "	if (svm_type != svm_parameter.C_SVC && svm_type != svm_parameter.NU_SVC && svm_type != svm_parameter.ONE_CLASS && svm_type != svm_parameter.EPSILON_SVR && svm_type != svm_parameter.NU_SVR) " is 188.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The length of the statement  "	if (kernel_type != svm_parameter.LINEAR && kernel_type != svm_parameter.POLY && kernel_type != svm_parameter.RBF && kernel_type != svm_parameter.SIGMOID) " is 153.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The length of the statement  "			//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_probability_model,The length of the statement  "	if (((model.param.svm_type == svm_parameter.C_SVC || model.param.svm_type == svm_parameter.NU_SVC) && model.probA != null && model.probB != null) || ((model.param.svm_type == svm_parameter.EPSILON_SVR || model.param.svm_type == svm_parameter.NU_SVR) && model.probA != null)) " is 274.
Long Statement,Encog.MathUtil.LIBSVM,svm_parameter,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm_parameter.cs,Clone,The length of the statement  "	//UPGRADE_NOTE: Exception 'java.lang.CloneNotSupportedException' was converted to 'System.Exception' which has different behavior. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1100_3"' " is 204.
Long Statement,Encog.MathUtil.Matrices,MatrixMath,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\MatrixMath.cs,Add,The length of the statement  "		throw new MatrixError ("To add the matrixes they must have the same number of rows and columns.  Matrix a has " + a.Rows + " rows and matrix b has " + b.Rows + " rows."); " is 170.
Long Statement,Encog.MathUtil.Matrices,MatrixMath,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\MatrixMath.cs,Add,The length of the statement  "		throw new MatrixError ("To add the matrixes they must have the same number of rows and columns.  Matrix a has " + a.Cols + " cols and matrix b has " + b.Cols + " cols."); " is 170.
Long Statement,Encog.MathUtil.Matrices,MatrixMath,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\MatrixMath.cs,Multiply,The length of the statement  "		throw new MatrixError ("To use ordinary matrix multiplication the number of columns on the first matrix must mat the number of rows on the second."); " is 149.
Long Statement,Encog.MathUtil.Matrices,MatrixMath,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\MatrixMath.cs,Subtract,The length of the statement  "		throw new MatrixError ("To subtract the matrixes they must have the same number of rows and columns.  Matrix a has " + a.Rows + " rows and matrix b has " + b.Rows + " rows."); " is 175.
Long Statement,Encog.MathUtil.Matrices,MatrixMath,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\MatrixMath.cs,Subtract,The length of the statement  "		throw new MatrixError ("To subtract the matrixes they must have the same number of rows and columns.  Matrix a has " + a.Cols + " cols and matrix b has " + b.Cols + " cols."); " is 175.
Long Statement,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The length of the statement  "				if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) { " is 165.
Long Statement,Encog.ML.Bayesian,BayesianNetwork,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\BayesianNetwork.cs,DefineProbability,The length of the statement  "		throw new BayesianError ("Probability must be of the form \"P(event|condition1'condition2'etc.)=0.5\".  Conditions are optional."); " is 131.
Long Statement,Encog.ML.Bayesian.Table,BayesianTable,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Table\BayesianTable.cs,AddLine,The length of the statement  "		throw new BayesianError ("Truth table line with " + args.Length + "' specified for event with " + _event.Parents.Count + " parents.  These numbers must be the same"); " is 166.
Long Statement,Encog.ML.Bayesian.Table,BayesianTable,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Table\BayesianTable.cs,Validate,The length of the statement  "		throw new BayesianError ("Truth table for " + _event.ToString () + " only has " + _lines.Count + " line(s)' should have " + this.MaxLines + " line(s)."); " is 153.
Long Statement,Encog.ML.Data.Buffer.CODEC,CSVDataCODEC,C:\repos\neismit_emds\encog-core-cs\ML\Data\Buffer\CODEC\CSVDataCODEC.cs,PrepareRead,The length of the statement  "		throw new BufferedDataError ("To import CSV' you must use the CSVDataCODEC constructor that specifies input and ideal sizes."); " is 127.
Long Statement,Encog.ML.Data.Image,ImageMLDataSet,C:\repos\neismit_emds\encog-core-cs\ML\Data\Image\ImageMLDataSet.cs,Downsample,The length of the statement  "			throw new NeuralNetworkError ("Invalid class type found in ImageNeuralDataSet' only " + "ImageNeuralData items are allowed."); " is 126.
Long Statement,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The length of the statement  "	//In case we want to use a different date format...and have used the SetDateFormat method' our DateFormat must then not be null.. " is 129.
Long Statement,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The length of the statement  "			Console.WriteLine (@"Current DateTime:" + ParsedDate.ToShortDateString () + @" Time:" + ParsedDate.ToShortTimeString () + @"  Asked Start date was " + from.ToShortDateString ()); " is 178.
Long Statement,Encog.ML.Factory.Train,GeneticFactory,C:\repos\neismit_emds\encog-core-cs\ML\Factory\Train\GeneticFactory.cs,Create,The length of the statement  "	IMLTrain train = new NeuralGeneticAlgorithm ((BasicNetwork)method' new RangeRandomizer (-1' 1)' score' populationSize' mutation' mate); " is 135.
Long Statement,Encog.ML.Genetic.Genome,BasicGenome,C:\repos\neismit_emds\encog-core-cs\ML\Genetic\Genome\BasicGenome.cs,Mate,The length of the statement  "		throw new GeneticError ("Mother and father must have same chromosome count' Mother:" + motherChromosomes + "'Father:" + fatherChromosomes); " is 139.
Long Statement,Encog.ML.HMM.Alog,KullbackLeiblerDistanceCalculator,C:\repos\neismit_emds\encog-core-cs\ML\HMM\Alog\KullbackLeiblerDistanceCalculator.cs,Distance,The length of the statement  "		distance += (new ForwardBackwardScaledCalculator (oseq' hmm1).LnProbability () - new ForwardBackwardScaledCalculator (oseq' hmm2).LnProbability ()) / Len; " is 154.
Long Statement,Encog.ML.HMM,HiddenMarkovModel,C:\repos\neismit_emds\encog-core-cs\ML\HMM\HiddenMarkovModel.cs,Probability,The length of the statement  "		probability *= _stateDistributions [i].Probability (oseqIterator.Current) * _transitionProbability [states [i]] [states [i + 1]]; " is 129.
Long Statement,Encog.ML.HMM.Train.BW,TrainBaumWelch,C:\repos\neismit_emds\encog-core-cs\ML\HMM\Train\BW\TrainBaumWelch.cs,EstimateXi,The length of the statement  "				xi [t] [i] [j] = (fbc.AlphaElement (t' i) * hmm.TransitionProbability [i] [j] * hmm.StateDistributions [j].Probability (o) * fbc.BetaElement (t + 1' j)) / probability; " is 167.
Long Statement,Encog.ML.HMM.Train.BW,TrainBaumWelchScaled,C:\repos\neismit_emds\encog-core-cs\ML\HMM\Train\BW\TrainBaumWelchScaled.cs,EstimateXi,The length of the statement  "				xi [t] [i] [j] = fbc.AlphaElement (t' i) * hmm.TransitionProbability [i] [j] * hmm.StateDistributions [j].Probability (observation) * fbc.BetaElement (t + 1' j); " is 161.
Long Statement,Encog.ML.Train.Strategy,RequiredImprovementStrategy,C:\repos\neismit_emds\encog-core-cs\ML\Train\Strategy\RequiredImprovementStrategy.cs,Init,The length of the statement  "		throw new TrainingError ("To use the required improvement strategy the machine learning method must support MLResettable."); " is 124.
Long Statement,Encog.Neural.ART,ART1,C:\repos\neismit_emds\encog-core-cs\Neural\ART\ART1.cs,ComputeF1,The length of the statement  "		double activation = (((input.GetBoolean (i)) ? 1 : 0) + _d1 * sum - _b1) / (1 + _a1 * (((input.GetBoolean (i)) ? 1 : 0) + _d1 * sum) + _c1); " is 140.
Long Statement,Encog.Neural.BAM,BAMNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\BAM\BAMNetwork.cs,Compute,The length of the statement  "	throw new NeuralNetworkError ("Compute on BasicNetwork cannot be used' rather call" + " the compute(NeuralData) method on the BAMLogic."); " is 138.
Long Statement,Encog.Neural.CPN.Training,TrainInstar,C:\repos\neismit_emds\encog-core-cs\Neural\CPN\Training\TrainInstar.cs,InitWeights,The length of the statement  "		throw new NeuralNetworkError ("If the weights are to be set from the " + "training data' then there must be one instar " + "neuron for each training element."); " is 160.
Long Statement,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The length of the statement  "			result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (p' NEATPopulation.PropertyOutputActivation); " is 120.
Long Statement,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The length of the statement  "			result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation); " is 120.
Long Statement,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The length of the statement  "			result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation); " is 124.
Long Statement,Encog.Neural.NEAT.Training,NEATGenome,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,AddLink,The length of the statement  "			if (!neuronGene.Recurrent && (neuronGene.NeuronType != NEATNeuronType.Bias) && (neuronGene.NeuronType != NEATNeuronType.Input)) { " is 129.
Long Statement,Encog.Neural.NEAT.Training,NEATGenome,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,AddLink,The length of the statement  "			if (!IsDuplicateLink (neuron1ID' neuron2ID) && (neuron1.Id != neuron2.Id) && (neuron2.NeuronType != NEATNeuronType.Bias)) { " is 123.
Long Statement,Encog.Neural.NEAT.Training,NEATGenome,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,AddLink,The length of the statement  "	NEATInnovation innovation = ((NEATTraining)GA).Innovations.CheckInnovation (neuron1ID' neuron1ID' NEATInnovationType.NewLink); " is 126.
Long Statement,Encog.Neural.NEAT.Training,NEATGenome,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,AddLink,The length of the statement  "		var linkGene_1 = new NEATLinkGene (neuron1ID' neuron2ID' true' innovation.InnovationID' RangeRandomizer.Randomize (-1' 1)' recurrent); " is 134.
Long Statement,Encog.Neural.NEAT.Training,NEATGenome,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,AddNeuron,The length of the statement  "		if ((link.Enabled) && (!link.Recurrent) && (((NEATNeuronGene)Neurons.Get (GetElementPos (fromNeuron))).NeuronType != NEATNeuronType.Bias)) { " is 140.
Long Statement,Encog.Neural.NEAT.Training,NEATGenome,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,AddNeuron,The length of the statement  "		long newNeuronID = ((NEATTraining)GA).Innovations.CreateNewInnovation (from' to' NEATInnovationType.NewNeuron' NEATNeuronType.Hidden' newWidth' newDepth); " is 154.
Long Statement,Encog.Neural.NEAT.Training,NEATGenome,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,AddNeuron,The length of the statement  "		NEATInnovation innovationLink1 = ((NEATTraining)GA).Innovations.CheckInnovation (from' newNeuronID_0' NEATInnovationType.NewLink); " is 130.
Long Statement,Encog.Neural.NEAT.Training,NEATGenome,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,AddNeuron,The length of the statement  "		NEATInnovation innovationLink2 = ((NEATTraining)GA).Innovations.CheckInnovation (newNeuronID_0' to' NEATInnovationType.NewLink); " is 128.
Long Statement,Encog.Neural.NEAT.Training,NEATGenome,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,Decode,The length of the statement  "		var neuron = new NEATNeuron (neuronGene.NeuronType' neuronGene.Id' neuronGene.SplitY' neuronGene.SplitX' neuronGene.ActivationResponse); " is 136.
Long Statement,Encog.Neural.NEAT.Training,NEATGenome,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,Decode,The length of the statement  "	var network = new NEATNetwork (inputCount' outputCount' neurons' pop.NeatActivationFunction' pop.OutputActivationFunction' 0); " is 126.
Long Statement,Encog.Neural.NEAT.Training,NEATGenome,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,GetCompatibilityScore,The length of the statement  "			weightDifference += Math.Abs (((NEATLinkGene)linksChromosome.Get (g1)).Weight - ((NEATLinkGene)genome.Links.Get (g2)).Weight); " is 126.
Long Statement,Encog.Neural.NEAT.Training,NEATGenome,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,GetCompatibilityScore,The length of the statement  "	double score = (TWEAK_EXCESS * numExcess / longest) + (TWEAK_DISJOINT * numDisjoint / longest) + (TWEAK_MATCHED * weightDifference / numMatched); " is 145.
Long Statement,Encog.Neural.NEAT.Training,NEATTraining,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATTraining.cs,Crossover,The length of the statement  "	var babyGenome = new NEATGenome (Population.AssignGenomeID ()' babyNeurons' babyGenes' mom.InputCount' mom.OutputCount); " is 120.
Long Statement,Encog.Neural.Networks,BasicNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\BasicNetwork.cs,Compute,The length of the statement  "		throw new NeuralNetworkError ("Index exception: there was likely a mismatch between layer sizes' or the size of the input presented to the network."' ex); " is 154.
Long Statement,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The length of the statement  "		EncogLogging.Log (EncogLogging.LevelInfo' "Beginning internal Iteration #" + iteration + "' currentError=" + fbest + "'target=" + maxError); " is 140.
Long Statement,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,ComputeDeriv,The length of the statement  "			der2 = _w [outvar * _network.InputCount + ivar] + 2.0d * xout [outvar] * vtot * vtot - 2.0d * _v [outvar * _network.InputCount + ivar] * vtot - xout [outvar] * wtot; " is 165.
Long Statement,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,Iteration,The length of the statement  "	double d = dermin.Calculate (32767' _maxError' 1.0e-8d' _minImprovement' this' _network.InputCount' x' globalMinimum.Y2' bs' direc' g' h' dwk2); " is 144.
Long Statement,Encog.Neural.Networks.Training.Propagation,GradientWorker,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\Propagation\GradientWorker.cs,Process,The length of the statement  "		_layerDelta [i] = (_network.ActivationFunctions [0].DerivativeFunction (_layerSums [i]' _layerOutput [i]) + _flatSpot [0]) * _layerDelta [i] * s; " is 145.
Long Statement,Encog.Neural.Networks.Training.Propagation,Propagation,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\Propagation\Propagation.cs,Init,The length of the statement  "		_workers [index++] = new GradientWorker (((FlatNetwork)_network.Flat.Clone ())' this' _indexable.OpenAdditional ()' r.Low' r.High' _flatSpot' ErrorFunction); " is 157.
Long Statement,Encog.Neural.Networks.Training.PSO,NeuralPSO,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PSO\NeuralPSO.cs,IsScoreBetter,The length of the statement  "	return ((m_calculateScore.ShouldMinimize && (score1 < score2)) || ((!m_calculateScore.ShouldMinimize) && (score1 > score2))); " is 125.
Long Statement,Encog.Neural.Prune,PruneIncremental,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneIncremental.cs,Process,The length of the statement  "		throw new EncogError ("To calculate the optimal hidden size' at least " + "one neuron must be the minimum for the first hidden layer."); " is 136.
Long Statement,Encog.Neural.Prune,PruneSelective,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneSelective.cs,Prune,The length of the statement  "		throw new NeuralNetworkError ("A layer must have at least a single neuron.  If you want to remove the entire layer you must create a new network."); " is 148.
Long Statement,Encog.Neural.RBF,RBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\RBFNetwork.cs,SetRBFCentersAndWidthsEqualSpacing,The length of the statement  "		throw new NeuralNetworkError ("Total number of RBF neurons must be some integer to the power of 'dimensions'.\n" + Format.FormatDouble (expectedSideLength' 5) + " <> " + Format.FormatDouble (cmp' 5)); " is 200.
Long Statement,Encog.Neural.RBF,RBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\RBFNetwork.cs,SetRBFCentersAndWidthsEqualSpacing,The length of the statement  "			centers [i] [j - 1] = ((int)(temp / Math.Pow (sideLength' j - 1)) * (disMinMaxPosition / (sideLength - 1))) + minPosition; " is 122.
Long Statement,Encog.Neural.SOM,SOMNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\SOMNetwork.cs,Classify,The length of the statement  "		throw new NeuralNetworkError ("Can't classify SOM with input size of " + InputCount + " with input data of count " + input.Count); " is 130.
Long Statement,Encog.Neural.Thermal,HopfieldNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Thermal\HopfieldNetwork.cs,AddPattern,The length of the statement  "		throw new NeuralNetworkError ("Network with " + NeuronCount + " neurons' cannot learn a pattern of size " + pattern.Count); " is 123.
Long Statement,Encog.Neural.Thermal,ThermalNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Thermal\ThermalNetwork.cs,Init,The length of the statement  "		throw new NeuralNetworkError ("Weight count(" + weights.Length + ") must be the square of the neuron count(" + neuronCount + ")."); " is 131.
Long Statement,Encog.Persist,EncogDirectoryPersistence,C:\repos\neismit_emds\encog-core-cs\Persist\EncogDirectoryPersistence.cs,LoadObject,The length of the statement  "		throw new PersistError ("The file you are trying to read is from a later version of Encog.  Please upgrade Encog to read this file."); " is 134.
Long Statement,Encog.Persist,EncogDirectoryPersistence,C:\repos\neismit_emds\encog-core-cs\Persist\EncogDirectoryPersistence.cs,SaveObject,The length of the statement  "		pw.WriteLine ("encog'" + p.PersistClassString + "'java'" + EncogFramework.Version + "'" + p.FileVersion + "'" + (now.Ticks / 10000)); " is 133.
Long Statement,Encog.Persist,EncogReadHelper,C:\repos\neismit_emds\encog-core-cs\Persist\EncogReadHelper.cs,ReadNextSection,The length of the statement  "						throw new PersistError ("Can't begin subsection " + line + "' while we are still in the section: " + currentSectionName); " is 121.
Long Statement,Encog.Util.Arrayutil,NormalizationActionExtension,C:\repos\neismit_emds\encog-core-cs\Util\Arrayutil\NormalizationActionExtension.cs,IsClassify,The length of the statement  "	return (extensionParam == NormalizationAction.OneOf) || (extensionParam == NormalizationAction.SingleField) || (extensionParam == NormalizationAction.Equilateral); " is 163.
Long Statement,Encog.Util.Arrayutil,NormalizedField,C:\repos\neismit_emds\encog-core-cs\Util\Arrayutil\NormalizedField.cs,DeNormalize,The length of the statement  "	double result = ((_actualLow - _actualHigh) * v - _normalizedHigh * _actualLow + _actualHigh * _normalizedLow) / (_normalizedLow - _normalizedHigh); " is 148.
Long Statement,Encog.Util.Arrayutil,NormalizedField,C:\repos\neismit_emds\encog-core-cs\Util\Arrayutil\NormalizedField.cs,MakeClass,The length of the statement  "	if ((theAction != NormalizationAction.Equilateral) && (theAction != NormalizationAction.OneOf) && (theAction != NormalizationAction.SingleField)) { " is 147.
Long Statement,Encog.Util.Arrayutil,NormalizedField,C:\repos\neismit_emds\encog-core-cs\Util\Arrayutil\NormalizedField.cs,MakeClass,The length of the statement  "	if ((theAction != NormalizationAction.Equilateral) && (theAction != NormalizationAction.OneOf) && (theAction != NormalizationAction.SingleField)) { " is 147.
Long Statement,Encog.Util,EncogValidate,C:\repos\neismit_emds\encog-core-cs\Util\EncogValidate.cs,ValidateNetworkForTraining,The length of the statement  "		throw new NeuralNetworkError ("The input layer size of " + inputCount + " must match the training input size of " + training.InputSize + "."); " is 142.
Long Statement,Encog.Util,EncogValidate,C:\repos\neismit_emds\encog-core-cs\Util\EncogValidate.cs,ValidateNetworkForTraining,The length of the statement  "		throw new NeuralNetworkError ("The output layer size of " + outputCount + " must match the training input size of " + training.IdealSize + "."); " is 144.
Long Statement,Encog.Util,ParamsHolder,C:\repos\neismit_emds\encog-core-cs\Util\ParamsHolder.cs,GetBoolean,The length of the statement  "	if (!str.Equals ("true"' StringComparison.InvariantCultureIgnoreCase) && !str.Equals ("false"' StringComparison.InvariantCultureIgnoreCase)) { " is 142.
Long Statement,Encog.Util.NetworkUtil,TrainerHelper,C:\repos\neismit_emds\encog-core-cs\Util\NetworkUtil\TrainerHelper.cs,MakeDataSet,The length of the statement  "	set = new BasicMLDataSet ((double[][])FirstList.ToArray (typeof(double[]))' (double[][])outputsar.ToArray (typeof(double[]))); " is 126.
Long Statement,Encog.Util.Normalize,DataNormalization,C:\repos\neismit_emds\encog-core-cs\Util\Normalize\DataNormalization.cs,BuildForNetworkInput,The length of the statement  "				throw new NormalizationError ("Can't build data' input fields used for neural input' must match provided data(" + data.Length + ")."); " is 134.
Long Statement,Encog.Util.Simple,EncogUtility,C:\repos\neismit_emds\encog-core-cs\Util\Simple\EncogUtility.cs,Evaluate,The length of the statement  "		Console.WriteLine (@"Input=" + FormatNeuralData (pair.Input) + @"' Actual=" + FormatNeuralData (output) + @"' Ideal=" + FormatNeuralData (pair.Ideal)); " is 151.
Long Statement,Encog.Util.Simple,EncogUtility,C:\repos\neismit_emds\encog-core-cs\Util\Simple\EncogUtility.cs,TrainConsole,The length of the statement  "		Console.WriteLine (@"Iteration #" + Format.FormatInteger (epoch) + @" Error:" + Format.FormatPercent (train.Error) + @" elapsed time = " + Format.FormatTimeSpan ((int)elapsed) + @" time left = " + Format.FormatTimeSpan ((int)remaining * 60)); " is 242.
Long Statement,Encog.Util.Simple,EncogUtility,C:\repos\neismit_emds\encog-core-cs\Util\Simple\EncogUtility.cs,TrainConsole,The length of the statement  "		Console.WriteLine (@"Iteration #" + Format.FormatInteger (epoch) + @" Error:" + Format.FormatPercent (train.Error) + @" elapsed time = " + Format.FormatTimeSpan ((int)elapsed) + @" time left = " + Format.FormatTimeSpan ((int)remaining)); " is 237.
Long Statement,Encog.Util.Simple,EncogUtility,C:\repos\neismit_emds\encog-core-cs\Util\Simple\EncogUtility.cs,TrainToError,The length of the statement  "		Console.WriteLine (@"Iteration #" + Format.FormatInteger (epoch) + @" Error:" + Format.FormatPercent (train.Error) + @" Target Error: " + Format.FormatPercent (error)); " is 168.
Long Statement,Encog.Util.Simple,EncogUtility,C:\repos\neismit_emds\encog-core-cs\Util\Simple\EncogUtility.cs,TrainToError,The length of the statement  "		Console.Out.WriteLine (@"Iteration #" + Format.FormatInteger (epoch) + @" Error:" + Format.FormatPercent (train.Error) + @" Target Error: " + Format.FormatPercent (error)); " is 172.
Long Statement,Encog.Parse.Tags.Read,ReadTags,C:\repos\neismit_emds\encog-core-cs\Parse\Tags\Read\ReadTags.cs,ParseAttributeName,The length of the statement  "		while (!char.IsWhiteSpace ((char)_source.Peek ()) && (_source.Peek () != '=') && (_source.Peek () != '>') && (_source.Peek () != -1)) { " is 135.
Long Statement,Encog.Parse.Tags.Read,ReadTags,C:\repos\neismit_emds\encog-core-cs\Parse\Tags\Read\ReadTags.cs,Read,The length of the statement  "		if ((_tag.TagType == Tag.Type.Begin) && ((StringUtil.EqualsIgnoreCase (_tag.Name' "script")) || (StringUtil.EqualsIgnoreCase (_tag.Name' "style")))) { " is 150.
Long Statement,Encog.Util.Validate,ValidateNetwork,C:\repos\neismit_emds\encog-core-cs\Util\Validate\ValidateNetwork.cs,ValidateMethodToData,The length of the statement  "		throw new EncogError ("The machine learning method has an input length of " + methodInputCount + "' but the training data has " + trainingInputCount + ". They must be the same."); " is 179.
Long Statement,Encog.Util.Validate,ValidateNetwork,C:\repos\neismit_emds\encog-core-cs\Util\Validate\ValidateNetwork.cs,ValidateMethodToData,The length of the statement  "			throw new EncogError ("The machine learning method has an output length of " + methodOutputCount + "' but the training data has " + trainingOutputCount + ". They must be the same."); " is 182.
Complex Conditional,Encog.App.Analyst.Commands,CmdTrain,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Commands\CmdTrain.cs,PerformTraining,The conditional expression  "(train.Error > targetError) && !Analyst.ShouldStopCommand () && !train.TrainingDone && ((maxIteration == -1) || (train.IterationNumber < maxIteration))"  is complex.
Complex Conditional,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict_probability,The conditional expression  "(model.param.svm_type == svm_parameter.C_SVC || model.param.svm_type == svm_parameter.NU_SVC) && model.probA != null && model.probB != null"  is complex.
Complex Conditional,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The conditional expression  "svm_type != svm_parameter.C_SVC && svm_type != svm_parameter.NU_SVC && svm_type != svm_parameter.ONE_CLASS && svm_type != svm_parameter.EPSILON_SVR && svm_type != svm_parameter.NU_SVR"  is complex.
Complex Conditional,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The conditional expression  "kernel_type != svm_parameter.LINEAR && kernel_type != svm_parameter.POLY && kernel_type != svm_parameter.RBF && kernel_type != svm_parameter.SIGMOID"  is complex.
Complex Conditional,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_probability_model,The conditional expression  "((model.param.svm_type == svm_parameter.C_SVC || model.param.svm_type == svm_parameter.NU_SVC) && model.probA != null && model.probB != null) || ((model.param.svm_type == svm_parameter.EPSILON_SVR || model.param.svm_type == svm_parameter.NU_SVR) && model.probA != null)"  is complex.
Virtual Method Call from Constructor,Encog.ML.Data.Basic,BasicMLDataSet,C:\repos\neismit_emds\encog-core-cs\ML\Data\Basic\BasicMLDataSet.cs,BasicMLDataSet,The constructor "BasicMLDataSet" calls a virtual method "Add".
Virtual Method Call from Constructor,Encog.ML.Data.Basic,BasicMLDataSet,C:\repos\neismit_emds\encog-core-cs\ML\Data\Basic\BasicMLDataSet.cs,BasicMLDataSet,The constructor "BasicMLDataSet" calls a virtual method "Add".
Empty Catch Block,Encog.ML.Bayesian.Parse,ParsedEvent,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Parse\ParsedEvent.cs,ResolveValue,The method has an empty catch block.
Magic Number,Encog.App.Analyst.Analyze,AnalyzedField,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Analyze\AnalyzedField.cs,Analyze2,The following statement contains a magic number: if (Real || Integer) {  	if (!str.Equals ("") && !str.Equals ("?")) {  		double d = this._script.DetermineFormat ().Parse (str);  		_devTotal += Math.Pow ((d - Mean)' 2);  	}  }  
Magic Number,Encog.App.Analyst.Analyze,AnalyzedField,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Analyze\AnalyzedField.cs,Analyze2,The following statement contains a magic number: if (!str.Equals ("") && !str.Equals ("?")) {  	double d = this._script.DetermineFormat ().Parse (str);  	_devTotal += Math.Pow ((d - Mean)' 2);  }  
Magic Number,Encog.App.Analyst.Analyze,AnalyzedField,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Analyze\AnalyzedField.cs,Analyze2,The following statement contains a magic number: _devTotal += Math.Pow ((d - Mean)' 2);  
Magic Number,Encog.App.Analyst.Analyze,AnalyzedField,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Analyze\AnalyzedField.cs,FinalizeField,The following statement contains a magic number: if (Math.Abs (Max - Min) < EncogFramework.DefaultDoubleEqual) {  	result.Min = Min - 0.0001;  	result.Max = Min + 0.0001;  }  
Magic Number,Encog.App.Analyst.Analyze,AnalyzedField,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Analyze\AnalyzedField.cs,FinalizeField,The following statement contains a magic number: if (Math.Abs (Max - Min) < EncogFramework.DefaultDoubleEqual) {  	result.Min = Min - 0.0001;  	result.Max = Min + 0.0001;  }  
Magic Number,Encog.App.Analyst.Analyze,AnalyzedField,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Analyze\AnalyzedField.cs,FinalizeField,The following statement contains a magic number: result.Min = Min - 0.0001;  
Magic Number,Encog.App.Analyst.Analyze,AnalyzedField,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Analyze\AnalyzedField.cs,FinalizeField,The following statement contains a magic number: result.Max = Min + 0.0001;  
Magic Number,Encog.App.Analyst.Commands,CmdTrain,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Commands\CmdTrain.cs,ObtainCross,The following statement contains a magic number: if (cross.ToLower ().StartsWith ("kfold:")) {  	String str = cross.Substring (6);  	try {  		return Int32.Parse (str);  	}  	catch (FormatException) {  		throw new AnalystError ("Invalid kfold :" + str);  	}  }  
Magic Number,Encog.App.Analyst.CSV.Basic,LoadedRow,C:\repos\neismit_emds\encog-core-cs\App\Analyst\CSV\Basic\LoadedRow.cs,LoadedRow,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	_data [i] = format.Format (data [i]' 5);  }  
Magic Number,Encog.App.Analyst.CSV.Basic,LoadedRow,C:\repos\neismit_emds\encog-core-cs\App\Analyst\CSV\Basic\LoadedRow.cs,LoadedRow,The following statement contains a magic number: _data [i] = format.Format (data [i]' 5);  
Magic Number,Encog.App.Analyst.CSV.Segregate,SegregateCSV,C:\repos\neismit_emds\encog-core-cs\App\Analyst\CSV\Segregate\SegregateCSV.cs,BalanceTargets,The following statement contains a magic number: foreach (SegregateTargetPercent p in _targets) {  	SegregateTargetPercent stp = p;  	// assign a number of records to this  	double percent = stp.Percent / 100.0;  	var c = (int)(RecordCount * percent);  	stp.NumberRemaining = c;  	// track the smallest group  	if ((smallestItem == null) || (smallestItem.Percent > stp.Percent)) {  		smallestItem = stp;  	}  	numberAssigned += c;  }  
Magic Number,Encog.App.Analyst.CSV.Segregate,SegregateCSV,C:\repos\neismit_emds\encog-core-cs\App\Analyst\CSV\Segregate\SegregateCSV.cs,Validate,The following statement contains a magic number: if (_targets.Count < 2) {  	throw new QuantError ("There must be at least two segregation targets.");  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataClasses,The following statement contains a magic number: foreach (String line in section.Lines) {  	if (!first) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols.Count < ColumnFour) {  			throw new AnalystError ("Invalid data class: " + line);  		}  		String field = cols [0];  		String code = cols [1];  		String name = cols [2];  		int count = Int32.Parse (cols [3]);  		DataField df = _script.FindDataField (field);  		if (df == null) {  			throw new AnalystError ("Attempting to add class to unknown field: " + name);  		}  		List<AnalystClassItem> classItems;  		if (!map.ContainsKey (field)) {  			classItems = new List<AnalystClassItem> ();  			map [field] = classItems;  		}  		else {  			classItems = map [field];  		}  		classItems.Add (new AnalystClassItem (code' name' count));  	}  	else {  		first = false;  	}  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataClasses,The following statement contains a magic number: foreach (String line in section.Lines) {  	if (!first) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols.Count < ColumnFour) {  			throw new AnalystError ("Invalid data class: " + line);  		}  		String field = cols [0];  		String code = cols [1];  		String name = cols [2];  		int count = Int32.Parse (cols [3]);  		DataField df = _script.FindDataField (field);  		if (df == null) {  			throw new AnalystError ("Attempting to add class to unknown field: " + name);  		}  		List<AnalystClassItem> classItems;  		if (!map.ContainsKey (field)) {  			classItems = new List<AnalystClassItem> ();  			map [field] = classItems;  		}  		else {  			classItems = map [field];  		}  		classItems.Add (new AnalystClassItem (code' name' count));  	}  	else {  		first = false;  	}  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataClasses,The following statement contains a magic number: if (!first) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	if (cols.Count < ColumnFour) {  		throw new AnalystError ("Invalid data class: " + line);  	}  	String field = cols [0];  	String code = cols [1];  	String name = cols [2];  	int count = Int32.Parse (cols [3]);  	DataField df = _script.FindDataField (field);  	if (df == null) {  		throw new AnalystError ("Attempting to add class to unknown field: " + name);  	}  	List<AnalystClassItem> classItems;  	if (!map.ContainsKey (field)) {  		classItems = new List<AnalystClassItem> ();  		map [field] = classItems;  	}  	else {  		classItems = map [field];  	}  	classItems.Add (new AnalystClassItem (code' name' count));  }  else {  	first = false;  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataClasses,The following statement contains a magic number: if (!first) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	if (cols.Count < ColumnFour) {  		throw new AnalystError ("Invalid data class: " + line);  	}  	String field = cols [0];  	String code = cols [1];  	String name = cols [2];  	int count = Int32.Parse (cols [3]);  	DataField df = _script.FindDataField (field);  	if (df == null) {  		throw new AnalystError ("Attempting to add class to unknown field: " + name);  	}  	List<AnalystClassItem> classItems;  	if (!map.ContainsKey (field)) {  		classItems = new List<AnalystClassItem> ();  		map [field] = classItems;  	}  	else {  		classItems = map [field];  	}  	classItems.Add (new AnalystClassItem (code' name' count));  }  else {  	first = false;  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: foreach (String line in section.Lines) {  	if (!first) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = cols [0];  		bool isclass = Int32.Parse (cols [1]) > 0;  		bool iscomplete = Int32.Parse (cols [2]) > 0;  		bool isint = Int32.Parse (cols [ColumnThree]) > 0;  		bool isreal = Int32.Parse (cols [ColumnFour]) > 0;  		double amax = CSVFormat.EgFormat.Parse (cols [5]);  		double amin = CSVFormat.EgFormat.Parse (cols [6]);  		double mean = CSVFormat.EgFormat.Parse (cols [7]);  		double sdev = CSVFormat.EgFormat.Parse (cols [8]);  		var df = new DataField (name) {  			Class = isclass'  			Complete = iscomplete'  			Integer = isint'  			Real = isreal'  			Max = amax'  			Min = amin'  			Mean = mean'  			StandardDeviation = sdev  		};  		dfs.Add (df);  	}  	else {  		first = false;  	}  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: foreach (String line in section.Lines) {  	if (!first) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = cols [0];  		bool isclass = Int32.Parse (cols [1]) > 0;  		bool iscomplete = Int32.Parse (cols [2]) > 0;  		bool isint = Int32.Parse (cols [ColumnThree]) > 0;  		bool isreal = Int32.Parse (cols [ColumnFour]) > 0;  		double amax = CSVFormat.EgFormat.Parse (cols [5]);  		double amin = CSVFormat.EgFormat.Parse (cols [6]);  		double mean = CSVFormat.EgFormat.Parse (cols [7]);  		double sdev = CSVFormat.EgFormat.Parse (cols [8]);  		var df = new DataField (name) {  			Class = isclass'  			Complete = iscomplete'  			Integer = isint'  			Real = isreal'  			Max = amax'  			Min = amin'  			Mean = mean'  			StandardDeviation = sdev  		};  		dfs.Add (df);  	}  	else {  		first = false;  	}  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: foreach (String line in section.Lines) {  	if (!first) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = cols [0];  		bool isclass = Int32.Parse (cols [1]) > 0;  		bool iscomplete = Int32.Parse (cols [2]) > 0;  		bool isint = Int32.Parse (cols [ColumnThree]) > 0;  		bool isreal = Int32.Parse (cols [ColumnFour]) > 0;  		double amax = CSVFormat.EgFormat.Parse (cols [5]);  		double amin = CSVFormat.EgFormat.Parse (cols [6]);  		double mean = CSVFormat.EgFormat.Parse (cols [7]);  		double sdev = CSVFormat.EgFormat.Parse (cols [8]);  		var df = new DataField (name) {  			Class = isclass'  			Complete = iscomplete'  			Integer = isint'  			Real = isreal'  			Max = amax'  			Min = amin'  			Mean = mean'  			StandardDeviation = sdev  		};  		dfs.Add (df);  	}  	else {  		first = false;  	}  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: foreach (String line in section.Lines) {  	if (!first) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = cols [0];  		bool isclass = Int32.Parse (cols [1]) > 0;  		bool iscomplete = Int32.Parse (cols [2]) > 0;  		bool isint = Int32.Parse (cols [ColumnThree]) > 0;  		bool isreal = Int32.Parse (cols [ColumnFour]) > 0;  		double amax = CSVFormat.EgFormat.Parse (cols [5]);  		double amin = CSVFormat.EgFormat.Parse (cols [6]);  		double mean = CSVFormat.EgFormat.Parse (cols [7]);  		double sdev = CSVFormat.EgFormat.Parse (cols [8]);  		var df = new DataField (name) {  			Class = isclass'  			Complete = iscomplete'  			Integer = isint'  			Real = isreal'  			Max = amax'  			Min = amin'  			Mean = mean'  			StandardDeviation = sdev  		};  		dfs.Add (df);  	}  	else {  		first = false;  	}  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: foreach (String line in section.Lines) {  	if (!first) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = cols [0];  		bool isclass = Int32.Parse (cols [1]) > 0;  		bool iscomplete = Int32.Parse (cols [2]) > 0;  		bool isint = Int32.Parse (cols [ColumnThree]) > 0;  		bool isreal = Int32.Parse (cols [ColumnFour]) > 0;  		double amax = CSVFormat.EgFormat.Parse (cols [5]);  		double amin = CSVFormat.EgFormat.Parse (cols [6]);  		double mean = CSVFormat.EgFormat.Parse (cols [7]);  		double sdev = CSVFormat.EgFormat.Parse (cols [8]);  		var df = new DataField (name) {  			Class = isclass'  			Complete = iscomplete'  			Integer = isint'  			Real = isreal'  			Max = amax'  			Min = amin'  			Mean = mean'  			StandardDeviation = sdev  		};  		dfs.Add (df);  	}  	else {  		first = false;  	}  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: if (!first) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	String name = cols [0];  	bool isclass = Int32.Parse (cols [1]) > 0;  	bool iscomplete = Int32.Parse (cols [2]) > 0;  	bool isint = Int32.Parse (cols [ColumnThree]) > 0;  	bool isreal = Int32.Parse (cols [ColumnFour]) > 0;  	double amax = CSVFormat.EgFormat.Parse (cols [5]);  	double amin = CSVFormat.EgFormat.Parse (cols [6]);  	double mean = CSVFormat.EgFormat.Parse (cols [7]);  	double sdev = CSVFormat.EgFormat.Parse (cols [8]);  	var df = new DataField (name) {  		Class = isclass'  		Complete = iscomplete'  		Integer = isint'  		Real = isreal'  		Max = amax'  		Min = amin'  		Mean = mean'  		StandardDeviation = sdev  	};  	dfs.Add (df);  }  else {  	first = false;  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: if (!first) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	String name = cols [0];  	bool isclass = Int32.Parse (cols [1]) > 0;  	bool iscomplete = Int32.Parse (cols [2]) > 0;  	bool isint = Int32.Parse (cols [ColumnThree]) > 0;  	bool isreal = Int32.Parse (cols [ColumnFour]) > 0;  	double amax = CSVFormat.EgFormat.Parse (cols [5]);  	double amin = CSVFormat.EgFormat.Parse (cols [6]);  	double mean = CSVFormat.EgFormat.Parse (cols [7]);  	double sdev = CSVFormat.EgFormat.Parse (cols [8]);  	var df = new DataField (name) {  		Class = isclass'  		Complete = iscomplete'  		Integer = isint'  		Real = isreal'  		Max = amax'  		Min = amin'  		Mean = mean'  		StandardDeviation = sdev  	};  	dfs.Add (df);  }  else {  	first = false;  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: if (!first) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	String name = cols [0];  	bool isclass = Int32.Parse (cols [1]) > 0;  	bool iscomplete = Int32.Parse (cols [2]) > 0;  	bool isint = Int32.Parse (cols [ColumnThree]) > 0;  	bool isreal = Int32.Parse (cols [ColumnFour]) > 0;  	double amax = CSVFormat.EgFormat.Parse (cols [5]);  	double amin = CSVFormat.EgFormat.Parse (cols [6]);  	double mean = CSVFormat.EgFormat.Parse (cols [7]);  	double sdev = CSVFormat.EgFormat.Parse (cols [8]);  	var df = new DataField (name) {  		Class = isclass'  		Complete = iscomplete'  		Integer = isint'  		Real = isreal'  		Max = amax'  		Min = amin'  		Mean = mean'  		StandardDeviation = sdev  	};  	dfs.Add (df);  }  else {  	first = false;  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: if (!first) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	String name = cols [0];  	bool isclass = Int32.Parse (cols [1]) > 0;  	bool iscomplete = Int32.Parse (cols [2]) > 0;  	bool isint = Int32.Parse (cols [ColumnThree]) > 0;  	bool isreal = Int32.Parse (cols [ColumnFour]) > 0;  	double amax = CSVFormat.EgFormat.Parse (cols [5]);  	double amin = CSVFormat.EgFormat.Parse (cols [6]);  	double mean = CSVFormat.EgFormat.Parse (cols [7]);  	double sdev = CSVFormat.EgFormat.Parse (cols [8]);  	var df = new DataField (name) {  		Class = isclass'  		Complete = iscomplete'  		Integer = isint'  		Real = isreal'  		Max = amax'  		Min = amin'  		Mean = mean'  		StandardDeviation = sdev  	};  	dfs.Add (df);  }  else {  	first = false;  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: if (!first) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	String name = cols [0];  	bool isclass = Int32.Parse (cols [1]) > 0;  	bool iscomplete = Int32.Parse (cols [2]) > 0;  	bool isint = Int32.Parse (cols [ColumnThree]) > 0;  	bool isreal = Int32.Parse (cols [ColumnFour]) > 0;  	double amax = CSVFormat.EgFormat.Parse (cols [5]);  	double amin = CSVFormat.EgFormat.Parse (cols [6]);  	double mean = CSVFormat.EgFormat.Parse (cols [7]);  	double sdev = CSVFormat.EgFormat.Parse (cols [8]);  	var df = new DataField (name) {  		Class = isclass'  		Complete = iscomplete'  		Integer = isint'  		Real = isreal'  		Max = amax'  		Min = amin'  		Mean = mean'  		StandardDeviation = sdev  	};  	dfs.Add (df);  }  else {  	first = false;  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleNormalizeRange,The following statement contains a magic number: foreach (String line in section.Lines) {  	if (!first) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = cols [0];  		bool isOutput = cols [1].ToLower ().Equals ("output");  		int timeSlice = Int32.Parse (cols [2]);  		String action = cols [3];  		double high = CSVFormat.EgFormat.Parse (cols [4]);  		double low = CSVFormat.EgFormat.Parse (cols [5]);  		NormalizationAction des;  		if (action.Equals ("range")) {  			des = NormalizationAction.Normalize;  		}  		else if (action.Equals ("ignore")) {  			des = NormalizationAction.Ignore;  		}  		else if (action.Equals ("pass")) {  			des = NormalizationAction.PassThrough;  		}  		else if (action.Equals ("equilateral")) {  			des = NormalizationAction.Equilateral;  		}  		else if (action.Equals ("single")) {  			des = NormalizationAction.SingleField;  		}  		else if (action.Equals ("oneof")) {  			des = NormalizationAction.OneOf;  		}  		else {  			throw new AnalystError ("Unknown field type:" + action);  		}  		var nf = new AnalystField (name' des' high' low) {  			TimeSlice = timeSlice'  			Output = isOutput  		};  		_script.Normalize.NormalizedFields.Add (nf);  	}  	else {  		first = false;  	}  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleNormalizeRange,The following statement contains a magic number: foreach (String line in section.Lines) {  	if (!first) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = cols [0];  		bool isOutput = cols [1].ToLower ().Equals ("output");  		int timeSlice = Int32.Parse (cols [2]);  		String action = cols [3];  		double high = CSVFormat.EgFormat.Parse (cols [4]);  		double low = CSVFormat.EgFormat.Parse (cols [5]);  		NormalizationAction des;  		if (action.Equals ("range")) {  			des = NormalizationAction.Normalize;  		}  		else if (action.Equals ("ignore")) {  			des = NormalizationAction.Ignore;  		}  		else if (action.Equals ("pass")) {  			des = NormalizationAction.PassThrough;  		}  		else if (action.Equals ("equilateral")) {  			des = NormalizationAction.Equilateral;  		}  		else if (action.Equals ("single")) {  			des = NormalizationAction.SingleField;  		}  		else if (action.Equals ("oneof")) {  			des = NormalizationAction.OneOf;  		}  		else {  			throw new AnalystError ("Unknown field type:" + action);  		}  		var nf = new AnalystField (name' des' high' low) {  			TimeSlice = timeSlice'  			Output = isOutput  		};  		_script.Normalize.NormalizedFields.Add (nf);  	}  	else {  		first = false;  	}  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleNormalizeRange,The following statement contains a magic number: foreach (String line in section.Lines) {  	if (!first) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = cols [0];  		bool isOutput = cols [1].ToLower ().Equals ("output");  		int timeSlice = Int32.Parse (cols [2]);  		String action = cols [3];  		double high = CSVFormat.EgFormat.Parse (cols [4]);  		double low = CSVFormat.EgFormat.Parse (cols [5]);  		NormalizationAction des;  		if (action.Equals ("range")) {  			des = NormalizationAction.Normalize;  		}  		else if (action.Equals ("ignore")) {  			des = NormalizationAction.Ignore;  		}  		else if (action.Equals ("pass")) {  			des = NormalizationAction.PassThrough;  		}  		else if (action.Equals ("equilateral")) {  			des = NormalizationAction.Equilateral;  		}  		else if (action.Equals ("single")) {  			des = NormalizationAction.SingleField;  		}  		else if (action.Equals ("oneof")) {  			des = NormalizationAction.OneOf;  		}  		else {  			throw new AnalystError ("Unknown field type:" + action);  		}  		var nf = new AnalystField (name' des' high' low) {  			TimeSlice = timeSlice'  			Output = isOutput  		};  		_script.Normalize.NormalizedFields.Add (nf);  	}  	else {  		first = false;  	}  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleNormalizeRange,The following statement contains a magic number: foreach (String line in section.Lines) {  	if (!first) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = cols [0];  		bool isOutput = cols [1].ToLower ().Equals ("output");  		int timeSlice = Int32.Parse (cols [2]);  		String action = cols [3];  		double high = CSVFormat.EgFormat.Parse (cols [4]);  		double low = CSVFormat.EgFormat.Parse (cols [5]);  		NormalizationAction des;  		if (action.Equals ("range")) {  			des = NormalizationAction.Normalize;  		}  		else if (action.Equals ("ignore")) {  			des = NormalizationAction.Ignore;  		}  		else if (action.Equals ("pass")) {  			des = NormalizationAction.PassThrough;  		}  		else if (action.Equals ("equilateral")) {  			des = NormalizationAction.Equilateral;  		}  		else if (action.Equals ("single")) {  			des = NormalizationAction.SingleField;  		}  		else if (action.Equals ("oneof")) {  			des = NormalizationAction.OneOf;  		}  		else {  			throw new AnalystError ("Unknown field type:" + action);  		}  		var nf = new AnalystField (name' des' high' low) {  			TimeSlice = timeSlice'  			Output = isOutput  		};  		_script.Normalize.NormalizedFields.Add (nf);  	}  	else {  		first = false;  	}  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleNormalizeRange,The following statement contains a magic number: if (!first) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	String name = cols [0];  	bool isOutput = cols [1].ToLower ().Equals ("output");  	int timeSlice = Int32.Parse (cols [2]);  	String action = cols [3];  	double high = CSVFormat.EgFormat.Parse (cols [4]);  	double low = CSVFormat.EgFormat.Parse (cols [5]);  	NormalizationAction des;  	if (action.Equals ("range")) {  		des = NormalizationAction.Normalize;  	}  	else if (action.Equals ("ignore")) {  		des = NormalizationAction.Ignore;  	}  	else if (action.Equals ("pass")) {  		des = NormalizationAction.PassThrough;  	}  	else if (action.Equals ("equilateral")) {  		des = NormalizationAction.Equilateral;  	}  	else if (action.Equals ("single")) {  		des = NormalizationAction.SingleField;  	}  	else if (action.Equals ("oneof")) {  		des = NormalizationAction.OneOf;  	}  	else {  		throw new AnalystError ("Unknown field type:" + action);  	}  	var nf = new AnalystField (name' des' high' low) {  		TimeSlice = timeSlice'  		Output = isOutput  	};  	_script.Normalize.NormalizedFields.Add (nf);  }  else {  	first = false;  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleNormalizeRange,The following statement contains a magic number: if (!first) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	String name = cols [0];  	bool isOutput = cols [1].ToLower ().Equals ("output");  	int timeSlice = Int32.Parse (cols [2]);  	String action = cols [3];  	double high = CSVFormat.EgFormat.Parse (cols [4]);  	double low = CSVFormat.EgFormat.Parse (cols [5]);  	NormalizationAction des;  	if (action.Equals ("range")) {  		des = NormalizationAction.Normalize;  	}  	else if (action.Equals ("ignore")) {  		des = NormalizationAction.Ignore;  	}  	else if (action.Equals ("pass")) {  		des = NormalizationAction.PassThrough;  	}  	else if (action.Equals ("equilateral")) {  		des = NormalizationAction.Equilateral;  	}  	else if (action.Equals ("single")) {  		des = NormalizationAction.SingleField;  	}  	else if (action.Equals ("oneof")) {  		des = NormalizationAction.OneOf;  	}  	else {  		throw new AnalystError ("Unknown field type:" + action);  	}  	var nf = new AnalystField (name' des' high' low) {  		TimeSlice = timeSlice'  		Output = isOutput  	};  	_script.Normalize.NormalizedFields.Add (nf);  }  else {  	first = false;  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleNormalizeRange,The following statement contains a magic number: if (!first) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	String name = cols [0];  	bool isOutput = cols [1].ToLower ().Equals ("output");  	int timeSlice = Int32.Parse (cols [2]);  	String action = cols [3];  	double high = CSVFormat.EgFormat.Parse (cols [4]);  	double low = CSVFormat.EgFormat.Parse (cols [5]);  	NormalizationAction des;  	if (action.Equals ("range")) {  		des = NormalizationAction.Normalize;  	}  	else if (action.Equals ("ignore")) {  		des = NormalizationAction.Ignore;  	}  	else if (action.Equals ("pass")) {  		des = NormalizationAction.PassThrough;  	}  	else if (action.Equals ("equilateral")) {  		des = NormalizationAction.Equilateral;  	}  	else if (action.Equals ("single")) {  		des = NormalizationAction.SingleField;  	}  	else if (action.Equals ("oneof")) {  		des = NormalizationAction.OneOf;  	}  	else {  		throw new AnalystError ("Unknown field type:" + action);  	}  	var nf = new AnalystField (name' des' high' low) {  		TimeSlice = timeSlice'  		Output = isOutput  	};  	_script.Normalize.NormalizedFields.Add (nf);  }  else {  	first = false;  }  
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleNormalizeRange,The following statement contains a magic number: if (!first) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	String name = cols [0];  	bool isOutput = cols [1].ToLower ().Equals ("output");  	int timeSlice = Int32.Parse (cols [2]);  	String action = cols [3];  	double high = CSVFormat.EgFormat.Parse (cols [4]);  	double low = CSVFormat.EgFormat.Parse (cols [5]);  	NormalizationAction des;  	if (action.Equals ("range")) {  		des = NormalizationAction.Normalize;  	}  	else if (action.Equals ("ignore")) {  		des = NormalizationAction.Ignore;  	}  	else if (action.Equals ("pass")) {  		des = NormalizationAction.PassThrough;  	}  	else if (action.Equals ("equilateral")) {  		des = NormalizationAction.Equilateral;  	}  	else if (action.Equals ("single")) {  		des = NormalizationAction.SingleField;  	}  	else if (action.Equals ("oneof")) {  		des = NormalizationAction.OneOf;  	}  	else {  		throw new AnalystError ("Unknown field type:" + action);  	}  	var nf = new AnalystField (name' des' high' low) {  		TimeSlice = timeSlice'  		Output = isOutput  	};  	_script.Normalize.NormalizedFields.Add (nf);  }  else {  	first = false;  }  
Magic Number,Encog.App.Analyst.Script.Normalize,AnalystField,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\Normalize\AnalystField.cs,DeNormalize,The following statement contains a magic number: if (Double.IsNaN (result)) {  	return ((NormalizedHigh - NormalizedLow) / 2) + NormalizedLow;  }  
Magic Number,Encog.App.Analyst.Script.Normalize,AnalystField,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\Normalize\AnalystField.cs,DeNormalize,The following statement contains a magic number: return ((NormalizedHigh - NormalizedLow) / 2) + NormalizedLow;  
Magic Number,Encog.App.Analyst.Script.Normalize,AnalystField,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\Normalize\AnalystField.cs,Normalize,The following statement contains a magic number: if (Double.IsNaN (result)) {  	return ((NormalizedHigh - NormalizedLow) / 2) + NormalizedLow;  }  
Magic Number,Encog.App.Analyst.Script.Normalize,AnalystField,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\Normalize\AnalystField.cs,Normalize,The following statement contains a magic number: return ((NormalizedHigh - NormalizedLow) / 2) + NormalizedLow;  
Magic Number,Encog.App.Analyst.Script.Prop,PropertyConstraints,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\Prop\PropertyConstraints.cs,PropertyConstraints,The following statement contains a magic number: try {  	Stream mask0 = ResourceLoader.CreateStream ("Encog.Resources.analyst.csv");  	var csv = new ReadCSV (mask0' false' CSVFormat.EgFormat);  	while (csv.Next ()) {  		String sectionStr = csv.Get (0);  		String nameStr = csv.Get (1);  		String typeStr = csv.Get (2);  		// determine type  		PropertyType t;  		if ("boolean".Equals (typeStr' StringComparison.InvariantCultureIgnoreCase)) {  			t = PropertyType.TypeBoolean;  		}  		else if ("real".Equals (typeStr' StringComparison.InvariantCultureIgnoreCase)) {  			t = PropertyType.TypeDouble;  		}  		else if ("format".Equals (typeStr' StringComparison.InvariantCultureIgnoreCase)) {  			t = PropertyType.TypeFormat;  		}  		else if ("int".Equals (typeStr' StringComparison.InvariantCultureIgnoreCase)) {  			t = PropertyType.TypeInteger;  		}  		else if ("list-string".Equals (typeStr' StringComparison.InvariantCultureIgnoreCase)) {  			t = PropertyType.TypeListString;  		}  		else if ("string".Equals (typeStr' StringComparison.InvariantCultureIgnoreCase)) {  			t = PropertyType.TypeString;  		}  		else {  			throw new AnalystError ("Unknown type constraint: " + typeStr);  		}  		var entry = new PropertyEntry (t' nameStr' sectionStr);  		List<PropertyEntry> list;  		if (_data.ContainsKey (sectionStr)) {  			list = _data [sectionStr];  		}  		else {  			list = new List<PropertyEntry> ();  			_data [sectionStr] = list;  		}  		list.Add (entry);  	}  	csv.Close ();  	mask0.Close ();  }  catch (IOException e) {  	throw new EncogError (e);  }  
Magic Number,Encog.App.Analyst.Script.Prop,PropertyConstraints,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Script\Prop\PropertyConstraints.cs,PropertyConstraints,The following statement contains a magic number: while (csv.Next ()) {  	String sectionStr = csv.Get (0);  	String nameStr = csv.Get (1);  	String typeStr = csv.Get (2);  	// determine type  	PropertyType t;  	if ("boolean".Equals (typeStr' StringComparison.InvariantCultureIgnoreCase)) {  		t = PropertyType.TypeBoolean;  	}  	else if ("real".Equals (typeStr' StringComparison.InvariantCultureIgnoreCase)) {  		t = PropertyType.TypeDouble;  	}  	else if ("format".Equals (typeStr' StringComparison.InvariantCultureIgnoreCase)) {  		t = PropertyType.TypeFormat;  	}  	else if ("int".Equals (typeStr' StringComparison.InvariantCultureIgnoreCase)) {  		t = PropertyType.TypeInteger;  	}  	else if ("list-string".Equals (typeStr' StringComparison.InvariantCultureIgnoreCase)) {  		t = PropertyType.TypeListString;  	}  	else if ("string".Equals (typeStr' StringComparison.InvariantCultureIgnoreCase)) {  		t = PropertyType.TypeString;  	}  	else {  		throw new AnalystError ("Unknown type constraint: " + typeStr);  	}  	var entry = new PropertyEntry (t' nameStr' sectionStr);  	List<PropertyEntry> list;  	if (_data.ContainsKey (sectionStr)) {  		list = _data [sectionStr];  	}  	else {  		list = new List<PropertyEntry> ();  		_data [sectionStr] = list;  	}  	list.Add (entry);  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,DetermineTargetField,The following statement contains a magic number: if (_taskCluster) {  	if ((TargetField == null) || (_goal != AnalystGoal.Classification)) {  		_script.Properties.SetProperty (ScriptProperties.ClusterConfigClusters' 2);  	}  	else {  		DataField tf = _script.FindDataField (TargetField.Name);  		_script.Properties.SetProperty (ScriptProperties.ClusterConfigClusters' tf.ClassMembers.Count);  	}  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,DetermineTargetField,The following statement contains a magic number: if ((TargetField == null) || (_goal != AnalystGoal.Classification)) {  	_script.Properties.SetProperty (ScriptProperties.ClusterConfigClusters' 2);  }  else {  	DataField tf = _script.FindDataField (TargetField.Name);  	_script.Properties.SetProperty (ScriptProperties.ClusterConfigClusters' tf.ClassMembers.Count);  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,DetermineTargetField,The following statement contains a magic number: _script.Properties.SetProperty (ScriptProperties.ClusterConfigClusters' 2);  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: foreach (DataField field in _analyst.Script.Fields) {  	a.Append ("P(");  	a.Append (field.Name);  	// handle actual class members  	if (field.ClassMembers.Count > 0) {  		a.Append ("[");  		bool first = true;  		foreach (AnalystClassItem item in field.ClassMembers) {  			if (!first) {  				a.Append ("'");  			}  			a.Append (item.Code);  			first = false;  		}  		// append a "fake" member' if there is only one  		if (field.ClassMembers.Count == 1) {  			a.Append ("'Other0");  		}  		a.Append ("]");  	}  	else {  		a.Append ("[");  		// handle ranges  		double size = Math.Abs (field.Max - field.Min);  		double per = size / segment;  		if (size < EncogFramework.DefaultDoubleEqual) {  			double low = field.Min - 0.0001;  			double hi = field.Min + 0.0001;  			a.Append ("BELOW: " + (low - 100) + " to " + hi + "'");  			a.Append ("Type0: " + low + " to " + hi + "'");  			a.Append ("ABOVE: " + hi + " to " + (hi + 100));  		}  		else {  			bool first = true;  			for (int i = 0; i < segment; i++) {  				if (!first) {  					a.Append ("'");  				}  				double low = field.Min + (per * i);  				double hi = i == (segment - 1) ? (field.Max) : (low + per);  				a.Append ("Type");  				a.Append (i);  				a.Append (":");  				a.Append (CSVFormat.EgFormat.Format (low' 16));  				a.Append (" to ");  				a.Append (CSVFormat.EgFormat.Format (hi' 16));  				first = false;  			}  		}  		a.Append ("]");  	}  	a.Append (") ");  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: foreach (DataField field in _analyst.Script.Fields) {  	a.Append ("P(");  	a.Append (field.Name);  	// handle actual class members  	if (field.ClassMembers.Count > 0) {  		a.Append ("[");  		bool first = true;  		foreach (AnalystClassItem item in field.ClassMembers) {  			if (!first) {  				a.Append ("'");  			}  			a.Append (item.Code);  			first = false;  		}  		// append a "fake" member' if there is only one  		if (field.ClassMembers.Count == 1) {  			a.Append ("'Other0");  		}  		a.Append ("]");  	}  	else {  		a.Append ("[");  		// handle ranges  		double size = Math.Abs (field.Max - field.Min);  		double per = size / segment;  		if (size < EncogFramework.DefaultDoubleEqual) {  			double low = field.Min - 0.0001;  			double hi = field.Min + 0.0001;  			a.Append ("BELOW: " + (low - 100) + " to " + hi + "'");  			a.Append ("Type0: " + low + " to " + hi + "'");  			a.Append ("ABOVE: " + hi + " to " + (hi + 100));  		}  		else {  			bool first = true;  			for (int i = 0; i < segment; i++) {  				if (!first) {  					a.Append ("'");  				}  				double low = field.Min + (per * i);  				double hi = i == (segment - 1) ? (field.Max) : (low + per);  				a.Append ("Type");  				a.Append (i);  				a.Append (":");  				a.Append (CSVFormat.EgFormat.Format (low' 16));  				a.Append (" to ");  				a.Append (CSVFormat.EgFormat.Format (hi' 16));  				first = false;  			}  		}  		a.Append ("]");  	}  	a.Append (") ");  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: foreach (DataField field in _analyst.Script.Fields) {  	a.Append ("P(");  	a.Append (field.Name);  	// handle actual class members  	if (field.ClassMembers.Count > 0) {  		a.Append ("[");  		bool first = true;  		foreach (AnalystClassItem item in field.ClassMembers) {  			if (!first) {  				a.Append ("'");  			}  			a.Append (item.Code);  			first = false;  		}  		// append a "fake" member' if there is only one  		if (field.ClassMembers.Count == 1) {  			a.Append ("'Other0");  		}  		a.Append ("]");  	}  	else {  		a.Append ("[");  		// handle ranges  		double size = Math.Abs (field.Max - field.Min);  		double per = size / segment;  		if (size < EncogFramework.DefaultDoubleEqual) {  			double low = field.Min - 0.0001;  			double hi = field.Min + 0.0001;  			a.Append ("BELOW: " + (low - 100) + " to " + hi + "'");  			a.Append ("Type0: " + low + " to " + hi + "'");  			a.Append ("ABOVE: " + hi + " to " + (hi + 100));  		}  		else {  			bool first = true;  			for (int i = 0; i < segment; i++) {  				if (!first) {  					a.Append ("'");  				}  				double low = field.Min + (per * i);  				double hi = i == (segment - 1) ? (field.Max) : (low + per);  				a.Append ("Type");  				a.Append (i);  				a.Append (":");  				a.Append (CSVFormat.EgFormat.Format (low' 16));  				a.Append (" to ");  				a.Append (CSVFormat.EgFormat.Format (hi' 16));  				first = false;  			}  		}  		a.Append ("]");  	}  	a.Append (") ");  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: foreach (DataField field in _analyst.Script.Fields) {  	a.Append ("P(");  	a.Append (field.Name);  	// handle actual class members  	if (field.ClassMembers.Count > 0) {  		a.Append ("[");  		bool first = true;  		foreach (AnalystClassItem item in field.ClassMembers) {  			if (!first) {  				a.Append ("'");  			}  			a.Append (item.Code);  			first = false;  		}  		// append a "fake" member' if there is only one  		if (field.ClassMembers.Count == 1) {  			a.Append ("'Other0");  		}  		a.Append ("]");  	}  	else {  		a.Append ("[");  		// handle ranges  		double size = Math.Abs (field.Max - field.Min);  		double per = size / segment;  		if (size < EncogFramework.DefaultDoubleEqual) {  			double low = field.Min - 0.0001;  			double hi = field.Min + 0.0001;  			a.Append ("BELOW: " + (low - 100) + " to " + hi + "'");  			a.Append ("Type0: " + low + " to " + hi + "'");  			a.Append ("ABOVE: " + hi + " to " + (hi + 100));  		}  		else {  			bool first = true;  			for (int i = 0; i < segment; i++) {  				if (!first) {  					a.Append ("'");  				}  				double low = field.Min + (per * i);  				double hi = i == (segment - 1) ? (field.Max) : (low + per);  				a.Append ("Type");  				a.Append (i);  				a.Append (":");  				a.Append (CSVFormat.EgFormat.Format (low' 16));  				a.Append (" to ");  				a.Append (CSVFormat.EgFormat.Format (hi' 16));  				first = false;  			}  		}  		a.Append ("]");  	}  	a.Append (") ");  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: foreach (DataField field in _analyst.Script.Fields) {  	a.Append ("P(");  	a.Append (field.Name);  	// handle actual class members  	if (field.ClassMembers.Count > 0) {  		a.Append ("[");  		bool first = true;  		foreach (AnalystClassItem item in field.ClassMembers) {  			if (!first) {  				a.Append ("'");  			}  			a.Append (item.Code);  			first = false;  		}  		// append a "fake" member' if there is only one  		if (field.ClassMembers.Count == 1) {  			a.Append ("'Other0");  		}  		a.Append ("]");  	}  	else {  		a.Append ("[");  		// handle ranges  		double size = Math.Abs (field.Max - field.Min);  		double per = size / segment;  		if (size < EncogFramework.DefaultDoubleEqual) {  			double low = field.Min - 0.0001;  			double hi = field.Min + 0.0001;  			a.Append ("BELOW: " + (low - 100) + " to " + hi + "'");  			a.Append ("Type0: " + low + " to " + hi + "'");  			a.Append ("ABOVE: " + hi + " to " + (hi + 100));  		}  		else {  			bool first = true;  			for (int i = 0; i < segment; i++) {  				if (!first) {  					a.Append ("'");  				}  				double low = field.Min + (per * i);  				double hi = i == (segment - 1) ? (field.Max) : (low + per);  				a.Append ("Type");  				a.Append (i);  				a.Append (":");  				a.Append (CSVFormat.EgFormat.Format (low' 16));  				a.Append (" to ");  				a.Append (CSVFormat.EgFormat.Format (hi' 16));  				first = false;  			}  		}  		a.Append ("]");  	}  	a.Append (") ");  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: foreach (DataField field in _analyst.Script.Fields) {  	a.Append ("P(");  	a.Append (field.Name);  	// handle actual class members  	if (field.ClassMembers.Count > 0) {  		a.Append ("[");  		bool first = true;  		foreach (AnalystClassItem item in field.ClassMembers) {  			if (!first) {  				a.Append ("'");  			}  			a.Append (item.Code);  			first = false;  		}  		// append a "fake" member' if there is only one  		if (field.ClassMembers.Count == 1) {  			a.Append ("'Other0");  		}  		a.Append ("]");  	}  	else {  		a.Append ("[");  		// handle ranges  		double size = Math.Abs (field.Max - field.Min);  		double per = size / segment;  		if (size < EncogFramework.DefaultDoubleEqual) {  			double low = field.Min - 0.0001;  			double hi = field.Min + 0.0001;  			a.Append ("BELOW: " + (low - 100) + " to " + hi + "'");  			a.Append ("Type0: " + low + " to " + hi + "'");  			a.Append ("ABOVE: " + hi + " to " + (hi + 100));  		}  		else {  			bool first = true;  			for (int i = 0; i < segment; i++) {  				if (!first) {  					a.Append ("'");  				}  				double low = field.Min + (per * i);  				double hi = i == (segment - 1) ? (field.Max) : (low + per);  				a.Append ("Type");  				a.Append (i);  				a.Append (":");  				a.Append (CSVFormat.EgFormat.Format (low' 16));  				a.Append (" to ");  				a.Append (CSVFormat.EgFormat.Format (hi' 16));  				first = false;  			}  		}  		a.Append ("]");  	}  	a.Append (") ");  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: if (field.ClassMembers.Count > 0) {  	a.Append ("[");  	bool first = true;  	foreach (AnalystClassItem item in field.ClassMembers) {  		if (!first) {  			a.Append ("'");  		}  		a.Append (item.Code);  		first = false;  	}  	// append a "fake" member' if there is only one  	if (field.ClassMembers.Count == 1) {  		a.Append ("'Other0");  	}  	a.Append ("]");  }  else {  	a.Append ("[");  	// handle ranges  	double size = Math.Abs (field.Max - field.Min);  	double per = size / segment;  	if (size < EncogFramework.DefaultDoubleEqual) {  		double low = field.Min - 0.0001;  		double hi = field.Min + 0.0001;  		a.Append ("BELOW: " + (low - 100) + " to " + hi + "'");  		a.Append ("Type0: " + low + " to " + hi + "'");  		a.Append ("ABOVE: " + hi + " to " + (hi + 100));  	}  	else {  		bool first = true;  		for (int i = 0; i < segment; i++) {  			if (!first) {  				a.Append ("'");  			}  			double low = field.Min + (per * i);  			double hi = i == (segment - 1) ? (field.Max) : (low + per);  			a.Append ("Type");  			a.Append (i);  			a.Append (":");  			a.Append (CSVFormat.EgFormat.Format (low' 16));  			a.Append (" to ");  			a.Append (CSVFormat.EgFormat.Format (hi' 16));  			first = false;  		}  	}  	a.Append ("]");  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: if (field.ClassMembers.Count > 0) {  	a.Append ("[");  	bool first = true;  	foreach (AnalystClassItem item in field.ClassMembers) {  		if (!first) {  			a.Append ("'");  		}  		a.Append (item.Code);  		first = false;  	}  	// append a "fake" member' if there is only one  	if (field.ClassMembers.Count == 1) {  		a.Append ("'Other0");  	}  	a.Append ("]");  }  else {  	a.Append ("[");  	// handle ranges  	double size = Math.Abs (field.Max - field.Min);  	double per = size / segment;  	if (size < EncogFramework.DefaultDoubleEqual) {  		double low = field.Min - 0.0001;  		double hi = field.Min + 0.0001;  		a.Append ("BELOW: " + (low - 100) + " to " + hi + "'");  		a.Append ("Type0: " + low + " to " + hi + "'");  		a.Append ("ABOVE: " + hi + " to " + (hi + 100));  	}  	else {  		bool first = true;  		for (int i = 0; i < segment; i++) {  			if (!first) {  				a.Append ("'");  			}  			double low = field.Min + (per * i);  			double hi = i == (segment - 1) ? (field.Max) : (low + per);  			a.Append ("Type");  			a.Append (i);  			a.Append (":");  			a.Append (CSVFormat.EgFormat.Format (low' 16));  			a.Append (" to ");  			a.Append (CSVFormat.EgFormat.Format (hi' 16));  			first = false;  		}  	}  	a.Append ("]");  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: if (field.ClassMembers.Count > 0) {  	a.Append ("[");  	bool first = true;  	foreach (AnalystClassItem item in field.ClassMembers) {  		if (!first) {  			a.Append ("'");  		}  		a.Append (item.Code);  		first = false;  	}  	// append a "fake" member' if there is only one  	if (field.ClassMembers.Count == 1) {  		a.Append ("'Other0");  	}  	a.Append ("]");  }  else {  	a.Append ("[");  	// handle ranges  	double size = Math.Abs (field.Max - field.Min);  	double per = size / segment;  	if (size < EncogFramework.DefaultDoubleEqual) {  		double low = field.Min - 0.0001;  		double hi = field.Min + 0.0001;  		a.Append ("BELOW: " + (low - 100) + " to " + hi + "'");  		a.Append ("Type0: " + low + " to " + hi + "'");  		a.Append ("ABOVE: " + hi + " to " + (hi + 100));  	}  	else {  		bool first = true;  		for (int i = 0; i < segment; i++) {  			if (!first) {  				a.Append ("'");  			}  			double low = field.Min + (per * i);  			double hi = i == (segment - 1) ? (field.Max) : (low + per);  			a.Append ("Type");  			a.Append (i);  			a.Append (":");  			a.Append (CSVFormat.EgFormat.Format (low' 16));  			a.Append (" to ");  			a.Append (CSVFormat.EgFormat.Format (hi' 16));  			first = false;  		}  	}  	a.Append ("]");  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: if (field.ClassMembers.Count > 0) {  	a.Append ("[");  	bool first = true;  	foreach (AnalystClassItem item in field.ClassMembers) {  		if (!first) {  			a.Append ("'");  		}  		a.Append (item.Code);  		first = false;  	}  	// append a "fake" member' if there is only one  	if (field.ClassMembers.Count == 1) {  		a.Append ("'Other0");  	}  	a.Append ("]");  }  else {  	a.Append ("[");  	// handle ranges  	double size = Math.Abs (field.Max - field.Min);  	double per = size / segment;  	if (size < EncogFramework.DefaultDoubleEqual) {  		double low = field.Min - 0.0001;  		double hi = field.Min + 0.0001;  		a.Append ("BELOW: " + (low - 100) + " to " + hi + "'");  		a.Append ("Type0: " + low + " to " + hi + "'");  		a.Append ("ABOVE: " + hi + " to " + (hi + 100));  	}  	else {  		bool first = true;  		for (int i = 0; i < segment; i++) {  			if (!first) {  				a.Append ("'");  			}  			double low = field.Min + (per * i);  			double hi = i == (segment - 1) ? (field.Max) : (low + per);  			a.Append ("Type");  			a.Append (i);  			a.Append (":");  			a.Append (CSVFormat.EgFormat.Format (low' 16));  			a.Append (" to ");  			a.Append (CSVFormat.EgFormat.Format (hi' 16));  			first = false;  		}  	}  	a.Append ("]");  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: if (field.ClassMembers.Count > 0) {  	a.Append ("[");  	bool first = true;  	foreach (AnalystClassItem item in field.ClassMembers) {  		if (!first) {  			a.Append ("'");  		}  		a.Append (item.Code);  		first = false;  	}  	// append a "fake" member' if there is only one  	if (field.ClassMembers.Count == 1) {  		a.Append ("'Other0");  	}  	a.Append ("]");  }  else {  	a.Append ("[");  	// handle ranges  	double size = Math.Abs (field.Max - field.Min);  	double per = size / segment;  	if (size < EncogFramework.DefaultDoubleEqual) {  		double low = field.Min - 0.0001;  		double hi = field.Min + 0.0001;  		a.Append ("BELOW: " + (low - 100) + " to " + hi + "'");  		a.Append ("Type0: " + low + " to " + hi + "'");  		a.Append ("ABOVE: " + hi + " to " + (hi + 100));  	}  	else {  		bool first = true;  		for (int i = 0; i < segment; i++) {  			if (!first) {  				a.Append ("'");  			}  			double low = field.Min + (per * i);  			double hi = i == (segment - 1) ? (field.Max) : (low + per);  			a.Append ("Type");  			a.Append (i);  			a.Append (":");  			a.Append (CSVFormat.EgFormat.Format (low' 16));  			a.Append (" to ");  			a.Append (CSVFormat.EgFormat.Format (hi' 16));  			first = false;  		}  	}  	a.Append ("]");  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: if (field.ClassMembers.Count > 0) {  	a.Append ("[");  	bool first = true;  	foreach (AnalystClassItem item in field.ClassMembers) {  		if (!first) {  			a.Append ("'");  		}  		a.Append (item.Code);  		first = false;  	}  	// append a "fake" member' if there is only one  	if (field.ClassMembers.Count == 1) {  		a.Append ("'Other0");  	}  	a.Append ("]");  }  else {  	a.Append ("[");  	// handle ranges  	double size = Math.Abs (field.Max - field.Min);  	double per = size / segment;  	if (size < EncogFramework.DefaultDoubleEqual) {  		double low = field.Min - 0.0001;  		double hi = field.Min + 0.0001;  		a.Append ("BELOW: " + (low - 100) + " to " + hi + "'");  		a.Append ("Type0: " + low + " to " + hi + "'");  		a.Append ("ABOVE: " + hi + " to " + (hi + 100));  	}  	else {  		bool first = true;  		for (int i = 0; i < segment; i++) {  			if (!first) {  				a.Append ("'");  			}  			double low = field.Min + (per * i);  			double hi = i == (segment - 1) ? (field.Max) : (low + per);  			a.Append ("Type");  			a.Append (i);  			a.Append (":");  			a.Append (CSVFormat.EgFormat.Format (low' 16));  			a.Append (" to ");  			a.Append (CSVFormat.EgFormat.Format (hi' 16));  			first = false;  		}  	}  	a.Append ("]");  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: if (size < EncogFramework.DefaultDoubleEqual) {  	double low = field.Min - 0.0001;  	double hi = field.Min + 0.0001;  	a.Append ("BELOW: " + (low - 100) + " to " + hi + "'");  	a.Append ("Type0: " + low + " to " + hi + "'");  	a.Append ("ABOVE: " + hi + " to " + (hi + 100));  }  else {  	bool first = true;  	for (int i = 0; i < segment; i++) {  		if (!first) {  			a.Append ("'");  		}  		double low = field.Min + (per * i);  		double hi = i == (segment - 1) ? (field.Max) : (low + per);  		a.Append ("Type");  		a.Append (i);  		a.Append (":");  		a.Append (CSVFormat.EgFormat.Format (low' 16));  		a.Append (" to ");  		a.Append (CSVFormat.EgFormat.Format (hi' 16));  		first = false;  	}  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: if (size < EncogFramework.DefaultDoubleEqual) {  	double low = field.Min - 0.0001;  	double hi = field.Min + 0.0001;  	a.Append ("BELOW: " + (low - 100) + " to " + hi + "'");  	a.Append ("Type0: " + low + " to " + hi + "'");  	a.Append ("ABOVE: " + hi + " to " + (hi + 100));  }  else {  	bool first = true;  	for (int i = 0; i < segment; i++) {  		if (!first) {  			a.Append ("'");  		}  		double low = field.Min + (per * i);  		double hi = i == (segment - 1) ? (field.Max) : (low + per);  		a.Append ("Type");  		a.Append (i);  		a.Append (":");  		a.Append (CSVFormat.EgFormat.Format (low' 16));  		a.Append (" to ");  		a.Append (CSVFormat.EgFormat.Format (hi' 16));  		first = false;  	}  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: if (size < EncogFramework.DefaultDoubleEqual) {  	double low = field.Min - 0.0001;  	double hi = field.Min + 0.0001;  	a.Append ("BELOW: " + (low - 100) + " to " + hi + "'");  	a.Append ("Type0: " + low + " to " + hi + "'");  	a.Append ("ABOVE: " + hi + " to " + (hi + 100));  }  else {  	bool first = true;  	for (int i = 0; i < segment; i++) {  		if (!first) {  			a.Append ("'");  		}  		double low = field.Min + (per * i);  		double hi = i == (segment - 1) ? (field.Max) : (low + per);  		a.Append ("Type");  		a.Append (i);  		a.Append (":");  		a.Append (CSVFormat.EgFormat.Format (low' 16));  		a.Append (" to ");  		a.Append (CSVFormat.EgFormat.Format (hi' 16));  		first = false;  	}  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: if (size < EncogFramework.DefaultDoubleEqual) {  	double low = field.Min - 0.0001;  	double hi = field.Min + 0.0001;  	a.Append ("BELOW: " + (low - 100) + " to " + hi + "'");  	a.Append ("Type0: " + low + " to " + hi + "'");  	a.Append ("ABOVE: " + hi + " to " + (hi + 100));  }  else {  	bool first = true;  	for (int i = 0; i < segment; i++) {  		if (!first) {  			a.Append ("'");  		}  		double low = field.Min + (per * i);  		double hi = i == (segment - 1) ? (field.Max) : (low + per);  		a.Append ("Type");  		a.Append (i);  		a.Append (":");  		a.Append (CSVFormat.EgFormat.Format (low' 16));  		a.Append (" to ");  		a.Append (CSVFormat.EgFormat.Format (hi' 16));  		first = false;  	}  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: if (size < EncogFramework.DefaultDoubleEqual) {  	double low = field.Min - 0.0001;  	double hi = field.Min + 0.0001;  	a.Append ("BELOW: " + (low - 100) + " to " + hi + "'");  	a.Append ("Type0: " + low + " to " + hi + "'");  	a.Append ("ABOVE: " + hi + " to " + (hi + 100));  }  else {  	bool first = true;  	for (int i = 0; i < segment; i++) {  		if (!first) {  			a.Append ("'");  		}  		double low = field.Min + (per * i);  		double hi = i == (segment - 1) ? (field.Max) : (low + per);  		a.Append ("Type");  		a.Append (i);  		a.Append (":");  		a.Append (CSVFormat.EgFormat.Format (low' 16));  		a.Append (" to ");  		a.Append (CSVFormat.EgFormat.Format (hi' 16));  		first = false;  	}  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: if (size < EncogFramework.DefaultDoubleEqual) {  	double low = field.Min - 0.0001;  	double hi = field.Min + 0.0001;  	a.Append ("BELOW: " + (low - 100) + " to " + hi + "'");  	a.Append ("Type0: " + low + " to " + hi + "'");  	a.Append ("ABOVE: " + hi + " to " + (hi + 100));  }  else {  	bool first = true;  	for (int i = 0; i < segment; i++) {  		if (!first) {  			a.Append ("'");  		}  		double low = field.Min + (per * i);  		double hi = i == (segment - 1) ? (field.Max) : (low + per);  		a.Append ("Type");  		a.Append (i);  		a.Append (":");  		a.Append (CSVFormat.EgFormat.Format (low' 16));  		a.Append (" to ");  		a.Append (CSVFormat.EgFormat.Format (hi' 16));  		first = false;  	}  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: a.Append ("BELOW: " + (low - 100) + " to " + hi + "'");  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: a.Append ("ABOVE: " + hi + " to " + (hi + 100));  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: for (int i = 0; i < segment; i++) {  	if (!first) {  		a.Append ("'");  	}  	double low = field.Min + (per * i);  	double hi = i == (segment - 1) ? (field.Max) : (low + per);  	a.Append ("Type");  	a.Append (i);  	a.Append (":");  	a.Append (CSVFormat.EgFormat.Format (low' 16));  	a.Append (" to ");  	a.Append (CSVFormat.EgFormat.Format (hi' 16));  	first = false;  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: for (int i = 0; i < segment; i++) {  	if (!first) {  		a.Append ("'");  	}  	double low = field.Min + (per * i);  	double hi = i == (segment - 1) ? (field.Max) : (low + per);  	a.Append ("Type");  	a.Append (i);  	a.Append (":");  	a.Append (CSVFormat.EgFormat.Format (low' 16));  	a.Append (" to ");  	a.Append (CSVFormat.EgFormat.Format (hi' 16));  	first = false;  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: a.Append (CSVFormat.EgFormat.Format (low' 16));  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: a.Append (CSVFormat.EgFormat.Format (hi' 16));  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateNormalizedFields,The following statement contains a magic number: for (int i = 0; i < _script.Fields.Length; i++) {  	DataField f = dataFields [i];  	NormalizationAction action;  	bool isLast = i == _script.Fields.Length - 1;  	if (_methodType == WizardMethodType.BayesianNetwork) {  		AnalystField af;  		if (f.Class) {  			af = new AnalystField (f.Name' NormalizationAction.SingleField' 0' 0);  		}  		else {  			af = new AnalystField (f.Name' NormalizationAction.PassThrough' 0' 0);  		}  		norm.Add (af);  	}  	else if ((f.Integer || f.Real) && !f.Class) {  		action = NormalizationAction.Normalize;  		AnalystField af = _range == NormalizeRange.NegOne2One ? new AnalystField (f.Name' action' 1' -1) : new AnalystField (f.Name' action' 1' 0);  		norm.Add (af);  		af.ActualHigh = f.Max;  		af.ActualLow = f.Min;  	}  	else if (f.Class) {  		if (isLast && _directClassification) {  			action = NormalizationAction.SingleField;  		}  		else if (f.ClassMembers.Count > 2) {  			action = NormalizationAction.Equilateral;  		}  		else {  			action = NormalizationAction.OneOf;  		}  		norm.Add (_range == NormalizeRange.NegOne2One ? new AnalystField (f.Name' action' 1' -1) : new AnalystField (f.Name' action' 1' 0));  	}  	else {  		action = NormalizationAction.Ignore;  		norm.Add (new AnalystField (action' f.Name));  	}  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateNormalizedFields,The following statement contains a magic number: if (_methodType == WizardMethodType.BayesianNetwork) {  	AnalystField af;  	if (f.Class) {  		af = new AnalystField (f.Name' NormalizationAction.SingleField' 0' 0);  	}  	else {  		af = new AnalystField (f.Name' NormalizationAction.PassThrough' 0' 0);  	}  	norm.Add (af);  }  else if ((f.Integer || f.Real) && !f.Class) {  	action = NormalizationAction.Normalize;  	AnalystField af = _range == NormalizeRange.NegOne2One ? new AnalystField (f.Name' action' 1' -1) : new AnalystField (f.Name' action' 1' 0);  	norm.Add (af);  	af.ActualHigh = f.Max;  	af.ActualLow = f.Min;  }  else if (f.Class) {  	if (isLast && _directClassification) {  		action = NormalizationAction.SingleField;  	}  	else if (f.ClassMembers.Count > 2) {  		action = NormalizationAction.Equilateral;  	}  	else {  		action = NormalizationAction.OneOf;  	}  	norm.Add (_range == NormalizeRange.NegOne2One ? new AnalystField (f.Name' action' 1' -1) : new AnalystField (f.Name' action' 1' 0));  }  else {  	action = NormalizationAction.Ignore;  	norm.Add (new AnalystField (action' f.Name));  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateNormalizedFields,The following statement contains a magic number: if ((f.Integer || f.Real) && !f.Class) {  	action = NormalizationAction.Normalize;  	AnalystField af = _range == NormalizeRange.NegOne2One ? new AnalystField (f.Name' action' 1' -1) : new AnalystField (f.Name' action' 1' 0);  	norm.Add (af);  	af.ActualHigh = f.Max;  	af.ActualLow = f.Min;  }  else if (f.Class) {  	if (isLast && _directClassification) {  		action = NormalizationAction.SingleField;  	}  	else if (f.ClassMembers.Count > 2) {  		action = NormalizationAction.Equilateral;  	}  	else {  		action = NormalizationAction.OneOf;  	}  	norm.Add (_range == NormalizeRange.NegOne2One ? new AnalystField (f.Name' action' 1' -1) : new AnalystField (f.Name' action' 1' 0));  }  else {  	action = NormalizationAction.Ignore;  	norm.Add (new AnalystField (action' f.Name));  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateNormalizedFields,The following statement contains a magic number: if (f.Class) {  	if (isLast && _directClassification) {  		action = NormalizationAction.SingleField;  	}  	else if (f.ClassMembers.Count > 2) {  		action = NormalizationAction.Equilateral;  	}  	else {  		action = NormalizationAction.OneOf;  	}  	norm.Add (_range == NormalizeRange.NegOne2One ? new AnalystField (f.Name' action' 1' -1) : new AnalystField (f.Name' action' 1' 0));  }  else {  	action = NormalizationAction.Ignore;  	norm.Add (new AnalystField (action' f.Name));  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateNormalizedFields,The following statement contains a magic number: if (isLast && _directClassification) {  	action = NormalizationAction.SingleField;  }  else if (f.ClassMembers.Count > 2) {  	action = NormalizationAction.Equilateral;  }  else {  	action = NormalizationAction.OneOf;  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateNormalizedFields,The following statement contains a magic number: if (f.ClassMembers.Count > 2) {  	action = NormalizationAction.Equilateral;  }  else {  	action = NormalizationAction.OneOf;  }  
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\neismit_emds\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateSegregate,The following statement contains a magic number: if (_taskSegregate) {  	var array = new AnalystSegregateTarget[2];  	array [0] = new AnalystSegregateTarget (FileTrain' DefaultTrainPercent);  	array [1] = new AnalystSegregateTarget (FileEval' DefaultEvalPercent);  	_script.Segregate.SegregateTargets = array;  }  else {  	var array = new AnalystSegregateTarget[0];  	_script.Segregate.SegregateTargets = array;  }  
Magic Number,Encog.App.Finance.Indicators,TechnicalIndicators,C:\repos\neismit_emds\encog-core-cs\App\Finance\Indicators\Finance.cs,Avg,The following statement contains a magic number: return (a + b) / 2;  
Magic Number,Encog.App.Quant.Loader.OpenQuant,DataArray,C:\repos\neismit_emds\encog-core-cs\App\Quant\Loader\OpenQuant\BarSeries.cs,GetIndex,The following statement contains a magic number: if (num2 != ticks) {  	num4 = index1 + ((int)((index2 - index1) * ((num3 - ticks) / (num2 - ticks))));  }  else {  	num4 = (index1 + index2) / 2;  }  
Magic Number,Encog.App.Quant.Loader.OpenQuant,DataArray,C:\repos\neismit_emds\encog-core-cs\App\Quant\Loader\OpenQuant\BarSeries.cs,GetIndex,The following statement contains a magic number: num4 = (index1 + index2) / 2;  
Magic Number,Encog.App.Quant.Loader.Yahoo,YahooDownload,C:\repos\neismit_emds\encog-core-cs\App\Quant\Loader\Yahoo\YahooDownload.cs,YahooDownload,The following statement contains a magic number: Precision = 10;  
Magic Number,Encog.App.Quant.Ninja,NinjaStreamWriter,C:\repos\neismit_emds\encog-core-cs\App\Quant\Ninja\NinjaStreamWriter.cs,NinjaStreamWriter,The following statement contains a magic number: Percision = 10;  
Magic Number,Encog.Bot.Browse,Browser,C:\repos\neismit_emds\encog-core-cs\Bot\Browse\Browser.cs,Navigate,The following statement contains a magic number: try {  	#if logging  	                if (logger.IsInfoEnabled)                 {                     logger.Info("Posting a form");                 } #endif  	Stream istream;  	Stream ostream;  	Uri targetURL;  	WebRequest http = null;  	if (form.Method == Form.FormMethod.Get) {  		ostream = new MemoryStream ();  	}  	else {  		http = WebRequest.Create (form.Action.Url);  		http.Timeout = 30000;  		http.ContentType = "application/x-www-form-urlencoded";  		http.Method = "POST";  		ostream = http.GetRequestStream ();  	}  	// add the parameters if present  	var formData = new FormUtility (ostream' null);  	foreach (DocumentRange dr in form.Elements) {  		if (dr is FormElement) {  			var element = (FormElement)dr;  			if ((element == submit) || element.AutoSend) {  				String name = element.Name;  				String value = element.Value;  				if (name != null) {  					if (value == null) {  						value = "";  					}  					formData.Add (name' value);  				}  			}  		}  	}  	// now execute the command  	if (form.Method == Form.FormMethod.Get) {  		String action = form.Action.Url.ToString ();  		ostream.Close ();  		action += "?";  		action += ostream.ToString ();  		targetURL = new Uri (action);  		http = WebRequest.Create (targetURL);  		var response = (HttpWebResponse)http.GetResponse ();  		istream = response.GetResponseStream ();  	}  	else {  		targetURL = form.Action.Url;  		ostream.Close ();  		var response = (HttpWebResponse)http.GetResponse ();  		istream = response.GetResponseStream ();  	}  	Navigate (targetURL' istream);  	istream.Close ();  }  catch (IOException e) {  	throw new BrowseError (e);  }  
Magic Number,Encog.Bot.Browse,Browser,C:\repos\neismit_emds\encog-core-cs\Bot\Browse\Browser.cs,Navigate,The following statement contains a magic number: if (form.Method == Form.FormMethod.Get) {  	ostream = new MemoryStream ();  }  else {  	http = WebRequest.Create (form.Action.Url);  	http.Timeout = 30000;  	http.ContentType = "application/x-www-form-urlencoded";  	http.Method = "POST";  	ostream = http.GetRequestStream ();  }  
Magic Number,Encog.Bot.Browse,Browser,C:\repos\neismit_emds\encog-core-cs\Bot\Browse\Browser.cs,Navigate,The following statement contains a magic number: http.Timeout = 30000;  
Magic Number,Encog.Engine.Network.Activation,ActivationElliott,C:\repos\neismit_emds\encog-core-cs\Engine\Network\Activation\ActivationElliott.cs,ActivationFunction,The following statement contains a magic number: for (int i = start; i < start + size; i++) {  	double s = _p [0];  	x [i] = ((x [i] * s) / 2) / (1 + Math.Abs (x [i] * s)) + 0.5;  }  
Magic Number,Encog.Engine.Network.Activation,ActivationElliott,C:\repos\neismit_emds\encog-core-cs\Engine\Network\Activation\ActivationElliott.cs,ActivationFunction,The following statement contains a magic number: for (int i = start; i < start + size; i++) {  	double s = _p [0];  	x [i] = ((x [i] * s) / 2) / (1 + Math.Abs (x [i] * s)) + 0.5;  }  
Magic Number,Encog.Engine.Network.Activation,ActivationElliott,C:\repos\neismit_emds\encog-core-cs\Engine\Network\Activation\ActivationElliott.cs,ActivationFunction,The following statement contains a magic number: x [i] = ((x [i] * s) / 2) / (1 + Math.Abs (x [i] * s)) + 0.5;  
Magic Number,Encog.Engine.Network.Activation,ActivationElliott,C:\repos\neismit_emds\encog-core-cs\Engine\Network\Activation\ActivationElliott.cs,ActivationFunction,The following statement contains a magic number: x [i] = ((x [i] * s) / 2) / (1 + Math.Abs (x [i] * s)) + 0.5;  
Magic Number,Encog.Engine.Network.Activation,ActivationElliott,C:\repos\neismit_emds\encog-core-cs\Engine\Network\Activation\ActivationElliott.cs,DerivativeFunction,The following statement contains a magic number: return s / (2.0 * (1.0 + Math.Abs (b * s)) * (1 + Math.Abs (b * s)));  
Magic Number,Encog.Engine.Network.Activation,ActivationGaussian,C:\repos\neismit_emds\encog-core-cs\Engine\Network\Activation\ActivationGaussian.cs,ActivationGaussian,The following statement contains a magic number: _paras = new double[3];  
Magic Number,Encog.Engine.Network.Activation,ActivationGaussian,C:\repos\neismit_emds\encog-core-cs\Engine\Network\Activation\ActivationGaussian.cs,ActivationFunction,The following statement contains a magic number: for (int i = start; i < start + size; i++) {  	x [i] = _paras [ParamGaussianPeak] * BoundMath.Exp (-Math.Pow (x [i] - _paras [ParamGaussianCenter]' 2) / (2.0d * _paras [ParamGaussianWidth] * _paras [ParamGaussianWidth]));  }  
Magic Number,Encog.Engine.Network.Activation,ActivationGaussian,C:\repos\neismit_emds\encog-core-cs\Engine\Network\Activation\ActivationGaussian.cs,ActivationFunction,The following statement contains a magic number: x [i] = _paras [ParamGaussianPeak] * BoundMath.Exp (-Math.Pow (x [i] - _paras [ParamGaussianCenter]' 2) / (2.0d * _paras [ParamGaussianWidth] * _paras [ParamGaussianWidth]));  
Magic Number,Encog.Engine.Network.Activation,ActivationRamp,C:\repos\neismit_emds\encog-core-cs\Engine\Network\Activation\ActivationRamp.cs,ActivationRamp,The following statement contains a magic number: _paras = new double[4];  
Magic Number,Encog.Engine.Network.Activation,ActivationStep,C:\repos\neismit_emds\encog-core-cs\Engine\Network\Activation\ActivationStep.cs,ActivationStep,The following statement contains a magic number: _paras = new double[3];  
Magic Number,Encog.Engine.Network.Activation,ActivationTANH,C:\repos\neismit_emds\encog-core-cs\Engine\Network\Activation\ActivationTANH.cs,ActivationFunction,The following statement contains a magic number: for (int i = start; i < start + size; i++) {  	x [i] = 2.0 / (1.0 + BoundMath.Exp (-2.0 * x [i])) - 1.0;  	//3x faster than Math.Tanh(x[i]);  }  
Magic Number,Encog.Engine.Network.Activation,ActivationTANH,C:\repos\neismit_emds\encog-core-cs\Engine\Network\Activation\ActivationTANH.cs,ActivationFunction,The following statement contains a magic number: for (int i = start; i < start + size; i++) {  	x [i] = 2.0 / (1.0 + BoundMath.Exp (-2.0 * x [i])) - 1.0;  	//3x faster than Math.Tanh(x[i]);  }  
Magic Number,Encog.Engine.Network.Activation,ActivationTANH,C:\repos\neismit_emds\encog-core-cs\Engine\Network\Activation\ActivationTANH.cs,ActivationFunction,The following statement contains a magic number: x [i] = 2.0 / (1.0 + BoundMath.Exp (-2.0 * x [i])) - 1.0;  
Magic Number,Encog.Engine.Network.Activation,ActivationTANH,C:\repos\neismit_emds\encog-core-cs\Engine\Network\Activation\ActivationTANH.cs,ActivationFunction,The following statement contains a magic number: x [i] = 2.0 / (1.0 + BoundMath.Exp (-2.0 * x [i])) - 1.0;  
Magic Number,Encog.MathUtil,ComplexNumber,C:\repos\neismit_emds\encog-core-cs\MathUtil\ComplexNumber.cs,Cosh,The following statement contains a magic number: return (Math.Exp (theta) + Math.Exp (-theta)) / 2;  
Magic Number,Encog.MathUtil,ComplexNumber,C:\repos\neismit_emds\encog-core-cs\MathUtil\ComplexNumber.cs,Sinh,The following statement contains a magic number: return (Math.Exp (theta) - Math.Exp (-theta)) / 2;  
Magic Number,Encog.MathUtil,ComplexNumber,C:\repos\neismit_emds\encog-core-cs\MathUtil\ComplexNumber.cs,ToString,The following statement contains a magic number: if (_y == 0) {  	return Format.FormatDouble (_x' 4);  }  
Magic Number,Encog.MathUtil,ComplexNumber,C:\repos\neismit_emds\encog-core-cs\MathUtil\ComplexNumber.cs,ToString,The following statement contains a magic number: return Format.FormatDouble (_x' 4);  
Magic Number,Encog.MathUtil,EncogMath,C:\repos\neismit_emds\encog-core-cs\MathUtil\EncogMath.cs,Deg2Rad,The following statement contains a magic number: return deg * (Math.PI / 180.0);  
Magic Number,Encog.MathUtil,EncogMath,C:\repos\neismit_emds\encog-core-cs\MathUtil\EncogMath.cs,Rad2Deg,The following statement contains a magic number: return rad * (180.0 / Math.PI);  
Magic Number,Encog.MathUtil,NumericRange,C:\repos\neismit_emds\encog-core-cs\MathUtil\NumericRange.cs,ToString,The following statement contains a magic number: result.Append (Format.FormatDouble (_low' 5));  
Magic Number,Encog.MathUtil,NumericRange,C:\repos\neismit_emds\encog-core-cs\MathUtil\NumericRange.cs,ToString,The following statement contains a magic number: result.Append (Format.FormatDouble (_high' 5));  
Magic Number,Encog.MathUtil,NumericRange,C:\repos\neismit_emds\encog-core-cs\MathUtil\NumericRange.cs,ToString,The following statement contains a magic number: result.Append (Format.FormatDouble (_mean' 5));  
Magic Number,Encog.MathUtil,NumericRange,C:\repos\neismit_emds\encog-core-cs\MathUtil\NumericRange.cs,ToString,The following statement contains a magic number: result.Append (Format.FormatDouble (_rms' 5));  
Magic Number,Encog.MathUtil,NumericRange,C:\repos\neismit_emds\encog-core-cs\MathUtil\NumericRange.cs,ToString,The following statement contains a magic number: result.Append (Format.FormatDouble (_standardDeviation' 5));  
Magic Number,Encog.MathUtil,VectorAlgebra,C:\repos\neismit_emds\encog-core-cs\MathUtil\VectorAlgebra.cs,Randomise,The following statement contains a magic number: Randomise (v' 0.1);  
Magic Number,Encog.MathUtil,VectorAlgebra,C:\repos\neismit_emds\encog-core-cs\MathUtil\VectorAlgebra.cs,Randomise,The following statement contains a magic number: for (int i = 0; i < v.Length; i++) {  	v [i] = (2 * rand.NextDouble () - 1) * maxValue;  }  
Magic Number,Encog.MathUtil,VectorAlgebra,C:\repos\neismit_emds\encog-core-cs\MathUtil\VectorAlgebra.cs,Randomise,The following statement contains a magic number: v [i] = (2 * rand.NextDouble () - 1) * maxValue;  
Magic Number,Encog.MathUtil,Equilateral,C:\repos\neismit_emds\encog-core-cs\MathUtil\Equilateral.cs,Equilat,The following statement contains a magic number: for (int k = 2; k < n; k++) {  	// scale the matrix so far  	double r = k;  	double f = Math.Sqrt (r * r - 1.0) / r;  	for (int i = 0; i < k; i++) {  		for (int j = 0; j < k - 1; j++) {  			result [i] [j] *= f;  		}  	}  	r = -1.0 / r;  	for (int i = 0; i < k; i++) {  		result [i] [k - 1] = r;  	}  	for (int i = 0; i < k - 1; i++) {  		result [k] [i] = 0.0;  	}  	result [k] [k - 1] = 1.0;  }  
Magic Number,Encog.MathUtil,Equilateral,C:\repos\neismit_emds\encog-core-cs\MathUtil\Equilateral.cs,GetDistance,The following statement contains a magic number: for (int i = 0; i < data.GetLength (0); i++) {  	result += Math.Pow (data [i] - _matrix [set] [i]' 2);  }  
Magic Number,Encog.MathUtil,Equilateral,C:\repos\neismit_emds\encog-core-cs\MathUtil\Equilateral.cs,GetDistance,The following statement contains a magic number: result += Math.Pow (data [i] - _matrix [set] [i]' 2);  
Magic Number,Encog.MathUtil.Error,ErrorCalculation,C:\repos\neismit_emds\encog-core-cs\MathUtil\Error\ErrorCalculation.cs,CalculateSSE,The following statement contains a magic number: return _globalError / 2;  
Magic Number,Encog.MathUtil.LIBSVM,Cache,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,Cache,The following statement contains a magic number: size /= 4;  
Magic Number,Encog.MathUtil.LIBSVM,Cache,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,Cache,The following statement contains a magic number: size -= l * (16 / 4);  
Magic Number,Encog.MathUtil.LIBSVM,Cache,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,Cache,The following statement contains a magic number: size -= l * (16 / 4);  
Magic Number,Encog.MathUtil.LIBSVM,Kernel,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,tanh,The following statement contains a magic number: return 1.0 - 2.0 / (e * e + 1);  
Magic Number,Encog.MathUtil.LIBSVM,Kernel,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,kernel_function,The following statement contains a magic number: switch (kernel_type) {  case svm_parameter.LINEAR:  	return dot (x [i]' x [j]);  case svm_parameter.POLY:  	return Math.Pow (gamma * dot (x [i]' x [j]) + coef0' degree);  case svm_parameter.RBF:  	return Math.Exp ((-gamma) * (x_square [i] + x_square [j] - 2 * dot (x [i]' x [j])));  case svm_parameter.SIGMOID:  	return tanh (gamma * dot (x [i]' x [j]) + coef0);  default:  	return 0;  // java  }  
Magic Number,Encog.MathUtil.LIBSVM,Kernel,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,kernel_function,The following statement contains a magic number: return Math.Exp ((-gamma) * (x_square [i] + x_square [j] - 2 * dot (x [i]' x [j])));  
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: while (true) {  	// max iterations?  	if (iter > 10000)  		break;  	// show progress and do shrinking  	if (--counter == 0) {  		counter = Math.Min (l' 1000);  		if (shrinking != 0)  			do_shrinking ();  		//Console.Error.Write(".");  	}  	if (select_working_set (working_set) != 0) {  		// reconstruct the whole gradient  		reconstruct_gradient ();  		// reset active set size and check  		active_size = l;  		//Console.Error.Write("*");  		if (select_working_set (working_set) != 0)  			break;  		else  			counter = 1;  		// do shrinking next iteration  	}  	int i = working_set [0];  	int j = working_set [1];  	++iter;  	// update alpha[i] and alpha[j]' handle bounds carefully  	float[] Q_i = Q.get_Q (i' active_size);  	float[] Q_j = Q.get_Q (j' active_size);  	double C_i = get_C (i);  	double C_j = get_C (j);  	double old_alpha_i = alpha [i];  	double old_alpha_j = alpha [j];  	if (y [i] != y [j]) {  		double delta = (-G [i] - G [j]) / Math.Max (Q_i [i] + Q_j [j] + 2 * Q_i [j]' 0);  		double diff = alpha [i] - alpha [j];  		alpha [i] += delta;  		alpha [j] += delta;  		if (diff > 0) {  			if (alpha [j] < 0) {  				alpha [j] = 0;  				alpha [i] = diff;  			}  		}  		else {  			if (alpha [i] < 0) {  				alpha [i] = 0;  				alpha [j] = -diff;  			}  		}  		if (diff > C_i - C_j) {  			if (alpha [i] > C_i) {  				alpha [i] = C_i;  				alpha [j] = C_i - diff;  			}  		}  		else {  			if (alpha [j] > C_j) {  				alpha [j] = C_j;  				alpha [i] = C_j + diff;  			}  		}  	}  	else {  		double delta = (G [i] - G [j]) / Math.Max (Q_i [i] + Q_j [j] - 2 * Q_i [j]' 0);  		double sum = alpha [i] + alpha [j];  		alpha [i] -= delta;  		alpha [j] += delta;  		if (sum > C_i) {  			if (alpha [i] > C_i) {  				alpha [i] = C_i;  				alpha [j] = sum - C_i;  			}  		}  		else {  			if (alpha [j] < 0) {  				alpha [j] = 0;  				alpha [i] = sum;  			}  		}  		if (sum > C_j) {  			if (alpha [j] > C_j) {  				alpha [j] = C_j;  				alpha [i] = sum - C_j;  			}  		}  		else {  			if (alpha [i] < 0) {  				alpha [i] = 0;  				alpha [j] = sum;  			}  		}  	}  	// update G  	double delta_alpha_i = alpha [i] - old_alpha_i;  	double delta_alpha_j = alpha [j] - old_alpha_j;  	for (int k = 0; k < active_size; k++) {  		G [k] += Q_i [k] * delta_alpha_i + Q_j [k] * delta_alpha_j;  	}  	// update alpha_status and G_bar  	{  		bool ui = is_upper_bound (i);  		bool uj = is_upper_bound (j);  		update_alpha_status (i);  		update_alpha_status (j);  		int k;  		if (ui != is_upper_bound (i)) {  			Q_i = Q.get_Q (i' l);  			if (ui)  				for (k = 0; k < l; k++)  					G_bar [k] -= C_i * Q_i [k];  			else  				for (k = 0; k < l; k++)  					G_bar [k] += C_i * Q_i [k];  		}  		if (uj != is_upper_bound (j)) {  			Q_j = Q.get_Q (j' l);  			if (uj)  				for (k = 0; k < l; k++)  					G_bar [k] -= C_j * Q_j [k];  			else  				for (k = 0; k < l; k++)  					G_bar [k] += C_j * Q_j [k];  		}  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: while (true) {  	// max iterations?  	if (iter > 10000)  		break;  	// show progress and do shrinking  	if (--counter == 0) {  		counter = Math.Min (l' 1000);  		if (shrinking != 0)  			do_shrinking ();  		//Console.Error.Write(".");  	}  	if (select_working_set (working_set) != 0) {  		// reconstruct the whole gradient  		reconstruct_gradient ();  		// reset active set size and check  		active_size = l;  		//Console.Error.Write("*");  		if (select_working_set (working_set) != 0)  			break;  		else  			counter = 1;  		// do shrinking next iteration  	}  	int i = working_set [0];  	int j = working_set [1];  	++iter;  	// update alpha[i] and alpha[j]' handle bounds carefully  	float[] Q_i = Q.get_Q (i' active_size);  	float[] Q_j = Q.get_Q (j' active_size);  	double C_i = get_C (i);  	double C_j = get_C (j);  	double old_alpha_i = alpha [i];  	double old_alpha_j = alpha [j];  	if (y [i] != y [j]) {  		double delta = (-G [i] - G [j]) / Math.Max (Q_i [i] + Q_j [j] + 2 * Q_i [j]' 0);  		double diff = alpha [i] - alpha [j];  		alpha [i] += delta;  		alpha [j] += delta;  		if (diff > 0) {  			if (alpha [j] < 0) {  				alpha [j] = 0;  				alpha [i] = diff;  			}  		}  		else {  			if (alpha [i] < 0) {  				alpha [i] = 0;  				alpha [j] = -diff;  			}  		}  		if (diff > C_i - C_j) {  			if (alpha [i] > C_i) {  				alpha [i] = C_i;  				alpha [j] = C_i - diff;  			}  		}  		else {  			if (alpha [j] > C_j) {  				alpha [j] = C_j;  				alpha [i] = C_j + diff;  			}  		}  	}  	else {  		double delta = (G [i] - G [j]) / Math.Max (Q_i [i] + Q_j [j] - 2 * Q_i [j]' 0);  		double sum = alpha [i] + alpha [j];  		alpha [i] -= delta;  		alpha [j] += delta;  		if (sum > C_i) {  			if (alpha [i] > C_i) {  				alpha [i] = C_i;  				alpha [j] = sum - C_i;  			}  		}  		else {  			if (alpha [j] < 0) {  				alpha [j] = 0;  				alpha [i] = sum;  			}  		}  		if (sum > C_j) {  			if (alpha [j] > C_j) {  				alpha [j] = C_j;  				alpha [i] = sum - C_j;  			}  		}  		else {  			if (alpha [i] < 0) {  				alpha [i] = 0;  				alpha [j] = sum;  			}  		}  	}  	// update G  	double delta_alpha_i = alpha [i] - old_alpha_i;  	double delta_alpha_j = alpha [j] - old_alpha_j;  	for (int k = 0; k < active_size; k++) {  		G [k] += Q_i [k] * delta_alpha_i + Q_j [k] * delta_alpha_j;  	}  	// update alpha_status and G_bar  	{  		bool ui = is_upper_bound (i);  		bool uj = is_upper_bound (j);  		update_alpha_status (i);  		update_alpha_status (j);  		int k;  		if (ui != is_upper_bound (i)) {  			Q_i = Q.get_Q (i' l);  			if (ui)  				for (k = 0; k < l; k++)  					G_bar [k] -= C_i * Q_i [k];  			else  				for (k = 0; k < l; k++)  					G_bar [k] += C_i * Q_i [k];  		}  		if (uj != is_upper_bound (j)) {  			Q_j = Q.get_Q (j' l);  			if (uj)  				for (k = 0; k < l; k++)  					G_bar [k] -= C_j * Q_j [k];  			else  				for (k = 0; k < l; k++)  					G_bar [k] += C_j * Q_j [k];  		}  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: while (true) {  	// max iterations?  	if (iter > 10000)  		break;  	// show progress and do shrinking  	if (--counter == 0) {  		counter = Math.Min (l' 1000);  		if (shrinking != 0)  			do_shrinking ();  		//Console.Error.Write(".");  	}  	if (select_working_set (working_set) != 0) {  		// reconstruct the whole gradient  		reconstruct_gradient ();  		// reset active set size and check  		active_size = l;  		//Console.Error.Write("*");  		if (select_working_set (working_set) != 0)  			break;  		else  			counter = 1;  		// do shrinking next iteration  	}  	int i = working_set [0];  	int j = working_set [1];  	++iter;  	// update alpha[i] and alpha[j]' handle bounds carefully  	float[] Q_i = Q.get_Q (i' active_size);  	float[] Q_j = Q.get_Q (j' active_size);  	double C_i = get_C (i);  	double C_j = get_C (j);  	double old_alpha_i = alpha [i];  	double old_alpha_j = alpha [j];  	if (y [i] != y [j]) {  		double delta = (-G [i] - G [j]) / Math.Max (Q_i [i] + Q_j [j] + 2 * Q_i [j]' 0);  		double diff = alpha [i] - alpha [j];  		alpha [i] += delta;  		alpha [j] += delta;  		if (diff > 0) {  			if (alpha [j] < 0) {  				alpha [j] = 0;  				alpha [i] = diff;  			}  		}  		else {  			if (alpha [i] < 0) {  				alpha [i] = 0;  				alpha [j] = -diff;  			}  		}  		if (diff > C_i - C_j) {  			if (alpha [i] > C_i) {  				alpha [i] = C_i;  				alpha [j] = C_i - diff;  			}  		}  		else {  			if (alpha [j] > C_j) {  				alpha [j] = C_j;  				alpha [i] = C_j + diff;  			}  		}  	}  	else {  		double delta = (G [i] - G [j]) / Math.Max (Q_i [i] + Q_j [j] - 2 * Q_i [j]' 0);  		double sum = alpha [i] + alpha [j];  		alpha [i] -= delta;  		alpha [j] += delta;  		if (sum > C_i) {  			if (alpha [i] > C_i) {  				alpha [i] = C_i;  				alpha [j] = sum - C_i;  			}  		}  		else {  			if (alpha [j] < 0) {  				alpha [j] = 0;  				alpha [i] = sum;  			}  		}  		if (sum > C_j) {  			if (alpha [j] > C_j) {  				alpha [j] = C_j;  				alpha [i] = sum - C_j;  			}  		}  		else {  			if (alpha [i] < 0) {  				alpha [i] = 0;  				alpha [j] = sum;  			}  		}  	}  	// update G  	double delta_alpha_i = alpha [i] - old_alpha_i;  	double delta_alpha_j = alpha [j] - old_alpha_j;  	for (int k = 0; k < active_size; k++) {  		G [k] += Q_i [k] * delta_alpha_i + Q_j [k] * delta_alpha_j;  	}  	// update alpha_status and G_bar  	{  		bool ui = is_upper_bound (i);  		bool uj = is_upper_bound (j);  		update_alpha_status (i);  		update_alpha_status (j);  		int k;  		if (ui != is_upper_bound (i)) {  			Q_i = Q.get_Q (i' l);  			if (ui)  				for (k = 0; k < l; k++)  					G_bar [k] -= C_i * Q_i [k];  			else  				for (k = 0; k < l; k++)  					G_bar [k] += C_i * Q_i [k];  		}  		if (uj != is_upper_bound (j)) {  			Q_j = Q.get_Q (j' l);  			if (uj)  				for (k = 0; k < l; k++)  					G_bar [k] -= C_j * Q_j [k];  			else  				for (k = 0; k < l; k++)  					G_bar [k] += C_j * Q_j [k];  		}  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: while (true) {  	// max iterations?  	if (iter > 10000)  		break;  	// show progress and do shrinking  	if (--counter == 0) {  		counter = Math.Min (l' 1000);  		if (shrinking != 0)  			do_shrinking ();  		//Console.Error.Write(".");  	}  	if (select_working_set (working_set) != 0) {  		// reconstruct the whole gradient  		reconstruct_gradient ();  		// reset active set size and check  		active_size = l;  		//Console.Error.Write("*");  		if (select_working_set (working_set) != 0)  			break;  		else  			counter = 1;  		// do shrinking next iteration  	}  	int i = working_set [0];  	int j = working_set [1];  	++iter;  	// update alpha[i] and alpha[j]' handle bounds carefully  	float[] Q_i = Q.get_Q (i' active_size);  	float[] Q_j = Q.get_Q (j' active_size);  	double C_i = get_C (i);  	double C_j = get_C (j);  	double old_alpha_i = alpha [i];  	double old_alpha_j = alpha [j];  	if (y [i] != y [j]) {  		double delta = (-G [i] - G [j]) / Math.Max (Q_i [i] + Q_j [j] + 2 * Q_i [j]' 0);  		double diff = alpha [i] - alpha [j];  		alpha [i] += delta;  		alpha [j] += delta;  		if (diff > 0) {  			if (alpha [j] < 0) {  				alpha [j] = 0;  				alpha [i] = diff;  			}  		}  		else {  			if (alpha [i] < 0) {  				alpha [i] = 0;  				alpha [j] = -diff;  			}  		}  		if (diff > C_i - C_j) {  			if (alpha [i] > C_i) {  				alpha [i] = C_i;  				alpha [j] = C_i - diff;  			}  		}  		else {  			if (alpha [j] > C_j) {  				alpha [j] = C_j;  				alpha [i] = C_j + diff;  			}  		}  	}  	else {  		double delta = (G [i] - G [j]) / Math.Max (Q_i [i] + Q_j [j] - 2 * Q_i [j]' 0);  		double sum = alpha [i] + alpha [j];  		alpha [i] -= delta;  		alpha [j] += delta;  		if (sum > C_i) {  			if (alpha [i] > C_i) {  				alpha [i] = C_i;  				alpha [j] = sum - C_i;  			}  		}  		else {  			if (alpha [j] < 0) {  				alpha [j] = 0;  				alpha [i] = sum;  			}  		}  		if (sum > C_j) {  			if (alpha [j] > C_j) {  				alpha [j] = C_j;  				alpha [i] = sum - C_j;  			}  		}  		else {  			if (alpha [i] < 0) {  				alpha [i] = 0;  				alpha [j] = sum;  			}  		}  	}  	// update G  	double delta_alpha_i = alpha [i] - old_alpha_i;  	double delta_alpha_j = alpha [j] - old_alpha_j;  	for (int k = 0; k < active_size; k++) {  		G [k] += Q_i [k] * delta_alpha_i + Q_j [k] * delta_alpha_j;  	}  	// update alpha_status and G_bar  	{  		bool ui = is_upper_bound (i);  		bool uj = is_upper_bound (j);  		update_alpha_status (i);  		update_alpha_status (j);  		int k;  		if (ui != is_upper_bound (i)) {  			Q_i = Q.get_Q (i' l);  			if (ui)  				for (k = 0; k < l; k++)  					G_bar [k] -= C_i * Q_i [k];  			else  				for (k = 0; k < l; k++)  					G_bar [k] += C_i * Q_i [k];  		}  		if (uj != is_upper_bound (j)) {  			Q_j = Q.get_Q (j' l);  			if (uj)  				for (k = 0; k < l; k++)  					G_bar [k] -= C_j * Q_j [k];  			else  				for (k = 0; k < l; k++)  					G_bar [k] += C_j * Q_j [k];  		}  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: if (iter > 10000)  	break;  
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: if (--counter == 0) {  	counter = Math.Min (l' 1000);  	if (shrinking != 0)  		do_shrinking ();  	//Console.Error.Write(".");  }  
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: counter = Math.Min (l' 1000);  
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: if (y [i] != y [j]) {  	double delta = (-G [i] - G [j]) / Math.Max (Q_i [i] + Q_j [j] + 2 * Q_i [j]' 0);  	double diff = alpha [i] - alpha [j];  	alpha [i] += delta;  	alpha [j] += delta;  	if (diff > 0) {  		if (alpha [j] < 0) {  			alpha [j] = 0;  			alpha [i] = diff;  		}  	}  	else {  		if (alpha [i] < 0) {  			alpha [i] = 0;  			alpha [j] = -diff;  		}  	}  	if (diff > C_i - C_j) {  		if (alpha [i] > C_i) {  			alpha [i] = C_i;  			alpha [j] = C_i - diff;  		}  	}  	else {  		if (alpha [j] > C_j) {  			alpha [j] = C_j;  			alpha [i] = C_j + diff;  		}  	}  }  else {  	double delta = (G [i] - G [j]) / Math.Max (Q_i [i] + Q_j [j] - 2 * Q_i [j]' 0);  	double sum = alpha [i] + alpha [j];  	alpha [i] -= delta;  	alpha [j] += delta;  	if (sum > C_i) {  		if (alpha [i] > C_i) {  			alpha [i] = C_i;  			alpha [j] = sum - C_i;  		}  	}  	else {  		if (alpha [j] < 0) {  			alpha [j] = 0;  			alpha [i] = sum;  		}  	}  	if (sum > C_j) {  		if (alpha [j] > C_j) {  			alpha [j] = C_j;  			alpha [i] = sum - C_j;  		}  	}  	else {  		if (alpha [i] < 0) {  			alpha [i] = 0;  			alpha [j] = sum;  		}  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: if (y [i] != y [j]) {  	double delta = (-G [i] - G [j]) / Math.Max (Q_i [i] + Q_j [j] + 2 * Q_i [j]' 0);  	double diff = alpha [i] - alpha [j];  	alpha [i] += delta;  	alpha [j] += delta;  	if (diff > 0) {  		if (alpha [j] < 0) {  			alpha [j] = 0;  			alpha [i] = diff;  		}  	}  	else {  		if (alpha [i] < 0) {  			alpha [i] = 0;  			alpha [j] = -diff;  		}  	}  	if (diff > C_i - C_j) {  		if (alpha [i] > C_i) {  			alpha [i] = C_i;  			alpha [j] = C_i - diff;  		}  	}  	else {  		if (alpha [j] > C_j) {  			alpha [j] = C_j;  			alpha [i] = C_j + diff;  		}  	}  }  else {  	double delta = (G [i] - G [j]) / Math.Max (Q_i [i] + Q_j [j] - 2 * Q_i [j]' 0);  	double sum = alpha [i] + alpha [j];  	alpha [i] -= delta;  	alpha [j] += delta;  	if (sum > C_i) {  		if (alpha [i] > C_i) {  			alpha [i] = C_i;  			alpha [j] = sum - C_i;  		}  	}  	else {  		if (alpha [j] < 0) {  			alpha [j] = 0;  			alpha [i] = sum;  		}  	}  	if (sum > C_j) {  		if (alpha [j] > C_j) {  			alpha [j] = C_j;  			alpha [i] = sum - C_j;  		}  	}  	else {  		if (alpha [i] < 0) {  			alpha [i] = 0;  			alpha [j] = sum;  		}  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: si.obj = v / 2;  
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,do_shrinking,The following statement contains a magic number: if (unshrinked || -(Gm1 + Gm2) > eps * 10)  	return;  
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,calculate_rho,The following statement contains a magic number: if (nr_free > 0)  	r = sum_free / nr_free;  else  	r = (ub + lb) / 2;  
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,calculate_rho,The following statement contains a magic number: r = (ub + lb) / 2;  
Magic Number,Encog.MathUtil.LIBSVM,Solver_NU,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,do_shrinking,The following statement contains a magic number: if (unshrinked || Math.Max (-(Gm1 + Gm2)' -(Gm3 + Gm4)) > eps * 10)  	return;  
Magic Number,Encog.MathUtil.LIBSVM,Solver_NU,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,calculate_rho,The following statement contains a magic number: if (nr_free1 > 0)  	r1 = sum_free1 / nr_free1;  else  	r1 = (ub1 + lb1) / 2;  
Magic Number,Encog.MathUtil.LIBSVM,Solver_NU,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,calculate_rho,The following statement contains a magic number: r1 = (ub1 + lb1) / 2;  
Magic Number,Encog.MathUtil.LIBSVM,Solver_NU,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,calculate_rho,The following statement contains a magic number: if (nr_free2 > 0)  	r2 = sum_free2 / nr_free2;  else  	r2 = (ub2 + lb2) / 2;  
Magic Number,Encog.MathUtil.LIBSVM,Solver_NU,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,calculate_rho,The following statement contains a magic number: r2 = (ub2 + lb2) / 2;  
Magic Number,Encog.MathUtil.LIBSVM,Solver_NU,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,calculate_rho,The following statement contains a magic number: si.r = (r1 + r2) / 2;  
Magic Number,Encog.MathUtil.LIBSVM,Solver_NU,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,calculate_rho,The following statement contains a magic number: return (r1 - r2) / 2;  
Magic Number,Encog.MathUtil.LIBSVM,SVC_Q,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVC_Q,The following statement contains a magic number: cache = new Cache (prob.l' (int)(param.cache_size * (1 << 20)));  
Magic Number,Encog.MathUtil.LIBSVM,ONE_CLASS_Q,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,ONE_CLASS_Q,The following statement contains a magic number: cache = new Cache (prob.l' (int)(param.cache_size * (1 << 20)));  
Magic Number,Encog.MathUtil.LIBSVM,SVR_Q,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVR_Q,The following statement contains a magic number: cache = new Cache (l' (int)(param.cache_size * (1 << 20)));  
Magic Number,Encog.MathUtil.LIBSVM,SVR_Q,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVR_Q,The following statement contains a magic number: sign = new sbyte[2 * l];  
Magic Number,Encog.MathUtil.LIBSVM,SVR_Q,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVR_Q,The following statement contains a magic number: index = new int[2 * l];  
Magic Number,Encog.MathUtil.LIBSVM,SVR_Q,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVR_Q,The following statement contains a magic number: buffer = new float[2][];  
Magic Number,Encog.MathUtil.LIBSVM,SVR_Q,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVR_Q,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	buffer [i] = new float[2 * l];  }  
Magic Number,Encog.MathUtil.LIBSVM,SVR_Q,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVR_Q,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	buffer [i] = new float[2 * l];  }  
Magic Number,Encog.MathUtil.LIBSVM,SVR_Q,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVR_Q,The following statement contains a magic number: buffer [i] = new float[2 * l];  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_epsilon_svr,The following statement contains a magic number: s.Solve (2 * l' new SVR_Q (prob' param)' linear_term' y' alpha2' param.C' param.C' param.eps' si' param.shrinking);  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_nu_svr,The following statement contains a magic number: s.Solve (2 * l' new SVR_Q (prob' param)' linear_term' y' alpha2' C' C' param.eps' si' param.shrinking);  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: for (iter = 0; iter < max_iter; iter++) {  	// Update Gradient and Hessian (use H' = H + sigma I)  	h11 = sigma;  	// numerically ensures strict PD  	h22 = sigma;  	h21 = 0.0;  	g1 = 0.0;  	g2 = 0.0;  	for (i = 0; i < l; i++) {  		fApB = dec_values [i] * A + B;  		if (fApB >= 0) {  			p = Math.Exp (-fApB) / (1.0 + Math.Exp (-fApB));  			q = 1.0 / (1.0 + Math.Exp (-fApB));  		}  		else {  			p = 1.0 / (1.0 + Math.Exp (fApB));  			q = Math.Exp (fApB) / (1.0 + Math.Exp (fApB));  		}  		d2 = p * q;  		h11 += dec_values [i] * dec_values [i] * d2;  		h22 += d2;  		h21 += dec_values [i] * d2;  		d1 = t [i] - p;  		g1 += dec_values [i] * d1;  		g2 += d1;  	}  	// Stopping Criteria  	if (Math.Abs (g1) < eps && Math.Abs (g2) < eps)  		break;  	// Finding Newton direction: -inv(H') * g  	det = h11 * h22 - h21 * h21;  	dA = (-(h22 * g1 - h21 * g2)) / det;  	dB = (-((-h21) * g1 + h11 * g2)) / det;  	gd = g1 * dA + g2 * dB;  	stepsize = 1;  	// Line Search  	while (stepsize >= min_step) {  		newA = A + stepsize * dA;  		newB = B + stepsize * dB;  		// New function value  		newf = 0.0;  		for (i = 0; i < l; i++) {  			fApB = dec_values [i] * newA + newB;  			if (fApB >= 0)  				newf += t [i] * fApB + Math.Log (1 + Math.Exp (-fApB));  			else  				newf += (t [i] - 1) * fApB + Math.Log (1 + Math.Exp (fApB));  		}  		// Check sufficient decrease  		if (newf < fval + 0.0001 * stepsize * gd) {  			A = newA;  			B = newB;  			fval = newf;  			break;  		}  		else  			stepsize = stepsize / 2.0;  	}  	if (stepsize < min_step) {  		//Console.Error.Write("Line search fails in two-class probability estimates\n");  		break;  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: for (iter = 0; iter < max_iter; iter++) {  	// Update Gradient and Hessian (use H' = H + sigma I)  	h11 = sigma;  	// numerically ensures strict PD  	h22 = sigma;  	h21 = 0.0;  	g1 = 0.0;  	g2 = 0.0;  	for (i = 0; i < l; i++) {  		fApB = dec_values [i] * A + B;  		if (fApB >= 0) {  			p = Math.Exp (-fApB) / (1.0 + Math.Exp (-fApB));  			q = 1.0 / (1.0 + Math.Exp (-fApB));  		}  		else {  			p = 1.0 / (1.0 + Math.Exp (fApB));  			q = Math.Exp (fApB) / (1.0 + Math.Exp (fApB));  		}  		d2 = p * q;  		h11 += dec_values [i] * dec_values [i] * d2;  		h22 += d2;  		h21 += dec_values [i] * d2;  		d1 = t [i] - p;  		g1 += dec_values [i] * d1;  		g2 += d1;  	}  	// Stopping Criteria  	if (Math.Abs (g1) < eps && Math.Abs (g2) < eps)  		break;  	// Finding Newton direction: -inv(H') * g  	det = h11 * h22 - h21 * h21;  	dA = (-(h22 * g1 - h21 * g2)) / det;  	dB = (-((-h21) * g1 + h11 * g2)) / det;  	gd = g1 * dA + g2 * dB;  	stepsize = 1;  	// Line Search  	while (stepsize >= min_step) {  		newA = A + stepsize * dA;  		newB = B + stepsize * dB;  		// New function value  		newf = 0.0;  		for (i = 0; i < l; i++) {  			fApB = dec_values [i] * newA + newB;  			if (fApB >= 0)  				newf += t [i] * fApB + Math.Log (1 + Math.Exp (-fApB));  			else  				newf += (t [i] - 1) * fApB + Math.Log (1 + Math.Exp (fApB));  		}  		// Check sufficient decrease  		if (newf < fval + 0.0001 * stepsize * gd) {  			A = newA;  			B = newB;  			fval = newf;  			break;  		}  		else  			stepsize = stepsize / 2.0;  	}  	if (stepsize < min_step) {  		//Console.Error.Write("Line search fails in two-class probability estimates\n");  		break;  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: while (stepsize >= min_step) {  	newA = A + stepsize * dA;  	newB = B + stepsize * dB;  	// New function value  	newf = 0.0;  	for (i = 0; i < l; i++) {  		fApB = dec_values [i] * newA + newB;  		if (fApB >= 0)  			newf += t [i] * fApB + Math.Log (1 + Math.Exp (-fApB));  		else  			newf += (t [i] - 1) * fApB + Math.Log (1 + Math.Exp (fApB));  	}  	// Check sufficient decrease  	if (newf < fval + 0.0001 * stepsize * gd) {  		A = newA;  		B = newB;  		fval = newf;  		break;  	}  	else  		stepsize = stepsize / 2.0;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: while (stepsize >= min_step) {  	newA = A + stepsize * dA;  	newB = B + stepsize * dB;  	// New function value  	newf = 0.0;  	for (i = 0; i < l; i++) {  		fApB = dec_values [i] * newA + newB;  		if (fApB >= 0)  			newf += t [i] * fApB + Math.Log (1 + Math.Exp (-fApB));  		else  			newf += (t [i] - 1) * fApB + Math.Log (1 + Math.Exp (fApB));  	}  	// Check sufficient decrease  	if (newf < fval + 0.0001 * stepsize * gd) {  		A = newA;  		B = newB;  		fval = newf;  		break;  	}  	else  		stepsize = stepsize / 2.0;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: if (newf < fval + 0.0001 * stepsize * gd) {  	A = newA;  	B = newB;  	fval = newf;  	break;  }  else  	stepsize = stepsize / 2.0;  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: if (newf < fval + 0.0001 * stepsize * gd) {  	A = newA;  	B = newB;  	fval = newf;  	break;  }  else  	stepsize = stepsize / 2.0;  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: stepsize = stepsize / 2.0;  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,multiclass_probability,The following statement contains a magic number: for (iter = 0; iter < max_iter; iter++) {  	// stopping condition' recalculate QP'pQP for numerical accuracy  	pQp = 0;  	for (t = 0; t < k; t++) {  		Qp [t] = 0;  		for (int j = 0; j < k; j++)  			Qp [t] += Q [t] [j] * p [j];  		pQp += p [t] * Qp [t];  	}  	double max_error = 0;  	for (t = 0; t < k; t++) {  		double error = Math.Abs (Qp [t] - pQp);  		if (error > max_error)  			max_error = error;  	}  	if (max_error < eps)  		break;  	for (t = 0; t < k; t++) {  		double diff = (-Qp [t] + pQp) / Q [t] [t];  		p [t] += diff;  		pQp = (pQp + diff * (diff * Q [t] [t] + 2 * Qp [t])) / (1 + diff) / (1 + diff);  		for (int j = 0; j < k; j++) {  			Qp [j] = (Qp [j] + diff * Q [t] [j]) / (1 + diff);  			p [j] /= (1 + diff);  		}  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,multiclass_probability,The following statement contains a magic number: for (t = 0; t < k; t++) {  	double diff = (-Qp [t] + pQp) / Q [t] [t];  	p [t] += diff;  	pQp = (pQp + diff * (diff * Q [t] [t] + 2 * Qp [t])) / (1 + diff) / (1 + diff);  	for (int j = 0; j < k; j++) {  		Qp [j] = (Qp [j] + diff * Q [t] [j]) / (1 + diff);  		p [j] /= (1 + diff);  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,multiclass_probability,The following statement contains a magic number: pQp = (pQp + diff * (diff * Q [t] [t] + 2 * Qp [t])) / (1 + diff) / (1 + diff);  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: for (i = 0; i < nr_fold; i++) {  	int begin = i * prob.l / nr_fold;  	int end = (i + 1) * prob.l / nr_fold;  	int j' k;  	var subprob = new svm_problem ();  	subprob.l = prob.l - (end - begin);  	subprob.x = new svm_node[subprob.l][];  	subprob.y = new double[subprob.l];  	k = 0;  	for (j = 0; j < begin; j++) {  		subprob.x [k] = prob.x [perm [j]];  		subprob.y [k] = prob.y [perm [j]];  		++k;  	}  	for (j = end; j < prob.l; j++) {  		subprob.x [k] = prob.x [perm [j]];  		subprob.y [k] = prob.y [perm [j]];  		++k;  	}  	int p_count = 0' n_count = 0;  	for (j = 0; j < k; j++)  		if (subprob.y [j] > 0)  			p_count++;  		else  			n_count++;  	if (p_count == 0 && n_count == 0)  		for (j = begin; j < end; j++)  			dec_values [perm [j]] = 0;  	else if (p_count > 0 && n_count == 0)  		for (j = begin; j < end; j++)  			dec_values [perm [j]] = 1;  	else if (p_count == 0 && n_count > 0)  		for (j = begin; j < end; j++)  			dec_values [perm [j]] = -1;  	else {  		var subparam = (svm_parameter)param.Clone ();  		subparam.probability = 0;  		subparam.C = 1.0;  		subparam.nr_weight = 2;  		subparam.weight_label = new int[2];  		subparam.weight = new double[2];  		subparam.weight_label [0] = +1;  		subparam.weight_label [1] = -1;  		subparam.weight [0] = Cp;  		subparam.weight [1] = Cn;  		svm_model submodel = svm_train (subprob' subparam);  		for (j = begin; j < end; j++) {  			var dec_value = new double[1];  			svm_predict_values (submodel' prob.x [perm [j]]' dec_value);  			dec_values [perm [j]] = dec_value [0];  			// ensure +1 -1 order; reason not using CV subroutine  			dec_values [perm [j]] *= submodel.label [0];  		}  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: for (i = 0; i < nr_fold; i++) {  	int begin = i * prob.l / nr_fold;  	int end = (i + 1) * prob.l / nr_fold;  	int j' k;  	var subprob = new svm_problem ();  	subprob.l = prob.l - (end - begin);  	subprob.x = new svm_node[subprob.l][];  	subprob.y = new double[subprob.l];  	k = 0;  	for (j = 0; j < begin; j++) {  		subprob.x [k] = prob.x [perm [j]];  		subprob.y [k] = prob.y [perm [j]];  		++k;  	}  	for (j = end; j < prob.l; j++) {  		subprob.x [k] = prob.x [perm [j]];  		subprob.y [k] = prob.y [perm [j]];  		++k;  	}  	int p_count = 0' n_count = 0;  	for (j = 0; j < k; j++)  		if (subprob.y [j] > 0)  			p_count++;  		else  			n_count++;  	if (p_count == 0 && n_count == 0)  		for (j = begin; j < end; j++)  			dec_values [perm [j]] = 0;  	else if (p_count > 0 && n_count == 0)  		for (j = begin; j < end; j++)  			dec_values [perm [j]] = 1;  	else if (p_count == 0 && n_count > 0)  		for (j = begin; j < end; j++)  			dec_values [perm [j]] = -1;  	else {  		var subparam = (svm_parameter)param.Clone ();  		subparam.probability = 0;  		subparam.C = 1.0;  		subparam.nr_weight = 2;  		subparam.weight_label = new int[2];  		subparam.weight = new double[2];  		subparam.weight_label [0] = +1;  		subparam.weight_label [1] = -1;  		subparam.weight [0] = Cp;  		subparam.weight [1] = Cn;  		svm_model submodel = svm_train (subprob' subparam);  		for (j = begin; j < end; j++) {  			var dec_value = new double[1];  			svm_predict_values (submodel' prob.x [perm [j]]' dec_value);  			dec_values [perm [j]] = dec_value [0];  			// ensure +1 -1 order; reason not using CV subroutine  			dec_values [perm [j]] *= submodel.label [0];  		}  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: for (i = 0; i < nr_fold; i++) {  	int begin = i * prob.l / nr_fold;  	int end = (i + 1) * prob.l / nr_fold;  	int j' k;  	var subprob = new svm_problem ();  	subprob.l = prob.l - (end - begin);  	subprob.x = new svm_node[subprob.l][];  	subprob.y = new double[subprob.l];  	k = 0;  	for (j = 0; j < begin; j++) {  		subprob.x [k] = prob.x [perm [j]];  		subprob.y [k] = prob.y [perm [j]];  		++k;  	}  	for (j = end; j < prob.l; j++) {  		subprob.x [k] = prob.x [perm [j]];  		subprob.y [k] = prob.y [perm [j]];  		++k;  	}  	int p_count = 0' n_count = 0;  	for (j = 0; j < k; j++)  		if (subprob.y [j] > 0)  			p_count++;  		else  			n_count++;  	if (p_count == 0 && n_count == 0)  		for (j = begin; j < end; j++)  			dec_values [perm [j]] = 0;  	else if (p_count > 0 && n_count == 0)  		for (j = begin; j < end; j++)  			dec_values [perm [j]] = 1;  	else if (p_count == 0 && n_count > 0)  		for (j = begin; j < end; j++)  			dec_values [perm [j]] = -1;  	else {  		var subparam = (svm_parameter)param.Clone ();  		subparam.probability = 0;  		subparam.C = 1.0;  		subparam.nr_weight = 2;  		subparam.weight_label = new int[2];  		subparam.weight = new double[2];  		subparam.weight_label [0] = +1;  		subparam.weight_label [1] = -1;  		subparam.weight [0] = Cp;  		subparam.weight [1] = Cn;  		svm_model submodel = svm_train (subprob' subparam);  		for (j = begin; j < end; j++) {  			var dec_value = new double[1];  			svm_predict_values (submodel' prob.x [perm [j]]' dec_value);  			dec_values [perm [j]] = dec_value [0];  			// ensure +1 -1 order; reason not using CV subroutine  			dec_values [perm [j]] *= submodel.label [0];  		}  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: if (p_count == 0 && n_count == 0)  	for (j = begin; j < end; j++)  		dec_values [perm [j]] = 0;  else if (p_count > 0 && n_count == 0)  	for (j = begin; j < end; j++)  		dec_values [perm [j]] = 1;  else if (p_count == 0 && n_count > 0)  	for (j = begin; j < end; j++)  		dec_values [perm [j]] = -1;  else {  	var subparam = (svm_parameter)param.Clone ();  	subparam.probability = 0;  	subparam.C = 1.0;  	subparam.nr_weight = 2;  	subparam.weight_label = new int[2];  	subparam.weight = new double[2];  	subparam.weight_label [0] = +1;  	subparam.weight_label [1] = -1;  	subparam.weight [0] = Cp;  	subparam.weight [1] = Cn;  	svm_model submodel = svm_train (subprob' subparam);  	for (j = begin; j < end; j++) {  		var dec_value = new double[1];  		svm_predict_values (submodel' prob.x [perm [j]]' dec_value);  		dec_values [perm [j]] = dec_value [0];  		// ensure +1 -1 order; reason not using CV subroutine  		dec_values [perm [j]] *= submodel.label [0];  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: if (p_count == 0 && n_count == 0)  	for (j = begin; j < end; j++)  		dec_values [perm [j]] = 0;  else if (p_count > 0 && n_count == 0)  	for (j = begin; j < end; j++)  		dec_values [perm [j]] = 1;  else if (p_count == 0 && n_count > 0)  	for (j = begin; j < end; j++)  		dec_values [perm [j]] = -1;  else {  	var subparam = (svm_parameter)param.Clone ();  	subparam.probability = 0;  	subparam.C = 1.0;  	subparam.nr_weight = 2;  	subparam.weight_label = new int[2];  	subparam.weight = new double[2];  	subparam.weight_label [0] = +1;  	subparam.weight_label [1] = -1;  	subparam.weight [0] = Cp;  	subparam.weight [1] = Cn;  	svm_model submodel = svm_train (subprob' subparam);  	for (j = begin; j < end; j++) {  		var dec_value = new double[1];  		svm_predict_values (submodel' prob.x [perm [j]]' dec_value);  		dec_values [perm [j]] = dec_value [0];  		// ensure +1 -1 order; reason not using CV subroutine  		dec_values [perm [j]] *= submodel.label [0];  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: if (p_count == 0 && n_count == 0)  	for (j = begin; j < end; j++)  		dec_values [perm [j]] = 0;  else if (p_count > 0 && n_count == 0)  	for (j = begin; j < end; j++)  		dec_values [perm [j]] = 1;  else if (p_count == 0 && n_count > 0)  	for (j = begin; j < end; j++)  		dec_values [perm [j]] = -1;  else {  	var subparam = (svm_parameter)param.Clone ();  	subparam.probability = 0;  	subparam.C = 1.0;  	subparam.nr_weight = 2;  	subparam.weight_label = new int[2];  	subparam.weight = new double[2];  	subparam.weight_label [0] = +1;  	subparam.weight_label [1] = -1;  	subparam.weight [0] = Cp;  	subparam.weight [1] = Cn;  	svm_model submodel = svm_train (subprob' subparam);  	for (j = begin; j < end; j++) {  		var dec_value = new double[1];  		svm_predict_values (submodel' prob.x [perm [j]]' dec_value);  		dec_values [perm [j]] = dec_value [0];  		// ensure +1 -1 order; reason not using CV subroutine  		dec_values [perm [j]] *= submodel.label [0];  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: if (p_count > 0 && n_count == 0)  	for (j = begin; j < end; j++)  		dec_values [perm [j]] = 1;  else if (p_count == 0 && n_count > 0)  	for (j = begin; j < end; j++)  		dec_values [perm [j]] = -1;  else {  	var subparam = (svm_parameter)param.Clone ();  	subparam.probability = 0;  	subparam.C = 1.0;  	subparam.nr_weight = 2;  	subparam.weight_label = new int[2];  	subparam.weight = new double[2];  	subparam.weight_label [0] = +1;  	subparam.weight_label [1] = -1;  	subparam.weight [0] = Cp;  	subparam.weight [1] = Cn;  	svm_model submodel = svm_train (subprob' subparam);  	for (j = begin; j < end; j++) {  		var dec_value = new double[1];  		svm_predict_values (submodel' prob.x [perm [j]]' dec_value);  		dec_values [perm [j]] = dec_value [0];  		// ensure +1 -1 order; reason not using CV subroutine  		dec_values [perm [j]] *= submodel.label [0];  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: if (p_count > 0 && n_count == 0)  	for (j = begin; j < end; j++)  		dec_values [perm [j]] = 1;  else if (p_count == 0 && n_count > 0)  	for (j = begin; j < end; j++)  		dec_values [perm [j]] = -1;  else {  	var subparam = (svm_parameter)param.Clone ();  	subparam.probability = 0;  	subparam.C = 1.0;  	subparam.nr_weight = 2;  	subparam.weight_label = new int[2];  	subparam.weight = new double[2];  	subparam.weight_label [0] = +1;  	subparam.weight_label [1] = -1;  	subparam.weight [0] = Cp;  	subparam.weight [1] = Cn;  	svm_model submodel = svm_train (subprob' subparam);  	for (j = begin; j < end; j++) {  		var dec_value = new double[1];  		svm_predict_values (submodel' prob.x [perm [j]]' dec_value);  		dec_values [perm [j]] = dec_value [0];  		// ensure +1 -1 order; reason not using CV subroutine  		dec_values [perm [j]] *= submodel.label [0];  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: if (p_count > 0 && n_count == 0)  	for (j = begin; j < end; j++)  		dec_values [perm [j]] = 1;  else if (p_count == 0 && n_count > 0)  	for (j = begin; j < end; j++)  		dec_values [perm [j]] = -1;  else {  	var subparam = (svm_parameter)param.Clone ();  	subparam.probability = 0;  	subparam.C = 1.0;  	subparam.nr_weight = 2;  	subparam.weight_label = new int[2];  	subparam.weight = new double[2];  	subparam.weight_label [0] = +1;  	subparam.weight_label [1] = -1;  	subparam.weight [0] = Cp;  	subparam.weight [1] = Cn;  	svm_model submodel = svm_train (subprob' subparam);  	for (j = begin; j < end; j++) {  		var dec_value = new double[1];  		svm_predict_values (submodel' prob.x [perm [j]]' dec_value);  		dec_values [perm [j]] = dec_value [0];  		// ensure +1 -1 order; reason not using CV subroutine  		dec_values [perm [j]] *= submodel.label [0];  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: if (p_count == 0 && n_count > 0)  	for (j = begin; j < end; j++)  		dec_values [perm [j]] = -1;  else {  	var subparam = (svm_parameter)param.Clone ();  	subparam.probability = 0;  	subparam.C = 1.0;  	subparam.nr_weight = 2;  	subparam.weight_label = new int[2];  	subparam.weight = new double[2];  	subparam.weight_label [0] = +1;  	subparam.weight_label [1] = -1;  	subparam.weight [0] = Cp;  	subparam.weight [1] = Cn;  	svm_model submodel = svm_train (subprob' subparam);  	for (j = begin; j < end; j++) {  		var dec_value = new double[1];  		svm_predict_values (submodel' prob.x [perm [j]]' dec_value);  		dec_values [perm [j]] = dec_value [0];  		// ensure +1 -1 order; reason not using CV subroutine  		dec_values [perm [j]] *= submodel.label [0];  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: if (p_count == 0 && n_count > 0)  	for (j = begin; j < end; j++)  		dec_values [perm [j]] = -1;  else {  	var subparam = (svm_parameter)param.Clone ();  	subparam.probability = 0;  	subparam.C = 1.0;  	subparam.nr_weight = 2;  	subparam.weight_label = new int[2];  	subparam.weight = new double[2];  	subparam.weight_label [0] = +1;  	subparam.weight_label [1] = -1;  	subparam.weight [0] = Cp;  	subparam.weight [1] = Cn;  	svm_model submodel = svm_train (subprob' subparam);  	for (j = begin; j < end; j++) {  		var dec_value = new double[1];  		svm_predict_values (submodel' prob.x [perm [j]]' dec_value);  		dec_values [perm [j]] = dec_value [0];  		// ensure +1 -1 order; reason not using CV subroutine  		dec_values [perm [j]] *= submodel.label [0];  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: if (p_count == 0 && n_count > 0)  	for (j = begin; j < end; j++)  		dec_values [perm [j]] = -1;  else {  	var subparam = (svm_parameter)param.Clone ();  	subparam.probability = 0;  	subparam.C = 1.0;  	subparam.nr_weight = 2;  	subparam.weight_label = new int[2];  	subparam.weight = new double[2];  	subparam.weight_label [0] = +1;  	subparam.weight_label [1] = -1;  	subparam.weight [0] = Cp;  	subparam.weight [1] = Cn;  	svm_model submodel = svm_train (subprob' subparam);  	for (j = begin; j < end; j++) {  		var dec_value = new double[1];  		svm_predict_values (submodel' prob.x [perm [j]]' dec_value);  		dec_values [perm [j]] = dec_value [0];  		// ensure +1 -1 order; reason not using CV subroutine  		dec_values [perm [j]] *= submodel.label [0];  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: subparam.nr_weight = 2;  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: subparam.weight_label = new int[2];  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: subparam.weight = new double[2];  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_svr_probability,The following statement contains a magic number: for (i = 0; i < prob.l; i++)  	if (Math.Abs (ymv [i]) > 5 * std)  		count = count + 1;  	else  		mae += Math.Abs (ymv [i]);  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_svr_probability,The following statement contains a magic number: if (Math.Abs (ymv [i]) > 5 * std)  	count = count + 1;  else  	mae += Math.Abs (ymv [i]);  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR) {  	// regression or one-class-svm  	model.nr_class = 2;  	model.label = null;  	model.nSV = null;  	model.probA = null;  	model.probB = null;  	model.sv_coef = new double[1][];  	if (param.probability == 1 && (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR)) {  		model.probA = new double[1];  		model.probA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.rho = new double[1];  	model.rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.l = nSV;  	model.SV = new svm_node[nSV][];  	model.sv_coef [0] = new double[nSV];  	int j = 0;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SV [j] = prob.x [i];  			model.sv_coef [0] [j] = f.alpha [i];  			++j;  		}  }  else {  	// classification  	// find out the number of classes  	int l = prob.l;  	int max_nr_class = 16;  	int nr_class = 0;  	var label = new int[max_nr_class];  	var count = new int[max_nr_class];  	var index = new int[l];  	int i;  	for (i = 0; i < l; i++) {  		//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'  		var this_label = (int)prob.y [i];  		int j;  		for (j = 0; j < nr_class; j++)  			if (this_label == label [j]) {  				++count [j];  				break;  			}  		index [i] = j;  		if (j == nr_class) {  			if (nr_class == max_nr_class) {  				max_nr_class *= 2;  				var new_data = new int[max_nr_class];  				Array.Copy (label' 0' new_data' 0' label.Length);  				label = new_data;  				new_data = new int[max_nr_class];  				Array.Copy (count' 0' new_data' 0' count.Length);  				count = new_data;  			}  			label [nr_class] = this_label;  			count [nr_class] = 1;  			++nr_class;  		}  	}  	// group training data of the same class  	var start = new int[nr_class];  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	var x = new svm_node[l][];  	for (i = 0; i < l; i++) {  		x [start [index [i]]] = prob.x [i];  		++start [index [i]];  	}  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	// calculate weighted C  	var weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < param.nr_weight; i++) {  		int j;  		for (j = 0; j < nr_class; j++)  			if (param.weight_label [i] == label [j])  				break;  		if (j == nr_class)  			;  		/*Console.Error.Write("warning: class label " + param.weight_label[i] +                                         " specified in weight is not found\n");*/else  			weighted_C [j] *= param.weight [i];  	}  	// train k*(k-1)/2 models  	var nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	var f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.probability == 1) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			var sub_prob = new svm_problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.l = ci + cj;  			sub_prob.x = new svm_node[sub_prob.l][];  			sub_prob.y = new double[sub_prob.l];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.x [k] = x [si + k];  				sub_prob.y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.x [ci + k] = x [sj + k];  				sub_prob.y [ci + k] = -1;  			}  			if (param.probability == 1) {  				var probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.nr_class = nr_class;  	model.label = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.label [i] = label [i];  	model.rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.rho [i] = f [i].rho;  	if (param.probability == 1) {  		model.probA = new double[nr_class * (nr_class - 1) / 2];  		model.probB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.probA [i] = probA [i];  			model.probB [i] = probB [i];  		}  	}  	else {  		model.probA = null;  		model.probB = null;  	}  	int nnz = 0;  	var nz_count = new int[nr_class];  	model.nSV = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.nSV [i] = nSV;  		nz_count [i] = nSV;  	}  	//Console.Out.Write("Total nSV = " + nnz + "\n");  	model.l = nnz;  	model.SV = new svm_node[nnz][];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i])  			model.SV [p++] = x [i];  	var nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.sv_coef = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.sv_coef [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.sv_coef [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.sv_coef [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR) {  	// regression or one-class-svm  	model.nr_class = 2;  	model.label = null;  	model.nSV = null;  	model.probA = null;  	model.probB = null;  	model.sv_coef = new double[1][];  	if (param.probability == 1 && (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR)) {  		model.probA = new double[1];  		model.probA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.rho = new double[1];  	model.rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.l = nSV;  	model.SV = new svm_node[nSV][];  	model.sv_coef [0] = new double[nSV];  	int j = 0;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SV [j] = prob.x [i];  			model.sv_coef [0] [j] = f.alpha [i];  			++j;  		}  }  else {  	// classification  	// find out the number of classes  	int l = prob.l;  	int max_nr_class = 16;  	int nr_class = 0;  	var label = new int[max_nr_class];  	var count = new int[max_nr_class];  	var index = new int[l];  	int i;  	for (i = 0; i < l; i++) {  		//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'  		var this_label = (int)prob.y [i];  		int j;  		for (j = 0; j < nr_class; j++)  			if (this_label == label [j]) {  				++count [j];  				break;  			}  		index [i] = j;  		if (j == nr_class) {  			if (nr_class == max_nr_class) {  				max_nr_class *= 2;  				var new_data = new int[max_nr_class];  				Array.Copy (label' 0' new_data' 0' label.Length);  				label = new_data;  				new_data = new int[max_nr_class];  				Array.Copy (count' 0' new_data' 0' count.Length);  				count = new_data;  			}  			label [nr_class] = this_label;  			count [nr_class] = 1;  			++nr_class;  		}  	}  	// group training data of the same class  	var start = new int[nr_class];  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	var x = new svm_node[l][];  	for (i = 0; i < l; i++) {  		x [start [index [i]]] = prob.x [i];  		++start [index [i]];  	}  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	// calculate weighted C  	var weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < param.nr_weight; i++) {  		int j;  		for (j = 0; j < nr_class; j++)  			if (param.weight_label [i] == label [j])  				break;  		if (j == nr_class)  			;  		/*Console.Error.Write("warning: class label " + param.weight_label[i] +                                         " specified in weight is not found\n");*/else  			weighted_C [j] *= param.weight [i];  	}  	// train k*(k-1)/2 models  	var nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	var f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.probability == 1) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			var sub_prob = new svm_problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.l = ci + cj;  			sub_prob.x = new svm_node[sub_prob.l][];  			sub_prob.y = new double[sub_prob.l];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.x [k] = x [si + k];  				sub_prob.y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.x [ci + k] = x [sj + k];  				sub_prob.y [ci + k] = -1;  			}  			if (param.probability == 1) {  				var probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.nr_class = nr_class;  	model.label = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.label [i] = label [i];  	model.rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.rho [i] = f [i].rho;  	if (param.probability == 1) {  		model.probA = new double[nr_class * (nr_class - 1) / 2];  		model.probB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.probA [i] = probA [i];  			model.probB [i] = probB [i];  		}  	}  	else {  		model.probA = null;  		model.probB = null;  	}  	int nnz = 0;  	var nz_count = new int[nr_class];  	model.nSV = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.nSV [i] = nSV;  		nz_count [i] = nSV;  	}  	//Console.Out.Write("Total nSV = " + nnz + "\n");  	model.l = nnz;  	model.SV = new svm_node[nnz][];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i])  			model.SV [p++] = x [i];  	var nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.sv_coef = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.sv_coef [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.sv_coef [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.sv_coef [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR) {  	// regression or one-class-svm  	model.nr_class = 2;  	model.label = null;  	model.nSV = null;  	model.probA = null;  	model.probB = null;  	model.sv_coef = new double[1][];  	if (param.probability == 1 && (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR)) {  		model.probA = new double[1];  		model.probA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.rho = new double[1];  	model.rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.l = nSV;  	model.SV = new svm_node[nSV][];  	model.sv_coef [0] = new double[nSV];  	int j = 0;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SV [j] = prob.x [i];  			model.sv_coef [0] [j] = f.alpha [i];  			++j;  		}  }  else {  	// classification  	// find out the number of classes  	int l = prob.l;  	int max_nr_class = 16;  	int nr_class = 0;  	var label = new int[max_nr_class];  	var count = new int[max_nr_class];  	var index = new int[l];  	int i;  	for (i = 0; i < l; i++) {  		//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'  		var this_label = (int)prob.y [i];  		int j;  		for (j = 0; j < nr_class; j++)  			if (this_label == label [j]) {  				++count [j];  				break;  			}  		index [i] = j;  		if (j == nr_class) {  			if (nr_class == max_nr_class) {  				max_nr_class *= 2;  				var new_data = new int[max_nr_class];  				Array.Copy (label' 0' new_data' 0' label.Length);  				label = new_data;  				new_data = new int[max_nr_class];  				Array.Copy (count' 0' new_data' 0' count.Length);  				count = new_data;  			}  			label [nr_class] = this_label;  			count [nr_class] = 1;  			++nr_class;  		}  	}  	// group training data of the same class  	var start = new int[nr_class];  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	var x = new svm_node[l][];  	for (i = 0; i < l; i++) {  		x [start [index [i]]] = prob.x [i];  		++start [index [i]];  	}  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	// calculate weighted C  	var weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < param.nr_weight; i++) {  		int j;  		for (j = 0; j < nr_class; j++)  			if (param.weight_label [i] == label [j])  				break;  		if (j == nr_class)  			;  		/*Console.Error.Write("warning: class label " + param.weight_label[i] +                                         " specified in weight is not found\n");*/else  			weighted_C [j] *= param.weight [i];  	}  	// train k*(k-1)/2 models  	var nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	var f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.probability == 1) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			var sub_prob = new svm_problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.l = ci + cj;  			sub_prob.x = new svm_node[sub_prob.l][];  			sub_prob.y = new double[sub_prob.l];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.x [k] = x [si + k];  				sub_prob.y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.x [ci + k] = x [sj + k];  				sub_prob.y [ci + k] = -1;  			}  			if (param.probability == 1) {  				var probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.nr_class = nr_class;  	model.label = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.label [i] = label [i];  	model.rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.rho [i] = f [i].rho;  	if (param.probability == 1) {  		model.probA = new double[nr_class * (nr_class - 1) / 2];  		model.probB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.probA [i] = probA [i];  			model.probB [i] = probB [i];  		}  	}  	else {  		model.probA = null;  		model.probB = null;  	}  	int nnz = 0;  	var nz_count = new int[nr_class];  	model.nSV = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.nSV [i] = nSV;  		nz_count [i] = nSV;  	}  	//Console.Out.Write("Total nSV = " + nnz + "\n");  	model.l = nnz;  	model.SV = new svm_node[nnz][];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i])  			model.SV [p++] = x [i];  	var nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.sv_coef = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.sv_coef [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.sv_coef [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.sv_coef [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR) {  	// regression or one-class-svm  	model.nr_class = 2;  	model.label = null;  	model.nSV = null;  	model.probA = null;  	model.probB = null;  	model.sv_coef = new double[1][];  	if (param.probability == 1 && (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR)) {  		model.probA = new double[1];  		model.probA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.rho = new double[1];  	model.rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.l = nSV;  	model.SV = new svm_node[nSV][];  	model.sv_coef [0] = new double[nSV];  	int j = 0;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SV [j] = prob.x [i];  			model.sv_coef [0] [j] = f.alpha [i];  			++j;  		}  }  else {  	// classification  	// find out the number of classes  	int l = prob.l;  	int max_nr_class = 16;  	int nr_class = 0;  	var label = new int[max_nr_class];  	var count = new int[max_nr_class];  	var index = new int[l];  	int i;  	for (i = 0; i < l; i++) {  		//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'  		var this_label = (int)prob.y [i];  		int j;  		for (j = 0; j < nr_class; j++)  			if (this_label == label [j]) {  				++count [j];  				break;  			}  		index [i] = j;  		if (j == nr_class) {  			if (nr_class == max_nr_class) {  				max_nr_class *= 2;  				var new_data = new int[max_nr_class];  				Array.Copy (label' 0' new_data' 0' label.Length);  				label = new_data;  				new_data = new int[max_nr_class];  				Array.Copy (count' 0' new_data' 0' count.Length);  				count = new_data;  			}  			label [nr_class] = this_label;  			count [nr_class] = 1;  			++nr_class;  		}  	}  	// group training data of the same class  	var start = new int[nr_class];  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	var x = new svm_node[l][];  	for (i = 0; i < l; i++) {  		x [start [index [i]]] = prob.x [i];  		++start [index [i]];  	}  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	// calculate weighted C  	var weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < param.nr_weight; i++) {  		int j;  		for (j = 0; j < nr_class; j++)  			if (param.weight_label [i] == label [j])  				break;  		if (j == nr_class)  			;  		/*Console.Error.Write("warning: class label " + param.weight_label[i] +                                         " specified in weight is not found\n");*/else  			weighted_C [j] *= param.weight [i];  	}  	// train k*(k-1)/2 models  	var nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	var f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.probability == 1) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			var sub_prob = new svm_problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.l = ci + cj;  			sub_prob.x = new svm_node[sub_prob.l][];  			sub_prob.y = new double[sub_prob.l];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.x [k] = x [si + k];  				sub_prob.y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.x [ci + k] = x [sj + k];  				sub_prob.y [ci + k] = -1;  			}  			if (param.probability == 1) {  				var probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.nr_class = nr_class;  	model.label = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.label [i] = label [i];  	model.rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.rho [i] = f [i].rho;  	if (param.probability == 1) {  		model.probA = new double[nr_class * (nr_class - 1) / 2];  		model.probB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.probA [i] = probA [i];  			model.probB [i] = probB [i];  		}  	}  	else {  		model.probA = null;  		model.probB = null;  	}  	int nnz = 0;  	var nz_count = new int[nr_class];  	model.nSV = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.nSV [i] = nSV;  		nz_count [i] = nSV;  	}  	//Console.Out.Write("Total nSV = " + nnz + "\n");  	model.l = nnz;  	model.SV = new svm_node[nnz][];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i])  			model.SV [p++] = x [i];  	var nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.sv_coef = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.sv_coef [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.sv_coef [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.sv_coef [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR) {  	// regression or one-class-svm  	model.nr_class = 2;  	model.label = null;  	model.nSV = null;  	model.probA = null;  	model.probB = null;  	model.sv_coef = new double[1][];  	if (param.probability == 1 && (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR)) {  		model.probA = new double[1];  		model.probA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.rho = new double[1];  	model.rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.l = nSV;  	model.SV = new svm_node[nSV][];  	model.sv_coef [0] = new double[nSV];  	int j = 0;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SV [j] = prob.x [i];  			model.sv_coef [0] [j] = f.alpha [i];  			++j;  		}  }  else {  	// classification  	// find out the number of classes  	int l = prob.l;  	int max_nr_class = 16;  	int nr_class = 0;  	var label = new int[max_nr_class];  	var count = new int[max_nr_class];  	var index = new int[l];  	int i;  	for (i = 0; i < l; i++) {  		//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'  		var this_label = (int)prob.y [i];  		int j;  		for (j = 0; j < nr_class; j++)  			if (this_label == label [j]) {  				++count [j];  				break;  			}  		index [i] = j;  		if (j == nr_class) {  			if (nr_class == max_nr_class) {  				max_nr_class *= 2;  				var new_data = new int[max_nr_class];  				Array.Copy (label' 0' new_data' 0' label.Length);  				label = new_data;  				new_data = new int[max_nr_class];  				Array.Copy (count' 0' new_data' 0' count.Length);  				count = new_data;  			}  			label [nr_class] = this_label;  			count [nr_class] = 1;  			++nr_class;  		}  	}  	// group training data of the same class  	var start = new int[nr_class];  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	var x = new svm_node[l][];  	for (i = 0; i < l; i++) {  		x [start [index [i]]] = prob.x [i];  		++start [index [i]];  	}  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	// calculate weighted C  	var weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < param.nr_weight; i++) {  		int j;  		for (j = 0; j < nr_class; j++)  			if (param.weight_label [i] == label [j])  				break;  		if (j == nr_class)  			;  		/*Console.Error.Write("warning: class label " + param.weight_label[i] +                                         " specified in weight is not found\n");*/else  			weighted_C [j] *= param.weight [i];  	}  	// train k*(k-1)/2 models  	var nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	var f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.probability == 1) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			var sub_prob = new svm_problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.l = ci + cj;  			sub_prob.x = new svm_node[sub_prob.l][];  			sub_prob.y = new double[sub_prob.l];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.x [k] = x [si + k];  				sub_prob.y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.x [ci + k] = x [sj + k];  				sub_prob.y [ci + k] = -1;  			}  			if (param.probability == 1) {  				var probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.nr_class = nr_class;  	model.label = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.label [i] = label [i];  	model.rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.rho [i] = f [i].rho;  	if (param.probability == 1) {  		model.probA = new double[nr_class * (nr_class - 1) / 2];  		model.probB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.probA [i] = probA [i];  			model.probB [i] = probB [i];  		}  	}  	else {  		model.probA = null;  		model.probB = null;  	}  	int nnz = 0;  	var nz_count = new int[nr_class];  	model.nSV = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.nSV [i] = nSV;  		nz_count [i] = nSV;  	}  	//Console.Out.Write("Total nSV = " + nnz + "\n");  	model.l = nnz;  	model.SV = new svm_node[nnz][];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i])  			model.SV [p++] = x [i];  	var nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.sv_coef = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.sv_coef [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.sv_coef [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.sv_coef [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR) {  	// regression or one-class-svm  	model.nr_class = 2;  	model.label = null;  	model.nSV = null;  	model.probA = null;  	model.probB = null;  	model.sv_coef = new double[1][];  	if (param.probability == 1 && (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR)) {  		model.probA = new double[1];  		model.probA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.rho = new double[1];  	model.rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.l = nSV;  	model.SV = new svm_node[nSV][];  	model.sv_coef [0] = new double[nSV];  	int j = 0;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SV [j] = prob.x [i];  			model.sv_coef [0] [j] = f.alpha [i];  			++j;  		}  }  else {  	// classification  	// find out the number of classes  	int l = prob.l;  	int max_nr_class = 16;  	int nr_class = 0;  	var label = new int[max_nr_class];  	var count = new int[max_nr_class];  	var index = new int[l];  	int i;  	for (i = 0; i < l; i++) {  		//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'  		var this_label = (int)prob.y [i];  		int j;  		for (j = 0; j < nr_class; j++)  			if (this_label == label [j]) {  				++count [j];  				break;  			}  		index [i] = j;  		if (j == nr_class) {  			if (nr_class == max_nr_class) {  				max_nr_class *= 2;  				var new_data = new int[max_nr_class];  				Array.Copy (label' 0' new_data' 0' label.Length);  				label = new_data;  				new_data = new int[max_nr_class];  				Array.Copy (count' 0' new_data' 0' count.Length);  				count = new_data;  			}  			label [nr_class] = this_label;  			count [nr_class] = 1;  			++nr_class;  		}  	}  	// group training data of the same class  	var start = new int[nr_class];  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	var x = new svm_node[l][];  	for (i = 0; i < l; i++) {  		x [start [index [i]]] = prob.x [i];  		++start [index [i]];  	}  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	// calculate weighted C  	var weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < param.nr_weight; i++) {  		int j;  		for (j = 0; j < nr_class; j++)  			if (param.weight_label [i] == label [j])  				break;  		if (j == nr_class)  			;  		/*Console.Error.Write("warning: class label " + param.weight_label[i] +                                         " specified in weight is not found\n");*/else  			weighted_C [j] *= param.weight [i];  	}  	// train k*(k-1)/2 models  	var nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	var f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.probability == 1) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			var sub_prob = new svm_problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.l = ci + cj;  			sub_prob.x = new svm_node[sub_prob.l][];  			sub_prob.y = new double[sub_prob.l];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.x [k] = x [si + k];  				sub_prob.y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.x [ci + k] = x [sj + k];  				sub_prob.y [ci + k] = -1;  			}  			if (param.probability == 1) {  				var probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.nr_class = nr_class;  	model.label = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.label [i] = label [i];  	model.rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.rho [i] = f [i].rho;  	if (param.probability == 1) {  		model.probA = new double[nr_class * (nr_class - 1) / 2];  		model.probB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.probA [i] = probA [i];  			model.probB [i] = probB [i];  		}  	}  	else {  		model.probA = null;  		model.probB = null;  	}  	int nnz = 0;  	var nz_count = new int[nr_class];  	model.nSV = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.nSV [i] = nSV;  		nz_count [i] = nSV;  	}  	//Console.Out.Write("Total nSV = " + nnz + "\n");  	model.l = nnz;  	model.SV = new svm_node[nnz][];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i])  			model.SV [p++] = x [i];  	var nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.sv_coef = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.sv_coef [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.sv_coef [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.sv_coef [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR) {  	// regression or one-class-svm  	model.nr_class = 2;  	model.label = null;  	model.nSV = null;  	model.probA = null;  	model.probB = null;  	model.sv_coef = new double[1][];  	if (param.probability == 1 && (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR)) {  		model.probA = new double[1];  		model.probA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.rho = new double[1];  	model.rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.l = nSV;  	model.SV = new svm_node[nSV][];  	model.sv_coef [0] = new double[nSV];  	int j = 0;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SV [j] = prob.x [i];  			model.sv_coef [0] [j] = f.alpha [i];  			++j;  		}  }  else {  	// classification  	// find out the number of classes  	int l = prob.l;  	int max_nr_class = 16;  	int nr_class = 0;  	var label = new int[max_nr_class];  	var count = new int[max_nr_class];  	var index = new int[l];  	int i;  	for (i = 0; i < l; i++) {  		//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'  		var this_label = (int)prob.y [i];  		int j;  		for (j = 0; j < nr_class; j++)  			if (this_label == label [j]) {  				++count [j];  				break;  			}  		index [i] = j;  		if (j == nr_class) {  			if (nr_class == max_nr_class) {  				max_nr_class *= 2;  				var new_data = new int[max_nr_class];  				Array.Copy (label' 0' new_data' 0' label.Length);  				label = new_data;  				new_data = new int[max_nr_class];  				Array.Copy (count' 0' new_data' 0' count.Length);  				count = new_data;  			}  			label [nr_class] = this_label;  			count [nr_class] = 1;  			++nr_class;  		}  	}  	// group training data of the same class  	var start = new int[nr_class];  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	var x = new svm_node[l][];  	for (i = 0; i < l; i++) {  		x [start [index [i]]] = prob.x [i];  		++start [index [i]];  	}  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	// calculate weighted C  	var weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < param.nr_weight; i++) {  		int j;  		for (j = 0; j < nr_class; j++)  			if (param.weight_label [i] == label [j])  				break;  		if (j == nr_class)  			;  		/*Console.Error.Write("warning: class label " + param.weight_label[i] +                                         " specified in weight is not found\n");*/else  			weighted_C [j] *= param.weight [i];  	}  	// train k*(k-1)/2 models  	var nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	var f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.probability == 1) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			var sub_prob = new svm_problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.l = ci + cj;  			sub_prob.x = new svm_node[sub_prob.l][];  			sub_prob.y = new double[sub_prob.l];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.x [k] = x [si + k];  				sub_prob.y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.x [ci + k] = x [sj + k];  				sub_prob.y [ci + k] = -1;  			}  			if (param.probability == 1) {  				var probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.nr_class = nr_class;  	model.label = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.label [i] = label [i];  	model.rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.rho [i] = f [i].rho;  	if (param.probability == 1) {  		model.probA = new double[nr_class * (nr_class - 1) / 2];  		model.probB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.probA [i] = probA [i];  			model.probB [i] = probB [i];  		}  	}  	else {  		model.probA = null;  		model.probB = null;  	}  	int nnz = 0;  	var nz_count = new int[nr_class];  	model.nSV = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.nSV [i] = nSV;  		nz_count [i] = nSV;  	}  	//Console.Out.Write("Total nSV = " + nnz + "\n");  	model.l = nnz;  	model.SV = new svm_node[nnz][];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i])  			model.SV [p++] = x [i];  	var nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.sv_coef = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.sv_coef [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.sv_coef [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.sv_coef [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR) {  	// regression or one-class-svm  	model.nr_class = 2;  	model.label = null;  	model.nSV = null;  	model.probA = null;  	model.probB = null;  	model.sv_coef = new double[1][];  	if (param.probability == 1 && (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR)) {  		model.probA = new double[1];  		model.probA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.rho = new double[1];  	model.rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.l = nSV;  	model.SV = new svm_node[nSV][];  	model.sv_coef [0] = new double[nSV];  	int j = 0;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SV [j] = prob.x [i];  			model.sv_coef [0] [j] = f.alpha [i];  			++j;  		}  }  else {  	// classification  	// find out the number of classes  	int l = prob.l;  	int max_nr_class = 16;  	int nr_class = 0;  	var label = new int[max_nr_class];  	var count = new int[max_nr_class];  	var index = new int[l];  	int i;  	for (i = 0; i < l; i++) {  		//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'  		var this_label = (int)prob.y [i];  		int j;  		for (j = 0; j < nr_class; j++)  			if (this_label == label [j]) {  				++count [j];  				break;  			}  		index [i] = j;  		if (j == nr_class) {  			if (nr_class == max_nr_class) {  				max_nr_class *= 2;  				var new_data = new int[max_nr_class];  				Array.Copy (label' 0' new_data' 0' label.Length);  				label = new_data;  				new_data = new int[max_nr_class];  				Array.Copy (count' 0' new_data' 0' count.Length);  				count = new_data;  			}  			label [nr_class] = this_label;  			count [nr_class] = 1;  			++nr_class;  		}  	}  	// group training data of the same class  	var start = new int[nr_class];  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	var x = new svm_node[l][];  	for (i = 0; i < l; i++) {  		x [start [index [i]]] = prob.x [i];  		++start [index [i]];  	}  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	// calculate weighted C  	var weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < param.nr_weight; i++) {  		int j;  		for (j = 0; j < nr_class; j++)  			if (param.weight_label [i] == label [j])  				break;  		if (j == nr_class)  			;  		/*Console.Error.Write("warning: class label " + param.weight_label[i] +                                         " specified in weight is not found\n");*/else  			weighted_C [j] *= param.weight [i];  	}  	// train k*(k-1)/2 models  	var nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	var f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.probability == 1) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			var sub_prob = new svm_problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.l = ci + cj;  			sub_prob.x = new svm_node[sub_prob.l][];  			sub_prob.y = new double[sub_prob.l];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.x [k] = x [si + k];  				sub_prob.y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.x [ci + k] = x [sj + k];  				sub_prob.y [ci + k] = -1;  			}  			if (param.probability == 1) {  				var probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.nr_class = nr_class;  	model.label = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.label [i] = label [i];  	model.rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.rho [i] = f [i].rho;  	if (param.probability == 1) {  		model.probA = new double[nr_class * (nr_class - 1) / 2];  		model.probB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.probA [i] = probA [i];  			model.probB [i] = probB [i];  		}  	}  	else {  		model.probA = null;  		model.probB = null;  	}  	int nnz = 0;  	var nz_count = new int[nr_class];  	model.nSV = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.nSV [i] = nSV;  		nz_count [i] = nSV;  	}  	//Console.Out.Write("Total nSV = " + nnz + "\n");  	model.l = nnz;  	model.SV = new svm_node[nnz][];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i])  			model.SV [p++] = x [i];  	var nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.sv_coef = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.sv_coef [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.sv_coef [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.sv_coef [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR) {  	// regression or one-class-svm  	model.nr_class = 2;  	model.label = null;  	model.nSV = null;  	model.probA = null;  	model.probB = null;  	model.sv_coef = new double[1][];  	if (param.probability == 1 && (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR)) {  		model.probA = new double[1];  		model.probA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.rho = new double[1];  	model.rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.l = nSV;  	model.SV = new svm_node[nSV][];  	model.sv_coef [0] = new double[nSV];  	int j = 0;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SV [j] = prob.x [i];  			model.sv_coef [0] [j] = f.alpha [i];  			++j;  		}  }  else {  	// classification  	// find out the number of classes  	int l = prob.l;  	int max_nr_class = 16;  	int nr_class = 0;  	var label = new int[max_nr_class];  	var count = new int[max_nr_class];  	var index = new int[l];  	int i;  	for (i = 0; i < l; i++) {  		//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'  		var this_label = (int)prob.y [i];  		int j;  		for (j = 0; j < nr_class; j++)  			if (this_label == label [j]) {  				++count [j];  				break;  			}  		index [i] = j;  		if (j == nr_class) {  			if (nr_class == max_nr_class) {  				max_nr_class *= 2;  				var new_data = new int[max_nr_class];  				Array.Copy (label' 0' new_data' 0' label.Length);  				label = new_data;  				new_data = new int[max_nr_class];  				Array.Copy (count' 0' new_data' 0' count.Length);  				count = new_data;  			}  			label [nr_class] = this_label;  			count [nr_class] = 1;  			++nr_class;  		}  	}  	// group training data of the same class  	var start = new int[nr_class];  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	var x = new svm_node[l][];  	for (i = 0; i < l; i++) {  		x [start [index [i]]] = prob.x [i];  		++start [index [i]];  	}  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	// calculate weighted C  	var weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < param.nr_weight; i++) {  		int j;  		for (j = 0; j < nr_class; j++)  			if (param.weight_label [i] == label [j])  				break;  		if (j == nr_class)  			;  		/*Console.Error.Write("warning: class label " + param.weight_label[i] +                                         " specified in weight is not found\n");*/else  			weighted_C [j] *= param.weight [i];  	}  	// train k*(k-1)/2 models  	var nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	var f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.probability == 1) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			var sub_prob = new svm_problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.l = ci + cj;  			sub_prob.x = new svm_node[sub_prob.l][];  			sub_prob.y = new double[sub_prob.l];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.x [k] = x [si + k];  				sub_prob.y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.x [ci + k] = x [sj + k];  				sub_prob.y [ci + k] = -1;  			}  			if (param.probability == 1) {  				var probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.nr_class = nr_class;  	model.label = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.label [i] = label [i];  	model.rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.rho [i] = f [i].rho;  	if (param.probability == 1) {  		model.probA = new double[nr_class * (nr_class - 1) / 2];  		model.probB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.probA [i] = probA [i];  			model.probB [i] = probB [i];  		}  	}  	else {  		model.probA = null;  		model.probB = null;  	}  	int nnz = 0;  	var nz_count = new int[nr_class];  	model.nSV = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.nSV [i] = nSV;  		nz_count [i] = nSV;  	}  	//Console.Out.Write("Total nSV = " + nnz + "\n");  	model.l = nnz;  	model.SV = new svm_node[nnz][];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i])  			model.SV [p++] = x [i];  	var nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.sv_coef = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.sv_coef [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.sv_coef [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.sv_coef [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR) {  	// regression or one-class-svm  	model.nr_class = 2;  	model.label = null;  	model.nSV = null;  	model.probA = null;  	model.probB = null;  	model.sv_coef = new double[1][];  	if (param.probability == 1 && (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR)) {  		model.probA = new double[1];  		model.probA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.rho = new double[1];  	model.rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.l = nSV;  	model.SV = new svm_node[nSV][];  	model.sv_coef [0] = new double[nSV];  	int j = 0;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SV [j] = prob.x [i];  			model.sv_coef [0] [j] = f.alpha [i];  			++j;  		}  }  else {  	// classification  	// find out the number of classes  	int l = prob.l;  	int max_nr_class = 16;  	int nr_class = 0;  	var label = new int[max_nr_class];  	var count = new int[max_nr_class];  	var index = new int[l];  	int i;  	for (i = 0; i < l; i++) {  		//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'  		var this_label = (int)prob.y [i];  		int j;  		for (j = 0; j < nr_class; j++)  			if (this_label == label [j]) {  				++count [j];  				break;  			}  		index [i] = j;  		if (j == nr_class) {  			if (nr_class == max_nr_class) {  				max_nr_class *= 2;  				var new_data = new int[max_nr_class];  				Array.Copy (label' 0' new_data' 0' label.Length);  				label = new_data;  				new_data = new int[max_nr_class];  				Array.Copy (count' 0' new_data' 0' count.Length);  				count = new_data;  			}  			label [nr_class] = this_label;  			count [nr_class] = 1;  			++nr_class;  		}  	}  	// group training data of the same class  	var start = new int[nr_class];  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	var x = new svm_node[l][];  	for (i = 0; i < l; i++) {  		x [start [index [i]]] = prob.x [i];  		++start [index [i]];  	}  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	// calculate weighted C  	var weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < param.nr_weight; i++) {  		int j;  		for (j = 0; j < nr_class; j++)  			if (param.weight_label [i] == label [j])  				break;  		if (j == nr_class)  			;  		/*Console.Error.Write("warning: class label " + param.weight_label[i] +                                         " specified in weight is not found\n");*/else  			weighted_C [j] *= param.weight [i];  	}  	// train k*(k-1)/2 models  	var nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	var f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.probability == 1) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			var sub_prob = new svm_problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.l = ci + cj;  			sub_prob.x = new svm_node[sub_prob.l][];  			sub_prob.y = new double[sub_prob.l];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.x [k] = x [si + k];  				sub_prob.y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.x [ci + k] = x [sj + k];  				sub_prob.y [ci + k] = -1;  			}  			if (param.probability == 1) {  				var probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.nr_class = nr_class;  	model.label = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.label [i] = label [i];  	model.rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.rho [i] = f [i].rho;  	if (param.probability == 1) {  		model.probA = new double[nr_class * (nr_class - 1) / 2];  		model.probB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.probA [i] = probA [i];  			model.probB [i] = probB [i];  		}  	}  	else {  		model.probA = null;  		model.probB = null;  	}  	int nnz = 0;  	var nz_count = new int[nr_class];  	model.nSV = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.nSV [i] = nSV;  		nz_count [i] = nSV;  	}  	//Console.Out.Write("Total nSV = " + nnz + "\n");  	model.l = nnz;  	model.SV = new svm_node[nnz][];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i])  			model.SV [p++] = x [i];  	var nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.sv_coef = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.sv_coef [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.sv_coef [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.sv_coef [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR) {  	// regression or one-class-svm  	model.nr_class = 2;  	model.label = null;  	model.nSV = null;  	model.probA = null;  	model.probB = null;  	model.sv_coef = new double[1][];  	if (param.probability == 1 && (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR)) {  		model.probA = new double[1];  		model.probA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.rho = new double[1];  	model.rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.l = nSV;  	model.SV = new svm_node[nSV][];  	model.sv_coef [0] = new double[nSV];  	int j = 0;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SV [j] = prob.x [i];  			model.sv_coef [0] [j] = f.alpha [i];  			++j;  		}  }  else {  	// classification  	// find out the number of classes  	int l = prob.l;  	int max_nr_class = 16;  	int nr_class = 0;  	var label = new int[max_nr_class];  	var count = new int[max_nr_class];  	var index = new int[l];  	int i;  	for (i = 0; i < l; i++) {  		//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'  		var this_label = (int)prob.y [i];  		int j;  		for (j = 0; j < nr_class; j++)  			if (this_label == label [j]) {  				++count [j];  				break;  			}  		index [i] = j;  		if (j == nr_class) {  			if (nr_class == max_nr_class) {  				max_nr_class *= 2;  				var new_data = new int[max_nr_class];  				Array.Copy (label' 0' new_data' 0' label.Length);  				label = new_data;  				new_data = new int[max_nr_class];  				Array.Copy (count' 0' new_data' 0' count.Length);  				count = new_data;  			}  			label [nr_class] = this_label;  			count [nr_class] = 1;  			++nr_class;  		}  	}  	// group training data of the same class  	var start = new int[nr_class];  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	var x = new svm_node[l][];  	for (i = 0; i < l; i++) {  		x [start [index [i]]] = prob.x [i];  		++start [index [i]];  	}  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	// calculate weighted C  	var weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < param.nr_weight; i++) {  		int j;  		for (j = 0; j < nr_class; j++)  			if (param.weight_label [i] == label [j])  				break;  		if (j == nr_class)  			;  		/*Console.Error.Write("warning: class label " + param.weight_label[i] +                                         " specified in weight is not found\n");*/else  			weighted_C [j] *= param.weight [i];  	}  	// train k*(k-1)/2 models  	var nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	var f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.probability == 1) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			var sub_prob = new svm_problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.l = ci + cj;  			sub_prob.x = new svm_node[sub_prob.l][];  			sub_prob.y = new double[sub_prob.l];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.x [k] = x [si + k];  				sub_prob.y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.x [ci + k] = x [sj + k];  				sub_prob.y [ci + k] = -1;  			}  			if (param.probability == 1) {  				var probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.nr_class = nr_class;  	model.label = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.label [i] = label [i];  	model.rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.rho [i] = f [i].rho;  	if (param.probability == 1) {  		model.probA = new double[nr_class * (nr_class - 1) / 2];  		model.probB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.probA [i] = probA [i];  			model.probB [i] = probB [i];  		}  	}  	else {  		model.probA = null;  		model.probB = null;  	}  	int nnz = 0;  	var nz_count = new int[nr_class];  	model.nSV = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.nSV [i] = nSV;  		nz_count [i] = nSV;  	}  	//Console.Out.Write("Total nSV = " + nnz + "\n");  	model.l = nnz;  	model.SV = new svm_node[nnz][];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i])  			model.SV [p++] = x [i];  	var nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.sv_coef = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.sv_coef [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.sv_coef [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.sv_coef [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR) {  	// regression or one-class-svm  	model.nr_class = 2;  	model.label = null;  	model.nSV = null;  	model.probA = null;  	model.probB = null;  	model.sv_coef = new double[1][];  	if (param.probability == 1 && (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR)) {  		model.probA = new double[1];  		model.probA [0] = svm_svr_probability (prob' param);  	}  	decision_function f = svm_train_one (prob' param' 0' 0);  	model.rho = new double[1];  	model.rho [0] = f.rho;  	int nSV = 0;  	int i;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0)  			++nSV;  	model.l = nSV;  	model.SV = new svm_node[nSV][];  	model.sv_coef [0] = new double[nSV];  	int j = 0;  	for (i = 0; i < prob.l; i++)  		if (Math.Abs (f.alpha [i]) > 0) {  			model.SV [j] = prob.x [i];  			model.sv_coef [0] [j] = f.alpha [i];  			++j;  		}  }  else {  	// classification  	// find out the number of classes  	int l = prob.l;  	int max_nr_class = 16;  	int nr_class = 0;  	var label = new int[max_nr_class];  	var count = new int[max_nr_class];  	var index = new int[l];  	int i;  	for (i = 0; i < l; i++) {  		//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'  		var this_label = (int)prob.y [i];  		int j;  		for (j = 0; j < nr_class; j++)  			if (this_label == label [j]) {  				++count [j];  				break;  			}  		index [i] = j;  		if (j == nr_class) {  			if (nr_class == max_nr_class) {  				max_nr_class *= 2;  				var new_data = new int[max_nr_class];  				Array.Copy (label' 0' new_data' 0' label.Length);  				label = new_data;  				new_data = new int[max_nr_class];  				Array.Copy (count' 0' new_data' 0' count.Length);  				count = new_data;  			}  			label [nr_class] = this_label;  			count [nr_class] = 1;  			++nr_class;  		}  	}  	// group training data of the same class  	var start = new int[nr_class];  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	var x = new svm_node[l][];  	for (i = 0; i < l; i++) {  		x [start [index [i]]] = prob.x [i];  		++start [index [i]];  	}  	start [0] = 0;  	for (i = 1; i < nr_class; i++)  		start [i] = start [i - 1] + count [i - 1];  	// calculate weighted C  	var weighted_C = new double[nr_class];  	for (i = 0; i < nr_class; i++)  		weighted_C [i] = param.C;  	for (i = 0; i < param.nr_weight; i++) {  		int j;  		for (j = 0; j < nr_class; j++)  			if (param.weight_label [i] == label [j])  				break;  		if (j == nr_class)  			;  		/*Console.Error.Write("warning: class label " + param.weight_label[i] +                                         " specified in weight is not found\n");*/else  			weighted_C [j] *= param.weight [i];  	}  	// train k*(k-1)/2 models  	var nonzero = new bool[l];  	for (i = 0; i < l; i++)  		nonzero [i] = false;  	var f = new decision_function[nr_class * (nr_class - 1) / 2];  	double[] probA = null' probB = null;  	if (param.probability == 1) {  		probA = new double[nr_class * (nr_class - 1) / 2];  		probB = new double[nr_class * (nr_class - 1) / 2];  	}  	int p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			var sub_prob = new svm_problem ();  			int si = start [i]' sj = start [j];  			int ci = count [i]' cj = count [j];  			sub_prob.l = ci + cj;  			sub_prob.x = new svm_node[sub_prob.l][];  			sub_prob.y = new double[sub_prob.l];  			int k;  			for (k = 0; k < ci; k++) {  				sub_prob.x [k] = x [si + k];  				sub_prob.y [k] = +1;  			}  			for (k = 0; k < cj; k++) {  				sub_prob.x [ci + k] = x [sj + k];  				sub_prob.y [ci + k] = -1;  			}  			if (param.probability == 1) {  				var probAB = new double[2];  				svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  				probA [p] = probAB [0];  				probB [p] = probAB [1];  			}  			f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  			for (k = 0; k < ci; k++)  				if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  					nonzero [si + k] = true;  			for (k = 0; k < cj; k++)  				if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  					nonzero [sj + k] = true;  			++p;  		}  	// build output  	model.nr_class = nr_class;  	model.label = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		model.label [i] = label [i];  	model.rho = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		model.rho [i] = f [i].rho;  	if (param.probability == 1) {  		model.probA = new double[nr_class * (nr_class - 1) / 2];  		model.probB = new double[nr_class * (nr_class - 1) / 2];  		for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  			model.probA [i] = probA [i];  			model.probB [i] = probB [i];  		}  	}  	else {  		model.probA = null;  		model.probB = null;  	}  	int nnz = 0;  	var nz_count = new int[nr_class];  	model.nSV = new int[nr_class];  	for (i = 0; i < nr_class; i++) {  		int nSV = 0;  		for (int j = 0; j < count [i]; j++)  			if (nonzero [start [i] + j]) {  				++nSV;  				++nnz;  			}  		model.nSV [i] = nSV;  		nz_count [i] = nSV;  	}  	//Console.Out.Write("Total nSV = " + nnz + "\n");  	model.l = nnz;  	model.SV = new svm_node[nnz][];  	p = 0;  	for (i = 0; i < l; i++)  		if (nonzero [i])  			model.SV [p++] = x [i];  	var nz_start = new int[nr_class];  	nz_start [0] = 0;  	for (i = 1; i < nr_class; i++)  		nz_start [i] = nz_start [i - 1] + nz_count [i - 1];  	model.sv_coef = new double[nr_class - 1][];  	for (i = 0; i < nr_class - 1; i++)  		model.sv_coef [i] = new double[nnz];  	p = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			// classifier (i'j): coefficients with  			// i are in sv_coef[j-1][nz_start[i]...]'  			// j are in sv_coef[i][nz_start[j]...]  			int si = start [i];  			int sj = start [j];  			int ci = count [i];  			int cj = count [j];  			int q = nz_start [i];  			int k;  			for (k = 0; k < ci; k++)  				if (nonzero [si + k])  					model.sv_coef [j - 1] [q++] = f [p].alpha [k];  			q = nz_start [j];  			for (k = 0; k < cj; k++)  				if (nonzero [sj + k])  					model.sv_coef [i] [q++] = f [p].alpha [ci + k];  			++p;  		}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: model.nr_class = 2;  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: for (i = 0; i < l; i++) {  	//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'  	var this_label = (int)prob.y [i];  	int j;  	for (j = 0; j < nr_class; j++)  		if (this_label == label [j]) {  			++count [j];  			break;  		}  	index [i] = j;  	if (j == nr_class) {  		if (nr_class == max_nr_class) {  			max_nr_class *= 2;  			var new_data = new int[max_nr_class];  			Array.Copy (label' 0' new_data' 0' label.Length);  			label = new_data;  			new_data = new int[max_nr_class];  			Array.Copy (count' 0' new_data' 0' count.Length);  			count = new_data;  		}  		label [nr_class] = this_label;  		count [nr_class] = 1;  		++nr_class;  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (j == nr_class) {  	if (nr_class == max_nr_class) {  		max_nr_class *= 2;  		var new_data = new int[max_nr_class];  		Array.Copy (label' 0' new_data' 0' label.Length);  		label = new_data;  		new_data = new int[max_nr_class];  		Array.Copy (count' 0' new_data' 0' count.Length);  		count = new_data;  	}  	label [nr_class] = this_label;  	count [nr_class] = 1;  	++nr_class;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (nr_class == max_nr_class) {  	max_nr_class *= 2;  	var new_data = new int[max_nr_class];  	Array.Copy (label' 0' new_data' 0' label.Length);  	label = new_data;  	new_data = new int[max_nr_class];  	Array.Copy (count' 0' new_data' 0' count.Length);  	count = new_data;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: max_nr_class *= 2;  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.probability == 1) {  	probA = new double[nr_class * (nr_class - 1) / 2];  	probB = new double[nr_class * (nr_class - 1) / 2];  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.probability == 1) {  	probA = new double[nr_class * (nr_class - 1) / 2];  	probB = new double[nr_class * (nr_class - 1) / 2];  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: probA = new double[nr_class * (nr_class - 1) / 2];  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: probB = new double[nr_class * (nr_class - 1) / 2];  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: for (i = 0; i < nr_class; i++)  	for (int j = i + 1; j < nr_class; j++) {  		var sub_prob = new svm_problem ();  		int si = start [i]' sj = start [j];  		int ci = count [i]' cj = count [j];  		sub_prob.l = ci + cj;  		sub_prob.x = new svm_node[sub_prob.l][];  		sub_prob.y = new double[sub_prob.l];  		int k;  		for (k = 0; k < ci; k++) {  			sub_prob.x [k] = x [si + k];  			sub_prob.y [k] = +1;  		}  		for (k = 0; k < cj; k++) {  			sub_prob.x [ci + k] = x [sj + k];  			sub_prob.y [ci + k] = -1;  		}  		if (param.probability == 1) {  			var probAB = new double[2];  			svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  			probA [p] = probAB [0];  			probB [p] = probAB [1];  		}  		f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  		for (k = 0; k < ci; k++)  			if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  				nonzero [si + k] = true;  		for (k = 0; k < cj; k++)  			if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  				nonzero [sj + k] = true;  		++p;  	}  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: for (int j = i + 1; j < nr_class; j++) {  	var sub_prob = new svm_problem ();  	int si = start [i]' sj = start [j];  	int ci = count [i]' cj = count [j];  	sub_prob.l = ci + cj;  	sub_prob.x = new svm_node[sub_prob.l][];  	sub_prob.y = new double[sub_prob.l];  	int k;  	for (k = 0; k < ci; k++) {  		sub_prob.x [k] = x [si + k];  		sub_prob.y [k] = +1;  	}  	for (k = 0; k < cj; k++) {  		sub_prob.x [ci + k] = x [sj + k];  		sub_prob.y [ci + k] = -1;  	}  	if (param.probability == 1) {  		var probAB = new double[2];  		svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  		probA [p] = probAB [0];  		probB [p] = probAB [1];  	}  	f [p] = svm_train_one (sub_prob' param' weighted_C [i]' weighted_C [j]);  	for (k = 0; k < ci; k++)  		if (!nonzero [si + k] && Math.Abs (f [p].alpha [k]) > 0)  			nonzero [si + k] = true;  	for (k = 0; k < cj; k++)  		if (!nonzero [sj + k] && Math.Abs (f [p].alpha [ci + k]) > 0)  			nonzero [sj + k] = true;  	++p;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.probability == 1) {  	var probAB = new double[2];  	svm_binary_svc_probability (sub_prob' param' weighted_C [i]' weighted_C [j]' probAB);  	probA [p] = probAB [0];  	probB [p] = probAB [1];  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: model.rho = new double[nr_class * (nr_class - 1) / 2];  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: for (i = 0; i < nr_class * (nr_class - 1) / 2; i++)  	model.rho [i] = f [i].rho;  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.probability == 1) {  	model.probA = new double[nr_class * (nr_class - 1) / 2];  	model.probB = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  		model.probA [i] = probA [i];  		model.probB [i] = probB [i];  	}  }  else {  	model.probA = null;  	model.probB = null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.probability == 1) {  	model.probA = new double[nr_class * (nr_class - 1) / 2];  	model.probB = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  		model.probA [i] = probA [i];  		model.probB [i] = probB [i];  	}  }  else {  	model.probA = null;  	model.probB = null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.probability == 1) {  	model.probA = new double[nr_class * (nr_class - 1) / 2];  	model.probB = new double[nr_class * (nr_class - 1) / 2];  	for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  		model.probA [i] = probA [i];  		model.probB [i] = probB [i];  	}  }  else {  	model.probA = null;  	model.probB = null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: model.probA = new double[nr_class * (nr_class - 1) / 2];  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: model.probB = new double[nr_class * (nr_class - 1) / 2];  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: for (i = 0; i < nr_class * (nr_class - 1) / 2; i++) {  	model.probA [i] = probA [i];  	model.probB [i] = probB [i];  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict,The following statement contains a magic number: if (model.param.svm_type == svm_parameter.ONE_CLASS || model.param.svm_type == svm_parameter.EPSILON_SVR || model.param.svm_type == svm_parameter.NU_SVR) {  	var res = new double[1];  	svm_predict_values (model' x' res);  	if (model.param.svm_type == svm_parameter.ONE_CLASS)  		return (res [0] > 0) ? 1 : -1;  	else  		return res [0];  }  else {  	int i;  	int nr_class = model.nr_class;  	var dec_values = new double[nr_class * (nr_class - 1) / 2];  	svm_predict_values (model' x' dec_values);  	var vote = new int[nr_class];  	for (i = 0; i < nr_class; i++)  		vote [i] = 0;  	int pos = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			if (dec_values [pos++] > 0)  				++vote [i];  			else  				++vote [j];  		}  	int vote_max_idx = 0;  	for (i = 1; i < nr_class; i++)  		if (vote [i] > vote [vote_max_idx])  			vote_max_idx = i;  	return model.label [vote_max_idx];  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict_probability,The following statement contains a magic number: if ((model.param.svm_type == svm_parameter.C_SVC || model.param.svm_type == svm_parameter.NU_SVC) && model.probA != null && model.probB != null) {  	int i;  	int nr_class = model.nr_class;  	var dec_values = new double[nr_class * (nr_class - 1) / 2];  	svm_predict_values (model' x' dec_values);  	double min_prob = 1e-7;  	var tmpArray = new double[nr_class][];  	for (int i2 = 0; i2 < nr_class; i2++) {  		tmpArray [i2] = new double[nr_class];  	}  	double[][] pairwise_prob = tmpArray;  	int k = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			pairwise_prob [i] [j] = Math.Min (Math.Max (sigmoid_predict (dec_values [k]' model.probA [k]' model.probB [k])' min_prob)' 1 - min_prob);  			pairwise_prob [j] [i] = 1 - pairwise_prob [i] [j];  			k++;  		}  	multiclass_probability (nr_class' pairwise_prob' prob_estimates);  	int prob_max_idx = 0;  	for (i = 1; i < nr_class; i++)  		if (prob_estimates [i] > prob_estimates [prob_max_idx])  			prob_max_idx = i;  	return model.label [prob_max_idx];  }  else  	return svm_predict (model' x);  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict_probability,The following statement contains a magic number: if ((model.param.svm_type == svm_parameter.C_SVC || model.param.svm_type == svm_parameter.NU_SVC) && model.probA != null && model.probB != null) {  	int i;  	int nr_class = model.nr_class;  	var dec_values = new double[nr_class * (nr_class - 1) / 2];  	svm_predict_values (model' x' dec_values);  	double min_prob = 1e-7;  	var tmpArray = new double[nr_class][];  	for (int i2 = 0; i2 < nr_class; i2++) {  		tmpArray [i2] = new double[nr_class];  	}  	double[][] pairwise_prob = tmpArray;  	int k = 0;  	for (i = 0; i < nr_class; i++)  		for (int j = i + 1; j < nr_class; j++) {  			pairwise_prob [i] [j] = Math.Min (Math.Max (sigmoid_predict (dec_values [k]' model.probA [k]' model.probB [k])' min_prob)' 1 - min_prob);  			pairwise_prob [j] [i] = 1 - pairwise_prob [i] [j];  			k++;  		}  	multiclass_probability (nr_class' pairwise_prob' prob_estimates);  	int prob_max_idx = 0;  	for (i = 1; i < nr_class; i++)  		if (prob_estimates [i] > prob_estimates [prob_max_idx])  			prob_max_idx = i;  	return model.label [prob_max_idx];  }  else  	return svm_predict (model' x);  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_save_model,The following statement contains a magic number: for (int i = 0; i < nr_class * (nr_class - 1) / 2; i++)  	fp.Write (" " + model.rho [i]);  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_save_model,The following statement contains a magic number: if (model.probA != null)// regression has probA only   {  	fp.Write ("probA");  	for (int i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		fp.Write (" " + model.probA [i]);  	fp.Write ("\n");  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_save_model,The following statement contains a magic number: for (int i = 0; i < nr_class * (nr_class - 1) / 2; i++)  	fp.Write (" " + model.probA [i]);  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_save_model,The following statement contains a magic number: if (model.probB != null) {  	fp.Write ("probB");  	for (int i = 0; i < nr_class * (nr_class - 1) / 2; i++)  		fp.Write (" " + model.probB [i]);  	fp.Write ("\n");  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_save_model,The following statement contains a magic number: for (int i = 0; i < nr_class * (nr_class - 1) / 2; i++)  	fp.Write (" " + model.probB [i]);  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: while (true) {  	String cmd = fp.ReadLine ();  	String arg = cmd.Substring (cmd.IndexOf (' ') + 1);  	if (cmd.StartsWith ("svm_type")) {  		int i;  		for (i = 0; i < svm_type_table.Length; i++) {  			if (arg.IndexOf (svm_type_table [i]) != -1) {  				param.svm_type = i;  				break;  			}  		}  		if (i == svm_type_table.Length) {  			//Console.Error.Write("unknown svm type.\n");  			return null;  		}  	}  	else if (cmd.StartsWith ("kernel_type")) {  		int i;  		for (i = 0; i < kernel_type_table.Length; i++) {  			if (arg.IndexOf (kernel_type_table [i]) != -1) {  				param.kernel_type = i;  				break;  			}  		}  		if (i == kernel_type_table.Length) {  			//Console.Error.Write("unknown kernel function.\n");  			return null;  		}  	}  	else if (cmd.StartsWith ("degree"))  		param.degree = atof (arg);  	else if (cmd.StartsWith ("gamma"))  		param.gamma = atof (arg);  	else if (cmd.StartsWith ("coef0"))  		param.coef0 = atof (arg);  	else if (cmd.StartsWith ("nr_class"))  		model.nr_class = atoi (arg);  	else if (cmd.StartsWith ("total_sv"))  		model.l = atoi (arg);  	else if (cmd.StartsWith ("rho")) {  		int n = model.nr_class * (model.nr_class - 1) / 2;  		model.rho = new double[n];  		var st = new SupportClass.Tokenizer (arg);  		for (int i = 0; i < n; i++)  			model.rho [i] = atof (st.NextToken ());  	}  	else if (cmd.StartsWith ("label")) {  		int n = model.nr_class;  		model.label = new int[n];  		var st = new SupportClass.Tokenizer (arg);  		for (int i = 0; i < n; i++)  			model.label [i] = atoi (st.NextToken ());  	}  	else if (cmd.StartsWith ("probA")) {  		int n = model.nr_class * (model.nr_class - 1) / 2;  		model.probA = new double[n];  		var st = new SupportClass.Tokenizer (arg);  		for (int i = 0; i < n; i++)  			model.probA [i] = atof (st.NextToken ());  	}  	else if (cmd.StartsWith ("probB")) {  		int n = model.nr_class * (model.nr_class - 1) / 2;  		model.probB = new double[n];  		var st = new SupportClass.Tokenizer (arg);  		for (int i = 0; i < n; i++)  			model.probB [i] = atof (st.NextToken ());  	}  	else if (cmd.StartsWith ("nr_sv")) {  		int n = model.nr_class;  		model.nSV = new int[n];  		var st = new SupportClass.Tokenizer (arg);  		for (int i = 0; i < n; i++)  			model.nSV [i] = atoi (st.NextToken ());  	}  	else if (cmd.StartsWith ("SV")) {  		break;  	}  	else {  		//Console.Error.Write("unknown text in model file\n");  		return null;  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: while (true) {  	String cmd = fp.ReadLine ();  	String arg = cmd.Substring (cmd.IndexOf (' ') + 1);  	if (cmd.StartsWith ("svm_type")) {  		int i;  		for (i = 0; i < svm_type_table.Length; i++) {  			if (arg.IndexOf (svm_type_table [i]) != -1) {  				param.svm_type = i;  				break;  			}  		}  		if (i == svm_type_table.Length) {  			//Console.Error.Write("unknown svm type.\n");  			return null;  		}  	}  	else if (cmd.StartsWith ("kernel_type")) {  		int i;  		for (i = 0; i < kernel_type_table.Length; i++) {  			if (arg.IndexOf (kernel_type_table [i]) != -1) {  				param.kernel_type = i;  				break;  			}  		}  		if (i == kernel_type_table.Length) {  			//Console.Error.Write("unknown kernel function.\n");  			return null;  		}  	}  	else if (cmd.StartsWith ("degree"))  		param.degree = atof (arg);  	else if (cmd.StartsWith ("gamma"))  		param.gamma = atof (arg);  	else if (cmd.StartsWith ("coef0"))  		param.coef0 = atof (arg);  	else if (cmd.StartsWith ("nr_class"))  		model.nr_class = atoi (arg);  	else if (cmd.StartsWith ("total_sv"))  		model.l = atoi (arg);  	else if (cmd.StartsWith ("rho")) {  		int n = model.nr_class * (model.nr_class - 1) / 2;  		model.rho = new double[n];  		var st = new SupportClass.Tokenizer (arg);  		for (int i = 0; i < n; i++)  			model.rho [i] = atof (st.NextToken ());  	}  	else if (cmd.StartsWith ("label")) {  		int n = model.nr_class;  		model.label = new int[n];  		var st = new SupportClass.Tokenizer (arg);  		for (int i = 0; i < n; i++)  			model.label [i] = atoi (st.NextToken ());  	}  	else if (cmd.StartsWith ("probA")) {  		int n = model.nr_class * (model.nr_class - 1) / 2;  		model.probA = new double[n];  		var st = new SupportClass.Tokenizer (arg);  		for (int i = 0; i < n; i++)  			model.probA [i] = atof (st.NextToken ());  	}  	else if (cmd.StartsWith ("probB")) {  		int n = model.nr_class * (model.nr_class - 1) / 2;  		model.probB = new double[n];  		var st = new SupportClass.Tokenizer (arg);  		for (int i = 0; i < n; i++)  			model.probB [i] = atof (st.NextToken ());  	}  	else if (cmd.StartsWith ("nr_sv")) {  		int n = model.nr_class;  		model.nSV = new int[n];  		var st = new SupportClass.Tokenizer (arg);  		for (int i = 0; i < n; i++)  			model.nSV [i] = atoi (st.NextToken ());  	}  	else if (cmd.StartsWith ("SV")) {  		break;  	}  	else {  		//Console.Error.Write("unknown text in model file\n");  		return null;  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: while (true) {  	String cmd = fp.ReadLine ();  	String arg = cmd.Substring (cmd.IndexOf (' ') + 1);  	if (cmd.StartsWith ("svm_type")) {  		int i;  		for (i = 0; i < svm_type_table.Length; i++) {  			if (arg.IndexOf (svm_type_table [i]) != -1) {  				param.svm_type = i;  				break;  			}  		}  		if (i == svm_type_table.Length) {  			//Console.Error.Write("unknown svm type.\n");  			return null;  		}  	}  	else if (cmd.StartsWith ("kernel_type")) {  		int i;  		for (i = 0; i < kernel_type_table.Length; i++) {  			if (arg.IndexOf (kernel_type_table [i]) != -1) {  				param.kernel_type = i;  				break;  			}  		}  		if (i == kernel_type_table.Length) {  			//Console.Error.Write("unknown kernel function.\n");  			return null;  		}  	}  	else if (cmd.StartsWith ("degree"))  		param.degree = atof (arg);  	else if (cmd.StartsWith ("gamma"))  		param.gamma = atof (arg);  	else if (cmd.StartsWith ("coef0"))  		param.coef0 = atof (arg);  	else if (cmd.StartsWith ("nr_class"))  		model.nr_class = atoi (arg);  	else if (cmd.StartsWith ("total_sv"))  		model.l = atoi (arg);  	else if (cmd.StartsWith ("rho")) {  		int n = model.nr_class * (model.nr_class - 1) / 2;  		model.rho = new double[n];  		var st = new SupportClass.Tokenizer (arg);  		for (int i = 0; i < n; i++)  			model.rho [i] = atof (st.NextToken ());  	}  	else if (cmd.StartsWith ("label")) {  		int n = model.nr_class;  		model.label = new int[n];  		var st = new SupportClass.Tokenizer (arg);  		for (int i = 0; i < n; i++)  			model.label [i] = atoi (st.NextToken ());  	}  	else if (cmd.StartsWith ("probA")) {  		int n = model.nr_class * (model.nr_class - 1) / 2;  		model.probA = new double[n];  		var st = new SupportClass.Tokenizer (arg);  		for (int i = 0; i < n; i++)  			model.probA [i] = atof (st.NextToken ());  	}  	else if (cmd.StartsWith ("probB")) {  		int n = model.nr_class * (model.nr_class - 1) / 2;  		model.probB = new double[n];  		var st = new SupportClass.Tokenizer (arg);  		for (int i = 0; i < n; i++)  			model.probB [i] = atof (st.NextToken ());  	}  	else if (cmd.StartsWith ("nr_sv")) {  		int n = model.nr_class;  		model.nSV = new int[n];  		var st = new SupportClass.Tokenizer (arg);  		for (int i = 0; i < n; i++)  			model.nSV [i] = atoi (st.NextToken ());  	}  	else if (cmd.StartsWith ("SV")) {  		break;  	}  	else {  		//Console.Error.Write("unknown text in model file\n");  		return null;  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("svm_type")) {  	int i;  	for (i = 0; i < svm_type_table.Length; i++) {  		if (arg.IndexOf (svm_type_table [i]) != -1) {  			param.svm_type = i;  			break;  		}  	}  	if (i == svm_type_table.Length) {  		//Console.Error.Write("unknown svm type.\n");  		return null;  	}  }  else if (cmd.StartsWith ("kernel_type")) {  	int i;  	for (i = 0; i < kernel_type_table.Length; i++) {  		if (arg.IndexOf (kernel_type_table [i]) != -1) {  			param.kernel_type = i;  			break;  		}  	}  	if (i == kernel_type_table.Length) {  		//Console.Error.Write("unknown kernel function.\n");  		return null;  	}  }  else if (cmd.StartsWith ("degree"))  	param.degree = atof (arg);  else if (cmd.StartsWith ("gamma"))  	param.gamma = atof (arg);  else if (cmd.StartsWith ("coef0"))  	param.coef0 = atof (arg);  else if (cmd.StartsWith ("nr_class"))  	model.nr_class = atoi (arg);  else if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("svm_type")) {  	int i;  	for (i = 0; i < svm_type_table.Length; i++) {  		if (arg.IndexOf (svm_type_table [i]) != -1) {  			param.svm_type = i;  			break;  		}  	}  	if (i == svm_type_table.Length) {  		//Console.Error.Write("unknown svm type.\n");  		return null;  	}  }  else if (cmd.StartsWith ("kernel_type")) {  	int i;  	for (i = 0; i < kernel_type_table.Length; i++) {  		if (arg.IndexOf (kernel_type_table [i]) != -1) {  			param.kernel_type = i;  			break;  		}  	}  	if (i == kernel_type_table.Length) {  		//Console.Error.Write("unknown kernel function.\n");  		return null;  	}  }  else if (cmd.StartsWith ("degree"))  	param.degree = atof (arg);  else if (cmd.StartsWith ("gamma"))  	param.gamma = atof (arg);  else if (cmd.StartsWith ("coef0"))  	param.coef0 = atof (arg);  else if (cmd.StartsWith ("nr_class"))  	model.nr_class = atoi (arg);  else if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("svm_type")) {  	int i;  	for (i = 0; i < svm_type_table.Length; i++) {  		if (arg.IndexOf (svm_type_table [i]) != -1) {  			param.svm_type = i;  			break;  		}  	}  	if (i == svm_type_table.Length) {  		//Console.Error.Write("unknown svm type.\n");  		return null;  	}  }  else if (cmd.StartsWith ("kernel_type")) {  	int i;  	for (i = 0; i < kernel_type_table.Length; i++) {  		if (arg.IndexOf (kernel_type_table [i]) != -1) {  			param.kernel_type = i;  			break;  		}  	}  	if (i == kernel_type_table.Length) {  		//Console.Error.Write("unknown kernel function.\n");  		return null;  	}  }  else if (cmd.StartsWith ("degree"))  	param.degree = atof (arg);  else if (cmd.StartsWith ("gamma"))  	param.gamma = atof (arg);  else if (cmd.StartsWith ("coef0"))  	param.coef0 = atof (arg);  else if (cmd.StartsWith ("nr_class"))  	model.nr_class = atoi (arg);  else if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("kernel_type")) {  	int i;  	for (i = 0; i < kernel_type_table.Length; i++) {  		if (arg.IndexOf (kernel_type_table [i]) != -1) {  			param.kernel_type = i;  			break;  		}  	}  	if (i == kernel_type_table.Length) {  		//Console.Error.Write("unknown kernel function.\n");  		return null;  	}  }  else if (cmd.StartsWith ("degree"))  	param.degree = atof (arg);  else if (cmd.StartsWith ("gamma"))  	param.gamma = atof (arg);  else if (cmd.StartsWith ("coef0"))  	param.coef0 = atof (arg);  else if (cmd.StartsWith ("nr_class"))  	model.nr_class = atoi (arg);  else if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("kernel_type")) {  	int i;  	for (i = 0; i < kernel_type_table.Length; i++) {  		if (arg.IndexOf (kernel_type_table [i]) != -1) {  			param.kernel_type = i;  			break;  		}  	}  	if (i == kernel_type_table.Length) {  		//Console.Error.Write("unknown kernel function.\n");  		return null;  	}  }  else if (cmd.StartsWith ("degree"))  	param.degree = atof (arg);  else if (cmd.StartsWith ("gamma"))  	param.gamma = atof (arg);  else if (cmd.StartsWith ("coef0"))  	param.coef0 = atof (arg);  else if (cmd.StartsWith ("nr_class"))  	model.nr_class = atoi (arg);  else if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("kernel_type")) {  	int i;  	for (i = 0; i < kernel_type_table.Length; i++) {  		if (arg.IndexOf (kernel_type_table [i]) != -1) {  			param.kernel_type = i;  			break;  		}  	}  	if (i == kernel_type_table.Length) {  		//Console.Error.Write("unknown kernel function.\n");  		return null;  	}  }  else if (cmd.StartsWith ("degree"))  	param.degree = atof (arg);  else if (cmd.StartsWith ("gamma"))  	param.gamma = atof (arg);  else if (cmd.StartsWith ("coef0"))  	param.coef0 = atof (arg);  else if (cmd.StartsWith ("nr_class"))  	model.nr_class = atoi (arg);  else if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("degree"))  	param.degree = atof (arg);  else if (cmd.StartsWith ("gamma"))  	param.gamma = atof (arg);  else if (cmd.StartsWith ("coef0"))  	param.coef0 = atof (arg);  else if (cmd.StartsWith ("nr_class"))  	model.nr_class = atoi (arg);  else if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("degree"))  	param.degree = atof (arg);  else if (cmd.StartsWith ("gamma"))  	param.gamma = atof (arg);  else if (cmd.StartsWith ("coef0"))  	param.coef0 = atof (arg);  else if (cmd.StartsWith ("nr_class"))  	model.nr_class = atoi (arg);  else if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("degree"))  	param.degree = atof (arg);  else if (cmd.StartsWith ("gamma"))  	param.gamma = atof (arg);  else if (cmd.StartsWith ("coef0"))  	param.coef0 = atof (arg);  else if (cmd.StartsWith ("nr_class"))  	model.nr_class = atoi (arg);  else if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("gamma"))  	param.gamma = atof (arg);  else if (cmd.StartsWith ("coef0"))  	param.coef0 = atof (arg);  else if (cmd.StartsWith ("nr_class"))  	model.nr_class = atoi (arg);  else if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("gamma"))  	param.gamma = atof (arg);  else if (cmd.StartsWith ("coef0"))  	param.coef0 = atof (arg);  else if (cmd.StartsWith ("nr_class"))  	model.nr_class = atoi (arg);  else if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("gamma"))  	param.gamma = atof (arg);  else if (cmd.StartsWith ("coef0"))  	param.coef0 = atof (arg);  else if (cmd.StartsWith ("nr_class"))  	model.nr_class = atoi (arg);  else if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("coef0"))  	param.coef0 = atof (arg);  else if (cmd.StartsWith ("nr_class"))  	model.nr_class = atoi (arg);  else if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("coef0"))  	param.coef0 = atof (arg);  else if (cmd.StartsWith ("nr_class"))  	model.nr_class = atoi (arg);  else if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("coef0"))  	param.coef0 = atof (arg);  else if (cmd.StartsWith ("nr_class"))  	model.nr_class = atoi (arg);  else if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("nr_class"))  	model.nr_class = atoi (arg);  else if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("nr_class"))  	model.nr_class = atoi (arg);  else if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("nr_class"))  	model.nr_class = atoi (arg);  else if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("total_sv"))  	model.l = atoi (arg);  else if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("rho")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.rho = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.rho [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("label")) {  	int n = model.nr_class;  	model.label = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.label [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("probA")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probA = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probA [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: if (cmd.StartsWith ("probB")) {  	int n = model.nr_class * (model.nr_class - 1) / 2;  	model.probB = new double[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.probB [i] = atof (st.NextToken ());  }  else if (cmd.StartsWith ("nr_sv")) {  	int n = model.nr_class;  	model.nSV = new int[n];  	var st = new SupportClass.Tokenizer (arg);  	for (int i = 0; i < n; i++)  		model.nSV [i] = atoi (st.NextToken ());  }  else if (cmd.StartsWith ("SV")) {  	break;  }  else {  	//Console.Error.Write("unknown text in model file\n");  	return null;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: for (int i = 0; i < l; i++) {  	String line = fp.ReadLine ();  	var st = new SupportClass.Tokenizer (line' " \t\n\r\f:");  	for (int k = 0; k < m; k++)  		model.sv_coef [k] [i] = atof (st.NextToken ());  	int n = st.Count / 2;  	model.SV [i] = new svm_node[n];  	for (int j = 0; j < n; j++) {  		model.SV [i] [j] = new svm_node ();  		model.SV [i] [j].index = atoi (st.NextToken ());  		model.SV [i] [j].value_Renamed = atof (st.NextToken ());  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The following statement contains a magic number: if (svm_type == svm_parameter.NU_SVC) {  	int l = prob.l;  	int max_nr_class = 16;  	int nr_class = 0;  	var label = new int[max_nr_class];  	var count = new int[max_nr_class];  	int i;  	for (i = 0; i < l; i++) {  		//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'  		var this_label = (int)prob.y [i];  		int j;  		for (j = 0; j < nr_class; j++)  			if (this_label == label [j]) {  				++count [j];  				break;  			}  		if (j == nr_class) {  			if (nr_class == max_nr_class) {  				max_nr_class *= 2;  				var new_data = new int[max_nr_class];  				Array.Copy (label' 0' new_data' 0' label.Length);  				label = new_data;  				new_data = new int[max_nr_class];  				Array.Copy (count' 0' new_data' 0' count.Length);  				count = new_data;  			}  			label [nr_class] = this_label;  			count [nr_class] = 1;  			++nr_class;  		}  	}  	for (i = 0; i < nr_class; i++) {  		int n1 = count [i];  		for (int j = i + 1; j < nr_class; j++) {  			int n2 = count [j];  			if (param.nu * (n1 + n2) / 2 > Math.Min (n1' n2))  				return "specified nu is infeasible";  		}  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The following statement contains a magic number: if (svm_type == svm_parameter.NU_SVC) {  	int l = prob.l;  	int max_nr_class = 16;  	int nr_class = 0;  	var label = new int[max_nr_class];  	var count = new int[max_nr_class];  	int i;  	for (i = 0; i < l; i++) {  		//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'  		var this_label = (int)prob.y [i];  		int j;  		for (j = 0; j < nr_class; j++)  			if (this_label == label [j]) {  				++count [j];  				break;  			}  		if (j == nr_class) {  			if (nr_class == max_nr_class) {  				max_nr_class *= 2;  				var new_data = new int[max_nr_class];  				Array.Copy (label' 0' new_data' 0' label.Length);  				label = new_data;  				new_data = new int[max_nr_class];  				Array.Copy (count' 0' new_data' 0' count.Length);  				count = new_data;  			}  			label [nr_class] = this_label;  			count [nr_class] = 1;  			++nr_class;  		}  	}  	for (i = 0; i < nr_class; i++) {  		int n1 = count [i];  		for (int j = i + 1; j < nr_class; j++) {  			int n2 = count [j];  			if (param.nu * (n1 + n2) / 2 > Math.Min (n1' n2))  				return "specified nu is infeasible";  		}  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The following statement contains a magic number: if (svm_type == svm_parameter.NU_SVC) {  	int l = prob.l;  	int max_nr_class = 16;  	int nr_class = 0;  	var label = new int[max_nr_class];  	var count = new int[max_nr_class];  	int i;  	for (i = 0; i < l; i++) {  		//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'  		var this_label = (int)prob.y [i];  		int j;  		for (j = 0; j < nr_class; j++)  			if (this_label == label [j]) {  				++count [j];  				break;  			}  		if (j == nr_class) {  			if (nr_class == max_nr_class) {  				max_nr_class *= 2;  				var new_data = new int[max_nr_class];  				Array.Copy (label' 0' new_data' 0' label.Length);  				label = new_data;  				new_data = new int[max_nr_class];  				Array.Copy (count' 0' new_data' 0' count.Length);  				count = new_data;  			}  			label [nr_class] = this_label;  			count [nr_class] = 1;  			++nr_class;  		}  	}  	for (i = 0; i < nr_class; i++) {  		int n1 = count [i];  		for (int j = i + 1; j < nr_class; j++) {  			int n2 = count [j];  			if (param.nu * (n1 + n2) / 2 > Math.Min (n1' n2))  				return "specified nu is infeasible";  		}  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The following statement contains a magic number: for (i = 0; i < l; i++) {  	//UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'  	var this_label = (int)prob.y [i];  	int j;  	for (j = 0; j < nr_class; j++)  		if (this_label == label [j]) {  			++count [j];  			break;  		}  	if (j == nr_class) {  		if (nr_class == max_nr_class) {  			max_nr_class *= 2;  			var new_data = new int[max_nr_class];  			Array.Copy (label' 0' new_data' 0' label.Length);  			label = new_data;  			new_data = new int[max_nr_class];  			Array.Copy (count' 0' new_data' 0' count.Length);  			count = new_data;  		}  		label [nr_class] = this_label;  		count [nr_class] = 1;  		++nr_class;  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The following statement contains a magic number: if (j == nr_class) {  	if (nr_class == max_nr_class) {  		max_nr_class *= 2;  		var new_data = new int[max_nr_class];  		Array.Copy (label' 0' new_data' 0' label.Length);  		label = new_data;  		new_data = new int[max_nr_class];  		Array.Copy (count' 0' new_data' 0' count.Length);  		count = new_data;  	}  	label [nr_class] = this_label;  	count [nr_class] = 1;  	++nr_class;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The following statement contains a magic number: if (nr_class == max_nr_class) {  	max_nr_class *= 2;  	var new_data = new int[max_nr_class];  	Array.Copy (label' 0' new_data' 0' label.Length);  	label = new_data;  	new_data = new int[max_nr_class];  	Array.Copy (count' 0' new_data' 0' count.Length);  	count = new_data;  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The following statement contains a magic number: max_nr_class *= 2;  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The following statement contains a magic number: for (i = 0; i < nr_class; i++) {  	int n1 = count [i];  	for (int j = i + 1; j < nr_class; j++) {  		int n2 = count [j];  		if (param.nu * (n1 + n2) / 2 > Math.Min (n1' n2))  			return "specified nu is infeasible";  	}  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The following statement contains a magic number: for (int j = i + 1; j < nr_class; j++) {  	int n2 = count [j];  	if (param.nu * (n1 + n2) / 2 > Math.Min (n1' n2))  		return "specified nu is infeasible";  }  
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The following statement contains a magic number: if (param.nu * (n1 + n2) / 2 > Math.Min (n1' n2))  	return "specified nu is infeasible";  
Magic Number,Encog.MathUtil.Matrices,BiPolarUtil,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\BiPolarUtil.cs,ToBinary,The following statement contains a magic number: return (d + 1) / 2.0;  
Magic Number,Encog.MathUtil.Matrices,BiPolarUtil,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\BiPolarUtil.cs,ToBiPolar,The following statement contains a magic number: return (2 * NormalizeBinary (d)) - 1;  
Magic Number,Encog.MathUtil.Matrices,Matrix,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Matrix.cs,Equals,The following statement contains a magic number: if (other is Matrix)  	return equals ((Matrix)other' 10);  else  	return false;  
Magic Number,Encog.MathUtil.Matrices,Matrix,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Matrix.cs,Equals,The following statement contains a magic number: return equals ((Matrix)other' 10);  
Magic Number,Encog.MathUtil.Matrices,Matrix,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Matrix.cs,equals,The following statement contains a magic number: precision = (int)Math.Pow (10' precision);  
Magic Number,Encog.MathUtil.Matrices,MatrixMath,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\MatrixMath.cs,VectorLength,The following statement contains a magic number: for (int i = 0; i < v.Length; i++) {  	rtn += Math.Pow (v [i]' 2);  }  
Magic Number,Encog.MathUtil.Matrices,MatrixMath,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\MatrixMath.cs,VectorLength,The following statement contains a magic number: rtn += Math.Pow (v [i]' 2);  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,The following statement contains a magic number: for (int l = 0; l < n; l++) {  	// Find small subdiagonal element  	tst1 = Math.Max (tst1' Math.Abs (d [l]) + Math.Abs (e [l]));  	int m = l;  	while (m < n) {  		if (Math.Abs (e [m]) <= eps * tst1) {  			break;  		}  		m++;  	}  	// If m == l' d[l] is an eigenvalue'  	// otherwise' iterate.  	if (m > l) {  		int iter = 0;  		do {  			iter = iter + 1;  			// (Could check iteration count here.)  			// Compute implicit shift  			double g = d [l];  			double p = (d [l + 1] - g) / (2.0 * e [l]);  			double r = EncogMath.Hypot (p' 1.0);  			if (p < 0) {  				r = -r;  			}  			d [l] = e [l] / (p + r);  			d [l + 1] = e [l] * (p + r);  			double dl1 = d [l + 1];  			double h = g - d [l];  			for (int i = l + 2; i < n; i++) {  				d [i] -= h;  			}  			f = f + h;  			// Implicit QL transformation.  			p = d [m];  			double c = 1.0;  			double c2 = c;  			double c3 = c;  			double el1 = e [l + 1];  			double s = 0.0;  			double s2 = 0.0;  			for (int i = m - 1; i >= l; i--) {  				c3 = c2;  				c2 = c;  				s2 = s;  				g = c * e [i];  				h = c * p;  				r = EncogMath.Hypot (p' e [i]);  				e [i + 1] = s * r;  				s = e [i] / r;  				c = p / r;  				p = c * d [i] - s * g;  				d [i + 1] = h + s * (c * g + s * d [i]);  				// Accumulate transformation.  				for (int k = 0; k < n; k++) {  					h = v [k] [i + 1];  					v [k] [i + 1] = s * v [k] [i] + c * h;  					v [k] [i] = c * v [k] [i] - s * h;  				}  			}  			p = -s * s2 * c3 * el1 * e [l] / dl1;  			e [l] = s * p;  			d [l] = c * p;  			// Check for convergence.  		}  		while (Math.Abs (e [l]) > eps * tst1);  	}  	d [l] = d [l] + f;  	e [l] = 0.0;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,The following statement contains a magic number: for (int l = 0; l < n; l++) {  	// Find small subdiagonal element  	tst1 = Math.Max (tst1' Math.Abs (d [l]) + Math.Abs (e [l]));  	int m = l;  	while (m < n) {  		if (Math.Abs (e [m]) <= eps * tst1) {  			break;  		}  		m++;  	}  	// If m == l' d[l] is an eigenvalue'  	// otherwise' iterate.  	if (m > l) {  		int iter = 0;  		do {  			iter = iter + 1;  			// (Could check iteration count here.)  			// Compute implicit shift  			double g = d [l];  			double p = (d [l + 1] - g) / (2.0 * e [l]);  			double r = EncogMath.Hypot (p' 1.0);  			if (p < 0) {  				r = -r;  			}  			d [l] = e [l] / (p + r);  			d [l + 1] = e [l] * (p + r);  			double dl1 = d [l + 1];  			double h = g - d [l];  			for (int i = l + 2; i < n; i++) {  				d [i] -= h;  			}  			f = f + h;  			// Implicit QL transformation.  			p = d [m];  			double c = 1.0;  			double c2 = c;  			double c3 = c;  			double el1 = e [l + 1];  			double s = 0.0;  			double s2 = 0.0;  			for (int i = m - 1; i >= l; i--) {  				c3 = c2;  				c2 = c;  				s2 = s;  				g = c * e [i];  				h = c * p;  				r = EncogMath.Hypot (p' e [i]);  				e [i + 1] = s * r;  				s = e [i] / r;  				c = p / r;  				p = c * d [i] - s * g;  				d [i + 1] = h + s * (c * g + s * d [i]);  				// Accumulate transformation.  				for (int k = 0; k < n; k++) {  					h = v [k] [i + 1];  					v [k] [i + 1] = s * v [k] [i] + c * h;  					v [k] [i] = c * v [k] [i] - s * h;  				}  			}  			p = -s * s2 * c3 * el1 * e [l] / dl1;  			e [l] = s * p;  			d [l] = c * p;  			// Check for convergence.  		}  		while (Math.Abs (e [l]) > eps * tst1);  	}  	d [l] = d [l] + f;  	e [l] = 0.0;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,The following statement contains a magic number: if (m > l) {  	int iter = 0;  	do {  		iter = iter + 1;  		// (Could check iteration count here.)  		// Compute implicit shift  		double g = d [l];  		double p = (d [l + 1] - g) / (2.0 * e [l]);  		double r = EncogMath.Hypot (p' 1.0);  		if (p < 0) {  			r = -r;  		}  		d [l] = e [l] / (p + r);  		d [l + 1] = e [l] * (p + r);  		double dl1 = d [l + 1];  		double h = g - d [l];  		for (int i = l + 2; i < n; i++) {  			d [i] -= h;  		}  		f = f + h;  		// Implicit QL transformation.  		p = d [m];  		double c = 1.0;  		double c2 = c;  		double c3 = c;  		double el1 = e [l + 1];  		double s = 0.0;  		double s2 = 0.0;  		for (int i = m - 1; i >= l; i--) {  			c3 = c2;  			c2 = c;  			s2 = s;  			g = c * e [i];  			h = c * p;  			r = EncogMath.Hypot (p' e [i]);  			e [i + 1] = s * r;  			s = e [i] / r;  			c = p / r;  			p = c * d [i] - s * g;  			d [i + 1] = h + s * (c * g + s * d [i]);  			// Accumulate transformation.  			for (int k = 0; k < n; k++) {  				h = v [k] [i + 1];  				v [k] [i + 1] = s * v [k] [i] + c * h;  				v [k] [i] = c * v [k] [i] - s * h;  			}  		}  		p = -s * s2 * c3 * el1 * e [l] / dl1;  		e [l] = s * p;  		d [l] = c * p;  		// Check for convergence.  	}  	while (Math.Abs (e [l]) > eps * tst1);  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,The following statement contains a magic number: if (m > l) {  	int iter = 0;  	do {  		iter = iter + 1;  		// (Could check iteration count here.)  		// Compute implicit shift  		double g = d [l];  		double p = (d [l + 1] - g) / (2.0 * e [l]);  		double r = EncogMath.Hypot (p' 1.0);  		if (p < 0) {  			r = -r;  		}  		d [l] = e [l] / (p + r);  		d [l + 1] = e [l] * (p + r);  		double dl1 = d [l + 1];  		double h = g - d [l];  		for (int i = l + 2; i < n; i++) {  			d [i] -= h;  		}  		f = f + h;  		// Implicit QL transformation.  		p = d [m];  		double c = 1.0;  		double c2 = c;  		double c3 = c;  		double el1 = e [l + 1];  		double s = 0.0;  		double s2 = 0.0;  		for (int i = m - 1; i >= l; i--) {  			c3 = c2;  			c2 = c;  			s2 = s;  			g = c * e [i];  			h = c * p;  			r = EncogMath.Hypot (p' e [i]);  			e [i + 1] = s * r;  			s = e [i] / r;  			c = p / r;  			p = c * d [i] - s * g;  			d [i + 1] = h + s * (c * g + s * d [i]);  			// Accumulate transformation.  			for (int k = 0; k < n; k++) {  				h = v [k] [i + 1];  				v [k] [i + 1] = s * v [k] [i] + c * h;  				v [k] [i] = c * v [k] [i] - s * h;  			}  		}  		p = -s * s2 * c3 * el1 * e [l] / dl1;  		e [l] = s * p;  		d [l] = c * p;  		// Check for convergence.  	}  	while (Math.Abs (e [l]) > eps * tst1);  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,The following statement contains a magic number: do {  	iter = iter + 1;  	// (Could check iteration count here.)  	// Compute implicit shift  	double g = d [l];  	double p = (d [l + 1] - g) / (2.0 * e [l]);  	double r = EncogMath.Hypot (p' 1.0);  	if (p < 0) {  		r = -r;  	}  	d [l] = e [l] / (p + r);  	d [l + 1] = e [l] * (p + r);  	double dl1 = d [l + 1];  	double h = g - d [l];  	for (int i = l + 2; i < n; i++) {  		d [i] -= h;  	}  	f = f + h;  	// Implicit QL transformation.  	p = d [m];  	double c = 1.0;  	double c2 = c;  	double c3 = c;  	double el1 = e [l + 1];  	double s = 0.0;  	double s2 = 0.0;  	for (int i = m - 1; i >= l; i--) {  		c3 = c2;  		c2 = c;  		s2 = s;  		g = c * e [i];  		h = c * p;  		r = EncogMath.Hypot (p' e [i]);  		e [i + 1] = s * r;  		s = e [i] / r;  		c = p / r;  		p = c * d [i] - s * g;  		d [i + 1] = h + s * (c * g + s * d [i]);  		// Accumulate transformation.  		for (int k = 0; k < n; k++) {  			h = v [k] [i + 1];  			v [k] [i + 1] = s * v [k] [i] + c * h;  			v [k] [i] = c * v [k] [i] - s * h;  		}  	}  	p = -s * s2 * c3 * el1 * e [l] / dl1;  	e [l] = s * p;  	d [l] = c * p;  	// Check for convergence.  }  while (Math.Abs (e [l]) > eps * tst1);  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,The following statement contains a magic number: do {  	iter = iter + 1;  	// (Could check iteration count here.)  	// Compute implicit shift  	double g = d [l];  	double p = (d [l + 1] - g) / (2.0 * e [l]);  	double r = EncogMath.Hypot (p' 1.0);  	if (p < 0) {  		r = -r;  	}  	d [l] = e [l] / (p + r);  	d [l + 1] = e [l] * (p + r);  	double dl1 = d [l + 1];  	double h = g - d [l];  	for (int i = l + 2; i < n; i++) {  		d [i] -= h;  	}  	f = f + h;  	// Implicit QL transformation.  	p = d [m];  	double c = 1.0;  	double c2 = c;  	double c3 = c;  	double el1 = e [l + 1];  	double s = 0.0;  	double s2 = 0.0;  	for (int i = m - 1; i >= l; i--) {  		c3 = c2;  		c2 = c;  		s2 = s;  		g = c * e [i];  		h = c * p;  		r = EncogMath.Hypot (p' e [i]);  		e [i + 1] = s * r;  		s = e [i] / r;  		c = p / r;  		p = c * d [i] - s * g;  		d [i + 1] = h + s * (c * g + s * d [i]);  		// Accumulate transformation.  		for (int k = 0; k < n; k++) {  			h = v [k] [i + 1];  			v [k] [i + 1] = s * v [k] [i] + c * h;  			v [k] [i] = c * v [k] [i] - s * h;  		}  	}  	p = -s * s2 * c3 * el1 * e [l] / dl1;  	e [l] = s * p;  	d [l] = c * p;  	// Check for convergence.  }  while (Math.Abs (e [l]) > eps * tst1);  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,The following statement contains a magic number: for (int i = l + 2; i < n; i++) {  	d [i] -= h;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (h [l - 1] [l - 1]) + Math.Abs (h [l] [l]);  		if (s == 0.0) {  			s = norm;  		}  		if (Math.Abs (h [l] [l - 1]) < eps * s) {  			break;  		}  		l--;  	}  	// Check for convergence  	// One root found  	if (l == n) {  		h [n] [n] = h [n] [n] + exshift;  		d [n] = h [n] [n];  		e [n] = 0.0;  		n--;  		iter = 0;  		// Two roots found  	}  	else if (l == n - 1) {  		w = h [n] [n - 1] * h [n - 1] [n];  		p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		h [n] [n] = h [n] [n] + exshift;  		h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  		x = h [n] [n];  		// Real pair  		if (q >= 0) {  			if (p >= 0) {  				z = p + z;  			}  			else {  				z = p - z;  			}  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0) {  				d [n] = x - w / z;  			}  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = h [n] [n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = h [n - 1] [j];  				h [n - 1] [j] = q * z + p * h [n] [j];  				h [n] [j] = q * h [n] [j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = h [i] [n - 1];  				h [i] [n - 1] = q * z + p * h [i] [n];  				h [i] [n] = q * h [i] [n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = v [i] [n - 1];  				v [i] [n - 1] = q * z + p * v [i] [n];  				v [i] [n] = q * v [i] [n] - p * z;  			}  			// Complex pair  		}  		else {  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  		// No convergence yet  	}  	else {  		// Form shift  		x = h [n] [n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = h [n - 1] [n - 1];  			w = h [n] [n - 1] * h [n - 1] [n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++) {  				h [i] [i] -= x;  			}  			s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x) {  					s = -s;  				}  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++) {  					h [i] [i] -= s;  				}  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// (Could check iteration count here.)  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = h [m] [m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  			q = h [m + 1] [m + 1] - z - r - s;  			r = h [m + 2] [m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l) {  				break;  			}  			if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  				break;  			}  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			h [i] [i - 2] = 0.0;  			if (i > m + 2) {  				h [i] [i - 3] = 0.0;  			}  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = h [k] [k - 1];  				q = h [k + 1] [k - 1];  				r = (notlast ? h [k + 2] [k - 1] : 0.0);  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0) {  				break;  			}  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0) {  				s = -s;  			}  			if (s != 0) {  				if (k != m) {  					h [k] [k - 1] = -s * x;  				}  				else if (l != m) {  					h [k] [k - 1] = -h [k] [k - 1];  				}  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = h [k] [j] + q * h [k + 1] [j];  					if (notlast) {  						p = p + r * h [k + 2] [j];  						h [k + 2] [j] = h [k + 2] [j] - p * z;  					}  					h [k] [j] = h [k] [j] - p * x;  					h [k + 1] [j] = h [k + 1] [j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * h [i] [k] + y * h [i] [k + 1];  					if (notlast) {  						p = p + z * h [i] [k + 2];  						h [i] [k + 2] = h [i] [k + 2] - p * r;  					}  					h [i] [k] = h [i] [k] - p;  					h [i] [k + 1] = h [i] [k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * v [i] [k] + y * v [i] [k + 1];  					if (notlast) {  						p = p + z * v [i] [k + 2];  						v [i] [k + 2] = v [i] [k + 2] - p * r;  					}  					v [i] [k] = v [i] [k] - p;  					v [i] [k + 1] = v [i] [k + 1] - p * q;  				}  			}  			// (s != 0)  		}  		// k loop  	}  	// check convergence  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n) {  	h [n] [n] = h [n] [n] + exshift;  	d [n] = h [n] [n];  	e [n] = 0.0;  	n--;  	iter = 0;  	// Two roots found  }  else if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (l == n - 1) {  	w = h [n] [n - 1] * h [n - 1] [n];  	p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	h [n] [n] = h [n] [n] + exshift;  	h [n - 1] [n - 1] = h [n - 1] [n - 1] + exshift;  	x = h [n] [n];  	// Real pair  	if (q >= 0) {  		if (p >= 0) {  			z = p + z;  		}  		else {  			z = p - z;  		}  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0) {  			d [n] = x - w / z;  		}  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = h [n] [n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = h [n - 1] [j];  			h [n - 1] [j] = q * z + p * h [n] [j];  			h [n] [j] = q * h [n] [j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = h [i] [n - 1];  			h [i] [n - 1] = q * z + p * h [i] [n];  			h [i] [n] = q * h [i] [n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = v [i] [n - 1];  			v [i] [n - 1] = q * z + p * v [i] [n];  			v [i] [n] = q * v [i] [n] - p * z;  		}  		// Complex pair  	}  	else {  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  	// No convergence yet  }  else {  	// Form shift  	x = h [n] [n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = h [n - 1] [n - 1];  		w = h [n] [n - 1] * h [n - 1] [n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++) {  			h [i] [i] -= x;  		}  		s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x) {  				s = -s;  			}  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++) {  				h [i] [i] -= s;  			}  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// (Could check iteration count here.)  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = h [m] [m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  		q = h [m + 1] [m + 1] - z - r - s;  		r = h [m + 2] [m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l) {  			break;  		}  		if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  			break;  		}  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		h [i] [i - 2] = 0.0;  		if (i > m + 2) {  			h [i] [i - 3] = 0.0;  		}  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = h [k] [k - 1];  			q = h [k + 1] [k - 1];  			r = (notlast ? h [k + 2] [k - 1] : 0.0);  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0) {  			break;  		}  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0) {  			s = -s;  		}  		if (s != 0) {  			if (k != m) {  				h [k] [k - 1] = -s * x;  			}  			else if (l != m) {  				h [k] [k - 1] = -h [k] [k - 1];  			}  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = h [k] [j] + q * h [k + 1] [j];  				if (notlast) {  					p = p + r * h [k + 2] [j];  					h [k + 2] [j] = h [k + 2] [j] - p * z;  				}  				h [k] [j] = h [k] [j] - p * x;  				h [k + 1] [j] = h [k + 1] [j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * h [i] [k] + y * h [i] [k + 1];  				if (notlast) {  					p = p + z * h [i] [k + 2];  					h [i] [k + 2] = h [i] [k + 2] - p * r;  				}  				h [i] [k] = h [i] [k] - p;  				h [i] [k + 1] = h [i] [k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * v [i] [k] + y * v [i] [k + 1];  				if (notlast) {  					p = p + z * v [i] [k + 2];  					v [i] [k + 2] = v [i] [k + 2] - p * r;  				}  				v [i] [k] = v [i] [k] - p;  				v [i] [k + 1] = v [i] [k + 1] - p * q;  			}  		}  		// (s != 0)  	}  	// k loop  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: p = (h [n - 1] [n - 1] - h [n] [n]) / 2.0;  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: n = n - 2;  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (iter == 10) {  	exshift += x;  	for (int i = low; i <= n; i++) {  		h [i] [i] -= x;  	}  	s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  	x = y = 0.75 * s;  	w = -0.4375 * s * s;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (iter == 10) {  	exshift += x;  	for (int i = low; i <= n; i++) {  		h [i] [i] -= x;  	}  	s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  	x = y = 0.75 * s;  	w = -0.4375 * s * s;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (iter == 10) {  	exshift += x;  	for (int i = low; i <= n; i++) {  		h [i] [i] -= x;  	}  	s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  	x = y = 0.75 * s;  	w = -0.4375 * s * s;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (iter == 10) {  	exshift += x;  	for (int i = low; i <= n; i++) {  		h [i] [i] -= x;  	}  	s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  	x = y = 0.75 * s;  	w = -0.4375 * s * s;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: s = Math.Abs (h [n] [n - 1]) + Math.Abs (h [n - 1] [n - 2]);  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: x = y = 0.75 * s;  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: w = -0.4375 * s * s;  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (iter == 30) {  	s = (y - x) / 2.0;  	s = s * s + w;  	if (s > 0) {  		s = Math.Sqrt (s);  		if (y < x) {  			s = -s;  		}  		s = x - w / ((y - x) / 2.0 + s);  		for (int i = low; i <= n; i++) {  			h [i] [i] -= s;  		}  		exshift += s;  		x = y = w = 0.964;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (iter == 30) {  	s = (y - x) / 2.0;  	s = s * s + w;  	if (s > 0) {  		s = Math.Sqrt (s);  		if (y < x) {  			s = -s;  		}  		s = x - w / ((y - x) / 2.0 + s);  		for (int i = low; i <= n; i++) {  			h [i] [i] -= s;  		}  		exshift += s;  		x = y = w = 0.964;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (iter == 30) {  	s = (y - x) / 2.0;  	s = s * s + w;  	if (s > 0) {  		s = Math.Sqrt (s);  		if (y < x) {  			s = -s;  		}  		s = x - w / ((y - x) / 2.0 + s);  		for (int i = low; i <= n; i++) {  			h [i] [i] -= s;  		}  		exshift += s;  		x = y = w = 0.964;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (iter == 30) {  	s = (y - x) / 2.0;  	s = s * s + w;  	if (s > 0) {  		s = Math.Sqrt (s);  		if (y < x) {  			s = -s;  		}  		s = x - w / ((y - x) / 2.0 + s);  		for (int i = low; i <= n; i++) {  			h [i] [i] -= s;  		}  		exshift += s;  		x = y = w = 0.964;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: s = (y - x) / 2.0;  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (s > 0) {  	s = Math.Sqrt (s);  	if (y < x) {  		s = -s;  	}  	s = x - w / ((y - x) / 2.0 + s);  	for (int i = low; i <= n; i++) {  		h [i] [i] -= s;  	}  	exshift += s;  	x = y = w = 0.964;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (s > 0) {  	s = Math.Sqrt (s);  	if (y < x) {  		s = -s;  	}  	s = x - w / ((y - x) / 2.0 + s);  	for (int i = low; i <= n; i++) {  		h [i] [i] -= s;  	}  	exshift += s;  	x = y = w = 0.964;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: s = x - w / ((y - x) / 2.0 + s);  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: x = y = w = 0.964;  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (m >= l) {  	z = h [m] [m];  	r = x - z;  	s = y - z;  	p = (r * s - w) / h [m + 1] [m] + h [m] [m + 1];  	q = h [m + 1] [m + 1] - z - r - s;  	r = h [m + 2] [m + 1];  	s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  	p = p / s;  	q = q / s;  	r = r / s;  	if (m == l) {  		break;  	}  	if (Math.Abs (h [m] [m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (h [m - 1] [m - 1]) + Math.Abs (z) + Math.Abs (h [m + 1] [m + 1])))) {  		break;  	}  	m--;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: r = h [m + 2] [m + 1];  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int i = m + 2; i <= n; i++) {  	h [i] [i - 2] = 0.0;  	if (i > m + 2) {  		h [i] [i - 3] = 0.0;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int i = m + 2; i <= n; i++) {  	h [i] [i - 2] = 0.0;  	if (i > m + 2) {  		h [i] [i - 3] = 0.0;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int i = m + 2; i <= n; i++) {  	h [i] [i - 2] = 0.0;  	if (i > m + 2) {  		h [i] [i - 3] = 0.0;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int i = m + 2; i <= n; i++) {  	h [i] [i - 2] = 0.0;  	if (i > m + 2) {  		h [i] [i - 3] = 0.0;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: h [i] [i - 2] = 0.0;  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (i > m + 2) {  	h [i] [i - 3] = 0.0;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (i > m + 2) {  	h [i] [i - 3] = 0.0;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: h [i] [i - 3] = 0.0;  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = h [k] [k - 1];  		q = h [k + 1] [k - 1];  		r = (notlast ? h [k + 2] [k - 1] : 0.0);  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0) {  		break;  	}  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0) {  		s = -s;  	}  	if (s != 0) {  		if (k != m) {  			h [k] [k - 1] = -s * x;  		}  		else if (l != m) {  			h [k] [k - 1] = -h [k] [k - 1];  		}  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = h [k] [j] + q * h [k + 1] [j];  			if (notlast) {  				p = p + r * h [k + 2] [j];  				h [k + 2] [j] = h [k + 2] [j] - p * z;  			}  			h [k] [j] = h [k] [j] - p * x;  			h [k + 1] [j] = h [k + 1] [j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * h [i] [k] + y * h [i] [k + 1];  			if (notlast) {  				p = p + z * h [i] [k + 2];  				h [i] [k + 2] = h [i] [k + 2] - p * r;  			}  			h [i] [k] = h [i] [k] - p;  			h [i] [k + 1] = h [i] [k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * v [i] [k] + y * v [i] [k + 1];  			if (notlast) {  				p = p + z * v [i] [k + 2];  				v [i] [k + 2] = v [i] [k + 2] - p * r;  			}  			v [i] [k] = v [i] [k] - p;  			v [i] [k + 1] = v [i] [k + 1] - p * q;  		}  	}  	// (s != 0)  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = h [k] [k - 1];  		q = h [k + 1] [k - 1];  		r = (notlast ? h [k + 2] [k - 1] : 0.0);  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0) {  		break;  	}  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0) {  		s = -s;  	}  	if (s != 0) {  		if (k != m) {  			h [k] [k - 1] = -s * x;  		}  		else if (l != m) {  			h [k] [k - 1] = -h [k] [k - 1];  		}  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = h [k] [j] + q * h [k + 1] [j];  			if (notlast) {  				p = p + r * h [k + 2] [j];  				h [k + 2] [j] = h [k + 2] [j] - p * z;  			}  			h [k] [j] = h [k] [j] - p * x;  			h [k + 1] [j] = h [k + 1] [j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * h [i] [k] + y * h [i] [k + 1];  			if (notlast) {  				p = p + z * h [i] [k + 2];  				h [i] [k + 2] = h [i] [k + 2] - p * r;  			}  			h [i] [k] = h [i] [k] - p;  			h [i] [k + 1] = h [i] [k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * v [i] [k] + y * v [i] [k + 1];  			if (notlast) {  				p = p + z * v [i] [k + 2];  				v [i] [k + 2] = v [i] [k + 2] - p * r;  			}  			v [i] [k] = v [i] [k] - p;  			v [i] [k + 1] = v [i] [k + 1] - p * q;  		}  	}  	// (s != 0)  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = h [k] [k - 1];  		q = h [k + 1] [k - 1];  		r = (notlast ? h [k + 2] [k - 1] : 0.0);  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0) {  		break;  	}  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0) {  		s = -s;  	}  	if (s != 0) {  		if (k != m) {  			h [k] [k - 1] = -s * x;  		}  		else if (l != m) {  			h [k] [k - 1] = -h [k] [k - 1];  		}  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = h [k] [j] + q * h [k + 1] [j];  			if (notlast) {  				p = p + r * h [k + 2] [j];  				h [k + 2] [j] = h [k + 2] [j] - p * z;  			}  			h [k] [j] = h [k] [j] - p * x;  			h [k + 1] [j] = h [k + 1] [j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * h [i] [k] + y * h [i] [k + 1];  			if (notlast) {  				p = p + z * h [i] [k + 2];  				h [i] [k + 2] = h [i] [k + 2] - p * r;  			}  			h [i] [k] = h [i] [k] - p;  			h [i] [k + 1] = h [i] [k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * v [i] [k] + y * v [i] [k + 1];  			if (notlast) {  				p = p + z * v [i] [k + 2];  				v [i] [k + 2] = v [i] [k + 2] - p * r;  			}  			v [i] [k] = v [i] [k] - p;  			v [i] [k + 1] = v [i] [k + 1] - p * q;  		}  	}  	// (s != 0)  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = h [k] [k - 1];  		q = h [k + 1] [k - 1];  		r = (notlast ? h [k + 2] [k - 1] : 0.0);  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0) {  		break;  	}  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0) {  		s = -s;  	}  	if (s != 0) {  		if (k != m) {  			h [k] [k - 1] = -s * x;  		}  		else if (l != m) {  			h [k] [k - 1] = -h [k] [k - 1];  		}  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = h [k] [j] + q * h [k + 1] [j];  			if (notlast) {  				p = p + r * h [k + 2] [j];  				h [k + 2] [j] = h [k + 2] [j] - p * z;  			}  			h [k] [j] = h [k] [j] - p * x;  			h [k + 1] [j] = h [k + 1] [j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * h [i] [k] + y * h [i] [k + 1];  			if (notlast) {  				p = p + z * h [i] [k + 2];  				h [i] [k + 2] = h [i] [k + 2] - p * r;  			}  			h [i] [k] = h [i] [k] - p;  			h [i] [k + 1] = h [i] [k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * v [i] [k] + y * v [i] [k + 1];  			if (notlast) {  				p = p + z * v [i] [k + 2];  				v [i] [k + 2] = v [i] [k + 2] - p * r;  			}  			v [i] [k] = v [i] [k] - p;  			v [i] [k + 1] = v [i] [k + 1] - p * q;  		}  	}  	// (s != 0)  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = h [k] [k - 1];  		q = h [k + 1] [k - 1];  		r = (notlast ? h [k + 2] [k - 1] : 0.0);  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0) {  		break;  	}  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0) {  		s = -s;  	}  	if (s != 0) {  		if (k != m) {  			h [k] [k - 1] = -s * x;  		}  		else if (l != m) {  			h [k] [k - 1] = -h [k] [k - 1];  		}  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = h [k] [j] + q * h [k + 1] [j];  			if (notlast) {  				p = p + r * h [k + 2] [j];  				h [k + 2] [j] = h [k + 2] [j] - p * z;  			}  			h [k] [j] = h [k] [j] - p * x;  			h [k + 1] [j] = h [k + 1] [j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * h [i] [k] + y * h [i] [k + 1];  			if (notlast) {  				p = p + z * h [i] [k + 2];  				h [i] [k + 2] = h [i] [k + 2] - p * r;  			}  			h [i] [k] = h [i] [k] - p;  			h [i] [k + 1] = h [i] [k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * v [i] [k] + y * v [i] [k + 1];  			if (notlast) {  				p = p + z * v [i] [k + 2];  				v [i] [k + 2] = v [i] [k + 2] - p * r;  			}  			v [i] [k] = v [i] [k] - p;  			v [i] [k + 1] = v [i] [k + 1] - p * q;  		}  	}  	// (s != 0)  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = h [k] [k - 1];  		q = h [k + 1] [k - 1];  		r = (notlast ? h [k + 2] [k - 1] : 0.0);  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0) {  		break;  	}  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0) {  		s = -s;  	}  	if (s != 0) {  		if (k != m) {  			h [k] [k - 1] = -s * x;  		}  		else if (l != m) {  			h [k] [k - 1] = -h [k] [k - 1];  		}  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = h [k] [j] + q * h [k + 1] [j];  			if (notlast) {  				p = p + r * h [k + 2] [j];  				h [k + 2] [j] = h [k + 2] [j] - p * z;  			}  			h [k] [j] = h [k] [j] - p * x;  			h [k + 1] [j] = h [k + 1] [j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * h [i] [k] + y * h [i] [k + 1];  			if (notlast) {  				p = p + z * h [i] [k + 2];  				h [i] [k + 2] = h [i] [k + 2] - p * r;  			}  			h [i] [k] = h [i] [k] - p;  			h [i] [k + 1] = h [i] [k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * v [i] [k] + y * v [i] [k + 1];  			if (notlast) {  				p = p + z * v [i] [k + 2];  				v [i] [k + 2] = v [i] [k + 2] - p * r;  			}  			v [i] [k] = v [i] [k] - p;  			v [i] [k + 1] = v [i] [k + 1] - p * q;  		}  	}  	// (s != 0)  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = h [k] [k - 1];  		q = h [k + 1] [k - 1];  		r = (notlast ? h [k + 2] [k - 1] : 0.0);  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0) {  		break;  	}  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0) {  		s = -s;  	}  	if (s != 0) {  		if (k != m) {  			h [k] [k - 1] = -s * x;  		}  		else if (l != m) {  			h [k] [k - 1] = -h [k] [k - 1];  		}  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = h [k] [j] + q * h [k + 1] [j];  			if (notlast) {  				p = p + r * h [k + 2] [j];  				h [k + 2] [j] = h [k + 2] [j] - p * z;  			}  			h [k] [j] = h [k] [j] - p * x;  			h [k + 1] [j] = h [k + 1] [j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * h [i] [k] + y * h [i] [k + 1];  			if (notlast) {  				p = p + z * h [i] [k + 2];  				h [i] [k + 2] = h [i] [k + 2] - p * r;  			}  			h [i] [k] = h [i] [k] - p;  			h [i] [k + 1] = h [i] [k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * v [i] [k] + y * v [i] [k + 1];  			if (notlast) {  				p = p + z * v [i] [k + 2];  				v [i] [k + 2] = v [i] [k + 2] - p * r;  			}  			v [i] [k] = v [i] [k] - p;  			v [i] [k + 1] = v [i] [k + 1] - p * q;  		}  	}  	// (s != 0)  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = h [k] [k - 1];  		q = h [k + 1] [k - 1];  		r = (notlast ? h [k + 2] [k - 1] : 0.0);  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0) {  		break;  	}  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0) {  		s = -s;  	}  	if (s != 0) {  		if (k != m) {  			h [k] [k - 1] = -s * x;  		}  		else if (l != m) {  			h [k] [k - 1] = -h [k] [k - 1];  		}  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = h [k] [j] + q * h [k + 1] [j];  			if (notlast) {  				p = p + r * h [k + 2] [j];  				h [k + 2] [j] = h [k + 2] [j] - p * z;  			}  			h [k] [j] = h [k] [j] - p * x;  			h [k + 1] [j] = h [k + 1] [j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * h [i] [k] + y * h [i] [k + 1];  			if (notlast) {  				p = p + z * h [i] [k + 2];  				h [i] [k + 2] = h [i] [k + 2] - p * r;  			}  			h [i] [k] = h [i] [k] - p;  			h [i] [k + 1] = h [i] [k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * v [i] [k] + y * v [i] [k + 1];  			if (notlast) {  				p = p + z * v [i] [k + 2];  				v [i] [k + 2] = v [i] [k + 2] - p * r;  			}  			v [i] [k] = v [i] [k] - p;  			v [i] [k + 1] = v [i] [k + 1] - p * q;  		}  	}  	// (s != 0)  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = h [k] [k - 1];  		q = h [k + 1] [k - 1];  		r = (notlast ? h [k + 2] [k - 1] : 0.0);  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0) {  		break;  	}  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0) {  		s = -s;  	}  	if (s != 0) {  		if (k != m) {  			h [k] [k - 1] = -s * x;  		}  		else if (l != m) {  			h [k] [k - 1] = -h [k] [k - 1];  		}  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = h [k] [j] + q * h [k + 1] [j];  			if (notlast) {  				p = p + r * h [k + 2] [j];  				h [k + 2] [j] = h [k + 2] [j] - p * z;  			}  			h [k] [j] = h [k] [j] - p * x;  			h [k + 1] [j] = h [k + 1] [j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * h [i] [k] + y * h [i] [k + 1];  			if (notlast) {  				p = p + z * h [i] [k + 2];  				h [i] [k + 2] = h [i] [k + 2] - p * r;  			}  			h [i] [k] = h [i] [k] - p;  			h [i] [k + 1] = h [i] [k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * v [i] [k] + y * v [i] [k + 1];  			if (notlast) {  				p = p + z * v [i] [k + 2];  				v [i] [k + 2] = v [i] [k + 2] - p * r;  			}  			v [i] [k] = v [i] [k] - p;  			v [i] [k + 1] = v [i] [k + 1] - p * q;  		}  	}  	// (s != 0)  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = h [k] [k - 1];  		q = h [k + 1] [k - 1];  		r = (notlast ? h [k + 2] [k - 1] : 0.0);  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0) {  		break;  	}  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0) {  		s = -s;  	}  	if (s != 0) {  		if (k != m) {  			h [k] [k - 1] = -s * x;  		}  		else if (l != m) {  			h [k] [k - 1] = -h [k] [k - 1];  		}  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = h [k] [j] + q * h [k + 1] [j];  			if (notlast) {  				p = p + r * h [k + 2] [j];  				h [k + 2] [j] = h [k + 2] [j] - p * z;  			}  			h [k] [j] = h [k] [j] - p * x;  			h [k + 1] [j] = h [k + 1] [j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * h [i] [k] + y * h [i] [k + 1];  			if (notlast) {  				p = p + z * h [i] [k + 2];  				h [i] [k + 2] = h [i] [k + 2] - p * r;  			}  			h [i] [k] = h [i] [k] - p;  			h [i] [k + 1] = h [i] [k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * v [i] [k] + y * v [i] [k + 1];  			if (notlast) {  				p = p + z * v [i] [k + 2];  				v [i] [k + 2] = v [i] [k + 2] - p * r;  			}  			v [i] [k] = v [i] [k] - p;  			v [i] [k + 1] = v [i] [k + 1] - p * q;  		}  	}  	// (s != 0)  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = h [k] [k - 1];  		q = h [k + 1] [k - 1];  		r = (notlast ? h [k + 2] [k - 1] : 0.0);  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0) {  		break;  	}  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0) {  		s = -s;  	}  	if (s != 0) {  		if (k != m) {  			h [k] [k - 1] = -s * x;  		}  		else if (l != m) {  			h [k] [k - 1] = -h [k] [k - 1];  		}  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = h [k] [j] + q * h [k + 1] [j];  			if (notlast) {  				p = p + r * h [k + 2] [j];  				h [k + 2] [j] = h [k + 2] [j] - p * z;  			}  			h [k] [j] = h [k] [j] - p * x;  			h [k + 1] [j] = h [k + 1] [j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * h [i] [k] + y * h [i] [k + 1];  			if (notlast) {  				p = p + z * h [i] [k + 2];  				h [i] [k + 2] = h [i] [k + 2] - p * r;  			}  			h [i] [k] = h [i] [k] - p;  			h [i] [k + 1] = h [i] [k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * v [i] [k] + y * v [i] [k + 1];  			if (notlast) {  				p = p + z * v [i] [k + 2];  				v [i] [k + 2] = v [i] [k + 2] - p * r;  			}  			v [i] [k] = v [i] [k] - p;  			v [i] [k + 1] = v [i] [k + 1] - p * q;  		}  	}  	// (s != 0)  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (k != m) {  	p = h [k] [k - 1];  	q = h [k + 1] [k - 1];  	r = (notlast ? h [k + 2] [k - 1] : 0.0);  	x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  	if (x != 0.0) {  		p = p / x;  		q = q / x;  		r = r / x;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: r = (notlast ? h [k + 2] [k - 1] : 0.0);  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m) {  		h [k] [k - 1] = -s * x;  	}  	else if (l != m) {  		h [k] [k - 1] = -h [k] [k - 1];  	}  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = h [k] [j] + q * h [k + 1] [j];  		if (notlast) {  			p = p + r * h [k + 2] [j];  			h [k + 2] [j] = h [k + 2] [j] - p * z;  		}  		h [k] [j] = h [k] [j] - p * x;  		h [k + 1] [j] = h [k + 1] [j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * h [i] [k] + y * h [i] [k + 1];  		if (notlast) {  			p = p + z * h [i] [k + 2];  			h [i] [k + 2] = h [i] [k + 2] - p * r;  		}  		h [i] [k] = h [i] [k] - p;  		h [i] [k + 1] = h [i] [k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * v [i] [k] + y * v [i] [k + 1];  		if (notlast) {  			p = p + z * v [i] [k + 2];  			v [i] [k + 2] = v [i] [k + 2] - p * r;  		}  		v [i] [k] = v [i] [k] - p;  		v [i] [k + 1] = v [i] [k + 1] - p * q;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m) {  		h [k] [k - 1] = -s * x;  	}  	else if (l != m) {  		h [k] [k - 1] = -h [k] [k - 1];  	}  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = h [k] [j] + q * h [k + 1] [j];  		if (notlast) {  			p = p + r * h [k + 2] [j];  			h [k + 2] [j] = h [k + 2] [j] - p * z;  		}  		h [k] [j] = h [k] [j] - p * x;  		h [k + 1] [j] = h [k + 1] [j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * h [i] [k] + y * h [i] [k + 1];  		if (notlast) {  			p = p + z * h [i] [k + 2];  			h [i] [k + 2] = h [i] [k + 2] - p * r;  		}  		h [i] [k] = h [i] [k] - p;  		h [i] [k + 1] = h [i] [k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * v [i] [k] + y * v [i] [k + 1];  		if (notlast) {  			p = p + z * v [i] [k + 2];  			v [i] [k + 2] = v [i] [k + 2] - p * r;  		}  		v [i] [k] = v [i] [k] - p;  		v [i] [k + 1] = v [i] [k + 1] - p * q;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m) {  		h [k] [k - 1] = -s * x;  	}  	else if (l != m) {  		h [k] [k - 1] = -h [k] [k - 1];  	}  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = h [k] [j] + q * h [k + 1] [j];  		if (notlast) {  			p = p + r * h [k + 2] [j];  			h [k + 2] [j] = h [k + 2] [j] - p * z;  		}  		h [k] [j] = h [k] [j] - p * x;  		h [k + 1] [j] = h [k + 1] [j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * h [i] [k] + y * h [i] [k + 1];  		if (notlast) {  			p = p + z * h [i] [k + 2];  			h [i] [k + 2] = h [i] [k + 2] - p * r;  		}  		h [i] [k] = h [i] [k] - p;  		h [i] [k + 1] = h [i] [k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * v [i] [k] + y * v [i] [k + 1];  		if (notlast) {  			p = p + z * v [i] [k + 2];  			v [i] [k + 2] = v [i] [k + 2] - p * r;  		}  		v [i] [k] = v [i] [k] - p;  		v [i] [k + 1] = v [i] [k + 1] - p * q;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m) {  		h [k] [k - 1] = -s * x;  	}  	else if (l != m) {  		h [k] [k - 1] = -h [k] [k - 1];  	}  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = h [k] [j] + q * h [k + 1] [j];  		if (notlast) {  			p = p + r * h [k + 2] [j];  			h [k + 2] [j] = h [k + 2] [j] - p * z;  		}  		h [k] [j] = h [k] [j] - p * x;  		h [k + 1] [j] = h [k + 1] [j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * h [i] [k] + y * h [i] [k + 1];  		if (notlast) {  			p = p + z * h [i] [k + 2];  			h [i] [k + 2] = h [i] [k + 2] - p * r;  		}  		h [i] [k] = h [i] [k] - p;  		h [i] [k + 1] = h [i] [k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * v [i] [k] + y * v [i] [k + 1];  		if (notlast) {  			p = p + z * v [i] [k + 2];  			v [i] [k + 2] = v [i] [k + 2] - p * r;  		}  		v [i] [k] = v [i] [k] - p;  		v [i] [k + 1] = v [i] [k + 1] - p * q;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m) {  		h [k] [k - 1] = -s * x;  	}  	else if (l != m) {  		h [k] [k - 1] = -h [k] [k - 1];  	}  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = h [k] [j] + q * h [k + 1] [j];  		if (notlast) {  			p = p + r * h [k + 2] [j];  			h [k + 2] [j] = h [k + 2] [j] - p * z;  		}  		h [k] [j] = h [k] [j] - p * x;  		h [k + 1] [j] = h [k + 1] [j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * h [i] [k] + y * h [i] [k + 1];  		if (notlast) {  			p = p + z * h [i] [k + 2];  			h [i] [k + 2] = h [i] [k + 2] - p * r;  		}  		h [i] [k] = h [i] [k] - p;  		h [i] [k + 1] = h [i] [k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * v [i] [k] + y * v [i] [k + 1];  		if (notlast) {  			p = p + z * v [i] [k + 2];  			v [i] [k + 2] = v [i] [k + 2] - p * r;  		}  		v [i] [k] = v [i] [k] - p;  		v [i] [k + 1] = v [i] [k + 1] - p * q;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m) {  		h [k] [k - 1] = -s * x;  	}  	else if (l != m) {  		h [k] [k - 1] = -h [k] [k - 1];  	}  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = h [k] [j] + q * h [k + 1] [j];  		if (notlast) {  			p = p + r * h [k + 2] [j];  			h [k + 2] [j] = h [k + 2] [j] - p * z;  		}  		h [k] [j] = h [k] [j] - p * x;  		h [k + 1] [j] = h [k + 1] [j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * h [i] [k] + y * h [i] [k + 1];  		if (notlast) {  			p = p + z * h [i] [k + 2];  			h [i] [k + 2] = h [i] [k + 2] - p * r;  		}  		h [i] [k] = h [i] [k] - p;  		h [i] [k + 1] = h [i] [k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * v [i] [k] + y * v [i] [k + 1];  		if (notlast) {  			p = p + z * v [i] [k + 2];  			v [i] [k + 2] = v [i] [k + 2] - p * r;  		}  		v [i] [k] = v [i] [k] - p;  		v [i] [k + 1] = v [i] [k + 1] - p * q;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m) {  		h [k] [k - 1] = -s * x;  	}  	else if (l != m) {  		h [k] [k - 1] = -h [k] [k - 1];  	}  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = h [k] [j] + q * h [k + 1] [j];  		if (notlast) {  			p = p + r * h [k + 2] [j];  			h [k + 2] [j] = h [k + 2] [j] - p * z;  		}  		h [k] [j] = h [k] [j] - p * x;  		h [k + 1] [j] = h [k + 1] [j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * h [i] [k] + y * h [i] [k + 1];  		if (notlast) {  			p = p + z * h [i] [k + 2];  			h [i] [k + 2] = h [i] [k + 2] - p * r;  		}  		h [i] [k] = h [i] [k] - p;  		h [i] [k + 1] = h [i] [k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * v [i] [k] + y * v [i] [k + 1];  		if (notlast) {  			p = p + z * v [i] [k + 2];  			v [i] [k + 2] = v [i] [k + 2] - p * r;  		}  		v [i] [k] = v [i] [k] - p;  		v [i] [k + 1] = v [i] [k + 1] - p * q;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m) {  		h [k] [k - 1] = -s * x;  	}  	else if (l != m) {  		h [k] [k - 1] = -h [k] [k - 1];  	}  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = h [k] [j] + q * h [k + 1] [j];  		if (notlast) {  			p = p + r * h [k + 2] [j];  			h [k + 2] [j] = h [k + 2] [j] - p * z;  		}  		h [k] [j] = h [k] [j] - p * x;  		h [k + 1] [j] = h [k + 1] [j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * h [i] [k] + y * h [i] [k + 1];  		if (notlast) {  			p = p + z * h [i] [k + 2];  			h [i] [k + 2] = h [i] [k + 2] - p * r;  		}  		h [i] [k] = h [i] [k] - p;  		h [i] [k + 1] = h [i] [k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * v [i] [k] + y * v [i] [k + 1];  		if (notlast) {  			p = p + z * v [i] [k + 2];  			v [i] [k + 2] = v [i] [k + 2] - p * r;  		}  		v [i] [k] = v [i] [k] - p;  		v [i] [k + 1] = v [i] [k + 1] - p * q;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m) {  		h [k] [k - 1] = -s * x;  	}  	else if (l != m) {  		h [k] [k - 1] = -h [k] [k - 1];  	}  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = h [k] [j] + q * h [k + 1] [j];  		if (notlast) {  			p = p + r * h [k + 2] [j];  			h [k + 2] [j] = h [k + 2] [j] - p * z;  		}  		h [k] [j] = h [k] [j] - p * x;  		h [k + 1] [j] = h [k + 1] [j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * h [i] [k] + y * h [i] [k + 1];  		if (notlast) {  			p = p + z * h [i] [k + 2];  			h [i] [k + 2] = h [i] [k + 2] - p * r;  		}  		h [i] [k] = h [i] [k] - p;  		h [i] [k + 1] = h [i] [k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * v [i] [k] + y * v [i] [k + 1];  		if (notlast) {  			p = p + z * v [i] [k + 2];  			v [i] [k + 2] = v [i] [k + 2] - p * r;  		}  		v [i] [k] = v [i] [k] - p;  		v [i] [k + 1] = v [i] [k + 1] - p * q;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m) {  		h [k] [k - 1] = -s * x;  	}  	else if (l != m) {  		h [k] [k - 1] = -h [k] [k - 1];  	}  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = h [k] [j] + q * h [k + 1] [j];  		if (notlast) {  			p = p + r * h [k + 2] [j];  			h [k + 2] [j] = h [k + 2] [j] - p * z;  		}  		h [k] [j] = h [k] [j] - p * x;  		h [k + 1] [j] = h [k + 1] [j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * h [i] [k] + y * h [i] [k + 1];  		if (notlast) {  			p = p + z * h [i] [k + 2];  			h [i] [k + 2] = h [i] [k + 2] - p * r;  		}  		h [i] [k] = h [i] [k] - p;  		h [i] [k + 1] = h [i] [k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * v [i] [k] + y * v [i] [k + 1];  		if (notlast) {  			p = p + z * v [i] [k + 2];  			v [i] [k + 2] = v [i] [k + 2] - p * r;  		}  		v [i] [k] = v [i] [k] - p;  		v [i] [k + 1] = v [i] [k + 1] - p * q;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int j = k; j < nn; j++) {  	p = h [k] [j] + q * h [k + 1] [j];  	if (notlast) {  		p = p + r * h [k + 2] [j];  		h [k + 2] [j] = h [k + 2] [j] - p * z;  	}  	h [k] [j] = h [k] [j] - p * x;  	h [k + 1] [j] = h [k + 1] [j] - p * y;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int j = k; j < nn; j++) {  	p = h [k] [j] + q * h [k + 1] [j];  	if (notlast) {  		p = p + r * h [k + 2] [j];  		h [k + 2] [j] = h [k + 2] [j] - p * z;  	}  	h [k] [j] = h [k] [j] - p * x;  	h [k + 1] [j] = h [k + 1] [j] - p * y;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int j = k; j < nn; j++) {  	p = h [k] [j] + q * h [k + 1] [j];  	if (notlast) {  		p = p + r * h [k + 2] [j];  		h [k + 2] [j] = h [k + 2] [j] - p * z;  	}  	h [k] [j] = h [k] [j] - p * x;  	h [k + 1] [j] = h [k + 1] [j] - p * y;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (notlast) {  	p = p + r * h [k + 2] [j];  	h [k + 2] [j] = h [k + 2] [j] - p * z;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (notlast) {  	p = p + r * h [k + 2] [j];  	h [k + 2] [j] = h [k + 2] [j] - p * z;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (notlast) {  	p = p + r * h [k + 2] [j];  	h [k + 2] [j] = h [k + 2] [j] - p * z;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: p = p + r * h [k + 2] [j];  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: h [k + 2] [j] = h [k + 2] [j] - p * z;  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: h [k + 2] [j] = h [k + 2] [j] - p * z;  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int i = 0; i <= Math.Min (n' k + 3); i++) {  	p = x * h [i] [k] + y * h [i] [k + 1];  	if (notlast) {  		p = p + z * h [i] [k + 2];  		h [i] [k + 2] = h [i] [k + 2] - p * r;  	}  	h [i] [k] = h [i] [k] - p;  	h [i] [k + 1] = h [i] [k + 1] - p * q;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int i = 0; i <= Math.Min (n' k + 3); i++) {  	p = x * h [i] [k] + y * h [i] [k + 1];  	if (notlast) {  		p = p + z * h [i] [k + 2];  		h [i] [k + 2] = h [i] [k + 2] - p * r;  	}  	h [i] [k] = h [i] [k] - p;  	h [i] [k + 1] = h [i] [k + 1] - p * q;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int i = 0; i <= Math.Min (n' k + 3); i++) {  	p = x * h [i] [k] + y * h [i] [k + 1];  	if (notlast) {  		p = p + z * h [i] [k + 2];  		h [i] [k + 2] = h [i] [k + 2] - p * r;  	}  	h [i] [k] = h [i] [k] - p;  	h [i] [k + 1] = h [i] [k + 1] - p * q;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int i = 0; i <= Math.Min (n' k + 3); i++) {  	p = x * h [i] [k] + y * h [i] [k + 1];  	if (notlast) {  		p = p + z * h [i] [k + 2];  		h [i] [k + 2] = h [i] [k + 2] - p * r;  	}  	h [i] [k] = h [i] [k] - p;  	h [i] [k + 1] = h [i] [k + 1] - p * q;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (notlast) {  	p = p + z * h [i] [k + 2];  	h [i] [k + 2] = h [i] [k + 2] - p * r;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (notlast) {  	p = p + z * h [i] [k + 2];  	h [i] [k + 2] = h [i] [k + 2] - p * r;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (notlast) {  	p = p + z * h [i] [k + 2];  	h [i] [k + 2] = h [i] [k + 2] - p * r;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: p = p + z * h [i] [k + 2];  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: h [i] [k + 2] = h [i] [k + 2] - p * r;  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: h [i] [k + 2] = h [i] [k + 2] - p * r;  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int i = low; i <= high; i++) {  	p = x * v [i] [k] + y * v [i] [k + 1];  	if (notlast) {  		p = p + z * v [i] [k + 2];  		v [i] [k + 2] = v [i] [k + 2] - p * r;  	}  	v [i] [k] = v [i] [k] - p;  	v [i] [k + 1] = v [i] [k + 1] - p * q;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int i = low; i <= high; i++) {  	p = x * v [i] [k] + y * v [i] [k + 1];  	if (notlast) {  		p = p + z * v [i] [k + 2];  		v [i] [k + 2] = v [i] [k + 2] - p * r;  	}  	v [i] [k] = v [i] [k] - p;  	v [i] [k + 1] = v [i] [k + 1] - p * q;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int i = low; i <= high; i++) {  	p = x * v [i] [k] + y * v [i] [k + 1];  	if (notlast) {  		p = p + z * v [i] [k + 2];  		v [i] [k + 2] = v [i] [k + 2] - p * r;  	}  	v [i] [k] = v [i] [k] - p;  	v [i] [k + 1] = v [i] [k + 1] - p * q;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (notlast) {  	p = p + z * v [i] [k + 2];  	v [i] [k + 2] = v [i] [k + 2] - p * r;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (notlast) {  	p = p + z * v [i] [k + 2];  	v [i] [k + 2] = v [i] [k + 2] - p * r;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (notlast) {  	p = p + z * v [i] [k + 2];  	v [i] [k + 2] = v [i] [k + 2] - p * r;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: p = p + z * v [i] [k + 2];  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: v [i] [k + 2] = v [i] [k + 2] - p * r;  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: v [i] [k + 2] = v [i] [k + 2] - p * r;  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (n = nn - 1; n >= 0; n--) {  	p = d [n];  	q = e [n];  	// Real vector  	if (q == 0) {  		int l = n;  		h [n] [n] = 1.0;  		for (int i = n - 1; i >= 0; i--) {  			w = h [i] [i] - p;  			r = 0.0;  			for (int j = l; j <= n; j++) {  				r = r + h [i] [j] * h [j] [n];  			}  			if (e [i] < 0.0) {  				z = w;  				s = r;  			}  			else {  				l = i;  				if (e [i] == 0.0) {  					if (w != 0.0) {  						h [i] [n] = -r / w;  					}  					else {  						h [i] [n] = -r / (eps * norm);  					}  					// Solve real equations  				}  				else {  					x = h [i] [i + 1];  					y = h [i + 1] [i];  					q = (d [i] - p) * (d [i] - p) + e [i] * e [i];  					t = (x * s - z * r) / q;  					h [i] [n] = t;  					if (Math.Abs (x) > Math.Abs (z)) {  						h [i + 1] [n] = (-r - w * t) / x;  					}  					else {  						h [i + 1] [n] = (-s - y * t) / z;  					}  				}  				// Overflow control  				t = Math.Abs (h [i] [n]);  				if ((eps * t) * t > 1) {  					for (int j = i; j <= n; j++) {  						h [j] [n] = h [j] [n] / t;  					}  				}  			}  		}  		// Complex vector  	}  	else if (q < 0) {  		int l = n - 1;  		// Last vector component imaginary so matrix is triangular  		if (Math.Abs (h [n] [n - 1]) > Math.Abs (h [n - 1] [n])) {  			h [n - 1] [n - 1] = q / h [n] [n - 1];  			h [n - 1] [n] = -(h [n] [n] - p) / h [n] [n - 1];  		}  		else {  			cdiv (0.0' -h [n - 1] [n]' h [n - 1] [n - 1] - p' q);  			h [n - 1] [n - 1] = cdivr;  			h [n - 1] [n] = cdivi;  		}  		h [n] [n - 1] = 0.0;  		h [n] [n] = 1.0;  		for (int i = n - 2; i >= 0; i--) {  			double ra' sa' vr' vi;  			ra = 0.0;  			sa = 0.0;  			for (int j = l; j <= n; j++) {  				ra = ra + h [i] [j] * h [j] [n - 1];  				sa = sa + h [i] [j] * h [j] [n];  			}  			w = h [i] [i] - p;  			if (e [i] < 0.0) {  				z = w;  				r = ra;  				s = sa;  			}  			else {  				l = i;  				if (e [i] == 0) {  					cdiv (-ra' -sa' w' q);  					h [i] [n - 1] = cdivr;  					h [i] [n] = cdivi;  				}  				else {  					// Solve complex equations  					x = h [i] [i + 1];  					y = h [i + 1] [i];  					vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  					vi = (d [i] - p) * 2.0 * q;  					if (vr == 0.0 & vi == 0.0) {  						vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  					}  					cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  					h [i] [n - 1] = cdivr;  					h [i] [n] = cdivi;  					if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  						h [i + 1] [n - 1] = (-ra - w * h [i] [n - 1] + q * h [i] [n]) / x;  						h [i + 1] [n] = (-sa - w * h [i] [n] - q * h [i] [n - 1]) / x;  					}  					else {  						cdiv (-r - y * h [i] [n - 1]' -s - y * h [i] [n]' z' q);  						h [i + 1] [n - 1] = cdivr;  						h [i + 1] [n] = cdivi;  					}  				}  				// Overflow control  				t = Math.Max (Math.Abs (h [i] [n - 1])' Math.Abs (h [i] [n]));  				if ((eps * t) * t > 1) {  					for (int j = i; j <= n; j++) {  						h [j] [n - 1] = h [j] [n - 1] / t;  						h [j] [n] = h [j] [n] / t;  					}  				}  			}  		}  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (n = nn - 1; n >= 0; n--) {  	p = d [n];  	q = e [n];  	// Real vector  	if (q == 0) {  		int l = n;  		h [n] [n] = 1.0;  		for (int i = n - 1; i >= 0; i--) {  			w = h [i] [i] - p;  			r = 0.0;  			for (int j = l; j <= n; j++) {  				r = r + h [i] [j] * h [j] [n];  			}  			if (e [i] < 0.0) {  				z = w;  				s = r;  			}  			else {  				l = i;  				if (e [i] == 0.0) {  					if (w != 0.0) {  						h [i] [n] = -r / w;  					}  					else {  						h [i] [n] = -r / (eps * norm);  					}  					// Solve real equations  				}  				else {  					x = h [i] [i + 1];  					y = h [i + 1] [i];  					q = (d [i] - p) * (d [i] - p) + e [i] * e [i];  					t = (x * s - z * r) / q;  					h [i] [n] = t;  					if (Math.Abs (x) > Math.Abs (z)) {  						h [i + 1] [n] = (-r - w * t) / x;  					}  					else {  						h [i + 1] [n] = (-s - y * t) / z;  					}  				}  				// Overflow control  				t = Math.Abs (h [i] [n]);  				if ((eps * t) * t > 1) {  					for (int j = i; j <= n; j++) {  						h [j] [n] = h [j] [n] / t;  					}  				}  			}  		}  		// Complex vector  	}  	else if (q < 0) {  		int l = n - 1;  		// Last vector component imaginary so matrix is triangular  		if (Math.Abs (h [n] [n - 1]) > Math.Abs (h [n - 1] [n])) {  			h [n - 1] [n - 1] = q / h [n] [n - 1];  			h [n - 1] [n] = -(h [n] [n] - p) / h [n] [n - 1];  		}  		else {  			cdiv (0.0' -h [n - 1] [n]' h [n - 1] [n - 1] - p' q);  			h [n - 1] [n - 1] = cdivr;  			h [n - 1] [n] = cdivi;  		}  		h [n] [n - 1] = 0.0;  		h [n] [n] = 1.0;  		for (int i = n - 2; i >= 0; i--) {  			double ra' sa' vr' vi;  			ra = 0.0;  			sa = 0.0;  			for (int j = l; j <= n; j++) {  				ra = ra + h [i] [j] * h [j] [n - 1];  				sa = sa + h [i] [j] * h [j] [n];  			}  			w = h [i] [i] - p;  			if (e [i] < 0.0) {  				z = w;  				r = ra;  				s = sa;  			}  			else {  				l = i;  				if (e [i] == 0) {  					cdiv (-ra' -sa' w' q);  					h [i] [n - 1] = cdivr;  					h [i] [n] = cdivi;  				}  				else {  					// Solve complex equations  					x = h [i] [i + 1];  					y = h [i + 1] [i];  					vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  					vi = (d [i] - p) * 2.0 * q;  					if (vr == 0.0 & vi == 0.0) {  						vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  					}  					cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  					h [i] [n - 1] = cdivr;  					h [i] [n] = cdivi;  					if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  						h [i + 1] [n - 1] = (-ra - w * h [i] [n - 1] + q * h [i] [n]) / x;  						h [i + 1] [n] = (-sa - w * h [i] [n] - q * h [i] [n - 1]) / x;  					}  					else {  						cdiv (-r - y * h [i] [n - 1]' -s - y * h [i] [n]' z' q);  						h [i + 1] [n - 1] = cdivr;  						h [i + 1] [n] = cdivi;  					}  				}  				// Overflow control  				t = Math.Max (Math.Abs (h [i] [n - 1])' Math.Abs (h [i] [n]));  				if ((eps * t) * t > 1) {  					for (int j = i; j <= n; j++) {  						h [j] [n - 1] = h [j] [n - 1] / t;  						h [j] [n] = h [j] [n] / t;  					}  				}  			}  		}  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (q == 0) {  	int l = n;  	h [n] [n] = 1.0;  	for (int i = n - 1; i >= 0; i--) {  		w = h [i] [i] - p;  		r = 0.0;  		for (int j = l; j <= n; j++) {  			r = r + h [i] [j] * h [j] [n];  		}  		if (e [i] < 0.0) {  			z = w;  			s = r;  		}  		else {  			l = i;  			if (e [i] == 0.0) {  				if (w != 0.0) {  					h [i] [n] = -r / w;  				}  				else {  					h [i] [n] = -r / (eps * norm);  				}  				// Solve real equations  			}  			else {  				x = h [i] [i + 1];  				y = h [i + 1] [i];  				q = (d [i] - p) * (d [i] - p) + e [i] * e [i];  				t = (x * s - z * r) / q;  				h [i] [n] = t;  				if (Math.Abs (x) > Math.Abs (z)) {  					h [i + 1] [n] = (-r - w * t) / x;  				}  				else {  					h [i + 1] [n] = (-s - y * t) / z;  				}  			}  			// Overflow control  			t = Math.Abs (h [i] [n]);  			if ((eps * t) * t > 1) {  				for (int j = i; j <= n; j++) {  					h [j] [n] = h [j] [n] / t;  				}  			}  		}  	}  	// Complex vector  }  else if (q < 0) {  	int l = n - 1;  	// Last vector component imaginary so matrix is triangular  	if (Math.Abs (h [n] [n - 1]) > Math.Abs (h [n - 1] [n])) {  		h [n - 1] [n - 1] = q / h [n] [n - 1];  		h [n - 1] [n] = -(h [n] [n] - p) / h [n] [n - 1];  	}  	else {  		cdiv (0.0' -h [n - 1] [n]' h [n - 1] [n - 1] - p' q);  		h [n - 1] [n - 1] = cdivr;  		h [n - 1] [n] = cdivi;  	}  	h [n] [n - 1] = 0.0;  	h [n] [n] = 1.0;  	for (int i = n - 2; i >= 0; i--) {  		double ra' sa' vr' vi;  		ra = 0.0;  		sa = 0.0;  		for (int j = l; j <= n; j++) {  			ra = ra + h [i] [j] * h [j] [n - 1];  			sa = sa + h [i] [j] * h [j] [n];  		}  		w = h [i] [i] - p;  		if (e [i] < 0.0) {  			z = w;  			r = ra;  			s = sa;  		}  		else {  			l = i;  			if (e [i] == 0) {  				cdiv (-ra' -sa' w' q);  				h [i] [n - 1] = cdivr;  				h [i] [n] = cdivi;  			}  			else {  				// Solve complex equations  				x = h [i] [i + 1];  				y = h [i + 1] [i];  				vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  				vi = (d [i] - p) * 2.0 * q;  				if (vr == 0.0 & vi == 0.0) {  					vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  				}  				cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  				h [i] [n - 1] = cdivr;  				h [i] [n] = cdivi;  				if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  					h [i + 1] [n - 1] = (-ra - w * h [i] [n - 1] + q * h [i] [n]) / x;  					h [i + 1] [n] = (-sa - w * h [i] [n] - q * h [i] [n - 1]) / x;  				}  				else {  					cdiv (-r - y * h [i] [n - 1]' -s - y * h [i] [n]' z' q);  					h [i + 1] [n - 1] = cdivr;  					h [i + 1] [n] = cdivi;  				}  			}  			// Overflow control  			t = Math.Max (Math.Abs (h [i] [n - 1])' Math.Abs (h [i] [n]));  			if ((eps * t) * t > 1) {  				for (int j = i; j <= n; j++) {  					h [j] [n - 1] = h [j] [n - 1] / t;  					h [j] [n] = h [j] [n] / t;  				}  			}  		}  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (q == 0) {  	int l = n;  	h [n] [n] = 1.0;  	for (int i = n - 1; i >= 0; i--) {  		w = h [i] [i] - p;  		r = 0.0;  		for (int j = l; j <= n; j++) {  			r = r + h [i] [j] * h [j] [n];  		}  		if (e [i] < 0.0) {  			z = w;  			s = r;  		}  		else {  			l = i;  			if (e [i] == 0.0) {  				if (w != 0.0) {  					h [i] [n] = -r / w;  				}  				else {  					h [i] [n] = -r / (eps * norm);  				}  				// Solve real equations  			}  			else {  				x = h [i] [i + 1];  				y = h [i + 1] [i];  				q = (d [i] - p) * (d [i] - p) + e [i] * e [i];  				t = (x * s - z * r) / q;  				h [i] [n] = t;  				if (Math.Abs (x) > Math.Abs (z)) {  					h [i + 1] [n] = (-r - w * t) / x;  				}  				else {  					h [i + 1] [n] = (-s - y * t) / z;  				}  			}  			// Overflow control  			t = Math.Abs (h [i] [n]);  			if ((eps * t) * t > 1) {  				for (int j = i; j <= n; j++) {  					h [j] [n] = h [j] [n] / t;  				}  			}  		}  	}  	// Complex vector  }  else if (q < 0) {  	int l = n - 1;  	// Last vector component imaginary so matrix is triangular  	if (Math.Abs (h [n] [n - 1]) > Math.Abs (h [n - 1] [n])) {  		h [n - 1] [n - 1] = q / h [n] [n - 1];  		h [n - 1] [n] = -(h [n] [n] - p) / h [n] [n - 1];  	}  	else {  		cdiv (0.0' -h [n - 1] [n]' h [n - 1] [n - 1] - p' q);  		h [n - 1] [n - 1] = cdivr;  		h [n - 1] [n] = cdivi;  	}  	h [n] [n - 1] = 0.0;  	h [n] [n] = 1.0;  	for (int i = n - 2; i >= 0; i--) {  		double ra' sa' vr' vi;  		ra = 0.0;  		sa = 0.0;  		for (int j = l; j <= n; j++) {  			ra = ra + h [i] [j] * h [j] [n - 1];  			sa = sa + h [i] [j] * h [j] [n];  		}  		w = h [i] [i] - p;  		if (e [i] < 0.0) {  			z = w;  			r = ra;  			s = sa;  		}  		else {  			l = i;  			if (e [i] == 0) {  				cdiv (-ra' -sa' w' q);  				h [i] [n - 1] = cdivr;  				h [i] [n] = cdivi;  			}  			else {  				// Solve complex equations  				x = h [i] [i + 1];  				y = h [i + 1] [i];  				vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  				vi = (d [i] - p) * 2.0 * q;  				if (vr == 0.0 & vi == 0.0) {  					vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  				}  				cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  				h [i] [n - 1] = cdivr;  				h [i] [n] = cdivi;  				if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  					h [i + 1] [n - 1] = (-ra - w * h [i] [n - 1] + q * h [i] [n]) / x;  					h [i + 1] [n] = (-sa - w * h [i] [n] - q * h [i] [n - 1]) / x;  				}  				else {  					cdiv (-r - y * h [i] [n - 1]' -s - y * h [i] [n]' z' q);  					h [i + 1] [n - 1] = cdivr;  					h [i + 1] [n] = cdivi;  				}  			}  			// Overflow control  			t = Math.Max (Math.Abs (h [i] [n - 1])' Math.Abs (h [i] [n]));  			if ((eps * t) * t > 1) {  				for (int j = i; j <= n; j++) {  					h [j] [n - 1] = h [j] [n - 1] / t;  					h [j] [n] = h [j] [n] / t;  				}  			}  		}  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (q < 0) {  	int l = n - 1;  	// Last vector component imaginary so matrix is triangular  	if (Math.Abs (h [n] [n - 1]) > Math.Abs (h [n - 1] [n])) {  		h [n - 1] [n - 1] = q / h [n] [n - 1];  		h [n - 1] [n] = -(h [n] [n] - p) / h [n] [n - 1];  	}  	else {  		cdiv (0.0' -h [n - 1] [n]' h [n - 1] [n - 1] - p' q);  		h [n - 1] [n - 1] = cdivr;  		h [n - 1] [n] = cdivi;  	}  	h [n] [n - 1] = 0.0;  	h [n] [n] = 1.0;  	for (int i = n - 2; i >= 0; i--) {  		double ra' sa' vr' vi;  		ra = 0.0;  		sa = 0.0;  		for (int j = l; j <= n; j++) {  			ra = ra + h [i] [j] * h [j] [n - 1];  			sa = sa + h [i] [j] * h [j] [n];  		}  		w = h [i] [i] - p;  		if (e [i] < 0.0) {  			z = w;  			r = ra;  			s = sa;  		}  		else {  			l = i;  			if (e [i] == 0) {  				cdiv (-ra' -sa' w' q);  				h [i] [n - 1] = cdivr;  				h [i] [n] = cdivi;  			}  			else {  				// Solve complex equations  				x = h [i] [i + 1];  				y = h [i + 1] [i];  				vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  				vi = (d [i] - p) * 2.0 * q;  				if (vr == 0.0 & vi == 0.0) {  					vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  				}  				cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  				h [i] [n - 1] = cdivr;  				h [i] [n] = cdivi;  				if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  					h [i + 1] [n - 1] = (-ra - w * h [i] [n - 1] + q * h [i] [n]) / x;  					h [i + 1] [n] = (-sa - w * h [i] [n] - q * h [i] [n - 1]) / x;  				}  				else {  					cdiv (-r - y * h [i] [n - 1]' -s - y * h [i] [n]' z' q);  					h [i + 1] [n - 1] = cdivr;  					h [i + 1] [n] = cdivi;  				}  			}  			// Overflow control  			t = Math.Max (Math.Abs (h [i] [n - 1])' Math.Abs (h [i] [n]));  			if ((eps * t) * t > 1) {  				for (int j = i; j <= n; j++) {  					h [j] [n - 1] = h [j] [n - 1] / t;  					h [j] [n] = h [j] [n] / t;  				}  			}  		}  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (q < 0) {  	int l = n - 1;  	// Last vector component imaginary so matrix is triangular  	if (Math.Abs (h [n] [n - 1]) > Math.Abs (h [n - 1] [n])) {  		h [n - 1] [n - 1] = q / h [n] [n - 1];  		h [n - 1] [n] = -(h [n] [n] - p) / h [n] [n - 1];  	}  	else {  		cdiv (0.0' -h [n - 1] [n]' h [n - 1] [n - 1] - p' q);  		h [n - 1] [n - 1] = cdivr;  		h [n - 1] [n] = cdivi;  	}  	h [n] [n - 1] = 0.0;  	h [n] [n] = 1.0;  	for (int i = n - 2; i >= 0; i--) {  		double ra' sa' vr' vi;  		ra = 0.0;  		sa = 0.0;  		for (int j = l; j <= n; j++) {  			ra = ra + h [i] [j] * h [j] [n - 1];  			sa = sa + h [i] [j] * h [j] [n];  		}  		w = h [i] [i] - p;  		if (e [i] < 0.0) {  			z = w;  			r = ra;  			s = sa;  		}  		else {  			l = i;  			if (e [i] == 0) {  				cdiv (-ra' -sa' w' q);  				h [i] [n - 1] = cdivr;  				h [i] [n] = cdivi;  			}  			else {  				// Solve complex equations  				x = h [i] [i + 1];  				y = h [i + 1] [i];  				vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  				vi = (d [i] - p) * 2.0 * q;  				if (vr == 0.0 & vi == 0.0) {  					vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  				}  				cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  				h [i] [n - 1] = cdivr;  				h [i] [n] = cdivi;  				if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  					h [i + 1] [n - 1] = (-ra - w * h [i] [n - 1] + q * h [i] [n]) / x;  					h [i + 1] [n] = (-sa - w * h [i] [n] - q * h [i] [n - 1]) / x;  				}  				else {  					cdiv (-r - y * h [i] [n - 1]' -s - y * h [i] [n]' z' q);  					h [i + 1] [n - 1] = cdivr;  					h [i + 1] [n] = cdivi;  				}  			}  			// Overflow control  			t = Math.Max (Math.Abs (h [i] [n - 1])' Math.Abs (h [i] [n]));  			if ((eps * t) * t > 1) {  				for (int j = i; j <= n; j++) {  					h [j] [n - 1] = h [j] [n - 1] / t;  					h [j] [n] = h [j] [n] / t;  				}  			}  		}  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int i = n - 2; i >= 0; i--) {  	double ra' sa' vr' vi;  	ra = 0.0;  	sa = 0.0;  	for (int j = l; j <= n; j++) {  		ra = ra + h [i] [j] * h [j] [n - 1];  		sa = sa + h [i] [j] * h [j] [n];  	}  	w = h [i] [i] - p;  	if (e [i] < 0.0) {  		z = w;  		r = ra;  		s = sa;  	}  	else {  		l = i;  		if (e [i] == 0) {  			cdiv (-ra' -sa' w' q);  			h [i] [n - 1] = cdivr;  			h [i] [n] = cdivi;  		}  		else {  			// Solve complex equations  			x = h [i] [i + 1];  			y = h [i + 1] [i];  			vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  			vi = (d [i] - p) * 2.0 * q;  			if (vr == 0.0 & vi == 0.0) {  				vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  			}  			cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  			h [i] [n - 1] = cdivr;  			h [i] [n] = cdivi;  			if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  				h [i + 1] [n - 1] = (-ra - w * h [i] [n - 1] + q * h [i] [n]) / x;  				h [i + 1] [n] = (-sa - w * h [i] [n] - q * h [i] [n - 1]) / x;  			}  			else {  				cdiv (-r - y * h [i] [n - 1]' -s - y * h [i] [n]' z' q);  				h [i + 1] [n - 1] = cdivr;  				h [i + 1] [n] = cdivi;  			}  		}  		// Overflow control  		t = Math.Max (Math.Abs (h [i] [n - 1])' Math.Abs (h [i] [n]));  		if ((eps * t) * t > 1) {  			for (int j = i; j <= n; j++) {  				h [j] [n - 1] = h [j] [n - 1] / t;  				h [j] [n] = h [j] [n] / t;  			}  		}  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (int i = n - 2; i >= 0; i--) {  	double ra' sa' vr' vi;  	ra = 0.0;  	sa = 0.0;  	for (int j = l; j <= n; j++) {  		ra = ra + h [i] [j] * h [j] [n - 1];  		sa = sa + h [i] [j] * h [j] [n];  	}  	w = h [i] [i] - p;  	if (e [i] < 0.0) {  		z = w;  		r = ra;  		s = sa;  	}  	else {  		l = i;  		if (e [i] == 0) {  			cdiv (-ra' -sa' w' q);  			h [i] [n - 1] = cdivr;  			h [i] [n] = cdivi;  		}  		else {  			// Solve complex equations  			x = h [i] [i + 1];  			y = h [i + 1] [i];  			vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  			vi = (d [i] - p) * 2.0 * q;  			if (vr == 0.0 & vi == 0.0) {  				vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  			}  			cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  			h [i] [n - 1] = cdivr;  			h [i] [n] = cdivi;  			if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  				h [i + 1] [n - 1] = (-ra - w * h [i] [n - 1] + q * h [i] [n]) / x;  				h [i + 1] [n] = (-sa - w * h [i] [n] - q * h [i] [n - 1]) / x;  			}  			else {  				cdiv (-r - y * h [i] [n - 1]' -s - y * h [i] [n]' z' q);  				h [i + 1] [n - 1] = cdivr;  				h [i + 1] [n] = cdivi;  			}  		}  		// Overflow control  		t = Math.Max (Math.Abs (h [i] [n - 1])' Math.Abs (h [i] [n]));  		if ((eps * t) * t > 1) {  			for (int j = i; j <= n; j++) {  				h [j] [n - 1] = h [j] [n - 1] / t;  				h [j] [n] = h [j] [n] / t;  			}  		}  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (e [i] < 0.0) {  	z = w;  	r = ra;  	s = sa;  }  else {  	l = i;  	if (e [i] == 0) {  		cdiv (-ra' -sa' w' q);  		h [i] [n - 1] = cdivr;  		h [i] [n] = cdivi;  	}  	else {  		// Solve complex equations  		x = h [i] [i + 1];  		y = h [i + 1] [i];  		vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  		vi = (d [i] - p) * 2.0 * q;  		if (vr == 0.0 & vi == 0.0) {  			vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  		}  		cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  		h [i] [n - 1] = cdivr;  		h [i] [n] = cdivi;  		if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  			h [i + 1] [n - 1] = (-ra - w * h [i] [n - 1] + q * h [i] [n]) / x;  			h [i + 1] [n] = (-sa - w * h [i] [n] - q * h [i] [n - 1]) / x;  		}  		else {  			cdiv (-r - y * h [i] [n - 1]' -s - y * h [i] [n]' z' q);  			h [i + 1] [n - 1] = cdivr;  			h [i + 1] [n] = cdivi;  		}  	}  	// Overflow control  	t = Math.Max (Math.Abs (h [i] [n - 1])' Math.Abs (h [i] [n]));  	if ((eps * t) * t > 1) {  		for (int j = i; j <= n; j++) {  			h [j] [n - 1] = h [j] [n - 1] / t;  			h [j] [n] = h [j] [n] / t;  		}  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: if (e [i] == 0) {  	cdiv (-ra' -sa' w' q);  	h [i] [n - 1] = cdivr;  	h [i] [n] = cdivi;  }  else {  	// Solve complex equations  	x = h [i] [i + 1];  	y = h [i + 1] [i];  	vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  	vi = (d [i] - p) * 2.0 * q;  	if (vr == 0.0 & vi == 0.0) {  		vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  	}  	cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  	h [i] [n - 1] = cdivr;  	h [i] [n] = cdivi;  	if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  		h [i + 1] [n - 1] = (-ra - w * h [i] [n - 1] + q * h [i] [n]) / x;  		h [i + 1] [n] = (-sa - w * h [i] [n] - q * h [i] [n - 1]) / x;  	}  	else {  		cdiv (-r - y * h [i] [n - 1]' -s - y * h [i] [n]' z' q);  		h [i + 1] [n - 1] = cdivr;  		h [i + 1] [n] = cdivi;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: vi = (d [i] - p) * 2.0 * q;  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays. On  	// completion the variables kase and k are set as follows.  	// kase = 1 if s(p) and e[k-1] are negligible and k<p  	// kase = 2 if s(k) is negligible and k<p  	// kase = 3 if e[k-1] is negligible' k<p' and  	// s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4 if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1) {  			break;  		}  		if (Math.Abs (e [k]) <= tiny + eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k) {  				break;  			}  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= tiny + eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k) {  			kase = 3;  		}  		else if (ks == p - 1) {  			kase = 1;  		}  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  						vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  						vmatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  						umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  						umatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0) {  					shift = -shift;  				}  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = EncogMath.Hypot (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k) {  					e [j - 1] = t;  				}  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  						vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  						vmatrix [i] [j] = t;  					}  				}  				t = EncogMath.Hypot (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  						umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  						umatrix [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv) {  					for (int i = 0; i <= pp; i++) {  						vmatrix [i] [k] = -vmatrix [i] [k];  					}  				}  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1]) {  					break;  				}  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1)) {  					for (int i = 0; i < n; i++) {  						t = vmatrix [i] [k + 1];  						vmatrix [i] [k + 1] = vmatrix [i] [k];  						vmatrix [i] [k] = t;  					}  				}  				if (wantu && (k < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = umatrix [i] [k + 1];  						umatrix [i] [k + 1] = umatrix [i] [k];  						umatrix [i] [k] = t;  					}  				}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays. On  	// completion the variables kase and k are set as follows.  	// kase = 1 if s(p) and e[k-1] are negligible and k<p  	// kase = 2 if s(k) is negligible and k<p  	// kase = 3 if e[k-1] is negligible' k<p' and  	// s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4 if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1) {  			break;  		}  		if (Math.Abs (e [k]) <= tiny + eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k) {  				break;  			}  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= tiny + eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k) {  			kase = 3;  		}  		else if (ks == p - 1) {  			kase = 1;  		}  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  						vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  						vmatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  						umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  						umatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0) {  					shift = -shift;  				}  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = EncogMath.Hypot (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k) {  					e [j - 1] = t;  				}  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  						vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  						vmatrix [i] [j] = t;  					}  				}  				t = EncogMath.Hypot (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  						umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  						umatrix [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv) {  					for (int i = 0; i <= pp; i++) {  						vmatrix [i] [k] = -vmatrix [i] [k];  					}  				}  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1]) {  					break;  				}  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1)) {  					for (int i = 0; i < n; i++) {  						t = vmatrix [i] [k + 1];  						vmatrix [i] [k + 1] = vmatrix [i] [k];  						vmatrix [i] [k] = t;  					}  				}  				if (wantu && (k < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = umatrix [i] [k + 1];  						umatrix [i] [k + 1] = umatrix [i] [k];  						umatrix [i] [k] = t;  					}  				}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays. On  	// completion the variables kase and k are set as follows.  	// kase = 1 if s(p) and e[k-1] are negligible and k<p  	// kase = 2 if s(k) is negligible and k<p  	// kase = 3 if e[k-1] is negligible' k<p' and  	// s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4 if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1) {  			break;  		}  		if (Math.Abs (e [k]) <= tiny + eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k) {  				break;  			}  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= tiny + eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k) {  			kase = 3;  		}  		else if (ks == p - 1) {  			kase = 1;  		}  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  						vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  						vmatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  						umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  						umatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0) {  					shift = -shift;  				}  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = EncogMath.Hypot (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k) {  					e [j - 1] = t;  				}  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  						vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  						vmatrix [i] [j] = t;  					}  				}  				t = EncogMath.Hypot (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  						umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  						umatrix [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv) {  					for (int i = 0; i <= pp; i++) {  						vmatrix [i] [k] = -vmatrix [i] [k];  					}  				}  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1]) {  					break;  				}  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1)) {  					for (int i = 0; i < n; i++) {  						t = vmatrix [i] [k + 1];  						vmatrix [i] [k + 1] = vmatrix [i] [k];  						vmatrix [i] [k] = t;  					}  				}  				if (wantu && (k < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = umatrix [i] [k + 1];  						umatrix [i] [k + 1] = umatrix [i] [k];  						umatrix [i] [k] = t;  					}  				}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays. On  	// completion the variables kase and k are set as follows.  	// kase = 1 if s(p) and e[k-1] are negligible and k<p  	// kase = 2 if s(k) is negligible and k<p  	// kase = 3 if e[k-1] is negligible' k<p' and  	// s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4 if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1) {  			break;  		}  		if (Math.Abs (e [k]) <= tiny + eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k) {  				break;  			}  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= tiny + eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k) {  			kase = 3;  		}  		else if (ks == p - 1) {  			kase = 1;  		}  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  						vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  						vmatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  						umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  						umatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0) {  					shift = -shift;  				}  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = EncogMath.Hypot (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k) {  					e [j - 1] = t;  				}  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  						vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  						vmatrix [i] [j] = t;  					}  				}  				t = EncogMath.Hypot (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  						umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  						umatrix [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv) {  					for (int i = 0; i <= pp; i++) {  						vmatrix [i] [k] = -vmatrix [i] [k];  					}  				}  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1]) {  					break;  				}  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1)) {  					for (int i = 0; i < n; i++) {  						t = vmatrix [i] [k + 1];  						vmatrix [i] [k + 1] = vmatrix [i] [k];  						vmatrix [i] [k] = t;  					}  				}  				if (wantu && (k < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = umatrix [i] [k + 1];  						umatrix [i] [k + 1] = umatrix [i] [k];  						umatrix [i] [k] = t;  					}  				}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays. On  	// completion the variables kase and k are set as follows.  	// kase = 1 if s(p) and e[k-1] are negligible and k<p  	// kase = 2 if s(k) is negligible and k<p  	// kase = 3 if e[k-1] is negligible' k<p' and  	// s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4 if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1) {  			break;  		}  		if (Math.Abs (e [k]) <= tiny + eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k) {  				break;  			}  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= tiny + eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k) {  			kase = 3;  		}  		else if (ks == p - 1) {  			kase = 1;  		}  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  						vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  						vmatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  						umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  						umatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0) {  					shift = -shift;  				}  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = EncogMath.Hypot (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k) {  					e [j - 1] = t;  				}  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  						vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  						vmatrix [i] [j] = t;  					}  				}  				t = EncogMath.Hypot (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  						umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  						umatrix [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv) {  					for (int i = 0; i <= pp; i++) {  						vmatrix [i] [k] = -vmatrix [i] [k];  					}  				}  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1]) {  					break;  				}  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1)) {  					for (int i = 0; i < n; i++) {  						t = vmatrix [i] [k + 1];  						vmatrix [i] [k + 1] = vmatrix [i] [k];  						vmatrix [i] [k] = t;  					}  				}  				if (wantu && (k < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = umatrix [i] [k + 1];  						umatrix [i] [k + 1] = umatrix [i] [k];  						umatrix [i] [k] = t;  					}  				}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays. On  	// completion the variables kase and k are set as follows.  	// kase = 1 if s(p) and e[k-1] are negligible and k<p  	// kase = 2 if s(k) is negligible and k<p  	// kase = 3 if e[k-1] is negligible' k<p' and  	// s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4 if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1) {  			break;  		}  		if (Math.Abs (e [k]) <= tiny + eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k) {  				break;  			}  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= tiny + eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k) {  			kase = 3;  		}  		else if (ks == p - 1) {  			kase = 1;  		}  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  						vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  						vmatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  						umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  						umatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0) {  					shift = -shift;  				}  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = EncogMath.Hypot (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k) {  					e [j - 1] = t;  				}  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  						vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  						vmatrix [i] [j] = t;  					}  				}  				t = EncogMath.Hypot (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  						umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  						umatrix [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv) {  					for (int i = 0; i <= pp; i++) {  						vmatrix [i] [k] = -vmatrix [i] [k];  					}  				}  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1]) {  					break;  				}  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1)) {  					for (int i = 0; i < n; i++) {  						t = vmatrix [i] [k + 1];  						vmatrix [i] [k + 1] = vmatrix [i] [k];  						vmatrix [i] [k] = t;  					}  				}  				if (wantu && (k < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = umatrix [i] [k + 1];  						umatrix [i] [k + 1] = umatrix [i] [k];  						umatrix [i] [k] = t;  					}  				}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays. On  	// completion the variables kase and k are set as follows.  	// kase = 1 if s(p) and e[k-1] are negligible and k<p  	// kase = 2 if s(k) is negligible and k<p  	// kase = 3 if e[k-1] is negligible' k<p' and  	// s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4 if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1) {  			break;  		}  		if (Math.Abs (e [k]) <= tiny + eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k) {  				break;  			}  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= tiny + eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k) {  			kase = 3;  		}  		else if (ks == p - 1) {  			kase = 1;  		}  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  						vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  						vmatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  						umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  						umatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0) {  					shift = -shift;  				}  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = EncogMath.Hypot (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k) {  					e [j - 1] = t;  				}  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  						vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  						vmatrix [i] [j] = t;  					}  				}  				t = EncogMath.Hypot (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  						umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  						umatrix [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv) {  					for (int i = 0; i <= pp; i++) {  						vmatrix [i] [k] = -vmatrix [i] [k];  					}  				}  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1]) {  					break;  				}  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1)) {  					for (int i = 0; i < n; i++) {  						t = vmatrix [i] [k + 1];  						vmatrix [i] [k + 1] = vmatrix [i] [k];  						vmatrix [i] [k] = t;  					}  				}  				if (wantu && (k < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = umatrix [i] [k + 1];  						umatrix [i] [k + 1] = umatrix [i] [k];  						umatrix [i] [k] = t;  					}  				}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays. On  	// completion the variables kase and k are set as follows.  	// kase = 1 if s(p) and e[k-1] are negligible and k<p  	// kase = 2 if s(k) is negligible and k<p  	// kase = 3 if e[k-1] is negligible' k<p' and  	// s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4 if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1) {  			break;  		}  		if (Math.Abs (e [k]) <= tiny + eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k) {  				break;  			}  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= tiny + eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k) {  			kase = 3;  		}  		else if (ks == p - 1) {  			kase = 1;  		}  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  						vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  						vmatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  						umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  						umatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0) {  					shift = -shift;  				}  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = EncogMath.Hypot (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k) {  					e [j - 1] = t;  				}  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  						vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  						vmatrix [i] [j] = t;  					}  				}  				t = EncogMath.Hypot (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  						umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  						umatrix [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv) {  					for (int i = 0; i <= pp; i++) {  						vmatrix [i] [k] = -vmatrix [i] [k];  					}  				}  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1]) {  					break;  				}  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1)) {  					for (int i = 0; i < n; i++) {  						t = vmatrix [i] [k + 1];  						vmatrix [i] [k + 1] = vmatrix [i] [k];  						vmatrix [i] [k] = t;  					}  				}  				if (wantu && (k < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = umatrix [i] [k + 1];  						umatrix [i] [k + 1] = umatrix [i] [k];  						umatrix [i] [k] = t;  					}  				}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays. On  	// completion the variables kase and k are set as follows.  	// kase = 1 if s(p) and e[k-1] are negligible and k<p  	// kase = 2 if s(k) is negligible and k<p  	// kase = 3 if e[k-1] is negligible' k<p' and  	// s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4 if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1) {  			break;  		}  		if (Math.Abs (e [k]) <= tiny + eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k) {  				break;  			}  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= tiny + eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k) {  			kase = 3;  		}  		else if (ks == p - 1) {  			kase = 1;  		}  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  						vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  						vmatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  						umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  						umatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0) {  					shift = -shift;  				}  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = EncogMath.Hypot (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k) {  					e [j - 1] = t;  				}  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  						vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  						vmatrix [i] [j] = t;  					}  				}  				t = EncogMath.Hypot (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  						umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  						umatrix [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv) {  					for (int i = 0; i <= pp; i++) {  						vmatrix [i] [k] = -vmatrix [i] [k];  					}  				}  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1]) {  					break;  				}  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1)) {  					for (int i = 0; i < n; i++) {  						t = vmatrix [i] [k + 1];  						vmatrix [i] [k + 1] = vmatrix [i] [k];  						vmatrix [i] [k] = t;  					}  				}  				if (wantu && (k < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = umatrix [i] [k + 1];  						umatrix [i] [k + 1] = umatrix [i] [k];  						umatrix [i] [k] = t;  					}  				}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays. On  	// completion the variables kase and k are set as follows.  	// kase = 1 if s(p) and e[k-1] are negligible and k<p  	// kase = 2 if s(k) is negligible and k<p  	// kase = 3 if e[k-1] is negligible' k<p' and  	// s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4 if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1) {  			break;  		}  		if (Math.Abs (e [k]) <= tiny + eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k) {  				break;  			}  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= tiny + eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k) {  			kase = 3;  		}  		else if (ks == p - 1) {  			kase = 1;  		}  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  						vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  						vmatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  						umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  						umatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0) {  					shift = -shift;  				}  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = EncogMath.Hypot (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k) {  					e [j - 1] = t;  				}  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  						vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  						vmatrix [i] [j] = t;  					}  				}  				t = EncogMath.Hypot (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  						umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  						umatrix [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv) {  					for (int i = 0; i <= pp; i++) {  						vmatrix [i] [k] = -vmatrix [i] [k];  					}  				}  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1]) {  					break;  				}  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1)) {  					for (int i = 0; i < n; i++) {  						t = vmatrix [i] [k + 1];  						vmatrix [i] [k + 1] = vmatrix [i] [k];  						vmatrix [i] [k] = t;  					}  				}  				if (wantu && (k < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = umatrix [i] [k + 1];  						umatrix [i] [k + 1] = umatrix [i] [k];  						umatrix [i] [k] = t;  					}  				}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays. On  	// completion the variables kase and k are set as follows.  	// kase = 1 if s(p) and e[k-1] are negligible and k<p  	// kase = 2 if s(k) is negligible and k<p  	// kase = 3 if e[k-1] is negligible' k<p' and  	// s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4 if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1) {  			break;  		}  		if (Math.Abs (e [k]) <= tiny + eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k) {  				break;  			}  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= tiny + eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k) {  			kase = 3;  		}  		else if (ks == p - 1) {  			kase = 1;  		}  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  						vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  						vmatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  						umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  						umatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0) {  					shift = -shift;  				}  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = EncogMath.Hypot (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k) {  					e [j - 1] = t;  				}  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  						vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  						vmatrix [i] [j] = t;  					}  				}  				t = EncogMath.Hypot (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  						umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  						umatrix [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv) {  					for (int i = 0; i <= pp; i++) {  						vmatrix [i] [k] = -vmatrix [i] [k];  					}  				}  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1]) {  					break;  				}  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1)) {  					for (int i = 0; i < n; i++) {  						t = vmatrix [i] [k + 1];  						vmatrix [i] [k + 1] = vmatrix [i] [k];  						vmatrix [i] [k] = t;  					}  				}  				if (wantu && (k < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = umatrix [i] [k + 1];  						umatrix [i] [k + 1] = umatrix [i] [k];  						umatrix [i] [k] = t;  					}  				}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays. On  	// completion the variables kase and k are set as follows.  	// kase = 1 if s(p) and e[k-1] are negligible and k<p  	// kase = 2 if s(k) is negligible and k<p  	// kase = 3 if e[k-1] is negligible' k<p' and  	// s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4 if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1) {  			break;  		}  		if (Math.Abs (e [k]) <= tiny + eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k) {  				break;  			}  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= tiny + eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k) {  			kase = 3;  		}  		else if (ks == p - 1) {  			kase = 1;  		}  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  						vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  						vmatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  						umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  						umatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0) {  					shift = -shift;  				}  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = EncogMath.Hypot (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k) {  					e [j - 1] = t;  				}  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  						vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  						vmatrix [i] [j] = t;  					}  				}  				t = EncogMath.Hypot (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  						umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  						umatrix [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv) {  					for (int i = 0; i <= pp; i++) {  						vmatrix [i] [k] = -vmatrix [i] [k];  					}  				}  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1]) {  					break;  				}  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1)) {  					for (int i = 0; i < n; i++) {  						t = vmatrix [i] [k + 1];  						vmatrix [i] [k + 1] = vmatrix [i] [k];  						vmatrix [i] [k] = t;  					}  				}  				if (wantu && (k < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = umatrix [i] [k + 1];  						umatrix [i] [k + 1] = umatrix [i] [k];  						umatrix [i] [k] = t;  					}  				}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays. On  	// completion the variables kase and k are set as follows.  	// kase = 1 if s(p) and e[k-1] are negligible and k<p  	// kase = 2 if s(k) is negligible and k<p  	// kase = 3 if e[k-1] is negligible' k<p' and  	// s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4 if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1) {  			break;  		}  		if (Math.Abs (e [k]) <= tiny + eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k) {  				break;  			}  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= tiny + eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k) {  			kase = 3;  		}  		else if (ks == p - 1) {  			kase = 1;  		}  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  						vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  						vmatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  						umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  						umatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0) {  					shift = -shift;  				}  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = EncogMath.Hypot (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k) {  					e [j - 1] = t;  				}  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  						vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  						vmatrix [i] [j] = t;  					}  				}  				t = EncogMath.Hypot (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  						umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  						umatrix [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv) {  					for (int i = 0; i <= pp; i++) {  						vmatrix [i] [k] = -vmatrix [i] [k];  					}  				}  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1]) {  					break;  				}  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1)) {  					for (int i = 0; i < n; i++) {  						t = vmatrix [i] [k + 1];  						vmatrix [i] [k + 1] = vmatrix [i] [k];  						vmatrix [i] [k] = t;  					}  				}  				if (wantu && (k < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = umatrix [i] [k + 1];  						umatrix [i] [k + 1] = umatrix [i] [k];  						umatrix [i] [k] = t;  					}  				}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays. On  	// completion the variables kase and k are set as follows.  	// kase = 1 if s(p) and e[k-1] are negligible and k<p  	// kase = 2 if s(k) is negligible and k<p  	// kase = 3 if e[k-1] is negligible' k<p' and  	// s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4 if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1) {  			break;  		}  		if (Math.Abs (e [k]) <= tiny + eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k) {  				break;  			}  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= tiny + eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k) {  			kase = 3;  		}  		else if (ks == p - 1) {  			kase = 1;  		}  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  						vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  						vmatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  						umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  						umatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0) {  					shift = -shift;  				}  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = EncogMath.Hypot (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k) {  					e [j - 1] = t;  				}  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  						vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  						vmatrix [i] [j] = t;  					}  				}  				t = EncogMath.Hypot (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  						umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  						umatrix [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv) {  					for (int i = 0; i <= pp; i++) {  						vmatrix [i] [k] = -vmatrix [i] [k];  					}  				}  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1]) {  					break;  				}  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1)) {  					for (int i = 0; i < n; i++) {  						t = vmatrix [i] [k + 1];  						vmatrix [i] [k + 1] = vmatrix [i] [k];  						vmatrix [i] [k] = t;  					}  				}  				if (wantu && (k < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = umatrix [i] [k + 1];  						umatrix [i] [k + 1] = umatrix [i] [k];  						umatrix [i] [k] = t;  					}  				}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays. On  	// completion the variables kase and k are set as follows.  	// kase = 1 if s(p) and e[k-1] are negligible and k<p  	// kase = 2 if s(k) is negligible and k<p  	// kase = 3 if e[k-1] is negligible' k<p' and  	// s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4 if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1) {  			break;  		}  		if (Math.Abs (e [k]) <= tiny + eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k) {  				break;  			}  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= tiny + eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k) {  			kase = 3;  		}  		else if (ks == p - 1) {  			kase = 1;  		}  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  						vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  						vmatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  						umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  						umatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0) {  					shift = -shift;  				}  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = EncogMath.Hypot (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k) {  					e [j - 1] = t;  				}  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  						vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  						vmatrix [i] [j] = t;  					}  				}  				t = EncogMath.Hypot (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  						umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  						umatrix [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv) {  					for (int i = 0; i <= pp; i++) {  						vmatrix [i] [k] = -vmatrix [i] [k];  					}  				}  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1]) {  					break;  				}  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1)) {  					for (int i = 0; i < n; i++) {  						t = vmatrix [i] [k + 1];  						vmatrix [i] [k + 1] = vmatrix [i] [k];  						vmatrix [i] [k] = t;  					}  				}  				if (wantu && (k < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = umatrix [i] [k + 1];  						umatrix [i] [k + 1] = umatrix [i] [k];  						umatrix [i] [k] = t;  					}  				}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays. On  	// completion the variables kase and k are set as follows.  	// kase = 1 if s(p) and e[k-1] are negligible and k<p  	// kase = 2 if s(k) is negligible and k<p  	// kase = 3 if e[k-1] is negligible' k<p' and  	// s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4 if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1) {  			break;  		}  		if (Math.Abs (e [k]) <= tiny + eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k) {  				break;  			}  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= tiny + eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k) {  			kase = 3;  		}  		else if (ks == p - 1) {  			kase = 1;  		}  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  						vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  						vmatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  						umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  						umatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0) {  					shift = -shift;  				}  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = EncogMath.Hypot (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k) {  					e [j - 1] = t;  				}  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  						vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  						vmatrix [i] [j] = t;  					}  				}  				t = EncogMath.Hypot (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  						umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  						umatrix [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv) {  					for (int i = 0; i <= pp; i++) {  						vmatrix [i] [k] = -vmatrix [i] [k];  					}  				}  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1]) {  					break;  				}  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1)) {  					for (int i = 0; i < n; i++) {  						t = vmatrix [i] [k + 1];  						vmatrix [i] [k + 1] = vmatrix [i] [k];  						vmatrix [i] [k] = t;  					}  				}  				if (wantu && (k < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = umatrix [i] [k + 1];  						umatrix [i] [k + 1] = umatrix [i] [k];  						umatrix [i] [k] = t;  					}  				}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays. On  	// completion the variables kase and k are set as follows.  	// kase = 1 if s(p) and e[k-1] are negligible and k<p  	// kase = 2 if s(k) is negligible and k<p  	// kase = 3 if e[k-1] is negligible' k<p' and  	// s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4 if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1) {  			break;  		}  		if (Math.Abs (e [k]) <= tiny + eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k) {  				break;  			}  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= tiny + eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k) {  			kase = 3;  		}  		else if (ks == p - 1) {  			kase = 1;  		}  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  						vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  						vmatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = EncogMath.Hypot (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  						umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  						umatrix [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0) {  					shift = -shift;  				}  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = EncogMath.Hypot (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k) {  					e [j - 1] = t;  				}  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  						vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  						vmatrix [i] [j] = t;  					}  				}  				t = EncogMath.Hypot (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  						umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  						umatrix [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv) {  					for (int i = 0; i <= pp; i++) {  						vmatrix [i] [k] = -vmatrix [i] [k];  					}  				}  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1]) {  					break;  				}  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1)) {  					for (int i = 0; i < n; i++) {  						t = vmatrix [i] [k + 1];  						vmatrix [i] [k + 1] = vmatrix [i] [k];  						vmatrix [i] [k] = t;  					}  				}  				if (wantu && (k < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = umatrix [i] [k + 1];  						umatrix [i] [k + 1] = umatrix [i] [k];  						umatrix [i] [k] = t;  					}  				}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: for (k = p - 2; k >= -1; k--) {  	if (k == -1) {  		break;  	}  	if (Math.Abs (e [k]) <= tiny + eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  		e [k] = 0.0;  		break;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: k = p - 2
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: if (k == p - 2) {  	kase = 4;  }  else {  	int ks;  	for (ks = p - 1; ks >= k; ks--) {  		if (ks == k) {  			break;  		}  		double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  		if (Math.Abs (s [ks]) <= tiny + eps * t) {  			s [ks] = 0.0;  			break;  		}  	}  	if (ks == k) {  		kase = 3;  	}  	else if (ks == p - 1) {  		kase = 1;  	}  	else {  		kase = 2;  		k = ks;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: if (k == p - 2) {  	kase = 4;  }  else {  	int ks;  	for (ks = p - 1; ks >= k; ks--) {  		if (ks == k) {  			break;  		}  		double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  		if (Math.Abs (s [ks]) <= tiny + eps * t) {  			s [ks] = 0.0;  			break;  		}  	}  	if (ks == k) {  		kase = 3;  	}  	else if (ks == p - 1) {  		kase = 1;  	}  	else {  		kase = 2;  		k = ks;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: if (k == p - 2) {  	kase = 4;  }  else {  	int ks;  	for (ks = p - 1; ks >= k; ks--) {  		if (ks == k) {  			break;  		}  		double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  		if (Math.Abs (s [ks]) <= tiny + eps * t) {  			s [ks] = 0.0;  			break;  		}  	}  	if (ks == k) {  		kase = 3;  	}  	else if (ks == p - 1) {  		kase = 1;  	}  	else {  		kase = 2;  		k = ks;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: if (k == p - 2) {  	kase = 4;  }  else {  	int ks;  	for (ks = p - 1; ks >= k; ks--) {  		if (ks == k) {  			break;  		}  		double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  		if (Math.Abs (s [ks]) <= tiny + eps * t) {  			s [ks] = 0.0;  			break;  		}  	}  	if (ks == k) {  		kase = 3;  	}  	else if (ks == p - 1) {  		kase = 1;  	}  	else {  		kase = 2;  		k = ks;  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: kase = 4;  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: if (ks == k) {  	kase = 3;  }  else if (ks == p - 1) {  	kase = 1;  }  else {  	kase = 2;  	k = ks;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: if (ks == k) {  	kase = 3;  }  else if (ks == p - 1) {  	kase = 1;  }  else {  	kase = 2;  	k = ks;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: kase = 3;  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: if (ks == p - 1) {  	kase = 1;  }  else {  	kase = 2;  	k = ks;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: kase = 2;  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  					vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  					vmatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  					umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  					umatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0) {  				shift = -shift;  			}  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = EncogMath.Hypot (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k) {  				e [j - 1] = t;  			}  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  					vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  					vmatrix [i] [j] = t;  				}  			}  			t = EncogMath.Hypot (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  					umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  					umatrix [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv) {  				for (int i = 0; i <= pp; i++) {  					vmatrix [i] [k] = -vmatrix [i] [k];  				}  			}  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1]) {  				break;  			}  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1)) {  				for (int i = 0; i < n; i++) {  					t = vmatrix [i] [k + 1];  					vmatrix [i] [k + 1] = vmatrix [i] [k];  					vmatrix [i] [k] = t;  				}  			}  			if (wantu && (k < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = umatrix [i] [k + 1];  					umatrix [i] [k + 1] = umatrix [i] [k];  					umatrix [i] [k] = t;  				}  			}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  					vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  					vmatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  					umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  					umatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0) {  				shift = -shift;  			}  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = EncogMath.Hypot (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k) {  				e [j - 1] = t;  			}  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  					vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  					vmatrix [i] [j] = t;  				}  			}  			t = EncogMath.Hypot (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  					umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  					umatrix [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv) {  				for (int i = 0; i <= pp; i++) {  					vmatrix [i] [k] = -vmatrix [i] [k];  				}  			}  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1]) {  				break;  			}  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1)) {  				for (int i = 0; i < n; i++) {  					t = vmatrix [i] [k + 1];  					vmatrix [i] [k + 1] = vmatrix [i] [k];  					vmatrix [i] [k] = t;  				}  			}  			if (wantu && (k < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = umatrix [i] [k + 1];  					umatrix [i] [k + 1] = umatrix [i] [k];  					umatrix [i] [k] = t;  				}  			}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  					vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  					vmatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  					umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  					umatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0) {  				shift = -shift;  			}  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = EncogMath.Hypot (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k) {  				e [j - 1] = t;  			}  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  					vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  					vmatrix [i] [j] = t;  				}  			}  			t = EncogMath.Hypot (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  					umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  					umatrix [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv) {  				for (int i = 0; i <= pp; i++) {  					vmatrix [i] [k] = -vmatrix [i] [k];  				}  			}  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1]) {  				break;  			}  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1)) {  				for (int i = 0; i < n; i++) {  					t = vmatrix [i] [k + 1];  					vmatrix [i] [k + 1] = vmatrix [i] [k];  					vmatrix [i] [k] = t;  				}  			}  			if (wantu && (k < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = umatrix [i] [k + 1];  					umatrix [i] [k + 1] = umatrix [i] [k];  					umatrix [i] [k] = t;  				}  			}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  					vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  					vmatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  					umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  					umatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0) {  				shift = -shift;  			}  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = EncogMath.Hypot (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k) {  				e [j - 1] = t;  			}  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  					vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  					vmatrix [i] [j] = t;  				}  			}  			t = EncogMath.Hypot (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  					umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  					umatrix [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv) {  				for (int i = 0; i <= pp; i++) {  					vmatrix [i] [k] = -vmatrix [i] [k];  				}  			}  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1]) {  				break;  			}  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1)) {  				for (int i = 0; i < n; i++) {  					t = vmatrix [i] [k + 1];  					vmatrix [i] [k + 1] = vmatrix [i] [k];  					vmatrix [i] [k] = t;  				}  			}  			if (wantu && (k < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = umatrix [i] [k + 1];  					umatrix [i] [k + 1] = umatrix [i] [k];  					umatrix [i] [k] = t;  				}  			}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  					vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  					vmatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  					umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  					umatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0) {  				shift = -shift;  			}  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = EncogMath.Hypot (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k) {  				e [j - 1] = t;  			}  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  					vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  					vmatrix [i] [j] = t;  				}  			}  			t = EncogMath.Hypot (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  					umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  					umatrix [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv) {  				for (int i = 0; i <= pp; i++) {  					vmatrix [i] [k] = -vmatrix [i] [k];  				}  			}  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1]) {  				break;  			}  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1)) {  				for (int i = 0; i < n; i++) {  					t = vmatrix [i] [k + 1];  					vmatrix [i] [k + 1] = vmatrix [i] [k];  					vmatrix [i] [k] = t;  				}  			}  			if (wantu && (k < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = umatrix [i] [k + 1];  					umatrix [i] [k + 1] = umatrix [i] [k];  					umatrix [i] [k] = t;  				}  			}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  					vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  					vmatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  					umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  					umatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0) {  				shift = -shift;  			}  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = EncogMath.Hypot (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k) {  				e [j - 1] = t;  			}  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  					vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  					vmatrix [i] [j] = t;  				}  			}  			t = EncogMath.Hypot (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  					umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  					umatrix [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv) {  				for (int i = 0; i <= pp; i++) {  					vmatrix [i] [k] = -vmatrix [i] [k];  				}  			}  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1]) {  				break;  			}  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1)) {  				for (int i = 0; i < n; i++) {  					t = vmatrix [i] [k + 1];  					vmatrix [i] [k + 1] = vmatrix [i] [k];  					vmatrix [i] [k] = t;  				}  			}  			if (wantu && (k < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = umatrix [i] [k + 1];  					umatrix [i] [k + 1] = umatrix [i] [k];  					umatrix [i] [k] = t;  				}  			}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  					vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  					vmatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  					umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  					umatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0) {  				shift = -shift;  			}  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = EncogMath.Hypot (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k) {  				e [j - 1] = t;  			}  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  					vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  					vmatrix [i] [j] = t;  				}  			}  			t = EncogMath.Hypot (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  					umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  					umatrix [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv) {  				for (int i = 0; i <= pp; i++) {  					vmatrix [i] [k] = -vmatrix [i] [k];  				}  			}  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1]) {  				break;  			}  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1)) {  				for (int i = 0; i < n; i++) {  					t = vmatrix [i] [k + 1];  					vmatrix [i] [k + 1] = vmatrix [i] [k];  					vmatrix [i] [k] = t;  				}  			}  			if (wantu && (k < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = umatrix [i] [k + 1];  					umatrix [i] [k + 1] = umatrix [i] [k];  					umatrix [i] [k] = t;  				}  			}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  					vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  					vmatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  					umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  					umatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0) {  				shift = -shift;  			}  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = EncogMath.Hypot (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k) {  				e [j - 1] = t;  			}  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  					vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  					vmatrix [i] [j] = t;  				}  			}  			t = EncogMath.Hypot (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  					umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  					umatrix [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv) {  				for (int i = 0; i <= pp; i++) {  					vmatrix [i] [k] = -vmatrix [i] [k];  				}  			}  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1]) {  				break;  			}  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1)) {  				for (int i = 0; i < n; i++) {  					t = vmatrix [i] [k + 1];  					vmatrix [i] [k + 1] = vmatrix [i] [k];  					vmatrix [i] [k] = t;  				}  			}  			if (wantu && (k < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = umatrix [i] [k + 1];  					umatrix [i] [k + 1] = umatrix [i] [k];  					umatrix [i] [k] = t;  				}  			}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  					vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  					vmatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  					umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  					umatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0) {  				shift = -shift;  			}  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = EncogMath.Hypot (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k) {  				e [j - 1] = t;  			}  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  					vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  					vmatrix [i] [j] = t;  				}  			}  			t = EncogMath.Hypot (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  					umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  					umatrix [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv) {  				for (int i = 0; i <= pp; i++) {  					vmatrix [i] [k] = -vmatrix [i] [k];  				}  			}  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1]) {  				break;  			}  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1)) {  				for (int i = 0; i < n; i++) {  					t = vmatrix [i] [k + 1];  					vmatrix [i] [k + 1] = vmatrix [i] [k];  					vmatrix [i] [k] = t;  				}  			}  			if (wantu && (k < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = umatrix [i] [k + 1];  					umatrix [i] [k + 1] = umatrix [i] [k];  					umatrix [i] [k] = t;  				}  			}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  					vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  					vmatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  					umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  					umatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0) {  				shift = -shift;  			}  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = EncogMath.Hypot (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k) {  				e [j - 1] = t;  			}  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  					vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  					vmatrix [i] [j] = t;  				}  			}  			t = EncogMath.Hypot (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  					umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  					umatrix [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv) {  				for (int i = 0; i <= pp; i++) {  					vmatrix [i] [k] = -vmatrix [i] [k];  				}  			}  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1]) {  				break;  			}  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1)) {  				for (int i = 0; i < n; i++) {  					t = vmatrix [i] [k + 1];  					vmatrix [i] [k + 1] = vmatrix [i] [k];  					vmatrix [i] [k] = t;  				}  			}  			if (wantu && (k < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = umatrix [i] [k + 1];  					umatrix [i] [k + 1] = umatrix [i] [k];  					umatrix [i] [k] = t;  				}  			}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  					vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  					vmatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  					umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  					umatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0) {  				shift = -shift;  			}  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = EncogMath.Hypot (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k) {  				e [j - 1] = t;  			}  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  					vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  					vmatrix [i] [j] = t;  				}  			}  			t = EncogMath.Hypot (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  					umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  					umatrix [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv) {  				for (int i = 0; i <= pp; i++) {  					vmatrix [i] [k] = -vmatrix [i] [k];  				}  			}  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1]) {  				break;  			}  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1)) {  				for (int i = 0; i < n; i++) {  					t = vmatrix [i] [k + 1];  					vmatrix [i] [k + 1] = vmatrix [i] [k];  					vmatrix [i] [k] = t;  				}  			}  			if (wantu && (k < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = umatrix [i] [k + 1];  					umatrix [i] [k + 1] = umatrix [i] [k];  					umatrix [i] [k] = t;  				}  			}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  					vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  					vmatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  					umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  					umatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0) {  				shift = -shift;  			}  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = EncogMath.Hypot (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k) {  				e [j - 1] = t;  			}  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  					vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  					vmatrix [i] [j] = t;  				}  			}  			t = EncogMath.Hypot (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  					umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  					umatrix [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv) {  				for (int i = 0; i <= pp; i++) {  					vmatrix [i] [k] = -vmatrix [i] [k];  				}  			}  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1]) {  				break;  			}  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1)) {  				for (int i = 0; i < n; i++) {  					t = vmatrix [i] [k + 1];  					vmatrix [i] [k + 1] = vmatrix [i] [k];  					vmatrix [i] [k] = t;  				}  			}  			if (wantu && (k < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = umatrix [i] [k + 1];  					umatrix [i] [k + 1] = umatrix [i] [k];  					umatrix [i] [k] = t;  				}  			}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: e [p - 2] = 0.0;  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: for (int j = p - 2; j >= k; j--) {  	double t = EncogMath.Hypot (s [j]' f);  	double cs = s [j] / t;  	double sn = f / t;  	s [j] = t;  	if (j != k) {  		f = -sn * e [j - 1];  		e [j - 1] = cs * e [j - 1];  	}  	if (wantv) {  		for (int i = 0; i < n; i++) {  			t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  			vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  			vmatrix [i] [j] = t;  		}  	}  }  
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: e [p - 2] = f;  
Magic Number,Encog.MathUtil.Matrices.Hessian,BasicHessian,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Hessian\BasicHessian.cs,UpdateHessian,The following statement contains a magic number: for (int i = 0; i < weightCount; i++) {  	for (int j = 0; j < weightCount; j++) {  		hessian [i] [j] += 2 * d [i] * d [j];  	}  }  
Magic Number,Encog.MathUtil.Matrices.Hessian,BasicHessian,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Hessian\BasicHessian.cs,UpdateHessian,The following statement contains a magic number: for (int j = 0; j < weightCount; j++) {  	hessian [i] [j] += 2 * d [i] * d [j];  }  
Magic Number,Encog.MathUtil.Matrices.Hessian,BasicHessian,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Hessian\BasicHessian.cs,UpdateHessian,The following statement contains a magic number: hessian [i] [j] += 2 * d [i] * d [j];  
Magic Number,Encog.MathUtil.Matrices.Hessian,HessianCR,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Hessian\HessianCR.cs,Compute,The following statement contains a magic number: sse = e / 2;  
Magic Number,Encog.MathUtil.Matrices.Hessian,HessianFD,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Hessian\HessianFD.cs,Init,The following statement contains a magic number: _pointCount = (_pointsPerSide * 2) + 1;  
Magic Number,Encog.MathUtil.Matrices.Hessian,HessianFD,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Hessian\HessianFD.cs,InternalCompute,The following statement contains a magic number: foreach (var pair in training) {  	var networkOutput = network.Compute (pair.Input);  	double e = pair.Ideal.Data [outputNeuron] - networkOutput [outputNeuron];  	error.UpdateError (networkOutput [outputNeuron]' pair.Ideal [outputNeuron]);  	int currentWeight = 0;  	// loop over the output weights  	int outputFeedCount = network.GetLayerTotalNeuronCount (network.LayerCount - 2);  	for (int i = 0; i < network.OutputCount; i++) {  		for (int j = 0; j < outputFeedCount; j++) {  			double jc;  			if (i == outputNeuron) {  				jc = ComputeDerivative (pair.Input' outputNeuron' currentWeight' _dStep' networkOutput [outputNeuron]' row);  			}  			else {  				jc = 0;  			}  			gradients [currentWeight] += jc * e;  			derivative [currentWeight] += jc;  			currentWeight++;  		}  	}  	// Loop over every weight in the neural network  	while (currentWeight < network.Flat.Weights.Length) {  		double jc = ComputeDerivative (pair.Input' outputNeuron' currentWeight' _dStep' networkOutput [outputNeuron]' row);  		derivative [currentWeight] += jc;  		gradients [currentWeight] += jc * e;  		currentWeight++;  	}  	row++;  }  
Magic Number,Encog.MathUtil.Randomize,BasicRandomizer,C:\repos\neismit_emds\encog-core-cs\MathUtil\Randomize\BasicRandomizer.cs,BasicRandomizer,The following statement contains a magic number: _random = new Random ((int)(DateTime.Now.Ticks * 100));  
Magic Number,Encog.MathUtil.Randomize,Distort,C:\repos\neismit_emds\encog-core-cs\MathUtil\Randomize\Distort.cs,Randomize,The following statement contains a magic number: return d + (_factor - (NextDouble () * _factor * 2));  
Magic Number,Encog.MathUtil.RBF,InverseMultiquadricFunction,C:\repos\neismit_emds\encog-core-cs\MathUtil\RBF\InverseMultiquadricFunction.cs,Calculate,The following statement contains a magic number: for (int i = 0; i < center.Length; i++) {  	value += Math.Pow (x [i] - center [i]' 2) + (width * width);  }  
Magic Number,Encog.MathUtil.RBF,InverseMultiquadricFunction,C:\repos\neismit_emds\encog-core-cs\MathUtil\RBF\InverseMultiquadricFunction.cs,Calculate,The following statement contains a magic number: value += Math.Pow (x [i] - center [i]' 2) + (width * width);  
Magic Number,Encog.MathUtil.RBF,MexicanHatFunction,C:\repos\neismit_emds\encog-core-cs\MathUtil\RBF\MexicanHatFunction.cs,Calculate,The following statement contains a magic number: for (int i = 0; i < center.Length; i++) {  	norm += Math.Pow (x [i] - center [i]' 2);  }  
Magic Number,Encog.MathUtil.RBF,MexicanHatFunction,C:\repos\neismit_emds\encog-core-cs\MathUtil\RBF\MexicanHatFunction.cs,Calculate,The following statement contains a magic number: norm += Math.Pow (x [i] - center [i]' 2);  
Magic Number,Encog.MathUtil.RBF,MexicanHatFunction,C:\repos\neismit_emds\encog-core-cs\MathUtil\RBF\MexicanHatFunction.cs,Calculate,The following statement contains a magic number: return Peak * (1 - norm) * Math.Exp (-norm / 2);  
Magic Number,Encog.MathUtil.RBF,MultiquadricFunction,C:\repos\neismit_emds\encog-core-cs\MathUtil\RBF\MultiquadricFunction.cs,Calculate,The following statement contains a magic number: for (int i = 0; i < center.Length; i++) {  	value += Math.Pow (x [i] - center [i]' 2) + (width * width);  }  
Magic Number,Encog.MathUtil.RBF,MultiquadricFunction,C:\repos\neismit_emds\encog-core-cs\MathUtil\RBF\MultiquadricFunction.cs,Calculate,The following statement contains a magic number: value += Math.Pow (x [i] - center [i]' 2) + (width * width);  
Magic Number,Encog.MathUtil.RBF,GaussianFunction,C:\repos\neismit_emds\encog-core-cs\MathUtil\RBF\GaussianFunction.cs,Calculate,The following statement contains a magic number: for (int i = 0; i < center.Length; i++) {  	value += Math.Pow (x [i] - center [i]' 2) / (2.0 * width * width);  }  
Magic Number,Encog.MathUtil.RBF,GaussianFunction,C:\repos\neismit_emds\encog-core-cs\MathUtil\RBF\GaussianFunction.cs,Calculate,The following statement contains a magic number: for (int i = 0; i < center.Length; i++) {  	value += Math.Pow (x [i] - center [i]' 2) / (2.0 * width * width);  }  
Magic Number,Encog.MathUtil.RBF,GaussianFunction,C:\repos\neismit_emds\encog-core-cs\MathUtil\RBF\GaussianFunction.cs,Calculate,The following statement contains a magic number: value += Math.Pow (x [i] - center [i]' 2) / (2.0 * width * width);  
Magic Number,Encog.MathUtil.RBF,GaussianFunction,C:\repos\neismit_emds\encog-core-cs\MathUtil\RBF\GaussianFunction.cs,Calculate,The following statement contains a magic number: value += Math.Pow (x [i] - center [i]' 2) / (2.0 * width * width);  
Magic Number,Encog.ML.Bayesian,BayesianChoice,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\BayesianChoice.cs,ToFullString,The following statement contains a magic number: if (!IsIndex) {  	result.Append (":");  	result.Append (CSVFormat.EgFormat.Format (Min' 4));  	result.Append (" to ");  	result.Append (CSVFormat.EgFormat.Format (Max' 4));  }  
Magic Number,Encog.ML.Bayesian,BayesianChoice,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\BayesianChoice.cs,ToFullString,The following statement contains a magic number: if (!IsIndex) {  	result.Append (":");  	result.Append (CSVFormat.EgFormat.Format (Min' 4));  	result.Append (" to ");  	result.Append (CSVFormat.EgFormat.Format (Max' 4));  }  
Magic Number,Encog.ML.Bayesian,BayesianChoice,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\BayesianChoice.cs,ToFullString,The following statement contains a magic number: result.Append (CSVFormat.EgFormat.Format (Min' 4));  
Magic Number,Encog.ML.Bayesian,BayesianChoice,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\BayesianChoice.cs,ToFullString,The following statement contains a magic number: result.Append (CSVFormat.EgFormat.Format (Max' 4));  
Magic Number,Encog.ML.Bayesian.Parse,ParseProbability,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Parse\ParseProbability.cs,AddEvents,The following statement contains a magic number: while (!done && !parser.EOL ()) {  	char ch = parser.Peek ();  	if (delim.IndexOf (ch) != -1) {  		if (ch == ')' || ch == '|')  			done = true;  		ParsedEvent parsedEvent;  		// deal with a value specified by + or -  		if (l.Length > 0 && l [0] == '+') {  			String l2 = l.ToString ().Substring (1);  			parsedEvent = new ParsedEvent (l2.Trim ());  			parsedEvent.Value = "true";  		}  		else if (l.Length > 0 && l [0] == '-') {  			String l2 = l.ToString ().Substring (1);  			parsedEvent = new ParsedEvent (l2.Trim ());  			parsedEvent.Value = "false";  		}  		else {  			String l2 = l.ToString ();  			parsedEvent = new ParsedEvent (l2.Trim ());  		}  		// parse choices  		if (ch == '[') {  			parser.Advance ();  			int index = 0;  			while (ch != ']' && !parser.EOL ()) {  				String labelName = parser.ReadToChars (":']");  				if (parser.Peek () == ':') {  					parser.Advance ();  					parser.EatWhiteSpace ();  					double min = double.Parse (parser.ReadToWhiteSpace ());  					parser.EatWhiteSpace ();  					if (!parser.LookAhead ("to"' true)) {  						throw new BayesianError ("Expected \"to\" in probability choice range.");  					}  					parser.Advance (2);  					double max = CSVFormat.EgFormat.Parse (parser.ReadToChars ("']"));  					parsedEvent.ChoiceList.Add (new ParsedChoice (labelName' min' max));  				}  				else {  					parsedEvent.ChoiceList.Add (new ParsedChoice (labelName' index++));  				}  				parser.EatWhiteSpace ();  				ch = parser.Peek ();  				if (ch == ''') {  					parser.Advance ();  				}  			}  		}  		// deal with a value specified by =  		if (parser.Peek () == '=') {  			parser.ReadChar ();  			String value = parser.ReadToChars (delim);  			//					BayesianEvent evt = this.network.getEvent(parsedEvent.getLabel());  			parsedEvent.Value = value;  		}  		if (ch == ''') {  			parser.Advance ();  		}  		if (ch == ']') {  			parser.Advance ();  		}  		if (parsedEvent.Label.Length > 0) {  			results.Add (parsedEvent);  		}  		l.Length = 0;  	}  	else {  		parser.Advance ();  		l.Append (ch);  	}  }  
Magic Number,Encog.ML.Bayesian.Parse,ParseProbability,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Parse\ParseProbability.cs,AddEvents,The following statement contains a magic number: if (delim.IndexOf (ch) != -1) {  	if (ch == ')' || ch == '|')  		done = true;  	ParsedEvent parsedEvent;  	// deal with a value specified by + or -  	if (l.Length > 0 && l [0] == '+') {  		String l2 = l.ToString ().Substring (1);  		parsedEvent = new ParsedEvent (l2.Trim ());  		parsedEvent.Value = "true";  	}  	else if (l.Length > 0 && l [0] == '-') {  		String l2 = l.ToString ().Substring (1);  		parsedEvent = new ParsedEvent (l2.Trim ());  		parsedEvent.Value = "false";  	}  	else {  		String l2 = l.ToString ();  		parsedEvent = new ParsedEvent (l2.Trim ());  	}  	// parse choices  	if (ch == '[') {  		parser.Advance ();  		int index = 0;  		while (ch != ']' && !parser.EOL ()) {  			String labelName = parser.ReadToChars (":']");  			if (parser.Peek () == ':') {  				parser.Advance ();  				parser.EatWhiteSpace ();  				double min = double.Parse (parser.ReadToWhiteSpace ());  				parser.EatWhiteSpace ();  				if (!parser.LookAhead ("to"' true)) {  					throw new BayesianError ("Expected \"to\" in probability choice range.");  				}  				parser.Advance (2);  				double max = CSVFormat.EgFormat.Parse (parser.ReadToChars ("']"));  				parsedEvent.ChoiceList.Add (new ParsedChoice (labelName' min' max));  			}  			else {  				parsedEvent.ChoiceList.Add (new ParsedChoice (labelName' index++));  			}  			parser.EatWhiteSpace ();  			ch = parser.Peek ();  			if (ch == ''') {  				parser.Advance ();  			}  		}  	}  	// deal with a value specified by =  	if (parser.Peek () == '=') {  		parser.ReadChar ();  		String value = parser.ReadToChars (delim);  		//					BayesianEvent evt = this.network.getEvent(parsedEvent.getLabel());  		parsedEvent.Value = value;  	}  	if (ch == ''') {  		parser.Advance ();  	}  	if (ch == ']') {  		parser.Advance ();  	}  	if (parsedEvent.Label.Length > 0) {  		results.Add (parsedEvent);  	}  	l.Length = 0;  }  else {  	parser.Advance ();  	l.Append (ch);  }  
Magic Number,Encog.ML.Bayesian.Parse,ParseProbability,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Parse\ParseProbability.cs,AddEvents,The following statement contains a magic number: if (ch == '[') {  	parser.Advance ();  	int index = 0;  	while (ch != ']' && !parser.EOL ()) {  		String labelName = parser.ReadToChars (":']");  		if (parser.Peek () == ':') {  			parser.Advance ();  			parser.EatWhiteSpace ();  			double min = double.Parse (parser.ReadToWhiteSpace ());  			parser.EatWhiteSpace ();  			if (!parser.LookAhead ("to"' true)) {  				throw new BayesianError ("Expected \"to\" in probability choice range.");  			}  			parser.Advance (2);  			double max = CSVFormat.EgFormat.Parse (parser.ReadToChars ("']"));  			parsedEvent.ChoiceList.Add (new ParsedChoice (labelName' min' max));  		}  		else {  			parsedEvent.ChoiceList.Add (new ParsedChoice (labelName' index++));  		}  		parser.EatWhiteSpace ();  		ch = parser.Peek ();  		if (ch == ''') {  			parser.Advance ();  		}  	}  }  
Magic Number,Encog.ML.Bayesian.Parse,ParseProbability,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Parse\ParseProbability.cs,AddEvents,The following statement contains a magic number: while (ch != ']' && !parser.EOL ()) {  	String labelName = parser.ReadToChars (":']");  	if (parser.Peek () == ':') {  		parser.Advance ();  		parser.EatWhiteSpace ();  		double min = double.Parse (parser.ReadToWhiteSpace ());  		parser.EatWhiteSpace ();  		if (!parser.LookAhead ("to"' true)) {  			throw new BayesianError ("Expected \"to\" in probability choice range.");  		}  		parser.Advance (2);  		double max = CSVFormat.EgFormat.Parse (parser.ReadToChars ("']"));  		parsedEvent.ChoiceList.Add (new ParsedChoice (labelName' min' max));  	}  	else {  		parsedEvent.ChoiceList.Add (new ParsedChoice (labelName' index++));  	}  	parser.EatWhiteSpace ();  	ch = parser.Peek ();  	if (ch == ''') {  		parser.Advance ();  	}  }  
Magic Number,Encog.ML.Bayesian.Parse,ParseProbability,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Parse\ParseProbability.cs,AddEvents,The following statement contains a magic number: if (parser.Peek () == ':') {  	parser.Advance ();  	parser.EatWhiteSpace ();  	double min = double.Parse (parser.ReadToWhiteSpace ());  	parser.EatWhiteSpace ();  	if (!parser.LookAhead ("to"' true)) {  		throw new BayesianError ("Expected \"to\" in probability choice range.");  	}  	parser.Advance (2);  	double max = CSVFormat.EgFormat.Parse (parser.ReadToChars ("']"));  	parsedEvent.ChoiceList.Add (new ParsedChoice (labelName' min' max));  }  else {  	parsedEvent.ChoiceList.Add (new ParsedChoice (labelName' index++));  }  
Magic Number,Encog.ML.Bayesian.Parse,ParseProbability,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Parse\ParseProbability.cs,AddEvents,The following statement contains a magic number: parser.Advance (2);  
Magic Number,Encog.ML.Bayesian.Parse,ParseProbability,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Parse\ParseProbability.cs,Parse,The following statement contains a magic number: parser.Advance (2);  
Magic Number,Encog.ML.Bayesian.Query,EventState,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Query\EventState.cs,ToString,The following statement contains a magic number: result.Append (Format.FormatDouble (_value' 2));  
Magic Number,Encog.ML.Bayesian.Query,EventState,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Query\EventState.cs,ToString,The following statement contains a magic number: result.Append (Format.FormatDouble (CompareValue' 2));  
Magic Number,Encog.ML.Bayesian.Table,TableLine,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Table\TableLine.cs,ToString,The following statement contains a magic number: r.Append (Format.FormatDouble (Probability' 2));  
Magic Number,Encog.ML.Bayesian.Table,TableLine,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Table\TableLine.cs,ToString,The following statement contains a magic number: foreach (int t in _arguments) {  	r.Append (Format.FormatDouble (t' 2));  	r.Append (" ");  }  
Magic Number,Encog.ML.Bayesian.Table,TableLine,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Table\TableLine.cs,ToString,The following statement contains a magic number: r.Append (Format.FormatDouble (t' 2));  
Magic Number,Encog.ML.Data.Buffer,BinaryDataLoader,C:\repos\neismit_emds\encog-core-cs\ML\Data\Buffer\BinaryDataLoader.cs,External2Binary,The following statement contains a magic number: while (_codec.Read (input' ideal' ref significance)) {  	egb.Write (input);  	egb.Write (ideal);  	currentRecord++;  	lastUpdate++;  	if (lastUpdate >= 10000) {  		lastUpdate = 0;  		Status.Report (0' currentRecord' "Importing...");  	}  	egb.Write (significance);  }  
Magic Number,Encog.ML.Data.Buffer,BinaryDataLoader,C:\repos\neismit_emds\encog-core-cs\ML\Data\Buffer\BinaryDataLoader.cs,External2Binary,The following statement contains a magic number: if (lastUpdate >= 10000) {  	lastUpdate = 0;  	Status.Report (0' currentRecord' "Importing...");  }  
Magic Number,Encog.ML.Data.Buffer,BinaryDataLoader,C:\repos\neismit_emds\encog-core-cs\ML\Data\Buffer\BinaryDataLoader.cs,Binary2External,The following statement contains a magic number: for (int i = 0; i < egb.NumberOfRecords; i++) {  	for (int j = 0; j < inputCount; j++) {  		input [j] = egb.Read ();  	}  	for (int j = 0; j < idealCount; j++) {  		ideal [j] = egb.Read ();  	}  	double significance = egb.Read ();  	_codec.Write (input' ideal' significance);  	currentRecord++;  	lastUpdate++;  	if (lastUpdate >= 10000) {  		lastUpdate = 0;  		Status.Report (egb.NumberOfRecords' currentRecord' "Exporting...");  	}  }  
Magic Number,Encog.ML.Data.Buffer,BinaryDataLoader,C:\repos\neismit_emds\encog-core-cs\ML\Data\Buffer\BinaryDataLoader.cs,Binary2External,The following statement contains a magic number: if (lastUpdate >= 10000) {  	lastUpdate = 0;  	Status.Report (egb.NumberOfRecords' currentRecord' "Exporting...");  }  
Magic Number,Encog.ML.Data.Buffer,MemoryDataLoader,C:\repos\neismit_emds\encog-core-cs\ML\Data\Buffer\MemoryDataLoader.cs,External2Memory,The following statement contains a magic number: while (_codec.Read (input' ideal' ref significance)) {  	IMLData b = null;  	IMLData a = new BasicMLData (input);  	if (_codec.IdealSize > 0)  		b = new BasicMLData (ideal);  	IMLDataPair pair = new BasicMLDataPair (a' b);  	pair.Significance = significance;  	Result.Add (pair);  	currentRecord++;  	lastUpdate++;  	if (lastUpdate >= 10000) {  		lastUpdate = 0;  		Status.Report (0' currentRecord' "Importing...");  	}  }  
Magic Number,Encog.ML.Data.Buffer,MemoryDataLoader,C:\repos\neismit_emds\encog-core-cs\ML\Data\Buffer\MemoryDataLoader.cs,External2Memory,The following statement contains a magic number: if (lastUpdate >= 10000) {  	lastUpdate = 0;  	Status.Report (0' currentRecord' "Importing...");  }  
Magic Number,Encog.ML.Data.Image,ImageMLData,C:\repos\neismit_emds\encog-core-cs\ML\Data\Image\ImageMLData.cs,Downsample,The following statement contains a magic number: for (int i = 0; i < sample.Length; i++) {  	sample [i] = ((sample [i] - 0) / (255 - 0)) * (hi - lo) + lo;  }  
Magic Number,Encog.ML.Data.Image,ImageMLData,C:\repos\neismit_emds\encog-core-cs\ML\Data\Image\ImageMLData.cs,Downsample,The following statement contains a magic number: sample [i] = ((sample [i] - 0) / (255 - 0)) * (hi - lo) + lo;  
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: while (csv.Next ()) {  	DateTime date = csv.GetDate (0);  	ParsedDate = date;  	if (writeonce) {  		Console.WriteLine (@"First parsed date in csv:" + ParsedDate.ToShortDateString ());  		Console.WriteLine (@"Stopping at date:" + to.ToShortDateString ());  		Console.WriteLine (@"Current DateTime:" + ParsedDate.ToShortDateString () + @" Time:" + ParsedDate.ToShortTimeString () + @"  Asked Start date was " + from.ToShortDateString ());  		writeonce = false;  	}  	if (ParsedDate >= from && ParsedDate <= to) {  		DateTime datex = csv.GetDate (0);  		double open = csv.GetDouble (1);  		double close = csv.GetDouble (2);  		double high = csv.GetDouble (3);  		double low = csv.GetDouble (4);  		double volume = csv.GetDouble (5);  		double range = Math.Abs (open - close);  		double HighLowRange = Math.Abs (high - low);  		double DirectionalRange = close - open;  		LoadedMarketData data = new LoadedMarketData (datex' symbol);  		data.SetData (MarketDataType.Open' open);  		data.SetData (MarketDataType.High' high);  		data.SetData (MarketDataType.Low' low);  		data.SetData (MarketDataType.Close' close);  		data.SetData (MarketDataType.Volume' volume);  		data.SetData (MarketDataType.RangeHighLow' Math.Round (HighLowRange' 6));  		data.SetData (MarketDataType.RangeOpenClose' Math.Round (range' 6));  		data.SetData (MarketDataType.RangeOpenCloseNonAbsolute' Math.Round (DirectionalRange' 6));  		result.Add (data);  	}  }  
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: while (csv.Next ()) {  	DateTime date = csv.GetDate (0);  	ParsedDate = date;  	if (writeonce) {  		Console.WriteLine (@"First parsed date in csv:" + ParsedDate.ToShortDateString ());  		Console.WriteLine (@"Stopping at date:" + to.ToShortDateString ());  		Console.WriteLine (@"Current DateTime:" + ParsedDate.ToShortDateString () + @" Time:" + ParsedDate.ToShortTimeString () + @"  Asked Start date was " + from.ToShortDateString ());  		writeonce = false;  	}  	if (ParsedDate >= from && ParsedDate <= to) {  		DateTime datex = csv.GetDate (0);  		double open = csv.GetDouble (1);  		double close = csv.GetDouble (2);  		double high = csv.GetDouble (3);  		double low = csv.GetDouble (4);  		double volume = csv.GetDouble (5);  		double range = Math.Abs (open - close);  		double HighLowRange = Math.Abs (high - low);  		double DirectionalRange = close - open;  		LoadedMarketData data = new LoadedMarketData (datex' symbol);  		data.SetData (MarketDataType.Open' open);  		data.SetData (MarketDataType.High' high);  		data.SetData (MarketDataType.Low' low);  		data.SetData (MarketDataType.Close' close);  		data.SetData (MarketDataType.Volume' volume);  		data.SetData (MarketDataType.RangeHighLow' Math.Round (HighLowRange' 6));  		data.SetData (MarketDataType.RangeOpenClose' Math.Round (range' 6));  		data.SetData (MarketDataType.RangeOpenCloseNonAbsolute' Math.Round (DirectionalRange' 6));  		result.Add (data);  	}  }  
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: while (csv.Next ()) {  	DateTime date = csv.GetDate (0);  	ParsedDate = date;  	if (writeonce) {  		Console.WriteLine (@"First parsed date in csv:" + ParsedDate.ToShortDateString ());  		Console.WriteLine (@"Stopping at date:" + to.ToShortDateString ());  		Console.WriteLine (@"Current DateTime:" + ParsedDate.ToShortDateString () + @" Time:" + ParsedDate.ToShortTimeString () + @"  Asked Start date was " + from.ToShortDateString ());  		writeonce = false;  	}  	if (ParsedDate >= from && ParsedDate <= to) {  		DateTime datex = csv.GetDate (0);  		double open = csv.GetDouble (1);  		double close = csv.GetDouble (2);  		double high = csv.GetDouble (3);  		double low = csv.GetDouble (4);  		double volume = csv.GetDouble (5);  		double range = Math.Abs (open - close);  		double HighLowRange = Math.Abs (high - low);  		double DirectionalRange = close - open;  		LoadedMarketData data = new LoadedMarketData (datex' symbol);  		data.SetData (MarketDataType.Open' open);  		data.SetData (MarketDataType.High' high);  		data.SetData (MarketDataType.Low' low);  		data.SetData (MarketDataType.Close' close);  		data.SetData (MarketDataType.Volume' volume);  		data.SetData (MarketDataType.RangeHighLow' Math.Round (HighLowRange' 6));  		data.SetData (MarketDataType.RangeOpenClose' Math.Round (range' 6));  		data.SetData (MarketDataType.RangeOpenCloseNonAbsolute' Math.Round (DirectionalRange' 6));  		result.Add (data);  	}  }  
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: while (csv.Next ()) {  	DateTime date = csv.GetDate (0);  	ParsedDate = date;  	if (writeonce) {  		Console.WriteLine (@"First parsed date in csv:" + ParsedDate.ToShortDateString ());  		Console.WriteLine (@"Stopping at date:" + to.ToShortDateString ());  		Console.WriteLine (@"Current DateTime:" + ParsedDate.ToShortDateString () + @" Time:" + ParsedDate.ToShortTimeString () + @"  Asked Start date was " + from.ToShortDateString ());  		writeonce = false;  	}  	if (ParsedDate >= from && ParsedDate <= to) {  		DateTime datex = csv.GetDate (0);  		double open = csv.GetDouble (1);  		double close = csv.GetDouble (2);  		double high = csv.GetDouble (3);  		double low = csv.GetDouble (4);  		double volume = csv.GetDouble (5);  		double range = Math.Abs (open - close);  		double HighLowRange = Math.Abs (high - low);  		double DirectionalRange = close - open;  		LoadedMarketData data = new LoadedMarketData (datex' symbol);  		data.SetData (MarketDataType.Open' open);  		data.SetData (MarketDataType.High' high);  		data.SetData (MarketDataType.Low' low);  		data.SetData (MarketDataType.Close' close);  		data.SetData (MarketDataType.Volume' volume);  		data.SetData (MarketDataType.RangeHighLow' Math.Round (HighLowRange' 6));  		data.SetData (MarketDataType.RangeOpenClose' Math.Round (range' 6));  		data.SetData (MarketDataType.RangeOpenCloseNonAbsolute' Math.Round (DirectionalRange' 6));  		result.Add (data);  	}  }  
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: while (csv.Next ()) {  	DateTime date = csv.GetDate (0);  	ParsedDate = date;  	if (writeonce) {  		Console.WriteLine (@"First parsed date in csv:" + ParsedDate.ToShortDateString ());  		Console.WriteLine (@"Stopping at date:" + to.ToShortDateString ());  		Console.WriteLine (@"Current DateTime:" + ParsedDate.ToShortDateString () + @" Time:" + ParsedDate.ToShortTimeString () + @"  Asked Start date was " + from.ToShortDateString ());  		writeonce = false;  	}  	if (ParsedDate >= from && ParsedDate <= to) {  		DateTime datex = csv.GetDate (0);  		double open = csv.GetDouble (1);  		double close = csv.GetDouble (2);  		double high = csv.GetDouble (3);  		double low = csv.GetDouble (4);  		double volume = csv.GetDouble (5);  		double range = Math.Abs (open - close);  		double HighLowRange = Math.Abs (high - low);  		double DirectionalRange = close - open;  		LoadedMarketData data = new LoadedMarketData (datex' symbol);  		data.SetData (MarketDataType.Open' open);  		data.SetData (MarketDataType.High' high);  		data.SetData (MarketDataType.Low' low);  		data.SetData (MarketDataType.Close' close);  		data.SetData (MarketDataType.Volume' volume);  		data.SetData (MarketDataType.RangeHighLow' Math.Round (HighLowRange' 6));  		data.SetData (MarketDataType.RangeOpenClose' Math.Round (range' 6));  		data.SetData (MarketDataType.RangeOpenCloseNonAbsolute' Math.Round (DirectionalRange' 6));  		result.Add (data);  	}  }  
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: while (csv.Next ()) {  	DateTime date = csv.GetDate (0);  	ParsedDate = date;  	if (writeonce) {  		Console.WriteLine (@"First parsed date in csv:" + ParsedDate.ToShortDateString ());  		Console.WriteLine (@"Stopping at date:" + to.ToShortDateString ());  		Console.WriteLine (@"Current DateTime:" + ParsedDate.ToShortDateString () + @" Time:" + ParsedDate.ToShortTimeString () + @"  Asked Start date was " + from.ToShortDateString ());  		writeonce = false;  	}  	if (ParsedDate >= from && ParsedDate <= to) {  		DateTime datex = csv.GetDate (0);  		double open = csv.GetDouble (1);  		double close = csv.GetDouble (2);  		double high = csv.GetDouble (3);  		double low = csv.GetDouble (4);  		double volume = csv.GetDouble (5);  		double range = Math.Abs (open - close);  		double HighLowRange = Math.Abs (high - low);  		double DirectionalRange = close - open;  		LoadedMarketData data = new LoadedMarketData (datex' symbol);  		data.SetData (MarketDataType.Open' open);  		data.SetData (MarketDataType.High' high);  		data.SetData (MarketDataType.Low' low);  		data.SetData (MarketDataType.Close' close);  		data.SetData (MarketDataType.Volume' volume);  		data.SetData (MarketDataType.RangeHighLow' Math.Round (HighLowRange' 6));  		data.SetData (MarketDataType.RangeOpenClose' Math.Round (range' 6));  		data.SetData (MarketDataType.RangeOpenCloseNonAbsolute' Math.Round (DirectionalRange' 6));  		result.Add (data);  	}  }  
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: while (csv.Next ()) {  	DateTime date = csv.GetDate (0);  	ParsedDate = date;  	if (writeonce) {  		Console.WriteLine (@"First parsed date in csv:" + ParsedDate.ToShortDateString ());  		Console.WriteLine (@"Stopping at date:" + to.ToShortDateString ());  		Console.WriteLine (@"Current DateTime:" + ParsedDate.ToShortDateString () + @" Time:" + ParsedDate.ToShortTimeString () + @"  Asked Start date was " + from.ToShortDateString ());  		writeonce = false;  	}  	if (ParsedDate >= from && ParsedDate <= to) {  		DateTime datex = csv.GetDate (0);  		double open = csv.GetDouble (1);  		double close = csv.GetDouble (2);  		double high = csv.GetDouble (3);  		double low = csv.GetDouble (4);  		double volume = csv.GetDouble (5);  		double range = Math.Abs (open - close);  		double HighLowRange = Math.Abs (high - low);  		double DirectionalRange = close - open;  		LoadedMarketData data = new LoadedMarketData (datex' symbol);  		data.SetData (MarketDataType.Open' open);  		data.SetData (MarketDataType.High' high);  		data.SetData (MarketDataType.Low' low);  		data.SetData (MarketDataType.Close' close);  		data.SetData (MarketDataType.Volume' volume);  		data.SetData (MarketDataType.RangeHighLow' Math.Round (HighLowRange' 6));  		data.SetData (MarketDataType.RangeOpenClose' Math.Round (range' 6));  		data.SetData (MarketDataType.RangeOpenCloseNonAbsolute' Math.Round (DirectionalRange' 6));  		result.Add (data);  	}  }  
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: if (ParsedDate >= from && ParsedDate <= to) {  	DateTime datex = csv.GetDate (0);  	double open = csv.GetDouble (1);  	double close = csv.GetDouble (2);  	double high = csv.GetDouble (3);  	double low = csv.GetDouble (4);  	double volume = csv.GetDouble (5);  	double range = Math.Abs (open - close);  	double HighLowRange = Math.Abs (high - low);  	double DirectionalRange = close - open;  	LoadedMarketData data = new LoadedMarketData (datex' symbol);  	data.SetData (MarketDataType.Open' open);  	data.SetData (MarketDataType.High' high);  	data.SetData (MarketDataType.Low' low);  	data.SetData (MarketDataType.Close' close);  	data.SetData (MarketDataType.Volume' volume);  	data.SetData (MarketDataType.RangeHighLow' Math.Round (HighLowRange' 6));  	data.SetData (MarketDataType.RangeOpenClose' Math.Round (range' 6));  	data.SetData (MarketDataType.RangeOpenCloseNonAbsolute' Math.Round (DirectionalRange' 6));  	result.Add (data);  }  
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: if (ParsedDate >= from && ParsedDate <= to) {  	DateTime datex = csv.GetDate (0);  	double open = csv.GetDouble (1);  	double close = csv.GetDouble (2);  	double high = csv.GetDouble (3);  	double low = csv.GetDouble (4);  	double volume = csv.GetDouble (5);  	double range = Math.Abs (open - close);  	double HighLowRange = Math.Abs (high - low);  	double DirectionalRange = close - open;  	LoadedMarketData data = new LoadedMarketData (datex' symbol);  	data.SetData (MarketDataType.Open' open);  	data.SetData (MarketDataType.High' high);  	data.SetData (MarketDataType.Low' low);  	data.SetData (MarketDataType.Close' close);  	data.SetData (MarketDataType.Volume' volume);  	data.SetData (MarketDataType.RangeHighLow' Math.Round (HighLowRange' 6));  	data.SetData (MarketDataType.RangeOpenClose' Math.Round (range' 6));  	data.SetData (MarketDataType.RangeOpenCloseNonAbsolute' Math.Round (DirectionalRange' 6));  	result.Add (data);  }  
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: if (ParsedDate >= from && ParsedDate <= to) {  	DateTime datex = csv.GetDate (0);  	double open = csv.GetDouble (1);  	double close = csv.GetDouble (2);  	double high = csv.GetDouble (3);  	double low = csv.GetDouble (4);  	double volume = csv.GetDouble (5);  	double range = Math.Abs (open - close);  	double HighLowRange = Math.Abs (high - low);  	double DirectionalRange = close - open;  	LoadedMarketData data = new LoadedMarketData (datex' symbol);  	data.SetData (MarketDataType.Open' open);  	data.SetData (MarketDataType.High' high);  	data.SetData (MarketDataType.Low' low);  	data.SetData (MarketDataType.Close' close);  	data.SetData (MarketDataType.Volume' volume);  	data.SetData (MarketDataType.RangeHighLow' Math.Round (HighLowRange' 6));  	data.SetData (MarketDataType.RangeOpenClose' Math.Round (range' 6));  	data.SetData (MarketDataType.RangeOpenCloseNonAbsolute' Math.Round (DirectionalRange' 6));  	result.Add (data);  }  
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: if (ParsedDate >= from && ParsedDate <= to) {  	DateTime datex = csv.GetDate (0);  	double open = csv.GetDouble (1);  	double close = csv.GetDouble (2);  	double high = csv.GetDouble (3);  	double low = csv.GetDouble (4);  	double volume = csv.GetDouble (5);  	double range = Math.Abs (open - close);  	double HighLowRange = Math.Abs (high - low);  	double DirectionalRange = close - open;  	LoadedMarketData data = new LoadedMarketData (datex' symbol);  	data.SetData (MarketDataType.Open' open);  	data.SetData (MarketDataType.High' high);  	data.SetData (MarketDataType.Low' low);  	data.SetData (MarketDataType.Close' close);  	data.SetData (MarketDataType.Volume' volume);  	data.SetData (MarketDataType.RangeHighLow' Math.Round (HighLowRange' 6));  	data.SetData (MarketDataType.RangeOpenClose' Math.Round (range' 6));  	data.SetData (MarketDataType.RangeOpenCloseNonAbsolute' Math.Round (DirectionalRange' 6));  	result.Add (data);  }  
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: if (ParsedDate >= from && ParsedDate <= to) {  	DateTime datex = csv.GetDate (0);  	double open = csv.GetDouble (1);  	double close = csv.GetDouble (2);  	double high = csv.GetDouble (3);  	double low = csv.GetDouble (4);  	double volume = csv.GetDouble (5);  	double range = Math.Abs (open - close);  	double HighLowRange = Math.Abs (high - low);  	double DirectionalRange = close - open;  	LoadedMarketData data = new LoadedMarketData (datex' symbol);  	data.SetData (MarketDataType.Open' open);  	data.SetData (MarketDataType.High' high);  	data.SetData (MarketDataType.Low' low);  	data.SetData (MarketDataType.Close' close);  	data.SetData (MarketDataType.Volume' volume);  	data.SetData (MarketDataType.RangeHighLow' Math.Round (HighLowRange' 6));  	data.SetData (MarketDataType.RangeOpenClose' Math.Round (range' 6));  	data.SetData (MarketDataType.RangeOpenCloseNonAbsolute' Math.Round (DirectionalRange' 6));  	result.Add (data);  }  
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: if (ParsedDate >= from && ParsedDate <= to) {  	DateTime datex = csv.GetDate (0);  	double open = csv.GetDouble (1);  	double close = csv.GetDouble (2);  	double high = csv.GetDouble (3);  	double low = csv.GetDouble (4);  	double volume = csv.GetDouble (5);  	double range = Math.Abs (open - close);  	double HighLowRange = Math.Abs (high - low);  	double DirectionalRange = close - open;  	LoadedMarketData data = new LoadedMarketData (datex' symbol);  	data.SetData (MarketDataType.Open' open);  	data.SetData (MarketDataType.High' high);  	data.SetData (MarketDataType.Low' low);  	data.SetData (MarketDataType.Close' close);  	data.SetData (MarketDataType.Volume' volume);  	data.SetData (MarketDataType.RangeHighLow' Math.Round (HighLowRange' 6));  	data.SetData (MarketDataType.RangeOpenClose' Math.Round (range' 6));  	data.SetData (MarketDataType.RangeOpenCloseNonAbsolute' Math.Round (DirectionalRange' 6));  	result.Add (data);  }  
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: if (ParsedDate >= from && ParsedDate <= to) {  	DateTime datex = csv.GetDate (0);  	double open = csv.GetDouble (1);  	double close = csv.GetDouble (2);  	double high = csv.GetDouble (3);  	double low = csv.GetDouble (4);  	double volume = csv.GetDouble (5);  	double range = Math.Abs (open - close);  	double HighLowRange = Math.Abs (high - low);  	double DirectionalRange = close - open;  	LoadedMarketData data = new LoadedMarketData (datex' symbol);  	data.SetData (MarketDataType.Open' open);  	data.SetData (MarketDataType.High' high);  	data.SetData (MarketDataType.Low' low);  	data.SetData (MarketDataType.Close' close);  	data.SetData (MarketDataType.Volume' volume);  	data.SetData (MarketDataType.RangeHighLow' Math.Round (HighLowRange' 6));  	data.SetData (MarketDataType.RangeOpenClose' Math.Round (range' 6));  	data.SetData (MarketDataType.RangeOpenCloseNonAbsolute' Math.Round (DirectionalRange' 6));  	result.Add (data);  }  
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: data.SetData (MarketDataType.RangeHighLow' Math.Round (HighLowRange' 6));  
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: data.SetData (MarketDataType.RangeOpenClose' Math.Round (range' 6));  
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: data.SetData (MarketDataType.RangeOpenCloseNonAbsolute' Math.Round (DirectionalRange' 6));  
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,button1_Click,The following statement contains a magic number: openFileDialog1.FilterIndex = (2);  
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\neismit_emds\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,CSVFormLoader_Load,The following statement contains a magic number: CSVFormatsCombo.SelectedIndex = 2;  
Magic Number,Encog.ML.Factory.Method,FeedforwardFactory,C:\repos\neismit_emds\encog-core-cs\ML\Factory\Method\FeedforwardFactory.cs,Create,The following statement contains a magic number: foreach (String layerStr in layers) {  	// determine default  	int defaultCount = questionPhase == 0 ? input : output;  	ArchitectureLayer layer = ArchitectureParse.ParseLayer (layerStr' defaultCount);  	bool bias = layer.Bias;  	String part = layer.Name;  	part = part != null ? part.Trim () : "";  	IActivationFunction lookup = _factory.Create (part);  	if (lookup != null) {  		af = lookup;  	}  	else {  		if (layer.UsedDefault) {  			questionPhase++;  			if (questionPhase > 2) {  				throw new EncogError ("Only two ?'s may be used.");  			}  		}  		if (layer.Count == 0) {  			throw new EncogError ("Unknown architecture element: " + architecture + "' can't parse: " + part);  		}  		result.AddLayer (new BasicLayer (af' bias' layer.Count));  	}  }  
Magic Number,Encog.ML.Factory.Method,FeedforwardFactory,C:\repos\neismit_emds\encog-core-cs\ML\Factory\Method\FeedforwardFactory.cs,Create,The following statement contains a magic number: if (lookup != null) {  	af = lookup;  }  else {  	if (layer.UsedDefault) {  		questionPhase++;  		if (questionPhase > 2) {  			throw new EncogError ("Only two ?'s may be used.");  		}  	}  	if (layer.Count == 0) {  		throw new EncogError ("Unknown architecture element: " + architecture + "' can't parse: " + part);  	}  	result.AddLayer (new BasicLayer (af' bias' layer.Count));  }  
Magic Number,Encog.ML.Factory.Method,FeedforwardFactory,C:\repos\neismit_emds\encog-core-cs\ML\Factory\Method\FeedforwardFactory.cs,Create,The following statement contains a magic number: if (layer.UsedDefault) {  	questionPhase++;  	if (questionPhase > 2) {  		throw new EncogError ("Only two ?'s may be used.");  	}  }  
Magic Number,Encog.ML.Factory.Method,FeedforwardFactory,C:\repos\neismit_emds\encog-core-cs\ML\Factory\Method\FeedforwardFactory.cs,Create,The following statement contains a magic number: if (questionPhase > 2) {  	throw new EncogError ("Only two ?'s may be used.");  }  
Magic Number,Encog.ML.Factory.Method,SOMFactory,C:\repos\neismit_emds\encog-core-cs\ML\Factory\Method\SOMFactory.cs,Create,The following statement contains a magic number: if (layers.Count != 2) {  	throw new EncogError ("SOM's must have exactly two elements' separated by ->.");  }  
Magic Number,Encog.ML.Factory.Parse,ArchitectureParse,C:\repos\neismit_emds\encog-core-cs\ML\Factory\Parse\ArchitectureParse.cs,ParseLayer,The following statement contains a magic number: if (check.EndsWith (":B")) {  	check = check.Substring (0' (check.Length - 2) - (0));  	layer.Bias = true;  }  
Magic Number,Encog.ML.Factory.Parse,ArchitectureParse,C:\repos\neismit_emds\encog-core-cs\ML\Factory\Parse\ArchitectureParse.cs,ParseLayer,The following statement contains a magic number: check = check.Substring (0' (check.Length - 2) - (0));  
Magic Number,Encog.ML.Factory.Parse,ArchitectureParse,C:\repos\neismit_emds\encog-core-cs\ML\Factory\Parse\ArchitectureParse.cs,ParseLayers,The following statement contains a magic number: do {  	String part;  	int index = line.IndexOf ("->"' bs);  	if (index != -1) {  		part = line.Substring (bs' (index) - (bs)).Trim ();  		bs = index + 2;  	}  	else {  		part = line.Substring (bs).Trim ();  		done = true;  	}  	bool bias = part.EndsWith ("b");  	if (bias) {  		part = part.Substring (0' (part.Length - 1) - (0));  	}  	result.Add (part);  }  while (!done);  
Magic Number,Encog.ML.Factory.Parse,ArchitectureParse,C:\repos\neismit_emds\encog-core-cs\ML\Factory\Parse\ArchitectureParse.cs,ParseLayers,The following statement contains a magic number: if (index != -1) {  	part = line.Substring (bs' (index) - (bs)).Trim ();  	bs = index + 2;  }  else {  	part = line.Substring (bs).Trim ();  	done = true;  }  
Magic Number,Encog.ML.Factory.Parse,ArchitectureParse,C:\repos\neismit_emds\encog-core-cs\ML\Factory\Parse\ArchitectureParse.cs,ParseLayers,The following statement contains a magic number: bs = index + 2;  
Magic Number,Encog.ML.Factory.Train,NeighborhoodSOMFactory,C:\repos\neismit_emds\encog-core-cs\ML\Factory\Train\NeighborhoodSOMFactory.cs,Create,The following statement contains a magic number: if (args.ContainsKey (MLTrainFactory.PropertyIterations)) {  	int plannedIterations = holder.GetInt (MLTrainFactory.PropertyIterations' false' 1000);  	double startRate = holder.GetDouble (MLTrainFactory.PropertyStartLearningRate' false' 0.05d);  	double endRate = holder.GetDouble (MLTrainFactory.PropertyEndLearningRate' false' 0.05d);  	double startRadius = holder.GetDouble (MLTrainFactory.PropertyStartRadius' false' 10);  	double endRadius = holder.GetDouble (MLTrainFactory.PropertyEndRadius' false' 1);  	result.SetAutoDecay (plannedIterations' startRate' endRate' startRadius' endRadius);  }  
Magic Number,Encog.ML.Factory.Train,NeighborhoodSOMFactory,C:\repos\neismit_emds\encog-core-cs\ML\Factory\Train\NeighborhoodSOMFactory.cs,Create,The following statement contains a magic number: if (args.ContainsKey (MLTrainFactory.PropertyIterations)) {  	int plannedIterations = holder.GetInt (MLTrainFactory.PropertyIterations' false' 1000);  	double startRate = holder.GetDouble (MLTrainFactory.PropertyStartLearningRate' false' 0.05d);  	double endRate = holder.GetDouble (MLTrainFactory.PropertyEndLearningRate' false' 0.05d);  	double startRadius = holder.GetDouble (MLTrainFactory.PropertyStartRadius' false' 10);  	double endRadius = holder.GetDouble (MLTrainFactory.PropertyEndRadius' false' 1);  	result.SetAutoDecay (plannedIterations' startRate' endRate' startRadius' endRadius);  }  
Magic Number,Encog.ML.Genetic,BasicGeneticAlgorithm,C:\repos\neismit_emds\encog-core-cs\ML\Genetic\BasicGeneticAlgorithm.cs,Iteration,The following statement contains a magic number: Parallel.For (0' countToMate' i =>  {  	IGenome mother = Population.Genomes [i];  	var fatherInt = (int)(ThreadSafeRandom.NextDouble () * matingPopulationSize);  	IGenome father = Population.Genomes [fatherInt];  	IGenome child1 = Population.Genomes [offspringIndex];  	IGenome child2 = Population.Genomes [offspringIndex + 1];  	var worker = new MateWorker (mother' father' child1' child2);  	worker.Run ();  	offspringIndex += 2;  });  
Magic Number,Encog.ML.Genetic,BasicGeneticAlgorithm,C:\repos\neismit_emds\encog-core-cs\ML\Genetic\BasicGeneticAlgorithm.cs,Iteration,The following statement contains a magic number: offspringIndex += 2;  
Magic Number,Encog.ML.Genetic.Mutate,MutatePerturb,C:\repos\neismit_emds\encog-core-cs\ML\Genetic\Mutate\MutatePerturb.cs,PerformMutation,The following statement contains a magic number: foreach (IGene gene in chromosome.Genes) {  	if (gene is DoubleGene) {  		var doubleGene = (DoubleGene)gene;  		double v = doubleGene.Value;  		v += (_perturbAmount - (ThreadSafeRandom.NextDouble () * _perturbAmount * 2));  		doubleGene.Value = v;  	}  }  
Magic Number,Encog.ML.Genetic.Mutate,MutatePerturb,C:\repos\neismit_emds\encog-core-cs\ML\Genetic\Mutate\MutatePerturb.cs,PerformMutation,The following statement contains a magic number: if (gene is DoubleGene) {  	var doubleGene = (DoubleGene)gene;  	double v = doubleGene.Value;  	v += (_perturbAmount - (ThreadSafeRandom.NextDouble () * _perturbAmount * 2));  	doubleGene.Value = v;  }  
Magic Number,Encog.ML.Genetic.Mutate,MutatePerturb,C:\repos\neismit_emds\encog-core-cs\ML\Genetic\Mutate\MutatePerturb.cs,PerformMutation,The following statement contains a magic number: v += (_perturbAmount - (ThreadSafeRandom.NextDouble () * _perturbAmount * 2));  
Magic Number,Encog.ML.HMM.Alog,ForwardBackwardCalculator,C:\repos\neismit_emds\encog-core-cs\ML\HMM\Alog\ForwardBackwardCalculator.cs,ComputeBeta,The following statement contains a magic number: for (var t = (int)(oseq.Count - 2); t >= 0; t--) {  	for (int i = 0; i < hmm.StateCount; i++) {  		ComputeBetaStep (hmm' oseq [t + 1]' t' i);  	}  }  
Magic Number,Encog.ML.HMM.Alog,ForwardBackwardScaledCalculator,C:\repos\neismit_emds\encog-core-cs\ML\HMM\Alog\ForwardBackwardScaledCalculator.cs,ComputeBeta,The following statement contains a magic number: for (var t = (int)(oseq.Count - 2); t >= 0; t--) {  	for (int i = 0; i < hmm.StateCount; i++) {  		ComputeBetaStep (hmm' oseq [t + 1]' t' i);  		Beta [t] [i] /= _ctFactors [t];  	}  }  
Magic Number,Encog.ML.HMM.Alog,KullbackLeiblerDistanceCalculator,C:\repos\neismit_emds\encog-core-cs\ML\HMM\Alog\KullbackLeiblerDistanceCalculator.cs,KullbackLeiblerDistanceCalculator,The following statement contains a magic number: Len = 1000;  
Magic Number,Encog.ML.HMM.Alog,KullbackLeiblerDistanceCalculator,C:\repos\neismit_emds\encog-core-cs\ML\HMM\Alog\KullbackLeiblerDistanceCalculator.cs,KullbackLeiblerDistanceCalculator,The following statement contains a magic number: SequenceCount = 10;  
Magic Number,Encog.ML.HMM.Alog,ViterbiCalculator,C:\repos\neismit_emds\encog-core-cs\ML\HMM\Alog\ViterbiCalculator.cs,ViterbiCalculator,The following statement contains a magic number: for (int t2 = (int)(oseq.Count - 2); t2 >= 0; t2--) {  	_stateSequence [t2] = this.psy [t2 + 1] [_stateSequence [t2 + 1]];  }  
Magic Number,Encog.ML.HMM.Distributions,ContinousDistribution,C:\repos\neismit_emds\encog-core-cs\ML\HMM\Distributions\ContinousDistribution.cs,Probability,The following statement contains a magic number: return Math.Exp (expArg) / (Math.Pow (2.0 * Math.PI' _dimension / 2.0) * Math.Pow (_covarianceDet' 0.5));  
Magic Number,Encog.ML.HMM.Distributions,ContinousDistribution,C:\repos\neismit_emds\encog-core-cs\ML\HMM\Distributions\ContinousDistribution.cs,Probability,The following statement contains a magic number: return Math.Exp (expArg) / (Math.Pow (2.0 * Math.PI' _dimension / 2.0) * Math.Pow (_covarianceDet' 0.5));  
Magic Number,Encog.ML.HMM.Distributions,ContinousDistribution,C:\repos\neismit_emds\encog-core-cs\ML\HMM\Distributions\ContinousDistribution.cs,Probability,The following statement contains a magic number: return Math.Exp (expArg) / (Math.Pow (2.0 * Math.PI' _dimension / 2.0) * Math.Pow (_covarianceDet' 0.5));  
Magic Number,Encog.ML.HMM.Train.KMeans,TrainKMeans,C:\repos\neismit_emds\encog-core-cs\ML\HMM\Train\KMeans\TrainKMeans.cs,LearnTransition,The following statement contains a magic number: foreach (IMLDataSet obsSeq in _training.Sequences) {  	if (obsSeq.Count < 2) {  		continue;  	}  	int secondState = _clusters.Cluster (obsSeq [0]);  	for (int i = 1; i < obsSeq.Count; i++) {  		int firstState = secondState;  		secondState = _clusters.Cluster (obsSeq [i]);  		hmm.TransitionProbability [firstState] [secondState] = hmm.TransitionProbability [firstState] [secondState] + 1.0;  	}  }  
Magic Number,Encog.ML.HMM.Train.KMeans,TrainKMeans,C:\repos\neismit_emds\encog-core-cs\ML\HMM\Train\KMeans\TrainKMeans.cs,LearnTransition,The following statement contains a magic number: if (obsSeq.Count < 2) {  	continue;  }  
Magic Number,Encog.ML.Train.Strategy,EarlyStoppingStrategy,C:\repos\neismit_emds\encog-core-cs\ML\Train\Strategy\EarlyStoppingStrategy.cs,PostIteration,The following statement contains a magic number: if (_lastCheck > _stripLength) {  	_validationError = _calc.CalculateError (_validationSet);  	_testError = _calc.CalculateError (_testSet);  	_eOpt = Math.Min (_validationError' _eOpt);  	_gl = 100.0 * ((_validationError / _eOpt) - 1.0);  	_stripEfficiency = (_stripTotal) / (_stripLength * _stripOpt);  	//System.out.println("eff=" + this.stripEfficiency + "' gl=" + this.gl);  	// setup for next time  	_stripTotal = 0;  	_lastCheck = 0;  	// should we stop?  	_stop = (_gl > _alpha) || (_stripEfficiency < _minEfficiency);  }  
Magic Number,Encog.ML.Train.Strategy,EarlyStoppingStrategy,C:\repos\neismit_emds\encog-core-cs\ML\Train\Strategy\EarlyStoppingStrategy.cs,PostIteration,The following statement contains a magic number: _gl = 100.0 * ((_validationError / _eOpt) - 1.0);  
Magic Number,Encog.Neural.ART,ART1,C:\repos\neismit_emds\encog-core-cs\Neural\ART\ART1.cs,ART1,The following statement contains a magic number: _c1 = 5;  
Magic Number,Encog.Neural.ART,ART1,C:\repos\neismit_emds\encog-core-cs\Neural\ART\ART1.cs,ART1,The following statement contains a magic number: _l = 3;  
Magic Number,Encog.Neural.ART,ART1,C:\repos\neismit_emds\encog-core-cs\Neural\ART\ART1.cs,ART1,The following statement contains a magic number: _c1 = 5;  
Magic Number,Encog.Neural.ART,ART1,C:\repos\neismit_emds\encog-core-cs\Neural\ART\ART1.cs,ART1,The following statement contains a magic number: _l = 3;  
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: if ((hidden1 == 0) && (hidden2 == 0)) {  	layers = new FlatLayer[2];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' output' NoBiasActivation);  }  else if ((hidden1 == 0) || (hidden2 == 0)) {  	int count = Math.Max (hidden1' hidden2);  	layers = new FlatLayer[3];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' count' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' output' NoBiasActivation);  }  else {  	layers = new FlatLayer[4];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' hidden1' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' hidden2' DefaultBiasActivation);  	layers [3] = new FlatLayer (act' output' NoBiasActivation);  }  
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: if ((hidden1 == 0) && (hidden2 == 0)) {  	layers = new FlatLayer[2];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' output' NoBiasActivation);  }  else if ((hidden1 == 0) || (hidden2 == 0)) {  	int count = Math.Max (hidden1' hidden2);  	layers = new FlatLayer[3];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' count' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' output' NoBiasActivation);  }  else {  	layers = new FlatLayer[4];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' hidden1' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' hidden2' DefaultBiasActivation);  	layers [3] = new FlatLayer (act' output' NoBiasActivation);  }  
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: if ((hidden1 == 0) && (hidden2 == 0)) {  	layers = new FlatLayer[2];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' output' NoBiasActivation);  }  else if ((hidden1 == 0) || (hidden2 == 0)) {  	int count = Math.Max (hidden1' hidden2);  	layers = new FlatLayer[3];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' count' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' output' NoBiasActivation);  }  else {  	layers = new FlatLayer[4];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' hidden1' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' hidden2' DefaultBiasActivation);  	layers [3] = new FlatLayer (act' output' NoBiasActivation);  }  
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: if ((hidden1 == 0) && (hidden2 == 0)) {  	layers = new FlatLayer[2];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' output' NoBiasActivation);  }  else if ((hidden1 == 0) || (hidden2 == 0)) {  	int count = Math.Max (hidden1' hidden2);  	layers = new FlatLayer[3];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' count' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' output' NoBiasActivation);  }  else {  	layers = new FlatLayer[4];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' hidden1' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' hidden2' DefaultBiasActivation);  	layers [3] = new FlatLayer (act' output' NoBiasActivation);  }  
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: if ((hidden1 == 0) && (hidden2 == 0)) {  	layers = new FlatLayer[2];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' output' NoBiasActivation);  }  else if ((hidden1 == 0) || (hidden2 == 0)) {  	int count = Math.Max (hidden1' hidden2);  	layers = new FlatLayer[3];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' count' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' output' NoBiasActivation);  }  else {  	layers = new FlatLayer[4];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' hidden1' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' hidden2' DefaultBiasActivation);  	layers [3] = new FlatLayer (act' output' NoBiasActivation);  }  
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: if ((hidden1 == 0) && (hidden2 == 0)) {  	layers = new FlatLayer[2];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' output' NoBiasActivation);  }  else if ((hidden1 == 0) || (hidden2 == 0)) {  	int count = Math.Max (hidden1' hidden2);  	layers = new FlatLayer[3];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' count' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' output' NoBiasActivation);  }  else {  	layers = new FlatLayer[4];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' hidden1' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' hidden2' DefaultBiasActivation);  	layers [3] = new FlatLayer (act' output' NoBiasActivation);  }  
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: layers = new FlatLayer[2];  
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: if ((hidden1 == 0) || (hidden2 == 0)) {  	int count = Math.Max (hidden1' hidden2);  	layers = new FlatLayer[3];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' count' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' output' NoBiasActivation);  }  else {  	layers = new FlatLayer[4];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' hidden1' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' hidden2' DefaultBiasActivation);  	layers [3] = new FlatLayer (act' output' NoBiasActivation);  }  
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: if ((hidden1 == 0) || (hidden2 == 0)) {  	int count = Math.Max (hidden1' hidden2);  	layers = new FlatLayer[3];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' count' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' output' NoBiasActivation);  }  else {  	layers = new FlatLayer[4];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' hidden1' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' hidden2' DefaultBiasActivation);  	layers [3] = new FlatLayer (act' output' NoBiasActivation);  }  
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: if ((hidden1 == 0) || (hidden2 == 0)) {  	int count = Math.Max (hidden1' hidden2);  	layers = new FlatLayer[3];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' count' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' output' NoBiasActivation);  }  else {  	layers = new FlatLayer[4];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' hidden1' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' hidden2' DefaultBiasActivation);  	layers [3] = new FlatLayer (act' output' NoBiasActivation);  }  
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: if ((hidden1 == 0) || (hidden2 == 0)) {  	int count = Math.Max (hidden1' hidden2);  	layers = new FlatLayer[3];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' count' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' output' NoBiasActivation);  }  else {  	layers = new FlatLayer[4];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' hidden1' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' hidden2' DefaultBiasActivation);  	layers [3] = new FlatLayer (act' output' NoBiasActivation);  }  
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: if ((hidden1 == 0) || (hidden2 == 0)) {  	int count = Math.Max (hidden1' hidden2);  	layers = new FlatLayer[3];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' count' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' output' NoBiasActivation);  }  else {  	layers = new FlatLayer[4];  	layers [0] = new FlatLayer (linearAct' input' DefaultBiasActivation);  	layers [1] = new FlatLayer (act' hidden1' DefaultBiasActivation);  	layers [2] = new FlatLayer (act' hidden2' DefaultBiasActivation);  	layers [3] = new FlatLayer (act' output' NoBiasActivation);  }  
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: layers = new FlatLayer[3];  
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: layers [2] = new FlatLayer (act' output' NoBiasActivation);  
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: layers = new FlatLayer[4];  
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: layers [2] = new FlatLayer (act' hidden2' DefaultBiasActivation);  
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: layers [3] = new FlatLayer (act' output' NoBiasActivation);  
Magic Number,Encog.Neural.Flat,FlatNetworkRBF,C:\repos\neismit_emds\encog-core-cs\Neural\Flat\FlatNetworkRBF.cs,FlatNetworkRBF,The following statement contains a magic number: layers [2] = new FlatLayer (new ActivationLinear ()' outputCount' 0.0d);  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("PARAMS")) {  		IDictionary<String' String> paras = section.ParseParams ();  		foreach (String key in paras.Keys) {  			result.Properties.Add (key' paras [key]);  		}  	}  	if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NETWORK")) {  		IDictionary<String' String> p = section.ParseParams ();  		result.InputCount = EncogFileSection.ParseInt (p' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (p' PersistConst.OutputCount);  		result.ActivationFunction = EncogFileSection.ParseActivationFunction (p' PersistConst.ActivationFunction);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (p' NEATPopulation.PropertyOutputActivation);  		result.NetworkDepth = EncogFileSection.ParseInt (p' PersistConst.Depth);  		result.Snapshot = EncogFileSection.ParseBoolean (p' PersistConst.Snapshot);  	}  	else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NEURONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			long neuronID = Int32.Parse (cols [0]);  			NEATNeuronType neuronType = PersistNEATPopulation.StringToNeuronType (cols [1]);  			double activationResponse = CSVFormat.EgFormat.Parse (cols [2]);  			double splitY = CSVFormat.EgFormat.Parse (cols [3]);  			double splitX = CSVFormat.EgFormat.Parse (cols [4]);  			var neatNeuron = new NEATNeuron (neuronType' neuronID' splitY' splitX' activationResponse);  			result.Neurons.Add (neatNeuron);  			neuronMap [((int)neuronID)] = (neatNeuron);  		}  	}  	else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("LINKS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			int fromID = Int32.Parse (cols [0]);  			int toID = Int32.Parse (cols [1]);  			bool recurrent = Int32.Parse (cols [2]) > 0;  			double weight = CSVFormat.EgFormat.Parse (cols [3]);  			NEATNeuron fromNeuron = (neuronMap [fromID]);  			NEATNeuron toNeuron = (neuronMap [toID]);  			var neatLink = new NEATLink (weight' fromNeuron' toNeuron' recurrent);  			fromNeuron.OutputboundLinks.Add (neatLink);  			toNeuron.InboundLinks.Add (neatLink);  		}  	}  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("PARAMS")) {  		IDictionary<String' String> paras = section.ParseParams ();  		foreach (String key in paras.Keys) {  			result.Properties.Add (key' paras [key]);  		}  	}  	if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NETWORK")) {  		IDictionary<String' String> p = section.ParseParams ();  		result.InputCount = EncogFileSection.ParseInt (p' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (p' PersistConst.OutputCount);  		result.ActivationFunction = EncogFileSection.ParseActivationFunction (p' PersistConst.ActivationFunction);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (p' NEATPopulation.PropertyOutputActivation);  		result.NetworkDepth = EncogFileSection.ParseInt (p' PersistConst.Depth);  		result.Snapshot = EncogFileSection.ParseBoolean (p' PersistConst.Snapshot);  	}  	else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NEURONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			long neuronID = Int32.Parse (cols [0]);  			NEATNeuronType neuronType = PersistNEATPopulation.StringToNeuronType (cols [1]);  			double activationResponse = CSVFormat.EgFormat.Parse (cols [2]);  			double splitY = CSVFormat.EgFormat.Parse (cols [3]);  			double splitX = CSVFormat.EgFormat.Parse (cols [4]);  			var neatNeuron = new NEATNeuron (neuronType' neuronID' splitY' splitX' activationResponse);  			result.Neurons.Add (neatNeuron);  			neuronMap [((int)neuronID)] = (neatNeuron);  		}  	}  	else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("LINKS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			int fromID = Int32.Parse (cols [0]);  			int toID = Int32.Parse (cols [1]);  			bool recurrent = Int32.Parse (cols [2]) > 0;  			double weight = CSVFormat.EgFormat.Parse (cols [3]);  			NEATNeuron fromNeuron = (neuronMap [fromID]);  			NEATNeuron toNeuron = (neuronMap [toID]);  			var neatLink = new NEATLink (weight' fromNeuron' toNeuron' recurrent);  			fromNeuron.OutputboundLinks.Add (neatLink);  			toNeuron.InboundLinks.Add (neatLink);  		}  	}  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("PARAMS")) {  		IDictionary<String' String> paras = section.ParseParams ();  		foreach (String key in paras.Keys) {  			result.Properties.Add (key' paras [key]);  		}  	}  	if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NETWORK")) {  		IDictionary<String' String> p = section.ParseParams ();  		result.InputCount = EncogFileSection.ParseInt (p' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (p' PersistConst.OutputCount);  		result.ActivationFunction = EncogFileSection.ParseActivationFunction (p' PersistConst.ActivationFunction);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (p' NEATPopulation.PropertyOutputActivation);  		result.NetworkDepth = EncogFileSection.ParseInt (p' PersistConst.Depth);  		result.Snapshot = EncogFileSection.ParseBoolean (p' PersistConst.Snapshot);  	}  	else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NEURONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			long neuronID = Int32.Parse (cols [0]);  			NEATNeuronType neuronType = PersistNEATPopulation.StringToNeuronType (cols [1]);  			double activationResponse = CSVFormat.EgFormat.Parse (cols [2]);  			double splitY = CSVFormat.EgFormat.Parse (cols [3]);  			double splitX = CSVFormat.EgFormat.Parse (cols [4]);  			var neatNeuron = new NEATNeuron (neuronType' neuronID' splitY' splitX' activationResponse);  			result.Neurons.Add (neatNeuron);  			neuronMap [((int)neuronID)] = (neatNeuron);  		}  	}  	else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("LINKS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			int fromID = Int32.Parse (cols [0]);  			int toID = Int32.Parse (cols [1]);  			bool recurrent = Int32.Parse (cols [2]) > 0;  			double weight = CSVFormat.EgFormat.Parse (cols [3]);  			NEATNeuron fromNeuron = (neuronMap [fromID]);  			NEATNeuron toNeuron = (neuronMap [toID]);  			var neatLink = new NEATLink (weight' fromNeuron' toNeuron' recurrent);  			fromNeuron.OutputboundLinks.Add (neatLink);  			toNeuron.InboundLinks.Add (neatLink);  		}  	}  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("PARAMS")) {  		IDictionary<String' String> paras = section.ParseParams ();  		foreach (String key in paras.Keys) {  			result.Properties.Add (key' paras [key]);  		}  	}  	if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NETWORK")) {  		IDictionary<String' String> p = section.ParseParams ();  		result.InputCount = EncogFileSection.ParseInt (p' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (p' PersistConst.OutputCount);  		result.ActivationFunction = EncogFileSection.ParseActivationFunction (p' PersistConst.ActivationFunction);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (p' NEATPopulation.PropertyOutputActivation);  		result.NetworkDepth = EncogFileSection.ParseInt (p' PersistConst.Depth);  		result.Snapshot = EncogFileSection.ParseBoolean (p' PersistConst.Snapshot);  	}  	else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NEURONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			long neuronID = Int32.Parse (cols [0]);  			NEATNeuronType neuronType = PersistNEATPopulation.StringToNeuronType (cols [1]);  			double activationResponse = CSVFormat.EgFormat.Parse (cols [2]);  			double splitY = CSVFormat.EgFormat.Parse (cols [3]);  			double splitX = CSVFormat.EgFormat.Parse (cols [4]);  			var neatNeuron = new NEATNeuron (neuronType' neuronID' splitY' splitX' activationResponse);  			result.Neurons.Add (neatNeuron);  			neuronMap [((int)neuronID)] = (neatNeuron);  		}  	}  	else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("LINKS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			int fromID = Int32.Parse (cols [0]);  			int toID = Int32.Parse (cols [1]);  			bool recurrent = Int32.Parse (cols [2]) > 0;  			double weight = CSVFormat.EgFormat.Parse (cols [3]);  			NEATNeuron fromNeuron = (neuronMap [fromID]);  			NEATNeuron toNeuron = (neuronMap [toID]);  			var neatLink = new NEATLink (weight' fromNeuron' toNeuron' recurrent);  			fromNeuron.OutputboundLinks.Add (neatLink);  			toNeuron.InboundLinks.Add (neatLink);  		}  	}  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("PARAMS")) {  		IDictionary<String' String> paras = section.ParseParams ();  		foreach (String key in paras.Keys) {  			result.Properties.Add (key' paras [key]);  		}  	}  	if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NETWORK")) {  		IDictionary<String' String> p = section.ParseParams ();  		result.InputCount = EncogFileSection.ParseInt (p' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (p' PersistConst.OutputCount);  		result.ActivationFunction = EncogFileSection.ParseActivationFunction (p' PersistConst.ActivationFunction);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (p' NEATPopulation.PropertyOutputActivation);  		result.NetworkDepth = EncogFileSection.ParseInt (p' PersistConst.Depth);  		result.Snapshot = EncogFileSection.ParseBoolean (p' PersistConst.Snapshot);  	}  	else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NEURONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			long neuronID = Int32.Parse (cols [0]);  			NEATNeuronType neuronType = PersistNEATPopulation.StringToNeuronType (cols [1]);  			double activationResponse = CSVFormat.EgFormat.Parse (cols [2]);  			double splitY = CSVFormat.EgFormat.Parse (cols [3]);  			double splitX = CSVFormat.EgFormat.Parse (cols [4]);  			var neatNeuron = new NEATNeuron (neuronType' neuronID' splitY' splitX' activationResponse);  			result.Neurons.Add (neatNeuron);  			neuronMap [((int)neuronID)] = (neatNeuron);  		}  	}  	else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("LINKS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			int fromID = Int32.Parse (cols [0]);  			int toID = Int32.Parse (cols [1]);  			bool recurrent = Int32.Parse (cols [2]) > 0;  			double weight = CSVFormat.EgFormat.Parse (cols [3]);  			NEATNeuron fromNeuron = (neuronMap [fromID]);  			NEATNeuron toNeuron = (neuronMap [toID]);  			var neatLink = new NEATLink (weight' fromNeuron' toNeuron' recurrent);  			fromNeuron.OutputboundLinks.Add (neatLink);  			toNeuron.InboundLinks.Add (neatLink);  		}  	}  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NETWORK")) {  	IDictionary<String' String> p = section.ParseParams ();  	result.InputCount = EncogFileSection.ParseInt (p' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (p' PersistConst.OutputCount);  	result.ActivationFunction = EncogFileSection.ParseActivationFunction (p' PersistConst.ActivationFunction);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (p' NEATPopulation.PropertyOutputActivation);  	result.NetworkDepth = EncogFileSection.ParseInt (p' PersistConst.Depth);  	result.Snapshot = EncogFileSection.ParseBoolean (p' PersistConst.Snapshot);  }  else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NEURONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		long neuronID = Int32.Parse (cols [0]);  		NEATNeuronType neuronType = PersistNEATPopulation.StringToNeuronType (cols [1]);  		double activationResponse = CSVFormat.EgFormat.Parse (cols [2]);  		double splitY = CSVFormat.EgFormat.Parse (cols [3]);  		double splitX = CSVFormat.EgFormat.Parse (cols [4]);  		var neatNeuron = new NEATNeuron (neuronType' neuronID' splitY' splitX' activationResponse);  		result.Neurons.Add (neatNeuron);  		neuronMap [((int)neuronID)] = (neatNeuron);  	}  }  else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("LINKS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		int fromID = Int32.Parse (cols [0]);  		int toID = Int32.Parse (cols [1]);  		bool recurrent = Int32.Parse (cols [2]) > 0;  		double weight = CSVFormat.EgFormat.Parse (cols [3]);  		NEATNeuron fromNeuron = (neuronMap [fromID]);  		NEATNeuron toNeuron = (neuronMap [toID]);  		var neatLink = new NEATLink (weight' fromNeuron' toNeuron' recurrent);  		fromNeuron.OutputboundLinks.Add (neatLink);  		toNeuron.InboundLinks.Add (neatLink);  	}  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NETWORK")) {  	IDictionary<String' String> p = section.ParseParams ();  	result.InputCount = EncogFileSection.ParseInt (p' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (p' PersistConst.OutputCount);  	result.ActivationFunction = EncogFileSection.ParseActivationFunction (p' PersistConst.ActivationFunction);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (p' NEATPopulation.PropertyOutputActivation);  	result.NetworkDepth = EncogFileSection.ParseInt (p' PersistConst.Depth);  	result.Snapshot = EncogFileSection.ParseBoolean (p' PersistConst.Snapshot);  }  else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NEURONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		long neuronID = Int32.Parse (cols [0]);  		NEATNeuronType neuronType = PersistNEATPopulation.StringToNeuronType (cols [1]);  		double activationResponse = CSVFormat.EgFormat.Parse (cols [2]);  		double splitY = CSVFormat.EgFormat.Parse (cols [3]);  		double splitX = CSVFormat.EgFormat.Parse (cols [4]);  		var neatNeuron = new NEATNeuron (neuronType' neuronID' splitY' splitX' activationResponse);  		result.Neurons.Add (neatNeuron);  		neuronMap [((int)neuronID)] = (neatNeuron);  	}  }  else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("LINKS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		int fromID = Int32.Parse (cols [0]);  		int toID = Int32.Parse (cols [1]);  		bool recurrent = Int32.Parse (cols [2]) > 0;  		double weight = CSVFormat.EgFormat.Parse (cols [3]);  		NEATNeuron fromNeuron = (neuronMap [fromID]);  		NEATNeuron toNeuron = (neuronMap [toID]);  		var neatLink = new NEATLink (weight' fromNeuron' toNeuron' recurrent);  		fromNeuron.OutputboundLinks.Add (neatLink);  		toNeuron.InboundLinks.Add (neatLink);  	}  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NETWORK")) {  	IDictionary<String' String> p = section.ParseParams ();  	result.InputCount = EncogFileSection.ParseInt (p' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (p' PersistConst.OutputCount);  	result.ActivationFunction = EncogFileSection.ParseActivationFunction (p' PersistConst.ActivationFunction);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (p' NEATPopulation.PropertyOutputActivation);  	result.NetworkDepth = EncogFileSection.ParseInt (p' PersistConst.Depth);  	result.Snapshot = EncogFileSection.ParseBoolean (p' PersistConst.Snapshot);  }  else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NEURONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		long neuronID = Int32.Parse (cols [0]);  		NEATNeuronType neuronType = PersistNEATPopulation.StringToNeuronType (cols [1]);  		double activationResponse = CSVFormat.EgFormat.Parse (cols [2]);  		double splitY = CSVFormat.EgFormat.Parse (cols [3]);  		double splitX = CSVFormat.EgFormat.Parse (cols [4]);  		var neatNeuron = new NEATNeuron (neuronType' neuronID' splitY' splitX' activationResponse);  		result.Neurons.Add (neatNeuron);  		neuronMap [((int)neuronID)] = (neatNeuron);  	}  }  else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("LINKS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		int fromID = Int32.Parse (cols [0]);  		int toID = Int32.Parse (cols [1]);  		bool recurrent = Int32.Parse (cols [2]) > 0;  		double weight = CSVFormat.EgFormat.Parse (cols [3]);  		NEATNeuron fromNeuron = (neuronMap [fromID]);  		NEATNeuron toNeuron = (neuronMap [toID]);  		var neatLink = new NEATLink (weight' fromNeuron' toNeuron' recurrent);  		fromNeuron.OutputboundLinks.Add (neatLink);  		toNeuron.InboundLinks.Add (neatLink);  	}  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NETWORK")) {  	IDictionary<String' String> p = section.ParseParams ();  	result.InputCount = EncogFileSection.ParseInt (p' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (p' PersistConst.OutputCount);  	result.ActivationFunction = EncogFileSection.ParseActivationFunction (p' PersistConst.ActivationFunction);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (p' NEATPopulation.PropertyOutputActivation);  	result.NetworkDepth = EncogFileSection.ParseInt (p' PersistConst.Depth);  	result.Snapshot = EncogFileSection.ParseBoolean (p' PersistConst.Snapshot);  }  else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NEURONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		long neuronID = Int32.Parse (cols [0]);  		NEATNeuronType neuronType = PersistNEATPopulation.StringToNeuronType (cols [1]);  		double activationResponse = CSVFormat.EgFormat.Parse (cols [2]);  		double splitY = CSVFormat.EgFormat.Parse (cols [3]);  		double splitX = CSVFormat.EgFormat.Parse (cols [4]);  		var neatNeuron = new NEATNeuron (neuronType' neuronID' splitY' splitX' activationResponse);  		result.Neurons.Add (neatNeuron);  		neuronMap [((int)neuronID)] = (neatNeuron);  	}  }  else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("LINKS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		int fromID = Int32.Parse (cols [0]);  		int toID = Int32.Parse (cols [1]);  		bool recurrent = Int32.Parse (cols [2]) > 0;  		double weight = CSVFormat.EgFormat.Parse (cols [3]);  		NEATNeuron fromNeuron = (neuronMap [fromID]);  		NEATNeuron toNeuron = (neuronMap [toID]);  		var neatLink = new NEATLink (weight' fromNeuron' toNeuron' recurrent);  		fromNeuron.OutputboundLinks.Add (neatLink);  		toNeuron.InboundLinks.Add (neatLink);  	}  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NETWORK")) {  	IDictionary<String' String> p = section.ParseParams ();  	result.InputCount = EncogFileSection.ParseInt (p' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (p' PersistConst.OutputCount);  	result.ActivationFunction = EncogFileSection.ParseActivationFunction (p' PersistConst.ActivationFunction);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (p' NEATPopulation.PropertyOutputActivation);  	result.NetworkDepth = EncogFileSection.ParseInt (p' PersistConst.Depth);  	result.Snapshot = EncogFileSection.ParseBoolean (p' PersistConst.Snapshot);  }  else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NEURONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		long neuronID = Int32.Parse (cols [0]);  		NEATNeuronType neuronType = PersistNEATPopulation.StringToNeuronType (cols [1]);  		double activationResponse = CSVFormat.EgFormat.Parse (cols [2]);  		double splitY = CSVFormat.EgFormat.Parse (cols [3]);  		double splitX = CSVFormat.EgFormat.Parse (cols [4]);  		var neatNeuron = new NEATNeuron (neuronType' neuronID' splitY' splitX' activationResponse);  		result.Neurons.Add (neatNeuron);  		neuronMap [((int)neuronID)] = (neatNeuron);  	}  }  else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("LINKS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		int fromID = Int32.Parse (cols [0]);  		int toID = Int32.Parse (cols [1]);  		bool recurrent = Int32.Parse (cols [2]) > 0;  		double weight = CSVFormat.EgFormat.Parse (cols [3]);  		NEATNeuron fromNeuron = (neuronMap [fromID]);  		NEATNeuron toNeuron = (neuronMap [toID]);  		var neatLink = new NEATLink (weight' fromNeuron' toNeuron' recurrent);  		fromNeuron.OutputboundLinks.Add (neatLink);  		toNeuron.InboundLinks.Add (neatLink);  	}  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NEURONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		long neuronID = Int32.Parse (cols [0]);  		NEATNeuronType neuronType = PersistNEATPopulation.StringToNeuronType (cols [1]);  		double activationResponse = CSVFormat.EgFormat.Parse (cols [2]);  		double splitY = CSVFormat.EgFormat.Parse (cols [3]);  		double splitX = CSVFormat.EgFormat.Parse (cols [4]);  		var neatNeuron = new NEATNeuron (neuronType' neuronID' splitY' splitX' activationResponse);  		result.Neurons.Add (neatNeuron);  		neuronMap [((int)neuronID)] = (neatNeuron);  	}  }  else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("LINKS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		int fromID = Int32.Parse (cols [0]);  		int toID = Int32.Parse (cols [1]);  		bool recurrent = Int32.Parse (cols [2]) > 0;  		double weight = CSVFormat.EgFormat.Parse (cols [3]);  		NEATNeuron fromNeuron = (neuronMap [fromID]);  		NEATNeuron toNeuron = (neuronMap [toID]);  		var neatLink = new NEATLink (weight' fromNeuron' toNeuron' recurrent);  		fromNeuron.OutputboundLinks.Add (neatLink);  		toNeuron.InboundLinks.Add (neatLink);  	}  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NEURONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		long neuronID = Int32.Parse (cols [0]);  		NEATNeuronType neuronType = PersistNEATPopulation.StringToNeuronType (cols [1]);  		double activationResponse = CSVFormat.EgFormat.Parse (cols [2]);  		double splitY = CSVFormat.EgFormat.Parse (cols [3]);  		double splitX = CSVFormat.EgFormat.Parse (cols [4]);  		var neatNeuron = new NEATNeuron (neuronType' neuronID' splitY' splitX' activationResponse);  		result.Neurons.Add (neatNeuron);  		neuronMap [((int)neuronID)] = (neatNeuron);  	}  }  else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("LINKS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		int fromID = Int32.Parse (cols [0]);  		int toID = Int32.Parse (cols [1]);  		bool recurrent = Int32.Parse (cols [2]) > 0;  		double weight = CSVFormat.EgFormat.Parse (cols [3]);  		NEATNeuron fromNeuron = (neuronMap [fromID]);  		NEATNeuron toNeuron = (neuronMap [toID]);  		var neatLink = new NEATLink (weight' fromNeuron' toNeuron' recurrent);  		fromNeuron.OutputboundLinks.Add (neatLink);  		toNeuron.InboundLinks.Add (neatLink);  	}  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NEURONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		long neuronID = Int32.Parse (cols [0]);  		NEATNeuronType neuronType = PersistNEATPopulation.StringToNeuronType (cols [1]);  		double activationResponse = CSVFormat.EgFormat.Parse (cols [2]);  		double splitY = CSVFormat.EgFormat.Parse (cols [3]);  		double splitX = CSVFormat.EgFormat.Parse (cols [4]);  		var neatNeuron = new NEATNeuron (neuronType' neuronID' splitY' splitX' activationResponse);  		result.Neurons.Add (neatNeuron);  		neuronMap [((int)neuronID)] = (neatNeuron);  	}  }  else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("LINKS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		int fromID = Int32.Parse (cols [0]);  		int toID = Int32.Parse (cols [1]);  		bool recurrent = Int32.Parse (cols [2]) > 0;  		double weight = CSVFormat.EgFormat.Parse (cols [3]);  		NEATNeuron fromNeuron = (neuronMap [fromID]);  		NEATNeuron toNeuron = (neuronMap [toID]);  		var neatLink = new NEATLink (weight' fromNeuron' toNeuron' recurrent);  		fromNeuron.OutputboundLinks.Add (neatLink);  		toNeuron.InboundLinks.Add (neatLink);  	}  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NEURONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		long neuronID = Int32.Parse (cols [0]);  		NEATNeuronType neuronType = PersistNEATPopulation.StringToNeuronType (cols [1]);  		double activationResponse = CSVFormat.EgFormat.Parse (cols [2]);  		double splitY = CSVFormat.EgFormat.Parse (cols [3]);  		double splitX = CSVFormat.EgFormat.Parse (cols [4]);  		var neatNeuron = new NEATNeuron (neuronType' neuronID' splitY' splitX' activationResponse);  		result.Neurons.Add (neatNeuron);  		neuronMap [((int)neuronID)] = (neatNeuron);  	}  }  else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("LINKS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		int fromID = Int32.Parse (cols [0]);  		int toID = Int32.Parse (cols [1]);  		bool recurrent = Int32.Parse (cols [2]) > 0;  		double weight = CSVFormat.EgFormat.Parse (cols [3]);  		NEATNeuron fromNeuron = (neuronMap [fromID]);  		NEATNeuron toNeuron = (neuronMap [toID]);  		var neatLink = new NEATLink (weight' fromNeuron' toNeuron' recurrent);  		fromNeuron.OutputboundLinks.Add (neatLink);  		toNeuron.InboundLinks.Add (neatLink);  	}  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("NEURONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		long neuronID = Int32.Parse (cols [0]);  		NEATNeuronType neuronType = PersistNEATPopulation.StringToNeuronType (cols [1]);  		double activationResponse = CSVFormat.EgFormat.Parse (cols [2]);  		double splitY = CSVFormat.EgFormat.Parse (cols [3]);  		double splitX = CSVFormat.EgFormat.Parse (cols [4]);  		var neatNeuron = new NEATNeuron (neuronType' neuronID' splitY' splitX' activationResponse);  		result.Neurons.Add (neatNeuron);  		neuronMap [((int)neuronID)] = (neatNeuron);  	}  }  else if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("LINKS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		int fromID = Int32.Parse (cols [0]);  		int toID = Int32.Parse (cols [1]);  		bool recurrent = Int32.Parse (cols [2]) > 0;  		double weight = CSVFormat.EgFormat.Parse (cols [3]);  		NEATNeuron fromNeuron = (neuronMap [fromID]);  		NEATNeuron toNeuron = (neuronMap [toID]);  		var neatLink = new NEATLink (weight' fromNeuron' toNeuron' recurrent);  		fromNeuron.OutputboundLinks.Add (neatLink);  		toNeuron.InboundLinks.Add (neatLink);  	}  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	long neuronID = Int32.Parse (cols [0]);  	NEATNeuronType neuronType = PersistNEATPopulation.StringToNeuronType (cols [1]);  	double activationResponse = CSVFormat.EgFormat.Parse (cols [2]);  	double splitY = CSVFormat.EgFormat.Parse (cols [3]);  	double splitX = CSVFormat.EgFormat.Parse (cols [4]);  	var neatNeuron = new NEATNeuron (neuronType' neuronID' splitY' splitX' activationResponse);  	result.Neurons.Add (neatNeuron);  	neuronMap [((int)neuronID)] = (neatNeuron);  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	long neuronID = Int32.Parse (cols [0]);  	NEATNeuronType neuronType = PersistNEATPopulation.StringToNeuronType (cols [1]);  	double activationResponse = CSVFormat.EgFormat.Parse (cols [2]);  	double splitY = CSVFormat.EgFormat.Parse (cols [3]);  	double splitX = CSVFormat.EgFormat.Parse (cols [4]);  	var neatNeuron = new NEATNeuron (neuronType' neuronID' splitY' splitX' activationResponse);  	result.Neurons.Add (neatNeuron);  	neuronMap [((int)neuronID)] = (neatNeuron);  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	long neuronID = Int32.Parse (cols [0]);  	NEATNeuronType neuronType = PersistNEATPopulation.StringToNeuronType (cols [1]);  	double activationResponse = CSVFormat.EgFormat.Parse (cols [2]);  	double splitY = CSVFormat.EgFormat.Parse (cols [3]);  	double splitX = CSVFormat.EgFormat.Parse (cols [4]);  	var neatNeuron = new NEATNeuron (neuronType' neuronID' splitY' splitX' activationResponse);  	result.Neurons.Add (neatNeuron);  	neuronMap [((int)neuronID)] = (neatNeuron);  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("LINKS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		int fromID = Int32.Parse (cols [0]);  		int toID = Int32.Parse (cols [1]);  		bool recurrent = Int32.Parse (cols [2]) > 0;  		double weight = CSVFormat.EgFormat.Parse (cols [3]);  		NEATNeuron fromNeuron = (neuronMap [fromID]);  		NEATNeuron toNeuron = (neuronMap [toID]);  		var neatLink = new NEATLink (weight' fromNeuron' toNeuron' recurrent);  		fromNeuron.OutputboundLinks.Add (neatLink);  		toNeuron.InboundLinks.Add (neatLink);  	}  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT") && section.SubSectionName.Equals ("LINKS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		int fromID = Int32.Parse (cols [0]);  		int toID = Int32.Parse (cols [1]);  		bool recurrent = Int32.Parse (cols [2]) > 0;  		double weight = CSVFormat.EgFormat.Parse (cols [3]);  		NEATNeuron fromNeuron = (neuronMap [fromID]);  		NEATNeuron toNeuron = (neuronMap [toID]);  		var neatLink = new NEATLink (weight' fromNeuron' toNeuron' recurrent);  		fromNeuron.OutputboundLinks.Add (neatLink);  		toNeuron.InboundLinks.Add (neatLink);  	}  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	int fromID = Int32.Parse (cols [0]);  	int toID = Int32.Parse (cols [1]);  	bool recurrent = Int32.Parse (cols [2]) > 0;  	double weight = CSVFormat.EgFormat.Parse (cols [3]);  	NEATNeuron fromNeuron = (neuronMap [fromID]);  	NEATNeuron toNeuron = (neuronMap [toID]);  	var neatLink = new NEATLink (weight' fromNeuron' toNeuron' recurrent);  	fromNeuron.OutputboundLinks.Add (neatLink);  	toNeuron.InboundLinks.Add (neatLink);  }  
Magic Number,Encog.Neural.NEAT,PersistNEATNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATNetwork.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	int fromID = Int32.Parse (cols [0]);  	int toID = Int32.Parse (cols [1]);  	bool recurrent = Int32.Parse (cols [2]) > 0;  	double weight = CSVFormat.EgFormat.Parse (cols [3]);  	NEATNeuron fromNeuron = (neuronMap [fromID]);  	NEATNeuron toNeuron = (neuronMap [toID]);  	var neatLink = new NEATLink (weight' fromNeuron' toNeuron' recurrent);  	fromNeuron.OutputboundLinks.Add (neatLink);  	toNeuron.InboundLinks.Add (neatLink);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			var innovation = new NEATInnovation {  				InnovationID = Int32.Parse (cols [0])'  				InnovationType = StringToInnovationType (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				SplitX = CSVFormat.EgFormat.Parse (cols [3])'  				SplitY = CSVFormat.EgFormat.Parse (cols [4])'  				NeuronID = Int32.Parse (cols [5])'  				FromNeuronID = Int32.Parse (cols [6])'  				ToNeuronID = Int32.Parse (cols [7])  			};  			result.Innovations.Add (innovation);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  		foreach (String line in section.Lines) {  			String[] cols = line.Split (''');  			var species = new BasicSpecies {  				SpeciesID = Int32.Parse (cols [0])'  				Age = Int32.Parse (cols [1])'  				BestScore = CSVFormat.EgFormat.Parse (cols [2])'  				GensNoImprovement = Int32.Parse (cols [3])'  				SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  			};  			species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  			leaderMap [(species)] = (Int32.Parse (cols [6]));  			result.Species.Add (species);  			speciesMap [((int)species.SpeciesID)] = (species);  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  		NEATGenome lastGenome = null;  		foreach (String line in section.Lines) {  			IList<String> cols = EncogFileSection.SplitColumns (line);  			if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  				lastGenome = new NEATGenome {  					NeuronsChromosome = new Chromosome ()'  					LinksChromosome = new Chromosome ()  				};  				lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  				lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  				lastGenome.GenomeID = Int32.Parse (cols [1]);  				lastGenome.SpeciesID = Int32.Parse (cols [2]);  				lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  				lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  				lastGenome.NetworkDepth = Int32.Parse (cols [5]);  				lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  				result.Add (lastGenome);  				genomeMap [(int)lastGenome.GenomeID] = lastGenome;  			}  			else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  				var neuronGene = new NEATNeuronGene {  					Id = Int32.Parse (cols [1])'  					NeuronType = StringToNeuronType (cols [2])'  					Enabled = Int32.Parse (cols [3]) > 0'  					InnovationId = Int32.Parse (cols [4])'  					ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  					SplitX = CSVFormat.EgFormat.Parse (cols [6])'  					SplitY = CSVFormat.EgFormat.Parse (cols [7])  				};  				lastGenome.Neurons.Add (neuronGene);  			}  			else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  				var linkGene = new NEATLinkGene ();  				linkGene.Id = Int32.Parse (cols [1]);  				linkGene.Enabled = Int32.Parse (cols [2]) > 0;  				linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  				linkGene.FromNeuronID = Int32.Parse (cols [4]);  				linkGene.ToNeuronID = Int32.Parse (cols [5]);  				linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  				linkGene.InnovationId = Int32.Parse (cols [7]);  				lastGenome.Links.Add (linkGene);  			}  		}  	}  	else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  		IDictionary<String' String> paras = section.ParseParams ();  		result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  		result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  		result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  		result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  		result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  		result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  		result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  		result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  		result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  		result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  		result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  		result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  		result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  		result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  		result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("INNOVATIONS")) {  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		var innovation = new NEATInnovation {  			InnovationID = Int32.Parse (cols [0])'  			InnovationType = StringToInnovationType (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			SplitX = CSVFormat.EgFormat.Parse (cols [3])'  			SplitY = CSVFormat.EgFormat.Parse (cols [4])'  			NeuronID = Int32.Parse (cols [5])'  			FromNeuronID = Int32.Parse (cols [6])'  			ToNeuronID = Int32.Parse (cols [7])  		};  		result.Innovations.Add (innovation);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	var innovation = new NEATInnovation {  		InnovationID = Int32.Parse (cols [0])'  		InnovationType = StringToInnovationType (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		SplitX = CSVFormat.EgFormat.Parse (cols [3])'  		SplitY = CSVFormat.EgFormat.Parse (cols [4])'  		NeuronID = Int32.Parse (cols [5])'  		FromNeuronID = Int32.Parse (cols [6])'  		ToNeuronID = Int32.Parse (cols [7])  	};  	result.Innovations.Add (innovation);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	var innovation = new NEATInnovation {  		InnovationID = Int32.Parse (cols [0])'  		InnovationType = StringToInnovationType (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		SplitX = CSVFormat.EgFormat.Parse (cols [3])'  		SplitY = CSVFormat.EgFormat.Parse (cols [4])'  		NeuronID = Int32.Parse (cols [5])'  		FromNeuronID = Int32.Parse (cols [6])'  		ToNeuronID = Int32.Parse (cols [7])  	};  	result.Innovations.Add (innovation);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	var innovation = new NEATInnovation {  		InnovationID = Int32.Parse (cols [0])'  		InnovationType = StringToInnovationType (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		SplitX = CSVFormat.EgFormat.Parse (cols [3])'  		SplitY = CSVFormat.EgFormat.Parse (cols [4])'  		NeuronID = Int32.Parse (cols [5])'  		FromNeuronID = Int32.Parse (cols [6])'  		ToNeuronID = Int32.Parse (cols [7])  	};  	result.Innovations.Add (innovation);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	var innovation = new NEATInnovation {  		InnovationID = Int32.Parse (cols [0])'  		InnovationType = StringToInnovationType (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		SplitX = CSVFormat.EgFormat.Parse (cols [3])'  		SplitY = CSVFormat.EgFormat.Parse (cols [4])'  		NeuronID = Int32.Parse (cols [5])'  		FromNeuronID = Int32.Parse (cols [6])'  		ToNeuronID = Int32.Parse (cols [7])  	};  	result.Innovations.Add (innovation);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	var innovation = new NEATInnovation {  		InnovationID = Int32.Parse (cols [0])'  		InnovationType = StringToInnovationType (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		SplitX = CSVFormat.EgFormat.Parse (cols [3])'  		SplitY = CSVFormat.EgFormat.Parse (cols [4])'  		NeuronID = Int32.Parse (cols [5])'  		FromNeuronID = Int32.Parse (cols [6])'  		ToNeuronID = Int32.Parse (cols [7])  	};  	result.Innovations.Add (innovation);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	var innovation = new NEATInnovation {  		InnovationID = Int32.Parse (cols [0])'  		InnovationType = StringToInnovationType (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		SplitX = CSVFormat.EgFormat.Parse (cols [3])'  		SplitY = CSVFormat.EgFormat.Parse (cols [4])'  		NeuronID = Int32.Parse (cols [5])'  		FromNeuronID = Int32.Parse (cols [6])'  		ToNeuronID = Int32.Parse (cols [7])  	};  	result.Innovations.Add (innovation);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("SPECIES")) {  	foreach (String line in section.Lines) {  		String[] cols = line.Split (''');  		var species = new BasicSpecies {  			SpeciesID = Int32.Parse (cols [0])'  			Age = Int32.Parse (cols [1])'  			BestScore = CSVFormat.EgFormat.Parse (cols [2])'  			GensNoImprovement = Int32.Parse (cols [3])'  			SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  		};  		species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  		leaderMap [(species)] = (Int32.Parse (cols [6]));  		result.Species.Add (species);  		speciesMap [((int)species.SpeciesID)] = (species);  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	String[] cols = line.Split (''');  	var species = new BasicSpecies {  		SpeciesID = Int32.Parse (cols [0])'  		Age = Int32.Parse (cols [1])'  		BestScore = CSVFormat.EgFormat.Parse (cols [2])'  		GensNoImprovement = Int32.Parse (cols [3])'  		SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  	};  	species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  	leaderMap [(species)] = (Int32.Parse (cols [6]));  	result.Species.Add (species);  	speciesMap [((int)species.SpeciesID)] = (species);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	String[] cols = line.Split (''');  	var species = new BasicSpecies {  		SpeciesID = Int32.Parse (cols [0])'  		Age = Int32.Parse (cols [1])'  		BestScore = CSVFormat.EgFormat.Parse (cols [2])'  		GensNoImprovement = Int32.Parse (cols [3])'  		SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  	};  	species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  	leaderMap [(species)] = (Int32.Parse (cols [6]));  	result.Species.Add (species);  	speciesMap [((int)species.SpeciesID)] = (species);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	String[] cols = line.Split (''');  	var species = new BasicSpecies {  		SpeciesID = Int32.Parse (cols [0])'  		Age = Int32.Parse (cols [1])'  		BestScore = CSVFormat.EgFormat.Parse (cols [2])'  		GensNoImprovement = Int32.Parse (cols [3])'  		SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  	};  	species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  	leaderMap [(species)] = (Int32.Parse (cols [6]));  	result.Species.Add (species);  	speciesMap [((int)species.SpeciesID)] = (species);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	String[] cols = line.Split (''');  	var species = new BasicSpecies {  		SpeciesID = Int32.Parse (cols [0])'  		Age = Int32.Parse (cols [1])'  		BestScore = CSVFormat.EgFormat.Parse (cols [2])'  		GensNoImprovement = Int32.Parse (cols [3])'  		SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  	};  	species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  	leaderMap [(species)] = (Int32.Parse (cols [6]));  	result.Species.Add (species);  	speciesMap [((int)species.SpeciesID)] = (species);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	String[] cols = line.Split (''');  	var species = new BasicSpecies {  		SpeciesID = Int32.Parse (cols [0])'  		Age = Int32.Parse (cols [1])'  		BestScore = CSVFormat.EgFormat.Parse (cols [2])'  		GensNoImprovement = Int32.Parse (cols [3])'  		SpawnsRequired = CSVFormat.EgFormat.Parse (cols [4])  	};  	species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  	leaderMap [(species)] = (Int32.Parse (cols [6]));  	result.Species.Add (species);  	speciesMap [((int)species.SpeciesID)] = (species);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: species.SpawnsRequired = CSVFormat.EgFormat.Parse (cols [5]);  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: leaderMap [(species)] = (Int32.Parse (cols [6]));  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("GENOMES")) {  	NEATGenome lastGenome = null;  	foreach (String line in section.Lines) {  		IList<String> cols = EncogFileSection.SplitColumns (line);  		if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  			lastGenome = new NEATGenome {  				NeuronsChromosome = new Chromosome ()'  				LinksChromosome = new Chromosome ()  			};  			lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  			lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  			lastGenome.GenomeID = Int32.Parse (cols [1]);  			lastGenome.SpeciesID = Int32.Parse (cols [2]);  			lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  			lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  			lastGenome.NetworkDepth = Int32.Parse (cols [5]);  			lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  			result.Add (lastGenome);  			genomeMap [(int)lastGenome.GenomeID] = lastGenome;  		}  		else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  			var neuronGene = new NEATNeuronGene {  				Id = Int32.Parse (cols [1])'  				NeuronType = StringToNeuronType (cols [2])'  				Enabled = Int32.Parse (cols [3]) > 0'  				InnovationId = Int32.Parse (cols [4])'  				ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  				SplitX = CSVFormat.EgFormat.Parse (cols [6])'  				SplitY = CSVFormat.EgFormat.Parse (cols [7])  			};  			lastGenome.Neurons.Add (neuronGene);  		}  		else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  			var linkGene = new NEATLinkGene ();  			linkGene.Id = Int32.Parse (cols [1]);  			linkGene.Enabled = Int32.Parse (cols [2]) > 0;  			linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  			linkGene.FromNeuronID = Int32.Parse (cols [4]);  			linkGene.ToNeuronID = Int32.Parse (cols [5]);  			linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  			linkGene.InnovationId = Int32.Parse (cols [7]);  			lastGenome.Links.Add (linkGene);  		}  	}  }  else if (section.SectionName.Equals ("NEAT-POPULATION") && section.SubSectionName.Equals ("CONFIG")) {  	IDictionary<String' String> paras = section.ParseParams ();  	result.NeatActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyNEATActivation);  	result.OutputActivationFunction = EncogFileSection.ParseActivationFunction (paras' NEATPopulation.PropertyOutputActivation);  	result.Snapshot = EncogFileSection.ParseBoolean (paras' PersistConst.Snapshot);  	result.InputCount = EncogFileSection.ParseInt (paras' PersistConst.InputCount);  	result.OutputCount = EncogFileSection.ParseInt (paras' PersistConst.OutputCount);  	result.OldAgePenalty = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyOldAgePenalty);  	result.OldAgeThreshold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyOldAgeThreshold);  	result.PopulationSize = EncogFileSection.ParseInt (paras' PopulationConst.PropertyPopulationSize);  	result.SurvivalRate = EncogFileSection.ParseDouble (paras' PopulationConst.PropertySurvivalRate);  	result.YoungBonusAgeThreshhold = EncogFileSection.ParseInt (paras' PopulationConst.PropertyYoungAgeThreshold);  	result.YoungScoreBonus = EncogFileSection.ParseDouble (paras' PopulationConst.PropertyYoungAgeBonus);  	result.GenomeIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGenomeID);  	result.InnovationIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextInnovationID);  	result.GeneIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextGeneID);  	result.SpeciesIDGenerate.CurrentID = EncogFileSection.ParseInt (paras' PopulationConst.PropertyNextSpeciesID);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  		lastGenome = new NEATGenome {  			NeuronsChromosome = new Chromosome ()'  			LinksChromosome = new Chromosome ()  		};  		lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  		lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  		lastGenome.GenomeID = Int32.Parse (cols [1]);  		lastGenome.SpeciesID = Int32.Parse (cols [2]);  		lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  		lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  		lastGenome.NetworkDepth = Int32.Parse (cols [5]);  		lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  		result.Add (lastGenome);  		genomeMap [(int)lastGenome.GenomeID] = lastGenome;  	}  	else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  		var neuronGene = new NEATNeuronGene {  			Id = Int32.Parse (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			Enabled = Int32.Parse (cols [3]) > 0'  			InnovationId = Int32.Parse (cols [4])'  			ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  			SplitX = CSVFormat.EgFormat.Parse (cols [6])'  			SplitY = CSVFormat.EgFormat.Parse (cols [7])  		};  		lastGenome.Neurons.Add (neuronGene);  	}  	else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  		var linkGene = new NEATLinkGene ();  		linkGene.Id = Int32.Parse (cols [1]);  		linkGene.Enabled = Int32.Parse (cols [2]) > 0;  		linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  		linkGene.FromNeuronID = Int32.Parse (cols [4]);  		linkGene.ToNeuronID = Int32.Parse (cols [5]);  		linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  		linkGene.InnovationId = Int32.Parse (cols [7]);  		lastGenome.Links.Add (linkGene);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  		lastGenome = new NEATGenome {  			NeuronsChromosome = new Chromosome ()'  			LinksChromosome = new Chromosome ()  		};  		lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  		lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  		lastGenome.GenomeID = Int32.Parse (cols [1]);  		lastGenome.SpeciesID = Int32.Parse (cols [2]);  		lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  		lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  		lastGenome.NetworkDepth = Int32.Parse (cols [5]);  		lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  		result.Add (lastGenome);  		genomeMap [(int)lastGenome.GenomeID] = lastGenome;  	}  	else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  		var neuronGene = new NEATNeuronGene {  			Id = Int32.Parse (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			Enabled = Int32.Parse (cols [3]) > 0'  			InnovationId = Int32.Parse (cols [4])'  			ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  			SplitX = CSVFormat.EgFormat.Parse (cols [6])'  			SplitY = CSVFormat.EgFormat.Parse (cols [7])  		};  		lastGenome.Neurons.Add (neuronGene);  	}  	else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  		var linkGene = new NEATLinkGene ();  		linkGene.Id = Int32.Parse (cols [1]);  		linkGene.Enabled = Int32.Parse (cols [2]) > 0;  		linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  		linkGene.FromNeuronID = Int32.Parse (cols [4]);  		linkGene.ToNeuronID = Int32.Parse (cols [5]);  		linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  		linkGene.InnovationId = Int32.Parse (cols [7]);  		lastGenome.Links.Add (linkGene);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  		lastGenome = new NEATGenome {  			NeuronsChromosome = new Chromosome ()'  			LinksChromosome = new Chromosome ()  		};  		lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  		lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  		lastGenome.GenomeID = Int32.Parse (cols [1]);  		lastGenome.SpeciesID = Int32.Parse (cols [2]);  		lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  		lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  		lastGenome.NetworkDepth = Int32.Parse (cols [5]);  		lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  		result.Add (lastGenome);  		genomeMap [(int)lastGenome.GenomeID] = lastGenome;  	}  	else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  		var neuronGene = new NEATNeuronGene {  			Id = Int32.Parse (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			Enabled = Int32.Parse (cols [3]) > 0'  			InnovationId = Int32.Parse (cols [4])'  			ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  			SplitX = CSVFormat.EgFormat.Parse (cols [6])'  			SplitY = CSVFormat.EgFormat.Parse (cols [7])  		};  		lastGenome.Neurons.Add (neuronGene);  	}  	else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  		var linkGene = new NEATLinkGene ();  		linkGene.Id = Int32.Parse (cols [1]);  		linkGene.Enabled = Int32.Parse (cols [2]) > 0;  		linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  		linkGene.FromNeuronID = Int32.Parse (cols [4]);  		linkGene.ToNeuronID = Int32.Parse (cols [5]);  		linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  		linkGene.InnovationId = Int32.Parse (cols [7]);  		lastGenome.Links.Add (linkGene);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  		lastGenome = new NEATGenome {  			NeuronsChromosome = new Chromosome ()'  			LinksChromosome = new Chromosome ()  		};  		lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  		lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  		lastGenome.GenomeID = Int32.Parse (cols [1]);  		lastGenome.SpeciesID = Int32.Parse (cols [2]);  		lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  		lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  		lastGenome.NetworkDepth = Int32.Parse (cols [5]);  		lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  		result.Add (lastGenome);  		genomeMap [(int)lastGenome.GenomeID] = lastGenome;  	}  	else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  		var neuronGene = new NEATNeuronGene {  			Id = Int32.Parse (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			Enabled = Int32.Parse (cols [3]) > 0'  			InnovationId = Int32.Parse (cols [4])'  			ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  			SplitX = CSVFormat.EgFormat.Parse (cols [6])'  			SplitY = CSVFormat.EgFormat.Parse (cols [7])  		};  		lastGenome.Neurons.Add (neuronGene);  	}  	else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  		var linkGene = new NEATLinkGene ();  		linkGene.Id = Int32.Parse (cols [1]);  		linkGene.Enabled = Int32.Parse (cols [2]) > 0;  		linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  		linkGene.FromNeuronID = Int32.Parse (cols [4]);  		linkGene.ToNeuronID = Int32.Parse (cols [5]);  		linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  		linkGene.InnovationId = Int32.Parse (cols [7]);  		lastGenome.Links.Add (linkGene);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  		lastGenome = new NEATGenome {  			NeuronsChromosome = new Chromosome ()'  			LinksChromosome = new Chromosome ()  		};  		lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  		lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  		lastGenome.GenomeID = Int32.Parse (cols [1]);  		lastGenome.SpeciesID = Int32.Parse (cols [2]);  		lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  		lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  		lastGenome.NetworkDepth = Int32.Parse (cols [5]);  		lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  		result.Add (lastGenome);  		genomeMap [(int)lastGenome.GenomeID] = lastGenome;  	}  	else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  		var neuronGene = new NEATNeuronGene {  			Id = Int32.Parse (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			Enabled = Int32.Parse (cols [3]) > 0'  			InnovationId = Int32.Parse (cols [4])'  			ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  			SplitX = CSVFormat.EgFormat.Parse (cols [6])'  			SplitY = CSVFormat.EgFormat.Parse (cols [7])  		};  		lastGenome.Neurons.Add (neuronGene);  	}  	else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  		var linkGene = new NEATLinkGene ();  		linkGene.Id = Int32.Parse (cols [1]);  		linkGene.Enabled = Int32.Parse (cols [2]) > 0;  		linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  		linkGene.FromNeuronID = Int32.Parse (cols [4]);  		linkGene.ToNeuronID = Int32.Parse (cols [5]);  		linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  		linkGene.InnovationId = Int32.Parse (cols [7]);  		lastGenome.Links.Add (linkGene);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  		lastGenome = new NEATGenome {  			NeuronsChromosome = new Chromosome ()'  			LinksChromosome = new Chromosome ()  		};  		lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  		lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  		lastGenome.GenomeID = Int32.Parse (cols [1]);  		lastGenome.SpeciesID = Int32.Parse (cols [2]);  		lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  		lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  		lastGenome.NetworkDepth = Int32.Parse (cols [5]);  		lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  		result.Add (lastGenome);  		genomeMap [(int)lastGenome.GenomeID] = lastGenome;  	}  	else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  		var neuronGene = new NEATNeuronGene {  			Id = Int32.Parse (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			Enabled = Int32.Parse (cols [3]) > 0'  			InnovationId = Int32.Parse (cols [4])'  			ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  			SplitX = CSVFormat.EgFormat.Parse (cols [6])'  			SplitY = CSVFormat.EgFormat.Parse (cols [7])  		};  		lastGenome.Neurons.Add (neuronGene);  	}  	else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  		var linkGene = new NEATLinkGene ();  		linkGene.Id = Int32.Parse (cols [1]);  		linkGene.Enabled = Int32.Parse (cols [2]) > 0;  		linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  		linkGene.FromNeuronID = Int32.Parse (cols [4]);  		linkGene.ToNeuronID = Int32.Parse (cols [5]);  		linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  		linkGene.InnovationId = Int32.Parse (cols [7]);  		lastGenome.Links.Add (linkGene);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  		lastGenome = new NEATGenome {  			NeuronsChromosome = new Chromosome ()'  			LinksChromosome = new Chromosome ()  		};  		lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  		lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  		lastGenome.GenomeID = Int32.Parse (cols [1]);  		lastGenome.SpeciesID = Int32.Parse (cols [2]);  		lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  		lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  		lastGenome.NetworkDepth = Int32.Parse (cols [5]);  		lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  		result.Add (lastGenome);  		genomeMap [(int)lastGenome.GenomeID] = lastGenome;  	}  	else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  		var neuronGene = new NEATNeuronGene {  			Id = Int32.Parse (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			Enabled = Int32.Parse (cols [3]) > 0'  			InnovationId = Int32.Parse (cols [4])'  			ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  			SplitX = CSVFormat.EgFormat.Parse (cols [6])'  			SplitY = CSVFormat.EgFormat.Parse (cols [7])  		};  		lastGenome.Neurons.Add (neuronGene);  	}  	else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  		var linkGene = new NEATLinkGene ();  		linkGene.Id = Int32.Parse (cols [1]);  		linkGene.Enabled = Int32.Parse (cols [2]) > 0;  		linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  		linkGene.FromNeuronID = Int32.Parse (cols [4]);  		linkGene.ToNeuronID = Int32.Parse (cols [5]);  		linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  		linkGene.InnovationId = Int32.Parse (cols [7]);  		lastGenome.Links.Add (linkGene);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  		lastGenome = new NEATGenome {  			NeuronsChromosome = new Chromosome ()'  			LinksChromosome = new Chromosome ()  		};  		lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  		lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  		lastGenome.GenomeID = Int32.Parse (cols [1]);  		lastGenome.SpeciesID = Int32.Parse (cols [2]);  		lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  		lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  		lastGenome.NetworkDepth = Int32.Parse (cols [5]);  		lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  		result.Add (lastGenome);  		genomeMap [(int)lastGenome.GenomeID] = lastGenome;  	}  	else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  		var neuronGene = new NEATNeuronGene {  			Id = Int32.Parse (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			Enabled = Int32.Parse (cols [3]) > 0'  			InnovationId = Int32.Parse (cols [4])'  			ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  			SplitX = CSVFormat.EgFormat.Parse (cols [6])'  			SplitY = CSVFormat.EgFormat.Parse (cols [7])  		};  		lastGenome.Neurons.Add (neuronGene);  	}  	else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  		var linkGene = new NEATLinkGene ();  		linkGene.Id = Int32.Parse (cols [1]);  		linkGene.Enabled = Int32.Parse (cols [2]) > 0;  		linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  		linkGene.FromNeuronID = Int32.Parse (cols [4]);  		linkGene.ToNeuronID = Int32.Parse (cols [5]);  		linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  		linkGene.InnovationId = Int32.Parse (cols [7]);  		lastGenome.Links.Add (linkGene);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  		lastGenome = new NEATGenome {  			NeuronsChromosome = new Chromosome ()'  			LinksChromosome = new Chromosome ()  		};  		lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  		lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  		lastGenome.GenomeID = Int32.Parse (cols [1]);  		lastGenome.SpeciesID = Int32.Parse (cols [2]);  		lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  		lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  		lastGenome.NetworkDepth = Int32.Parse (cols [5]);  		lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  		result.Add (lastGenome);  		genomeMap [(int)lastGenome.GenomeID] = lastGenome;  	}  	else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  		var neuronGene = new NEATNeuronGene {  			Id = Int32.Parse (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			Enabled = Int32.Parse (cols [3]) > 0'  			InnovationId = Int32.Parse (cols [4])'  			ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  			SplitX = CSVFormat.EgFormat.Parse (cols [6])'  			SplitY = CSVFormat.EgFormat.Parse (cols [7])  		};  		lastGenome.Neurons.Add (neuronGene);  	}  	else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  		var linkGene = new NEATLinkGene ();  		linkGene.Id = Int32.Parse (cols [1]);  		linkGene.Enabled = Int32.Parse (cols [2]) > 0;  		linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  		linkGene.FromNeuronID = Int32.Parse (cols [4]);  		linkGene.ToNeuronID = Int32.Parse (cols [5]);  		linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  		linkGene.InnovationId = Int32.Parse (cols [7]);  		lastGenome.Links.Add (linkGene);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  		lastGenome = new NEATGenome {  			NeuronsChromosome = new Chromosome ()'  			LinksChromosome = new Chromosome ()  		};  		lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  		lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  		lastGenome.GenomeID = Int32.Parse (cols [1]);  		lastGenome.SpeciesID = Int32.Parse (cols [2]);  		lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  		lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  		lastGenome.NetworkDepth = Int32.Parse (cols [5]);  		lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  		result.Add (lastGenome);  		genomeMap [(int)lastGenome.GenomeID] = lastGenome;  	}  	else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  		var neuronGene = new NEATNeuronGene {  			Id = Int32.Parse (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			Enabled = Int32.Parse (cols [3]) > 0'  			InnovationId = Int32.Parse (cols [4])'  			ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  			SplitX = CSVFormat.EgFormat.Parse (cols [6])'  			SplitY = CSVFormat.EgFormat.Parse (cols [7])  		};  		lastGenome.Neurons.Add (neuronGene);  	}  	else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  		var linkGene = new NEATLinkGene ();  		linkGene.Id = Int32.Parse (cols [1]);  		linkGene.Enabled = Int32.Parse (cols [2]) > 0;  		linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  		linkGene.FromNeuronID = Int32.Parse (cols [4]);  		linkGene.ToNeuronID = Int32.Parse (cols [5]);  		linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  		linkGene.InnovationId = Int32.Parse (cols [7]);  		lastGenome.Links.Add (linkGene);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  		lastGenome = new NEATGenome {  			NeuronsChromosome = new Chromosome ()'  			LinksChromosome = new Chromosome ()  		};  		lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  		lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  		lastGenome.GenomeID = Int32.Parse (cols [1]);  		lastGenome.SpeciesID = Int32.Parse (cols [2]);  		lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  		lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  		lastGenome.NetworkDepth = Int32.Parse (cols [5]);  		lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  		result.Add (lastGenome);  		genomeMap [(int)lastGenome.GenomeID] = lastGenome;  	}  	else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  		var neuronGene = new NEATNeuronGene {  			Id = Int32.Parse (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			Enabled = Int32.Parse (cols [3]) > 0'  			InnovationId = Int32.Parse (cols [4])'  			ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  			SplitX = CSVFormat.EgFormat.Parse (cols [6])'  			SplitY = CSVFormat.EgFormat.Parse (cols [7])  		};  		lastGenome.Neurons.Add (neuronGene);  	}  	else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  		var linkGene = new NEATLinkGene ();  		linkGene.Id = Int32.Parse (cols [1]);  		linkGene.Enabled = Int32.Parse (cols [2]) > 0;  		linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  		linkGene.FromNeuronID = Int32.Parse (cols [4]);  		linkGene.ToNeuronID = Int32.Parse (cols [5]);  		linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  		linkGene.InnovationId = Int32.Parse (cols [7]);  		lastGenome.Links.Add (linkGene);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  		lastGenome = new NEATGenome {  			NeuronsChromosome = new Chromosome ()'  			LinksChromosome = new Chromosome ()  		};  		lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  		lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  		lastGenome.GenomeID = Int32.Parse (cols [1]);  		lastGenome.SpeciesID = Int32.Parse (cols [2]);  		lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  		lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  		lastGenome.NetworkDepth = Int32.Parse (cols [5]);  		lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  		result.Add (lastGenome);  		genomeMap [(int)lastGenome.GenomeID] = lastGenome;  	}  	else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  		var neuronGene = new NEATNeuronGene {  			Id = Int32.Parse (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			Enabled = Int32.Parse (cols [3]) > 0'  			InnovationId = Int32.Parse (cols [4])'  			ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  			SplitX = CSVFormat.EgFormat.Parse (cols [6])'  			SplitY = CSVFormat.EgFormat.Parse (cols [7])  		};  		lastGenome.Neurons.Add (neuronGene);  	}  	else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  		var linkGene = new NEATLinkGene ();  		linkGene.Id = Int32.Parse (cols [1]);  		linkGene.Enabled = Int32.Parse (cols [2]) > 0;  		linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  		linkGene.FromNeuronID = Int32.Parse (cols [4]);  		linkGene.ToNeuronID = Int32.Parse (cols [5]);  		linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  		linkGene.InnovationId = Int32.Parse (cols [7]);  		lastGenome.Links.Add (linkGene);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  		lastGenome = new NEATGenome {  			NeuronsChromosome = new Chromosome ()'  			LinksChromosome = new Chromosome ()  		};  		lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  		lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  		lastGenome.GenomeID = Int32.Parse (cols [1]);  		lastGenome.SpeciesID = Int32.Parse (cols [2]);  		lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  		lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  		lastGenome.NetworkDepth = Int32.Parse (cols [5]);  		lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  		result.Add (lastGenome);  		genomeMap [(int)lastGenome.GenomeID] = lastGenome;  	}  	else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  		var neuronGene = new NEATNeuronGene {  			Id = Int32.Parse (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			Enabled = Int32.Parse (cols [3]) > 0'  			InnovationId = Int32.Parse (cols [4])'  			ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  			SplitX = CSVFormat.EgFormat.Parse (cols [6])'  			SplitY = CSVFormat.EgFormat.Parse (cols [7])  		};  		lastGenome.Neurons.Add (neuronGene);  	}  	else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  		var linkGene = new NEATLinkGene ();  		linkGene.Id = Int32.Parse (cols [1]);  		linkGene.Enabled = Int32.Parse (cols [2]) > 0;  		linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  		linkGene.FromNeuronID = Int32.Parse (cols [4]);  		linkGene.ToNeuronID = Int32.Parse (cols [5]);  		linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  		linkGene.InnovationId = Int32.Parse (cols [7]);  		lastGenome.Links.Add (linkGene);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  		lastGenome = new NEATGenome {  			NeuronsChromosome = new Chromosome ()'  			LinksChromosome = new Chromosome ()  		};  		lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  		lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  		lastGenome.GenomeID = Int32.Parse (cols [1]);  		lastGenome.SpeciesID = Int32.Parse (cols [2]);  		lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  		lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  		lastGenome.NetworkDepth = Int32.Parse (cols [5]);  		lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  		result.Add (lastGenome);  		genomeMap [(int)lastGenome.GenomeID] = lastGenome;  	}  	else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  		var neuronGene = new NEATNeuronGene {  			Id = Int32.Parse (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			Enabled = Int32.Parse (cols [3]) > 0'  			InnovationId = Int32.Parse (cols [4])'  			ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  			SplitX = CSVFormat.EgFormat.Parse (cols [6])'  			SplitY = CSVFormat.EgFormat.Parse (cols [7])  		};  		lastGenome.Neurons.Add (neuronGene);  	}  	else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  		var linkGene = new NEATLinkGene ();  		linkGene.Id = Int32.Parse (cols [1]);  		linkGene.Enabled = Int32.Parse (cols [2]) > 0;  		linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  		linkGene.FromNeuronID = Int32.Parse (cols [4]);  		linkGene.ToNeuronID = Int32.Parse (cols [5]);  		linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  		linkGene.InnovationId = Int32.Parse (cols [7]);  		lastGenome.Links.Add (linkGene);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  		lastGenome = new NEATGenome {  			NeuronsChromosome = new Chromosome ()'  			LinksChromosome = new Chromosome ()  		};  		lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  		lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  		lastGenome.GenomeID = Int32.Parse (cols [1]);  		lastGenome.SpeciesID = Int32.Parse (cols [2]);  		lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  		lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  		lastGenome.NetworkDepth = Int32.Parse (cols [5]);  		lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  		result.Add (lastGenome);  		genomeMap [(int)lastGenome.GenomeID] = lastGenome;  	}  	else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  		var neuronGene = new NEATNeuronGene {  			Id = Int32.Parse (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			Enabled = Int32.Parse (cols [3]) > 0'  			InnovationId = Int32.Parse (cols [4])'  			ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  			SplitX = CSVFormat.EgFormat.Parse (cols [6])'  			SplitY = CSVFormat.EgFormat.Parse (cols [7])  		};  		lastGenome.Neurons.Add (neuronGene);  	}  	else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  		var linkGene = new NEATLinkGene ();  		linkGene.Id = Int32.Parse (cols [1]);  		linkGene.Enabled = Int32.Parse (cols [2]) > 0;  		linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  		linkGene.FromNeuronID = Int32.Parse (cols [4]);  		linkGene.ToNeuronID = Int32.Parse (cols [5]);  		linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  		linkGene.InnovationId = Int32.Parse (cols [7]);  		lastGenome.Links.Add (linkGene);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  		lastGenome = new NEATGenome {  			NeuronsChromosome = new Chromosome ()'  			LinksChromosome = new Chromosome ()  		};  		lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  		lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  		lastGenome.GenomeID = Int32.Parse (cols [1]);  		lastGenome.SpeciesID = Int32.Parse (cols [2]);  		lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  		lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  		lastGenome.NetworkDepth = Int32.Parse (cols [5]);  		lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  		result.Add (lastGenome);  		genomeMap [(int)lastGenome.GenomeID] = lastGenome;  	}  	else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  		var neuronGene = new NEATNeuronGene {  			Id = Int32.Parse (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			Enabled = Int32.Parse (cols [3]) > 0'  			InnovationId = Int32.Parse (cols [4])'  			ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  			SplitX = CSVFormat.EgFormat.Parse (cols [6])'  			SplitY = CSVFormat.EgFormat.Parse (cols [7])  		};  		lastGenome.Neurons.Add (neuronGene);  	}  	else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  		var linkGene = new NEATLinkGene ();  		linkGene.Id = Int32.Parse (cols [1]);  		linkGene.Enabled = Int32.Parse (cols [2]) > 0;  		linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  		linkGene.FromNeuronID = Int32.Parse (cols [4]);  		linkGene.ToNeuronID = Int32.Parse (cols [5]);  		linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  		linkGene.InnovationId = Int32.Parse (cols [7]);  		lastGenome.Links.Add (linkGene);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IList<String> cols = EncogFileSection.SplitColumns (line);  	if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  		lastGenome = new NEATGenome {  			NeuronsChromosome = new Chromosome ()'  			LinksChromosome = new Chromosome ()  		};  		lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  		lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  		lastGenome.GenomeID = Int32.Parse (cols [1]);  		lastGenome.SpeciesID = Int32.Parse (cols [2]);  		lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  		lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  		lastGenome.NetworkDepth = Int32.Parse (cols [5]);  		lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  		result.Add (lastGenome);  		genomeMap [(int)lastGenome.GenomeID] = lastGenome;  	}  	else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  		var neuronGene = new NEATNeuronGene {  			Id = Int32.Parse (cols [1])'  			NeuronType = StringToNeuronType (cols [2])'  			Enabled = Int32.Parse (cols [3]) > 0'  			InnovationId = Int32.Parse (cols [4])'  			ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  			SplitX = CSVFormat.EgFormat.Parse (cols [6])'  			SplitY = CSVFormat.EgFormat.Parse (cols [7])  		};  		lastGenome.Neurons.Add (neuronGene);  	}  	else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  		var linkGene = new NEATLinkGene ();  		linkGene.Id = Int32.Parse (cols [1]);  		linkGene.Enabled = Int32.Parse (cols [2]) > 0;  		linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  		linkGene.FromNeuronID = Int32.Parse (cols [4]);  		linkGene.ToNeuronID = Int32.Parse (cols [5]);  		linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  		linkGene.InnovationId = Int32.Parse (cols [7]);  		lastGenome.Links.Add (linkGene);  	}  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  	lastGenome = new NEATGenome {  		NeuronsChromosome = new Chromosome ()'  		LinksChromosome = new Chromosome ()  	};  	lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  	lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  	lastGenome.GenomeID = Int32.Parse (cols [1]);  	lastGenome.SpeciesID = Int32.Parse (cols [2]);  	lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  	lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  	lastGenome.NetworkDepth = Int32.Parse (cols [5]);  	lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  	result.Add (lastGenome);  	genomeMap [(int)lastGenome.GenomeID] = lastGenome;  }  else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  	lastGenome = new NEATGenome {  		NeuronsChromosome = new Chromosome ()'  		LinksChromosome = new Chromosome ()  	};  	lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  	lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  	lastGenome.GenomeID = Int32.Parse (cols [1]);  	lastGenome.SpeciesID = Int32.Parse (cols [2]);  	lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  	lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  	lastGenome.NetworkDepth = Int32.Parse (cols [5]);  	lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  	result.Add (lastGenome);  	genomeMap [(int)lastGenome.GenomeID] = lastGenome;  }  else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  	lastGenome = new NEATGenome {  		NeuronsChromosome = new Chromosome ()'  		LinksChromosome = new Chromosome ()  	};  	lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  	lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  	lastGenome.GenomeID = Int32.Parse (cols [1]);  	lastGenome.SpeciesID = Int32.Parse (cols [2]);  	lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  	lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  	lastGenome.NetworkDepth = Int32.Parse (cols [5]);  	lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  	result.Add (lastGenome);  	genomeMap [(int)lastGenome.GenomeID] = lastGenome;  }  else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  	lastGenome = new NEATGenome {  		NeuronsChromosome = new Chromosome ()'  		LinksChromosome = new Chromosome ()  	};  	lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  	lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  	lastGenome.GenomeID = Int32.Parse (cols [1]);  	lastGenome.SpeciesID = Int32.Parse (cols [2]);  	lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  	lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  	lastGenome.NetworkDepth = Int32.Parse (cols [5]);  	lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  	result.Add (lastGenome);  	genomeMap [(int)lastGenome.GenomeID] = lastGenome;  }  else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  	lastGenome = new NEATGenome {  		NeuronsChromosome = new Chromosome ()'  		LinksChromosome = new Chromosome ()  	};  	lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  	lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  	lastGenome.GenomeID = Int32.Parse (cols [1]);  	lastGenome.SpeciesID = Int32.Parse (cols [2]);  	lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  	lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  	lastGenome.NetworkDepth = Int32.Parse (cols [5]);  	lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  	result.Add (lastGenome);  	genomeMap [(int)lastGenome.GenomeID] = lastGenome;  }  else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  	lastGenome = new NEATGenome {  		NeuronsChromosome = new Chromosome ()'  		LinksChromosome = new Chromosome ()  	};  	lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  	lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  	lastGenome.GenomeID = Int32.Parse (cols [1]);  	lastGenome.SpeciesID = Int32.Parse (cols [2]);  	lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  	lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  	lastGenome.NetworkDepth = Int32.Parse (cols [5]);  	lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  	result.Add (lastGenome);  	genomeMap [(int)lastGenome.GenomeID] = lastGenome;  }  else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  	lastGenome = new NEATGenome {  		NeuronsChromosome = new Chromosome ()'  		LinksChromosome = new Chromosome ()  	};  	lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  	lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  	lastGenome.GenomeID = Int32.Parse (cols [1]);  	lastGenome.SpeciesID = Int32.Parse (cols [2]);  	lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  	lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  	lastGenome.NetworkDepth = Int32.Parse (cols [5]);  	lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  	result.Add (lastGenome);  	genomeMap [(int)lastGenome.GenomeID] = lastGenome;  }  else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  	lastGenome = new NEATGenome {  		NeuronsChromosome = new Chromosome ()'  		LinksChromosome = new Chromosome ()  	};  	lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  	lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  	lastGenome.GenomeID = Int32.Parse (cols [1]);  	lastGenome.SpeciesID = Int32.Parse (cols [2]);  	lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  	lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  	lastGenome.NetworkDepth = Int32.Parse (cols [5]);  	lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  	result.Add (lastGenome);  	genomeMap [(int)lastGenome.GenomeID] = lastGenome;  }  else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  	lastGenome = new NEATGenome {  		NeuronsChromosome = new Chromosome ()'  		LinksChromosome = new Chromosome ()  	};  	lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  	lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  	lastGenome.GenomeID = Int32.Parse (cols [1]);  	lastGenome.SpeciesID = Int32.Parse (cols [2]);  	lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  	lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  	lastGenome.NetworkDepth = Int32.Parse (cols [5]);  	lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  	result.Add (lastGenome);  	genomeMap [(int)lastGenome.GenomeID] = lastGenome;  }  else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  	lastGenome = new NEATGenome {  		NeuronsChromosome = new Chromosome ()'  		LinksChromosome = new Chromosome ()  	};  	lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  	lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  	lastGenome.GenomeID = Int32.Parse (cols [1]);  	lastGenome.SpeciesID = Int32.Parse (cols [2]);  	lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  	lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  	lastGenome.NetworkDepth = Int32.Parse (cols [5]);  	lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  	result.Add (lastGenome);  	genomeMap [(int)lastGenome.GenomeID] = lastGenome;  }  else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  	lastGenome = new NEATGenome {  		NeuronsChromosome = new Chromosome ()'  		LinksChromosome = new Chromosome ()  	};  	lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  	lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  	lastGenome.GenomeID = Int32.Parse (cols [1]);  	lastGenome.SpeciesID = Int32.Parse (cols [2]);  	lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  	lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  	lastGenome.NetworkDepth = Int32.Parse (cols [5]);  	lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  	result.Add (lastGenome);  	genomeMap [(int)lastGenome.GenomeID] = lastGenome;  }  else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  	lastGenome = new NEATGenome {  		NeuronsChromosome = new Chromosome ()'  		LinksChromosome = new Chromosome ()  	};  	lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  	lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  	lastGenome.GenomeID = Int32.Parse (cols [1]);  	lastGenome.SpeciesID = Int32.Parse (cols [2]);  	lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  	lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  	lastGenome.NetworkDepth = Int32.Parse (cols [5]);  	lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  	result.Add (lastGenome);  	genomeMap [(int)lastGenome.GenomeID] = lastGenome;  }  else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  	lastGenome = new NEATGenome {  		NeuronsChromosome = new Chromosome ()'  		LinksChromosome = new Chromosome ()  	};  	lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  	lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  	lastGenome.GenomeID = Int32.Parse (cols [1]);  	lastGenome.SpeciesID = Int32.Parse (cols [2]);  	lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  	lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  	lastGenome.NetworkDepth = Int32.Parse (cols [5]);  	lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  	result.Add (lastGenome);  	genomeMap [(int)lastGenome.GenomeID] = lastGenome;  }  else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  	lastGenome = new NEATGenome {  		NeuronsChromosome = new Chromosome ()'  		LinksChromosome = new Chromosome ()  	};  	lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  	lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  	lastGenome.GenomeID = Int32.Parse (cols [1]);  	lastGenome.SpeciesID = Int32.Parse (cols [2]);  	lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  	lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  	lastGenome.NetworkDepth = Int32.Parse (cols [5]);  	lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  	result.Add (lastGenome);  	genomeMap [(int)lastGenome.GenomeID] = lastGenome;  }  else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  	lastGenome = new NEATGenome {  		NeuronsChromosome = new Chromosome ()'  		LinksChromosome = new Chromosome ()  	};  	lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  	lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  	lastGenome.GenomeID = Int32.Parse (cols [1]);  	lastGenome.SpeciesID = Int32.Parse (cols [2]);  	lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  	lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  	lastGenome.NetworkDepth = Int32.Parse (cols [5]);  	lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  	result.Add (lastGenome);  	genomeMap [(int)lastGenome.GenomeID] = lastGenome;  }  else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  	lastGenome = new NEATGenome {  		NeuronsChromosome = new Chromosome ()'  		LinksChromosome = new Chromosome ()  	};  	lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  	lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  	lastGenome.GenomeID = Int32.Parse (cols [1]);  	lastGenome.SpeciesID = Int32.Parse (cols [2]);  	lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  	lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  	lastGenome.NetworkDepth = Int32.Parse (cols [5]);  	lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  	result.Add (lastGenome);  	genomeMap [(int)lastGenome.GenomeID] = lastGenome;  }  else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("g"' StringComparison.InvariantCultureIgnoreCase)) {  	lastGenome = new NEATGenome {  		NeuronsChromosome = new Chromosome ()'  		LinksChromosome = new Chromosome ()  	};  	lastGenome.Chromosomes.Add (lastGenome.NeuronsChromosome);  	lastGenome.Chromosomes.Add (lastGenome.LinksChromosome);  	lastGenome.GenomeID = Int32.Parse (cols [1]);  	lastGenome.SpeciesID = Int32.Parse (cols [2]);  	lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  	lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  	lastGenome.NetworkDepth = Int32.Parse (cols [5]);  	lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  	result.Add (lastGenome);  	genomeMap [(int)lastGenome.GenomeID] = lastGenome;  }  else if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: lastGenome.SpeciesID = Int32.Parse (cols [2]);  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: lastGenome.AdjustedScore = CSVFormat.EgFormat.Parse (cols [3]);  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: lastGenome.AmountToSpawn = CSVFormat.EgFormat.Parse (cols [4]);  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: lastGenome.NetworkDepth = Int32.Parse (cols [5]);  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: lastGenome.Score = CSVFormat.EgFormat.Parse (cols [6]);  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("n"' StringComparison.InvariantCultureIgnoreCase)) {  	var neuronGene = new NEATNeuronGene {  		Id = Int32.Parse (cols [1])'  		NeuronType = StringToNeuronType (cols [2])'  		Enabled = Int32.Parse (cols [3]) > 0'  		InnovationId = Int32.Parse (cols [4])'  		ActivationResponse = CSVFormat.EgFormat.Parse (cols [5])'  		SplitX = CSVFormat.EgFormat.Parse (cols [6])'  		SplitY = CSVFormat.EgFormat.Parse (cols [7])  	};  	lastGenome.Neurons.Add (neuronGene);  }  else if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: if (cols [0].Equals ("l"' StringComparison.InvariantCultureIgnoreCase)) {  	var linkGene = new NEATLinkGene ();  	linkGene.Id = Int32.Parse (cols [1]);  	linkGene.Enabled = Int32.Parse (cols [2]) > 0;  	linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  	linkGene.FromNeuronID = Int32.Parse (cols [4]);  	linkGene.ToNeuronID = Int32.Parse (cols [5]);  	linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  	linkGene.InnovationId = Int32.Parse (cols [7]);  	lastGenome.Links.Add (linkGene);  }  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: linkGene.Enabled = Int32.Parse (cols [2]) > 0;  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: linkGene.Recurrent = Int32.Parse (cols [3]) > 0;  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: linkGene.FromNeuronID = Int32.Parse (cols [4]);  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: linkGene.ToNeuronID = Int32.Parse (cols [5]);  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: linkGene.Weight = CSVFormat.EgFormat.Parse (cols [6]);  
Magic Number,Encog.Neural.Neat,PersistNEATPopulation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: linkGene.InnovationId = Int32.Parse (cols [7]);  
Magic Number,Encog.Neural.NEAT.Training,NEATTraining,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATTraining.cs,Iteration,The following statement contains a magic number: foreach (ISpecies s in Population.Species) {  	if (numSpawnedSoFar < Population.Size ()) {  		var numToSpawn = (int)Math.Round (s.NumToSpawn);  		bool bChosenBestYet = false;  		while ((numToSpawn--) > 0) {  			NEATGenome baby = null;  			if (!bChosenBestYet) {  				baby = (NEATGenome)s.Leader;  				bChosenBestYet = true;  			}  			else {  				// if the number of individuals in this species is only  				// one  				// then we can only perform mutation  				if (s.Members.Count == 1) {  					// spawn a child  					baby = new NEATGenome ((NEATGenome)s.ChooseParent ());  				}  				else {  					var g1 = (NEATGenome)s.ChooseParent ();  					if (ThreadSafeRandom.NextDouble () < paramCrossoverRate) {  						var g2 = (NEATGenome)s.ChooseParent ();  						int numAttempts = 5;  						while ((g1.GenomeID == g2.GenomeID) && ((numAttempts--) > 0)) {  							g2 = (NEATGenome)s.ChooseParent ();  						}  						if (g1.GenomeID != g2.GenomeID) {  							baby = Crossover (g1' g2);  						}  					}  					else {  						baby = new NEATGenome (g1);  					}  				}  				if (baby != null) {  					baby.GenomeID = Population.AssignGenomeID ();  					if (baby.Neurons.Size () < paramMaxPermittedNeurons) {  						baby.AddNeuron (paramChanceAddNode' paramNumTrysToFindOldLink);  					}  					// now there's the chance a link may be added  					baby.AddLink (paramChanceAddLink' paramChanceAddRecurrentLink' paramNumTrysToFindLoopedLink' paramNumAddLinkAttempts);  					// mutate the weights  					baby.MutateWeights (paramMutationRate' paramProbabilityWeightReplaced' paramMaxWeightPerturbation);  					baby.MutateActivationResponse (paramActivationMutationRate' paramMaxActivationPerturbation);  				}  			}  			if (baby != null) {  				// sort the baby's genes by their innovation numbers  				baby.SortGenes ();  				// add to new pop  				// if (newPop.contains(baby)) {  				// throw new EncogError("readd");  				// }  				newPop.Add (baby);  				++numSpawnedSoFar;  				if (numSpawnedSoFar == Population.Size ()) {  					numToSpawn = 0;  				}  			}  		}  	}  }  
Magic Number,Encog.Neural.NEAT.Training,NEATTraining,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATTraining.cs,Iteration,The following statement contains a magic number: if (numSpawnedSoFar < Population.Size ()) {  	var numToSpawn = (int)Math.Round (s.NumToSpawn);  	bool bChosenBestYet = false;  	while ((numToSpawn--) > 0) {  		NEATGenome baby = null;  		if (!bChosenBestYet) {  			baby = (NEATGenome)s.Leader;  			bChosenBestYet = true;  		}  		else {  			// if the number of individuals in this species is only  			// one  			// then we can only perform mutation  			if (s.Members.Count == 1) {  				// spawn a child  				baby = new NEATGenome ((NEATGenome)s.ChooseParent ());  			}  			else {  				var g1 = (NEATGenome)s.ChooseParent ();  				if (ThreadSafeRandom.NextDouble () < paramCrossoverRate) {  					var g2 = (NEATGenome)s.ChooseParent ();  					int numAttempts = 5;  					while ((g1.GenomeID == g2.GenomeID) && ((numAttempts--) > 0)) {  						g2 = (NEATGenome)s.ChooseParent ();  					}  					if (g1.GenomeID != g2.GenomeID) {  						baby = Crossover (g1' g2);  					}  				}  				else {  					baby = new NEATGenome (g1);  				}  			}  			if (baby != null) {  				baby.GenomeID = Population.AssignGenomeID ();  				if (baby.Neurons.Size () < paramMaxPermittedNeurons) {  					baby.AddNeuron (paramChanceAddNode' paramNumTrysToFindOldLink);  				}  				// now there's the chance a link may be added  				baby.AddLink (paramChanceAddLink' paramChanceAddRecurrentLink' paramNumTrysToFindLoopedLink' paramNumAddLinkAttempts);  				// mutate the weights  				baby.MutateWeights (paramMutationRate' paramProbabilityWeightReplaced' paramMaxWeightPerturbation);  				baby.MutateActivationResponse (paramActivationMutationRate' paramMaxActivationPerturbation);  			}  		}  		if (baby != null) {  			// sort the baby's genes by their innovation numbers  			baby.SortGenes ();  			// add to new pop  			// if (newPop.contains(baby)) {  			// throw new EncogError("readd");  			// }  			newPop.Add (baby);  			++numSpawnedSoFar;  			if (numSpawnedSoFar == Population.Size ()) {  				numToSpawn = 0;  			}  		}  	}  }  
Magic Number,Encog.Neural.NEAT.Training,NEATTraining,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATTraining.cs,Iteration,The following statement contains a magic number: while ((numToSpawn--) > 0) {  	NEATGenome baby = null;  	if (!bChosenBestYet) {  		baby = (NEATGenome)s.Leader;  		bChosenBestYet = true;  	}  	else {  		// if the number of individuals in this species is only  		// one  		// then we can only perform mutation  		if (s.Members.Count == 1) {  			// spawn a child  			baby = new NEATGenome ((NEATGenome)s.ChooseParent ());  		}  		else {  			var g1 = (NEATGenome)s.ChooseParent ();  			if (ThreadSafeRandom.NextDouble () < paramCrossoverRate) {  				var g2 = (NEATGenome)s.ChooseParent ();  				int numAttempts = 5;  				while ((g1.GenomeID == g2.GenomeID) && ((numAttempts--) > 0)) {  					g2 = (NEATGenome)s.ChooseParent ();  				}  				if (g1.GenomeID != g2.GenomeID) {  					baby = Crossover (g1' g2);  				}  			}  			else {  				baby = new NEATGenome (g1);  			}  		}  		if (baby != null) {  			baby.GenomeID = Population.AssignGenomeID ();  			if (baby.Neurons.Size () < paramMaxPermittedNeurons) {  				baby.AddNeuron (paramChanceAddNode' paramNumTrysToFindOldLink);  			}  			// now there's the chance a link may be added  			baby.AddLink (paramChanceAddLink' paramChanceAddRecurrentLink' paramNumTrysToFindLoopedLink' paramNumAddLinkAttempts);  			// mutate the weights  			baby.MutateWeights (paramMutationRate' paramProbabilityWeightReplaced' paramMaxWeightPerturbation);  			baby.MutateActivationResponse (paramActivationMutationRate' paramMaxActivationPerturbation);  		}  	}  	if (baby != null) {  		// sort the baby's genes by their innovation numbers  		baby.SortGenes ();  		// add to new pop  		// if (newPop.contains(baby)) {  		// throw new EncogError("readd");  		// }  		newPop.Add (baby);  		++numSpawnedSoFar;  		if (numSpawnedSoFar == Population.Size ()) {  			numToSpawn = 0;  		}  	}  }  
Magic Number,Encog.Neural.NEAT.Training,NEATTraining,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATTraining.cs,Iteration,The following statement contains a magic number: if (!bChosenBestYet) {  	baby = (NEATGenome)s.Leader;  	bChosenBestYet = true;  }  else {  	// if the number of individuals in this species is only  	// one  	// then we can only perform mutation  	if (s.Members.Count == 1) {  		// spawn a child  		baby = new NEATGenome ((NEATGenome)s.ChooseParent ());  	}  	else {  		var g1 = (NEATGenome)s.ChooseParent ();  		if (ThreadSafeRandom.NextDouble () < paramCrossoverRate) {  			var g2 = (NEATGenome)s.ChooseParent ();  			int numAttempts = 5;  			while ((g1.GenomeID == g2.GenomeID) && ((numAttempts--) > 0)) {  				g2 = (NEATGenome)s.ChooseParent ();  			}  			if (g1.GenomeID != g2.GenomeID) {  				baby = Crossover (g1' g2);  			}  		}  		else {  			baby = new NEATGenome (g1);  		}  	}  	if (baby != null) {  		baby.GenomeID = Population.AssignGenomeID ();  		if (baby.Neurons.Size () < paramMaxPermittedNeurons) {  			baby.AddNeuron (paramChanceAddNode' paramNumTrysToFindOldLink);  		}  		// now there's the chance a link may be added  		baby.AddLink (paramChanceAddLink' paramChanceAddRecurrentLink' paramNumTrysToFindLoopedLink' paramNumAddLinkAttempts);  		// mutate the weights  		baby.MutateWeights (paramMutationRate' paramProbabilityWeightReplaced' paramMaxWeightPerturbation);  		baby.MutateActivationResponse (paramActivationMutationRate' paramMaxActivationPerturbation);  	}  }  
Magic Number,Encog.Neural.NEAT.Training,NEATTraining,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATTraining.cs,Iteration,The following statement contains a magic number: if (s.Members.Count == 1) {  	// spawn a child  	baby = new NEATGenome ((NEATGenome)s.ChooseParent ());  }  else {  	var g1 = (NEATGenome)s.ChooseParent ();  	if (ThreadSafeRandom.NextDouble () < paramCrossoverRate) {  		var g2 = (NEATGenome)s.ChooseParent ();  		int numAttempts = 5;  		while ((g1.GenomeID == g2.GenomeID) && ((numAttempts--) > 0)) {  			g2 = (NEATGenome)s.ChooseParent ();  		}  		if (g1.GenomeID != g2.GenomeID) {  			baby = Crossover (g1' g2);  		}  	}  	else {  		baby = new NEATGenome (g1);  	}  }  
Magic Number,Encog.Neural.NEAT.Training,NEATTraining,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATTraining.cs,Iteration,The following statement contains a magic number: if (ThreadSafeRandom.NextDouble () < paramCrossoverRate) {  	var g2 = (NEATGenome)s.ChooseParent ();  	int numAttempts = 5;  	while ((g1.GenomeID == g2.GenomeID) && ((numAttempts--) > 0)) {  		g2 = (NEATGenome)s.ChooseParent ();  	}  	if (g1.GenomeID != g2.GenomeID) {  		baby = Crossover (g1' g2);  	}  }  else {  	baby = new NEATGenome (g1);  }  
Magic Number,Encog.Neural.NEAT.Training,NEATTraining,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATTraining.cs,Iteration,The following statement contains a magic number: while (newPop.Count < Population.Size ()) {  	newPop.Add (TournamentSelection (Population.Size () / 5));  }  
Magic Number,Encog.Neural.NEAT.Training,NEATTraining,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATTraining.cs,Iteration,The following statement contains a magic number: newPop.Add (TournamentSelection (Population.Size () / 5));  
Magic Number,Encog.Neural.NEAT.Training,NEATTraining,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATTraining.cs,AdjustCompatibilityThreshold,The following statement contains a magic number: if (Population.Species.Count > paramMaxNumberOfSpecies) {  	paramCompatibilityThreshold += thresholdIncrement;  }  else if (Population.Species.Count < 2) {  	paramCompatibilityThreshold -= thresholdIncrement;  }  
Magic Number,Encog.Neural.NEAT.Training,NEATTraining,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATTraining.cs,AdjustCompatibilityThreshold,The following statement contains a magic number: if (Population.Species.Count < 2) {  	paramCompatibilityThreshold -= thresholdIncrement;  }  
Magic Number,Encog.Neural.Networks,BasicNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\BasicNetwork.cs,Reset,The following statement contains a magic number: if (LayerCount < 3) {  	(new RangeRandomizer (-1' 1)).Randomize (this);  }  else {  	(new NguyenWidrowRandomizer ()).Randomize (this);  }  
Magic Number,Encog.Neural.Networks.Structure,NeuralStructure,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Structure\NeuralStructure.cs,FinalizeStructure,The following statement contains a magic number: if (_layers.Count < 2) {  	throw new NeuralNetworkError ("There must be at least two layers before the structure is finalized.");  }  
Magic Number,Encog.Neural.Networks.Training.Genetic,NeuralGeneticAlgorithm,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\Genetic\NeuralGeneticAlgorithm.cs,NeuralGeneticAlgorithm,The following statement contains a magic number: Genetic.MatingPopulation = percentToMate * 2;  
Magic Number,Encog.Neural.Networks.Training.Genetic,NeuralGeneticAlgorithm,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\Genetic\NeuralGeneticAlgorithm.cs,NeuralGeneticAlgorithm,The following statement contains a magic number: Genetic.Crossover = new Splice (network.Structure.CalculateSize () / 3);  
Magic Number,Encog.Neural.Networks.Training.Lma,LevenbergMarquardtTraining,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\LMA\LevenbergMarquardtTraining.cs,LevenbergMarquardtTraining,The following statement contains a magic number: _lambda = 0.1;  
Magic Number,Encog.Neural.Networks.Training.NM,NelderMeadTraining,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,NelderMeadTraining,The following statement contains a magic number: _jcount = _konvge = 500;  
Magic Number,Encog.Neural.Networks.Training.NM,NelderMeadTraining,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,Iteration,The following statement contains a magic number: for (; ;) {  	/*                  * if (kcount <= icount) { break; }                  */_ynewlo = _y [0];  	_ihi = 0;  	for (int i = 1; i < _nn; i++) {  		if (_ynewlo < _y [i]) {  			_ynewlo = _y [i];  			_ihi = i;  		}  	}  	/*                  * Calculate PBAR' the centroid of the simplex vertices excepting                  * the vertex with Y value YNEWLO.                  */for (int i = 0; i < n; i++) {  		_z = 0.0;  		for (int j = 0; j < _nn; j++) {  			_z = _z + _p [i + j * n];  		}  		_z = _z - _p [i + _ihi * n];  		_pbar [i] = _z / n;  	}  	/*                  * Reflection through the centroid.                  */for (int i = 0; i < n; i++) {  		_pstar [i] = _pbar [i] + rcoeff * (_pbar [i] - _p [i + _ihi * n]);  	}  	_ystar = Fn (_pstar);  	/*                  * Successful reflection' so extension.                  */if (_ystar < _ylo) {  		for (int i = 0; i < n; i++) {  			_p2Star [i] = _pbar [i] + ecoeff * (_pstar [i] - _pbar [i]);  		}  		_y2Star = Fn (_p2Star);  		/*                      * Check extension.                      */if (_ystar < _y2Star) {  			for (int i = 0; i < n; i++) {  				_p [i + _ihi * n] = _pstar [i];  			}  			_y [_ihi] = _ystar;  		}  		/*                      * Retain extension or contraction.                      */else {  			for (int i = 0; i < n; i++) {  				_p [i + _ihi * n] = _p2Star [i];  			}  			_y [_ihi] = _y2Star;  		}  	}  	/*                  * No extension.                  */else {  		_l = 0;  		for (int i = 0; i < _nn; i++) {  			if (_ystar < _y [i]) {  				_l = _l + 1;  			}  		}  		if (1 < _l) {  			for (int i = 0; i < n; i++) {  				_p [i + _ihi * n] = _pstar [i];  			}  			_y [_ihi] = _ystar;  		}  		/*                      * Contraction on the Y(IHI) side of the centroid.                      */else if (_l == 0) {  			for (int i = 0; i < n; i++) {  				_p2Star [i] = _pbar [i] + ccoeff * (_p [i + _ihi * n] - _pbar [i]);  			}  			_y2Star = Fn (_p2Star);  			/*                          * Contract the whole simplex.                          */if (_y [_ihi] < _y2Star) {  				for (int j = 0; j < _nn; j++) {  					for (int i = 0; i < n; i++) {  						_p [i + j * n] = (_p [i + j * n] + _p [i + _ilo * n]) * 0.5;  						_trainedWeights [i] = _p [i + j * n];  					}  					_y [j] = Fn (_trainedWeights);  				}  				_ylo = _y [0];  				_ilo = 0;  				for (int i = 1; i < _nn; i++) {  					if (_y [i] < _ylo) {  						_ylo = _y [i];  						_ilo = i;  					}  				}  				continue;  			}  			/*                          * Retain contraction.                          */for (int i = 0; i < n; i++) {  				_p [i + _ihi * n] = _p2Star [i];  			}  			_y [_ihi] = _y2Star;  		}  		/*                      * Contraction on the reflection side of the centroid.                      */else if (_l == 1) {  			for (int i = 0; i < n; i++) {  				_p2Star [i] = _pbar [i] + ccoeff * (_pstar [i] - _pbar [i]);  			}  			_y2Star = Fn (_p2Star);  			/*                          * Retain reflection?                          */if (_y2Star <= _ystar) {  				for (int i = 0; i < n; i++) {  					_p [i + _ihi * n] = _p2Star [i];  				}  				_y [_ihi] = _y2Star;  			}  			else {  				for (int i = 0; i < n; i++) {  					_p [i + _ihi * n] = _pstar [i];  				}  				_y [_ihi] = _ystar;  			}  		}  	}  	/*                  * Check if YLO improved.                  */if (_y [_ihi] < _ylo) {  		_ylo = _y [_ihi];  		_ilo = _ihi;  	}  	_jcount = _jcount - 1;  	if (0 < _jcount) {  		continue;  	}  	/*                  * Check to see if minimum reached.                  */// if (icount <= kcount)  	{  		_jcount = _konvge;  		_z = 0.0;  		for (int i = 0; i < _nn; i++) {  			_z = _z + _y [i];  		}  		double x = _z / _nn;  		_z = 0.0;  		for (int i = 0; i < _nn; i++) {  			_z = _z + Math.Pow (_y [i] - x' 2);  		}  		if (_z <= _rq) {  			break;  		}  	}  }  
Magic Number,Encog.Neural.Networks.Training.NM,NelderMeadTraining,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,Iteration,The following statement contains a magic number: for (; ;) {  	/*                  * if (kcount <= icount) { break; }                  */_ynewlo = _y [0];  	_ihi = 0;  	for (int i = 1; i < _nn; i++) {  		if (_ynewlo < _y [i]) {  			_ynewlo = _y [i];  			_ihi = i;  		}  	}  	/*                  * Calculate PBAR' the centroid of the simplex vertices excepting                  * the vertex with Y value YNEWLO.                  */for (int i = 0; i < n; i++) {  		_z = 0.0;  		for (int j = 0; j < _nn; j++) {  			_z = _z + _p [i + j * n];  		}  		_z = _z - _p [i + _ihi * n];  		_pbar [i] = _z / n;  	}  	/*                  * Reflection through the centroid.                  */for (int i = 0; i < n; i++) {  		_pstar [i] = _pbar [i] + rcoeff * (_pbar [i] - _p [i + _ihi * n]);  	}  	_ystar = Fn (_pstar);  	/*                  * Successful reflection' so extension.                  */if (_ystar < _ylo) {  		for (int i = 0; i < n; i++) {  			_p2Star [i] = _pbar [i] + ecoeff * (_pstar [i] - _pbar [i]);  		}  		_y2Star = Fn (_p2Star);  		/*                      * Check extension.                      */if (_ystar < _y2Star) {  			for (int i = 0; i < n; i++) {  				_p [i + _ihi * n] = _pstar [i];  			}  			_y [_ihi] = _ystar;  		}  		/*                      * Retain extension or contraction.                      */else {  			for (int i = 0; i < n; i++) {  				_p [i + _ihi * n] = _p2Star [i];  			}  			_y [_ihi] = _y2Star;  		}  	}  	/*                  * No extension.                  */else {  		_l = 0;  		for (int i = 0; i < _nn; i++) {  			if (_ystar < _y [i]) {  				_l = _l + 1;  			}  		}  		if (1 < _l) {  			for (int i = 0; i < n; i++) {  				_p [i + _ihi * n] = _pstar [i];  			}  			_y [_ihi] = _ystar;  		}  		/*                      * Contraction on the Y(IHI) side of the centroid.                      */else if (_l == 0) {  			for (int i = 0; i < n; i++) {  				_p2Star [i] = _pbar [i] + ccoeff * (_p [i + _ihi * n] - _pbar [i]);  			}  			_y2Star = Fn (_p2Star);  			/*                          * Contract the whole simplex.                          */if (_y [_ihi] < _y2Star) {  				for (int j = 0; j < _nn; j++) {  					for (int i = 0; i < n; i++) {  						_p [i + j * n] = (_p [i + j * n] + _p [i + _ilo * n]) * 0.5;  						_trainedWeights [i] = _p [i + j * n];  					}  					_y [j] = Fn (_trainedWeights);  				}  				_ylo = _y [0];  				_ilo = 0;  				for (int i = 1; i < _nn; i++) {  					if (_y [i] < _ylo) {  						_ylo = _y [i];  						_ilo = i;  					}  				}  				continue;  			}  			/*                          * Retain contraction.                          */for (int i = 0; i < n; i++) {  				_p [i + _ihi * n] = _p2Star [i];  			}  			_y [_ihi] = _y2Star;  		}  		/*                      * Contraction on the reflection side of the centroid.                      */else if (_l == 1) {  			for (int i = 0; i < n; i++) {  				_p2Star [i] = _pbar [i] + ccoeff * (_pstar [i] - _pbar [i]);  			}  			_y2Star = Fn (_p2Star);  			/*                          * Retain reflection?                          */if (_y2Star <= _ystar) {  				for (int i = 0; i < n; i++) {  					_p [i + _ihi * n] = _p2Star [i];  				}  				_y [_ihi] = _y2Star;  			}  			else {  				for (int i = 0; i < n; i++) {  					_p [i + _ihi * n] = _pstar [i];  				}  				_y [_ihi] = _ystar;  			}  		}  	}  	/*                  * Check if YLO improved.                  */if (_y [_ihi] < _ylo) {  		_ylo = _y [_ihi];  		_ilo = _ihi;  	}  	_jcount = _jcount - 1;  	if (0 < _jcount) {  		continue;  	}  	/*                  * Check to see if minimum reached.                  */// if (icount <= kcount)  	{  		_jcount = _konvge;  		_z = 0.0;  		for (int i = 0; i < _nn; i++) {  			_z = _z + _y [i];  		}  		double x = _z / _nn;  		_z = 0.0;  		for (int i = 0; i < _nn; i++) {  			_z = _z + Math.Pow (_y [i] - x' 2);  		}  		if (_z <= _rq) {  			break;  		}  	}  }  
Magic Number,Encog.Neural.Networks.Training.NM,NelderMeadTraining,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,Iteration,The following statement contains a magic number: if (_ystar < _ylo) {  	for (int i = 0; i < n; i++) {  		_p2Star [i] = _pbar [i] + ecoeff * (_pstar [i] - _pbar [i]);  	}  	_y2Star = Fn (_p2Star);  	/*                      * Check extension.                      */if (_ystar < _y2Star) {  		for (int i = 0; i < n; i++) {  			_p [i + _ihi * n] = _pstar [i];  		}  		_y [_ihi] = _ystar;  	}  	/*                      * Retain extension or contraction.                      */else {  		for (int i = 0; i < n; i++) {  			_p [i + _ihi * n] = _p2Star [i];  		}  		_y [_ihi] = _y2Star;  	}  }  /*                  * No extension.                  */else {  	_l = 0;  	for (int i = 0; i < _nn; i++) {  		if (_ystar < _y [i]) {  			_l = _l + 1;  		}  	}  	if (1 < _l) {  		for (int i = 0; i < n; i++) {  			_p [i + _ihi * n] = _pstar [i];  		}  		_y [_ihi] = _ystar;  	}  	/*                      * Contraction on the Y(IHI) side of the centroid.                      */else if (_l == 0) {  		for (int i = 0; i < n; i++) {  			_p2Star [i] = _pbar [i] + ccoeff * (_p [i + _ihi * n] - _pbar [i]);  		}  		_y2Star = Fn (_p2Star);  		/*                          * Contract the whole simplex.                          */if (_y [_ihi] < _y2Star) {  			for (int j = 0; j < _nn; j++) {  				for (int i = 0; i < n; i++) {  					_p [i + j * n] = (_p [i + j * n] + _p [i + _ilo * n]) * 0.5;  					_trainedWeights [i] = _p [i + j * n];  				}  				_y [j] = Fn (_trainedWeights);  			}  			_ylo = _y [0];  			_ilo = 0;  			for (int i = 1; i < _nn; i++) {  				if (_y [i] < _ylo) {  					_ylo = _y [i];  					_ilo = i;  				}  			}  			continue;  		}  		/*                          * Retain contraction.                          */for (int i = 0; i < n; i++) {  			_p [i + _ihi * n] = _p2Star [i];  		}  		_y [_ihi] = _y2Star;  	}  	/*                      * Contraction on the reflection side of the centroid.                      */else if (_l == 1) {  		for (int i = 0; i < n; i++) {  			_p2Star [i] = _pbar [i] + ccoeff * (_pstar [i] - _pbar [i]);  		}  		_y2Star = Fn (_p2Star);  		/*                          * Retain reflection?                          */if (_y2Star <= _ystar) {  			for (int i = 0; i < n; i++) {  				_p [i + _ihi * n] = _p2Star [i];  			}  			_y [_ihi] = _y2Star;  		}  		else {  			for (int i = 0; i < n; i++) {  				_p [i + _ihi * n] = _pstar [i];  			}  			_y [_ihi] = _ystar;  		}  	}  }  
Magic Number,Encog.Neural.Networks.Training.NM,NelderMeadTraining,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,Iteration,The following statement contains a magic number: if (1 < _l) {  	for (int i = 0; i < n; i++) {  		_p [i + _ihi * n] = _pstar [i];  	}  	_y [_ihi] = _ystar;  }  /*                      * Contraction on the Y(IHI) side of the centroid.                      */else if (_l == 0) {  	for (int i = 0; i < n; i++) {  		_p2Star [i] = _pbar [i] + ccoeff * (_p [i + _ihi * n] - _pbar [i]);  	}  	_y2Star = Fn (_p2Star);  	/*                          * Contract the whole simplex.                          */if (_y [_ihi] < _y2Star) {  		for (int j = 0; j < _nn; j++) {  			for (int i = 0; i < n; i++) {  				_p [i + j * n] = (_p [i + j * n] + _p [i + _ilo * n]) * 0.5;  				_trainedWeights [i] = _p [i + j * n];  			}  			_y [j] = Fn (_trainedWeights);  		}  		_ylo = _y [0];  		_ilo = 0;  		for (int i = 1; i < _nn; i++) {  			if (_y [i] < _ylo) {  				_ylo = _y [i];  				_ilo = i;  			}  		}  		continue;  	}  	/*                          * Retain contraction.                          */for (int i = 0; i < n; i++) {  		_p [i + _ihi * n] = _p2Star [i];  	}  	_y [_ihi] = _y2Star;  }  /*                      * Contraction on the reflection side of the centroid.                      */else if (_l == 1) {  	for (int i = 0; i < n; i++) {  		_p2Star [i] = _pbar [i] + ccoeff * (_pstar [i] - _pbar [i]);  	}  	_y2Star = Fn (_p2Star);  	/*                          * Retain reflection?                          */if (_y2Star <= _ystar) {  		for (int i = 0; i < n; i++) {  			_p [i + _ihi * n] = _p2Star [i];  		}  		_y [_ihi] = _y2Star;  	}  	else {  		for (int i = 0; i < n; i++) {  			_p [i + _ihi * n] = _pstar [i];  		}  		_y [_ihi] = _ystar;  	}  }  
Magic Number,Encog.Neural.Networks.Training.NM,NelderMeadTraining,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,Iteration,The following statement contains a magic number: if (_l == 0) {  	for (int i = 0; i < n; i++) {  		_p2Star [i] = _pbar [i] + ccoeff * (_p [i + _ihi * n] - _pbar [i]);  	}  	_y2Star = Fn (_p2Star);  	/*                          * Contract the whole simplex.                          */if (_y [_ihi] < _y2Star) {  		for (int j = 0; j < _nn; j++) {  			for (int i = 0; i < n; i++) {  				_p [i + j * n] = (_p [i + j * n] + _p [i + _ilo * n]) * 0.5;  				_trainedWeights [i] = _p [i + j * n];  			}  			_y [j] = Fn (_trainedWeights);  		}  		_ylo = _y [0];  		_ilo = 0;  		for (int i = 1; i < _nn; i++) {  			if (_y [i] < _ylo) {  				_ylo = _y [i];  				_ilo = i;  			}  		}  		continue;  	}  	/*                          * Retain contraction.                          */for (int i = 0; i < n; i++) {  		_p [i + _ihi * n] = _p2Star [i];  	}  	_y [_ihi] = _y2Star;  }  /*                      * Contraction on the reflection side of the centroid.                      */else if (_l == 1) {  	for (int i = 0; i < n; i++) {  		_p2Star [i] = _pbar [i] + ccoeff * (_pstar [i] - _pbar [i]);  	}  	_y2Star = Fn (_p2Star);  	/*                          * Retain reflection?                          */if (_y2Star <= _ystar) {  		for (int i = 0; i < n; i++) {  			_p [i + _ihi * n] = _p2Star [i];  		}  		_y [_ihi] = _y2Star;  	}  	else {  		for (int i = 0; i < n; i++) {  			_p [i + _ihi * n] = _pstar [i];  		}  		_y [_ihi] = _ystar;  	}  }  
Magic Number,Encog.Neural.Networks.Training.NM,NelderMeadTraining,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,Iteration,The following statement contains a magic number: if (_y [_ihi] < _y2Star) {  	for (int j = 0; j < _nn; j++) {  		for (int i = 0; i < n; i++) {  			_p [i + j * n] = (_p [i + j * n] + _p [i + _ilo * n]) * 0.5;  			_trainedWeights [i] = _p [i + j * n];  		}  		_y [j] = Fn (_trainedWeights);  	}  	_ylo = _y [0];  	_ilo = 0;  	for (int i = 1; i < _nn; i++) {  		if (_y [i] < _ylo) {  			_ylo = _y [i];  			_ilo = i;  		}  	}  	continue;  }  
Magic Number,Encog.Neural.Networks.Training.NM,NelderMeadTraining,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,Iteration,The following statement contains a magic number: for (int j = 0; j < _nn; j++) {  	for (int i = 0; i < n; i++) {  		_p [i + j * n] = (_p [i + j * n] + _p [i + _ilo * n]) * 0.5;  		_trainedWeights [i] = _p [i + j * n];  	}  	_y [j] = Fn (_trainedWeights);  }  
Magic Number,Encog.Neural.Networks.Training.NM,NelderMeadTraining,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,Iteration,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	_p [i + j * n] = (_p [i + j * n] + _p [i + _ilo * n]) * 0.5;  	_trainedWeights [i] = _p [i + j * n];  }  
Magic Number,Encog.Neural.Networks.Training.NM,NelderMeadTraining,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,Iteration,The following statement contains a magic number: _p [i + j * n] = (_p [i + j * n] + _p [i + _ilo * n]) * 0.5;  
Magic Number,Encog.Neural.Networks.Training.NM,NelderMeadTraining,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,Iteration,The following statement contains a magic number: for (int i = 0; i < _nn; i++) {  	_z = _z + Math.Pow (_y [i] - x' 2);  }  
Magic Number,Encog.Neural.Networks.Training.NM,NelderMeadTraining,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,Iteration,The following statement contains a magic number: _z = _z + Math.Pow (_y [i] - x' 2);  
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: for (int iteration = 0; iteration < maxIterations; iteration++) {  	if (fbest < maxError) {  		break;  	}  	EncogLogging.Log (EncogLogging.LevelInfo' "Beginning internal Iteration #" + iteration + "' currentError=" + fbest + "'target=" + maxError);  	// Check for convergence  	double toler;  	if (prevBest <= 1.0d) {  		toler = tol;  	}  	else {  		toler = tol * prevBest;  	}  	// Stop if there is little improvement  	if ((prevBest - fbest) <= toler) {  		if (++convergenceCounter >= 3) {  			break;  		}  	}  	else {  		convergenceCounter = 0;  	}  	double dot2 = 0;  	double dlen = 0;  	double dot1 = dot2 = dlen = 0.0d;  	double high = 1.0e-4d;  	for (int i = 0; i < n; i++) {  		bs [i] = x [i];  		if (deriv2 [i] > high) {  			high = deriv2 [i];  		}  		dot1 += direc [i] * g [i];  		// Directional first derivative  		dot2 += direc [i] * direc [i] * deriv2 [i];  		// and second  		dlen += direc [i] * direc [i];  		// Length of search vector  	}  	double scale;  	if (Math.Abs (dot2) < EncogFramework.DefaultDoubleEqual) {  		scale = 0;  	}  	else {  		scale = dot1 / dot2;  	}  	high = 1.5d / high;  	if (high < 1.0e-4d) {  		high = 1.0e-4d;  	}  	if (scale < 0.0d) {  		scale = high;  	}  	else if (scale < 0.1d * high) {  		scale = 0.1d * high;  	}  	else if (scale > 10.0d * high) {  		scale = 10.0d * high;  	}  	prevBest = fbest;  	globalMinimum.Y2 = fbest;  	globalMinimum.FindBestRange (0.0d' 2.0d * scale' -3' false' maxError' network);  	if (globalMinimum.Y2 < maxError) {  		if (globalMinimum.Y2 < fbest) {  			for (int i = 0; i < n; i++) {  				x [i] = bs [i] + globalMinimum.Y2 * direc [i];  				if (x [i] < 1.0e-10d) {  					x [i] = 1.0e-10d;  				}  			}  			fbest = globalMinimum.Y2;  		}  		else {  			for (int i = 0; i < n; i++) {  				x [i] = bs [i];  			}  		}  		break;  	}  	if (convergenceCounter > 0) {  		fbest = globalMinimum.Brentmin (20' maxError' eps' 1.0e-7d' network' globalMinimum.Y2);  	}  	else {  		fbest = globalMinimum.Brentmin (10' maxError' 1.0e-6d' 1.0e-5d' network' globalMinimum.Y2);  	}  	for (int i = 0; i < n; i++) {  		x [i] = bs [i] + globalMinimum.X2 * direc [i];  		if (x [i] < 1.0e-10d) {  			x [i] = 1.0e-10d;  		}  	}  	double improvement = (prevBest - fbest) / prevBest;  	if (fbest < maxError) {  		break;  	}  	for (int i = 0; i < n; i++) {  		direc [i] = -direc [i];  		// negative gradient  	}  	double gam = Gamma (n' g' direc);  	if (gam < 0.0d) {  		gam = 0.0d;  	}  	if (gam > 10.0d) {  		gam = 10.0d;  	}  	if (improvement < 0.001d) {  		++poorCj;  	}  	else {  		poorCj = 0;  	}  	if (poorCj >= 2) {  		if (gam > 1.0d) {  			gam = 1.0d;  		}  	}  	if (poorCj >= 6) {  		poorCj = 0;  		gam = 0.0d;  	}  	FindNewDir (n' gam' g' h' direc);  }  
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: for (int iteration = 0; iteration < maxIterations; iteration++) {  	if (fbest < maxError) {  		break;  	}  	EncogLogging.Log (EncogLogging.LevelInfo' "Beginning internal Iteration #" + iteration + "' currentError=" + fbest + "'target=" + maxError);  	// Check for convergence  	double toler;  	if (prevBest <= 1.0d) {  		toler = tol;  	}  	else {  		toler = tol * prevBest;  	}  	// Stop if there is little improvement  	if ((prevBest - fbest) <= toler) {  		if (++convergenceCounter >= 3) {  			break;  		}  	}  	else {  		convergenceCounter = 0;  	}  	double dot2 = 0;  	double dlen = 0;  	double dot1 = dot2 = dlen = 0.0d;  	double high = 1.0e-4d;  	for (int i = 0; i < n; i++) {  		bs [i] = x [i];  		if (deriv2 [i] > high) {  			high = deriv2 [i];  		}  		dot1 += direc [i] * g [i];  		// Directional first derivative  		dot2 += direc [i] * direc [i] * deriv2 [i];  		// and second  		dlen += direc [i] * direc [i];  		// Length of search vector  	}  	double scale;  	if (Math.Abs (dot2) < EncogFramework.DefaultDoubleEqual) {  		scale = 0;  	}  	else {  		scale = dot1 / dot2;  	}  	high = 1.5d / high;  	if (high < 1.0e-4d) {  		high = 1.0e-4d;  	}  	if (scale < 0.0d) {  		scale = high;  	}  	else if (scale < 0.1d * high) {  		scale = 0.1d * high;  	}  	else if (scale > 10.0d * high) {  		scale = 10.0d * high;  	}  	prevBest = fbest;  	globalMinimum.Y2 = fbest;  	globalMinimum.FindBestRange (0.0d' 2.0d * scale' -3' false' maxError' network);  	if (globalMinimum.Y2 < maxError) {  		if (globalMinimum.Y2 < fbest) {  			for (int i = 0; i < n; i++) {  				x [i] = bs [i] + globalMinimum.Y2 * direc [i];  				if (x [i] < 1.0e-10d) {  					x [i] = 1.0e-10d;  				}  			}  			fbest = globalMinimum.Y2;  		}  		else {  			for (int i = 0; i < n; i++) {  				x [i] = bs [i];  			}  		}  		break;  	}  	if (convergenceCounter > 0) {  		fbest = globalMinimum.Brentmin (20' maxError' eps' 1.0e-7d' network' globalMinimum.Y2);  	}  	else {  		fbest = globalMinimum.Brentmin (10' maxError' 1.0e-6d' 1.0e-5d' network' globalMinimum.Y2);  	}  	for (int i = 0; i < n; i++) {  		x [i] = bs [i] + globalMinimum.X2 * direc [i];  		if (x [i] < 1.0e-10d) {  			x [i] = 1.0e-10d;  		}  	}  	double improvement = (prevBest - fbest) / prevBest;  	if (fbest < maxError) {  		break;  	}  	for (int i = 0; i < n; i++) {  		direc [i] = -direc [i];  		// negative gradient  	}  	double gam = Gamma (n' g' direc);  	if (gam < 0.0d) {  		gam = 0.0d;  	}  	if (gam > 10.0d) {  		gam = 10.0d;  	}  	if (improvement < 0.001d) {  		++poorCj;  	}  	else {  		poorCj = 0;  	}  	if (poorCj >= 2) {  		if (gam > 1.0d) {  			gam = 1.0d;  		}  	}  	if (poorCj >= 6) {  		poorCj = 0;  		gam = 0.0d;  	}  	FindNewDir (n' gam' g' h' direc);  }  
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: for (int iteration = 0; iteration < maxIterations; iteration++) {  	if (fbest < maxError) {  		break;  	}  	EncogLogging.Log (EncogLogging.LevelInfo' "Beginning internal Iteration #" + iteration + "' currentError=" + fbest + "'target=" + maxError);  	// Check for convergence  	double toler;  	if (prevBest <= 1.0d) {  		toler = tol;  	}  	else {  		toler = tol * prevBest;  	}  	// Stop if there is little improvement  	if ((prevBest - fbest) <= toler) {  		if (++convergenceCounter >= 3) {  			break;  		}  	}  	else {  		convergenceCounter = 0;  	}  	double dot2 = 0;  	double dlen = 0;  	double dot1 = dot2 = dlen = 0.0d;  	double high = 1.0e-4d;  	for (int i = 0; i < n; i++) {  		bs [i] = x [i];  		if (deriv2 [i] > high) {  			high = deriv2 [i];  		}  		dot1 += direc [i] * g [i];  		// Directional first derivative  		dot2 += direc [i] * direc [i] * deriv2 [i];  		// and second  		dlen += direc [i] * direc [i];  		// Length of search vector  	}  	double scale;  	if (Math.Abs (dot2) < EncogFramework.DefaultDoubleEqual) {  		scale = 0;  	}  	else {  		scale = dot1 / dot2;  	}  	high = 1.5d / high;  	if (high < 1.0e-4d) {  		high = 1.0e-4d;  	}  	if (scale < 0.0d) {  		scale = high;  	}  	else if (scale < 0.1d * high) {  		scale = 0.1d * high;  	}  	else if (scale > 10.0d * high) {  		scale = 10.0d * high;  	}  	prevBest = fbest;  	globalMinimum.Y2 = fbest;  	globalMinimum.FindBestRange (0.0d' 2.0d * scale' -3' false' maxError' network);  	if (globalMinimum.Y2 < maxError) {  		if (globalMinimum.Y2 < fbest) {  			for (int i = 0; i < n; i++) {  				x [i] = bs [i] + globalMinimum.Y2 * direc [i];  				if (x [i] < 1.0e-10d) {  					x [i] = 1.0e-10d;  				}  			}  			fbest = globalMinimum.Y2;  		}  		else {  			for (int i = 0; i < n; i++) {  				x [i] = bs [i];  			}  		}  		break;  	}  	if (convergenceCounter > 0) {  		fbest = globalMinimum.Brentmin (20' maxError' eps' 1.0e-7d' network' globalMinimum.Y2);  	}  	else {  		fbest = globalMinimum.Brentmin (10' maxError' 1.0e-6d' 1.0e-5d' network' globalMinimum.Y2);  	}  	for (int i = 0; i < n; i++) {  		x [i] = bs [i] + globalMinimum.X2 * direc [i];  		if (x [i] < 1.0e-10d) {  			x [i] = 1.0e-10d;  		}  	}  	double improvement = (prevBest - fbest) / prevBest;  	if (fbest < maxError) {  		break;  	}  	for (int i = 0; i < n; i++) {  		direc [i] = -direc [i];  		// negative gradient  	}  	double gam = Gamma (n' g' direc);  	if (gam < 0.0d) {  		gam = 0.0d;  	}  	if (gam > 10.0d) {  		gam = 10.0d;  	}  	if (improvement < 0.001d) {  		++poorCj;  	}  	else {  		poorCj = 0;  	}  	if (poorCj >= 2) {  		if (gam > 1.0d) {  			gam = 1.0d;  		}  	}  	if (poorCj >= 6) {  		poorCj = 0;  		gam = 0.0d;  	}  	FindNewDir (n' gam' g' h' direc);  }  
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: for (int iteration = 0; iteration < maxIterations; iteration++) {  	if (fbest < maxError) {  		break;  	}  	EncogLogging.Log (EncogLogging.LevelInfo' "Beginning internal Iteration #" + iteration + "' currentError=" + fbest + "'target=" + maxError);  	// Check for convergence  	double toler;  	if (prevBest <= 1.0d) {  		toler = tol;  	}  	else {  		toler = tol * prevBest;  	}  	// Stop if there is little improvement  	if ((prevBest - fbest) <= toler) {  		if (++convergenceCounter >= 3) {  			break;  		}  	}  	else {  		convergenceCounter = 0;  	}  	double dot2 = 0;  	double dlen = 0;  	double dot1 = dot2 = dlen = 0.0d;  	double high = 1.0e-4d;  	for (int i = 0; i < n; i++) {  		bs [i] = x [i];  		if (deriv2 [i] > high) {  			high = deriv2 [i];  		}  		dot1 += direc [i] * g [i];  		// Directional first derivative  		dot2 += direc [i] * direc [i] * deriv2 [i];  		// and second  		dlen += direc [i] * direc [i];  		// Length of search vector  	}  	double scale;  	if (Math.Abs (dot2) < EncogFramework.DefaultDoubleEqual) {  		scale = 0;  	}  	else {  		scale = dot1 / dot2;  	}  	high = 1.5d / high;  	if (high < 1.0e-4d) {  		high = 1.0e-4d;  	}  	if (scale < 0.0d) {  		scale = high;  	}  	else if (scale < 0.1d * high) {  		scale = 0.1d * high;  	}  	else if (scale > 10.0d * high) {  		scale = 10.0d * high;  	}  	prevBest = fbest;  	globalMinimum.Y2 = fbest;  	globalMinimum.FindBestRange (0.0d' 2.0d * scale' -3' false' maxError' network);  	if (globalMinimum.Y2 < maxError) {  		if (globalMinimum.Y2 < fbest) {  			for (int i = 0; i < n; i++) {  				x [i] = bs [i] + globalMinimum.Y2 * direc [i];  				if (x [i] < 1.0e-10d) {  					x [i] = 1.0e-10d;  				}  			}  			fbest = globalMinimum.Y2;  		}  		else {  			for (int i = 0; i < n; i++) {  				x [i] = bs [i];  			}  		}  		break;  	}  	if (convergenceCounter > 0) {  		fbest = globalMinimum.Brentmin (20' maxError' eps' 1.0e-7d' network' globalMinimum.Y2);  	}  	else {  		fbest = globalMinimum.Brentmin (10' maxError' 1.0e-6d' 1.0e-5d' network' globalMinimum.Y2);  	}  	for (int i = 0; i < n; i++) {  		x [i] = bs [i] + globalMinimum.X2 * direc [i];  		if (x [i] < 1.0e-10d) {  			x [i] = 1.0e-10d;  		}  	}  	double improvement = (prevBest - fbest) / prevBest;  	if (fbest < maxError) {  		break;  	}  	for (int i = 0; i < n; i++) {  		direc [i] = -direc [i];  		// negative gradient  	}  	double gam = Gamma (n' g' direc);  	if (gam < 0.0d) {  		gam = 0.0d;  	}  	if (gam > 10.0d) {  		gam = 10.0d;  	}  	if (improvement < 0.001d) {  		++poorCj;  	}  	else {  		poorCj = 0;  	}  	if (poorCj >= 2) {  		if (gam > 1.0d) {  			gam = 1.0d;  		}  	}  	if (poorCj >= 6) {  		poorCj = 0;  		gam = 0.0d;  	}  	FindNewDir (n' gam' g' h' direc);  }  
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: for (int iteration = 0; iteration < maxIterations; iteration++) {  	if (fbest < maxError) {  		break;  	}  	EncogLogging.Log (EncogLogging.LevelInfo' "Beginning internal Iteration #" + iteration + "' currentError=" + fbest + "'target=" + maxError);  	// Check for convergence  	double toler;  	if (prevBest <= 1.0d) {  		toler = tol;  	}  	else {  		toler = tol * prevBest;  	}  	// Stop if there is little improvement  	if ((prevBest - fbest) <= toler) {  		if (++convergenceCounter >= 3) {  			break;  		}  	}  	else {  		convergenceCounter = 0;  	}  	double dot2 = 0;  	double dlen = 0;  	double dot1 = dot2 = dlen = 0.0d;  	double high = 1.0e-4d;  	for (int i = 0; i < n; i++) {  		bs [i] = x [i];  		if (deriv2 [i] > high) {  			high = deriv2 [i];  		}  		dot1 += direc [i] * g [i];  		// Directional first derivative  		dot2 += direc [i] * direc [i] * deriv2 [i];  		// and second  		dlen += direc [i] * direc [i];  		// Length of search vector  	}  	double scale;  	if (Math.Abs (dot2) < EncogFramework.DefaultDoubleEqual) {  		scale = 0;  	}  	else {  		scale = dot1 / dot2;  	}  	high = 1.5d / high;  	if (high < 1.0e-4d) {  		high = 1.0e-4d;  	}  	if (scale < 0.0d) {  		scale = high;  	}  	else if (scale < 0.1d * high) {  		scale = 0.1d * high;  	}  	else if (scale > 10.0d * high) {  		scale = 10.0d * high;  	}  	prevBest = fbest;  	globalMinimum.Y2 = fbest;  	globalMinimum.FindBestRange (0.0d' 2.0d * scale' -3' false' maxError' network);  	if (globalMinimum.Y2 < maxError) {  		if (globalMinimum.Y2 < fbest) {  			for (int i = 0; i < n; i++) {  				x [i] = bs [i] + globalMinimum.Y2 * direc [i];  				if (x [i] < 1.0e-10d) {  					x [i] = 1.0e-10d;  				}  			}  			fbest = globalMinimum.Y2;  		}  		else {  			for (int i = 0; i < n; i++) {  				x [i] = bs [i];  			}  		}  		break;  	}  	if (convergenceCounter > 0) {  		fbest = globalMinimum.Brentmin (20' maxError' eps' 1.0e-7d' network' globalMinimum.Y2);  	}  	else {  		fbest = globalMinimum.Brentmin (10' maxError' 1.0e-6d' 1.0e-5d' network' globalMinimum.Y2);  	}  	for (int i = 0; i < n; i++) {  		x [i] = bs [i] + globalMinimum.X2 * direc [i];  		if (x [i] < 1.0e-10d) {  			x [i] = 1.0e-10d;  		}  	}  	double improvement = (prevBest - fbest) / prevBest;  	if (fbest < maxError) {  		break;  	}  	for (int i = 0; i < n; i++) {  		direc [i] = -direc [i];  		// negative gradient  	}  	double gam = Gamma (n' g' direc);  	if (gam < 0.0d) {  		gam = 0.0d;  	}  	if (gam > 10.0d) {  		gam = 10.0d;  	}  	if (improvement < 0.001d) {  		++poorCj;  	}  	else {  		poorCj = 0;  	}  	if (poorCj >= 2) {  		if (gam > 1.0d) {  			gam = 1.0d;  		}  	}  	if (poorCj >= 6) {  		poorCj = 0;  		gam = 0.0d;  	}  	FindNewDir (n' gam' g' h' direc);  }  
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: for (int iteration = 0; iteration < maxIterations; iteration++) {  	if (fbest < maxError) {  		break;  	}  	EncogLogging.Log (EncogLogging.LevelInfo' "Beginning internal Iteration #" + iteration + "' currentError=" + fbest + "'target=" + maxError);  	// Check for convergence  	double toler;  	if (prevBest <= 1.0d) {  		toler = tol;  	}  	else {  		toler = tol * prevBest;  	}  	// Stop if there is little improvement  	if ((prevBest - fbest) <= toler) {  		if (++convergenceCounter >= 3) {  			break;  		}  	}  	else {  		convergenceCounter = 0;  	}  	double dot2 = 0;  	double dlen = 0;  	double dot1 = dot2 = dlen = 0.0d;  	double high = 1.0e-4d;  	for (int i = 0; i < n; i++) {  		bs [i] = x [i];  		if (deriv2 [i] > high) {  			high = deriv2 [i];  		}  		dot1 += direc [i] * g [i];  		// Directional first derivative  		dot2 += direc [i] * direc [i] * deriv2 [i];  		// and second  		dlen += direc [i] * direc [i];  		// Length of search vector  	}  	double scale;  	if (Math.Abs (dot2) < EncogFramework.DefaultDoubleEqual) {  		scale = 0;  	}  	else {  		scale = dot1 / dot2;  	}  	high = 1.5d / high;  	if (high < 1.0e-4d) {  		high = 1.0e-4d;  	}  	if (scale < 0.0d) {  		scale = high;  	}  	else if (scale < 0.1d * high) {  		scale = 0.1d * high;  	}  	else if (scale > 10.0d * high) {  		scale = 10.0d * high;  	}  	prevBest = fbest;  	globalMinimum.Y2 = fbest;  	globalMinimum.FindBestRange (0.0d' 2.0d * scale' -3' false' maxError' network);  	if (globalMinimum.Y2 < maxError) {  		if (globalMinimum.Y2 < fbest) {  			for (int i = 0; i < n; i++) {  				x [i] = bs [i] + globalMinimum.Y2 * direc [i];  				if (x [i] < 1.0e-10d) {  					x [i] = 1.0e-10d;  				}  			}  			fbest = globalMinimum.Y2;  		}  		else {  			for (int i = 0; i < n; i++) {  				x [i] = bs [i];  			}  		}  		break;  	}  	if (convergenceCounter > 0) {  		fbest = globalMinimum.Brentmin (20' maxError' eps' 1.0e-7d' network' globalMinimum.Y2);  	}  	else {  		fbest = globalMinimum.Brentmin (10' maxError' 1.0e-6d' 1.0e-5d' network' globalMinimum.Y2);  	}  	for (int i = 0; i < n; i++) {  		x [i] = bs [i] + globalMinimum.X2 * direc [i];  		if (x [i] < 1.0e-10d) {  			x [i] = 1.0e-10d;  		}  	}  	double improvement = (prevBest - fbest) / prevBest;  	if (fbest < maxError) {  		break;  	}  	for (int i = 0; i < n; i++) {  		direc [i] = -direc [i];  		// negative gradient  	}  	double gam = Gamma (n' g' direc);  	if (gam < 0.0d) {  		gam = 0.0d;  	}  	if (gam > 10.0d) {  		gam = 10.0d;  	}  	if (improvement < 0.001d) {  		++poorCj;  	}  	else {  		poorCj = 0;  	}  	if (poorCj >= 2) {  		if (gam > 1.0d) {  			gam = 1.0d;  		}  	}  	if (poorCj >= 6) {  		poorCj = 0;  		gam = 0.0d;  	}  	FindNewDir (n' gam' g' h' direc);  }  
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: if ((prevBest - fbest) <= toler) {  	if (++convergenceCounter >= 3) {  		break;  	}  }  else {  	convergenceCounter = 0;  }  
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: if (++convergenceCounter >= 3) {  	break;  }  
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: globalMinimum.FindBestRange (0.0d' 2.0d * scale' -3' false' maxError' network);  
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: if (convergenceCounter > 0) {  	fbest = globalMinimum.Brentmin (20' maxError' eps' 1.0e-7d' network' globalMinimum.Y2);  }  else {  	fbest = globalMinimum.Brentmin (10' maxError' 1.0e-6d' 1.0e-5d' network' globalMinimum.Y2);  }  
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: if (convergenceCounter > 0) {  	fbest = globalMinimum.Brentmin (20' maxError' eps' 1.0e-7d' network' globalMinimum.Y2);  }  else {  	fbest = globalMinimum.Brentmin (10' maxError' 1.0e-6d' 1.0e-5d' network' globalMinimum.Y2);  }  
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: fbest = globalMinimum.Brentmin (20' maxError' eps' 1.0e-7d' network' globalMinimum.Y2);  
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: fbest = globalMinimum.Brentmin (10' maxError' 1.0e-6d' 1.0e-5d' network' globalMinimum.Y2);  
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: if (poorCj >= 2) {  	if (gam > 1.0d) {  		gam = 1.0d;  	}  }  
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: if (poorCj >= 6) {  	poorCj = 0;  	gam = 0.0d;  }  
Magic Number,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The following statement contains a magic number: for (int iter = 0; iter < maxIterations; iter++) {  	// Have we reached an acceptable error?  	if (fbest < maxError) {  		break;  	}  	double xmid = 0.5d * (xlow + xhigh);  	double tol1 = tol * (Math.Abs (xbest) + eps);  	double tol2 = 2.0 * tol1;  	// See if xlow is close relative to tol2'  	// Also' that that xbest is near the midpoint.  	if (Math.Abs (xbest - xmid) <= (tol2 - 0.5d * (xhigh - xlow))) {  		break;  	}  	// Don't go to close to eps' the machine precision.  	if ((iter >= 2) && ((fthirdbest - fbest) < eps)) {  		break;  	}  	double xrecent = 0;  	// Try parabolic fit' if we moved far enough.  	if (Math.Abs (prevdist) > tol1) {  		// Temps holders for the parabolic estimate  		double t1 = (xbest - x2ndBest) * (fbest - fthirdbest);  		double t2 = (xbest - x3rdBest) * (fbest - fsecbest);  		double numer = (xbest - x3rdBest) * t2 - (xbest - x2ndBest) * t1;  		double denom = 2.0 * (t1 - t2);  		double testdist = prevdist;  		prevdist = step;  		// This is the parabolic estimate to min.  		if (denom != 0.0d) {  			step = numer / denom;  		}  		else {  			// test failed.  			step = 1.0e30d;  		}  		// If shrinking' and within bounds' then use the parabolic  		// estimate.  		if ((Math.Abs (step) < Math.Abs (0.5d * testdist)) && (step + xbest > xlow) && (step + xbest < xhigh)) {  			xrecent = xbest + step;  			// If very close to known bounds.  			if ((xrecent - xlow < tol2) || (xhigh - xrecent < tol2)) {  				if (xbest < xmid) {  					step = tol1;  				}  				else {  					step = -tol1;  				}  			}  		}  		else {  			// Parabolic estimate poor' so use golden section  			prevdist = (xbest >= xmid) ? xlow - xbest : xhigh - xbest;  			step = Cgold * prevdist;  		}  	}  	else {  		// prevdist did not exceed tol1: we did not move far  		// enough  		// to justify a parabolic fit. Use golden section.  		prevdist = (xbest >= xmid) ? xlow - xbest : xhigh - xbest;  		step = .3819660d * prevdist;  	}  	if (Math.Abs (step) >= tol1) {  		xrecent = xbest + step;  		// another trial we must move a  	}  	else {  		// decent distance.  		if (step > 0.0) {  			xrecent = xbest + tol1;  		}  		else {  			xrecent = xbest - tol1;  		}  	}  	/* 				 * At long last we have a trial point 'xrecent'. Evaluate the 				 * function. 				 */double frecent = network.CalcErrorWithSingleSigma (xrecent);  	if (frecent < 0.0d) {  		break;  	}  	if (frecent <= fbest) {  		// If we improved...  		if (xrecent >= xbest) {  			xlow = xbest;  			// replacing the appropriate endpoint  		}  		else {  			xhigh = xbest;  		}  		x3rdBest = x2ndBest;  		// Update x and f values for best'  		x2ndBest = xbest;  		// second and third best  		xbest = xrecent;  		fthirdbest = fsecbest;  		fsecbest = fbest;  		fbest = frecent;  	}  	else {  		// We did not improve  		if (xrecent < xbest) {  			xlow = xrecent;  			// replacing the appropriate endpoint  		}  		else {  			xhigh = xrecent;  		}  		if ((frecent <= fsecbest) || (x2ndBest == xbest)) {  			x3rdBest = x2ndBest;  			x2ndBest = xrecent;  			fthirdbest = fsecbest;  			fsecbest = frecent;  		}  		else if ((frecent <= fthirdbest) || (x3rdBest == xbest) || (x3rdBest == x2ndBest)) {  			x3rdBest = xrecent;  			fthirdbest = frecent;  		}  	}  }  
Magic Number,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The following statement contains a magic number: for (int iter = 0; iter < maxIterations; iter++) {  	// Have we reached an acceptable error?  	if (fbest < maxError) {  		break;  	}  	double xmid = 0.5d * (xlow + xhigh);  	double tol1 = tol * (Math.Abs (xbest) + eps);  	double tol2 = 2.0 * tol1;  	// See if xlow is close relative to tol2'  	// Also' that that xbest is near the midpoint.  	if (Math.Abs (xbest - xmid) <= (tol2 - 0.5d * (xhigh - xlow))) {  		break;  	}  	// Don't go to close to eps' the machine precision.  	if ((iter >= 2) && ((fthirdbest - fbest) < eps)) {  		break;  	}  	double xrecent = 0;  	// Try parabolic fit' if we moved far enough.  	if (Math.Abs (prevdist) > tol1) {  		// Temps holders for the parabolic estimate  		double t1 = (xbest - x2ndBest) * (fbest - fthirdbest);  		double t2 = (xbest - x3rdBest) * (fbest - fsecbest);  		double numer = (xbest - x3rdBest) * t2 - (xbest - x2ndBest) * t1;  		double denom = 2.0 * (t1 - t2);  		double testdist = prevdist;  		prevdist = step;  		// This is the parabolic estimate to min.  		if (denom != 0.0d) {  			step = numer / denom;  		}  		else {  			// test failed.  			step = 1.0e30d;  		}  		// If shrinking' and within bounds' then use the parabolic  		// estimate.  		if ((Math.Abs (step) < Math.Abs (0.5d * testdist)) && (step + xbest > xlow) && (step + xbest < xhigh)) {  			xrecent = xbest + step;  			// If very close to known bounds.  			if ((xrecent - xlow < tol2) || (xhigh - xrecent < tol2)) {  				if (xbest < xmid) {  					step = tol1;  				}  				else {  					step = -tol1;  				}  			}  		}  		else {  			// Parabolic estimate poor' so use golden section  			prevdist = (xbest >= xmid) ? xlow - xbest : xhigh - xbest;  			step = Cgold * prevdist;  		}  	}  	else {  		// prevdist did not exceed tol1: we did not move far  		// enough  		// to justify a parabolic fit. Use golden section.  		prevdist = (xbest >= xmid) ? xlow - xbest : xhigh - xbest;  		step = .3819660d * prevdist;  	}  	if (Math.Abs (step) >= tol1) {  		xrecent = xbest + step;  		// another trial we must move a  	}  	else {  		// decent distance.  		if (step > 0.0) {  			xrecent = xbest + tol1;  		}  		else {  			xrecent = xbest - tol1;  		}  	}  	/* 				 * At long last we have a trial point 'xrecent'. Evaluate the 				 * function. 				 */double frecent = network.CalcErrorWithSingleSigma (xrecent);  	if (frecent < 0.0d) {  		break;  	}  	if (frecent <= fbest) {  		// If we improved...  		if (xrecent >= xbest) {  			xlow = xbest;  			// replacing the appropriate endpoint  		}  		else {  			xhigh = xbest;  		}  		x3rdBest = x2ndBest;  		// Update x and f values for best'  		x2ndBest = xbest;  		// second and third best  		xbest = xrecent;  		fthirdbest = fsecbest;  		fsecbest = fbest;  		fbest = frecent;  	}  	else {  		// We did not improve  		if (xrecent < xbest) {  			xlow = xrecent;  			// replacing the appropriate endpoint  		}  		else {  			xhigh = xrecent;  		}  		if ((frecent <= fsecbest) || (x2ndBest == xbest)) {  			x3rdBest = x2ndBest;  			x2ndBest = xrecent;  			fthirdbest = fsecbest;  			fsecbest = frecent;  		}  		else if ((frecent <= fthirdbest) || (x3rdBest == xbest) || (x3rdBest == x2ndBest)) {  			x3rdBest = xrecent;  			fthirdbest = frecent;  		}  	}  }  
Magic Number,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The following statement contains a magic number: for (int iter = 0; iter < maxIterations; iter++) {  	// Have we reached an acceptable error?  	if (fbest < maxError) {  		break;  	}  	double xmid = 0.5d * (xlow + xhigh);  	double tol1 = tol * (Math.Abs (xbest) + eps);  	double tol2 = 2.0 * tol1;  	// See if xlow is close relative to tol2'  	// Also' that that xbest is near the midpoint.  	if (Math.Abs (xbest - xmid) <= (tol2 - 0.5d * (xhigh - xlow))) {  		break;  	}  	// Don't go to close to eps' the machine precision.  	if ((iter >= 2) && ((fthirdbest - fbest) < eps)) {  		break;  	}  	double xrecent = 0;  	// Try parabolic fit' if we moved far enough.  	if (Math.Abs (prevdist) > tol1) {  		// Temps holders for the parabolic estimate  		double t1 = (xbest - x2ndBest) * (fbest - fthirdbest);  		double t2 = (xbest - x3rdBest) * (fbest - fsecbest);  		double numer = (xbest - x3rdBest) * t2 - (xbest - x2ndBest) * t1;  		double denom = 2.0 * (t1 - t2);  		double testdist = prevdist;  		prevdist = step;  		// This is the parabolic estimate to min.  		if (denom != 0.0d) {  			step = numer / denom;  		}  		else {  			// test failed.  			step = 1.0e30d;  		}  		// If shrinking' and within bounds' then use the parabolic  		// estimate.  		if ((Math.Abs (step) < Math.Abs (0.5d * testdist)) && (step + xbest > xlow) && (step + xbest < xhigh)) {  			xrecent = xbest + step;  			// If very close to known bounds.  			if ((xrecent - xlow < tol2) || (xhigh - xrecent < tol2)) {  				if (xbest < xmid) {  					step = tol1;  				}  				else {  					step = -tol1;  				}  			}  		}  		else {  			// Parabolic estimate poor' so use golden section  			prevdist = (xbest >= xmid) ? xlow - xbest : xhigh - xbest;  			step = Cgold * prevdist;  		}  	}  	else {  		// prevdist did not exceed tol1: we did not move far  		// enough  		// to justify a parabolic fit. Use golden section.  		prevdist = (xbest >= xmid) ? xlow - xbest : xhigh - xbest;  		step = .3819660d * prevdist;  	}  	if (Math.Abs (step) >= tol1) {  		xrecent = xbest + step;  		// another trial we must move a  	}  	else {  		// decent distance.  		if (step > 0.0) {  			xrecent = xbest + tol1;  		}  		else {  			xrecent = xbest - tol1;  		}  	}  	/* 				 * At long last we have a trial point 'xrecent'. Evaluate the 				 * function. 				 */double frecent = network.CalcErrorWithSingleSigma (xrecent);  	if (frecent < 0.0d) {  		break;  	}  	if (frecent <= fbest) {  		// If we improved...  		if (xrecent >= xbest) {  			xlow = xbest;  			// replacing the appropriate endpoint  		}  		else {  			xhigh = xbest;  		}  		x3rdBest = x2ndBest;  		// Update x and f values for best'  		x2ndBest = xbest;  		// second and third best  		xbest = xrecent;  		fthirdbest = fsecbest;  		fsecbest = fbest;  		fbest = frecent;  	}  	else {  		// We did not improve  		if (xrecent < xbest) {  			xlow = xrecent;  			// replacing the appropriate endpoint  		}  		else {  			xhigh = xrecent;  		}  		if ((frecent <= fsecbest) || (x2ndBest == xbest)) {  			x3rdBest = x2ndBest;  			x2ndBest = xrecent;  			fthirdbest = fsecbest;  			fsecbest = frecent;  		}  		else if ((frecent <= fthirdbest) || (x3rdBest == xbest) || (x3rdBest == x2ndBest)) {  			x3rdBest = xrecent;  			fthirdbest = frecent;  		}  	}  }  
Magic Number,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The following statement contains a magic number: if ((iter >= 2) && ((fthirdbest - fbest) < eps)) {  	break;  }  
Magic Number,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The following statement contains a magic number: if (Math.Abs (prevdist) > tol1) {  	// Temps holders for the parabolic estimate  	double t1 = (xbest - x2ndBest) * (fbest - fthirdbest);  	double t2 = (xbest - x3rdBest) * (fbest - fsecbest);  	double numer = (xbest - x3rdBest) * t2 - (xbest - x2ndBest) * t1;  	double denom = 2.0 * (t1 - t2);  	double testdist = prevdist;  	prevdist = step;  	// This is the parabolic estimate to min.  	if (denom != 0.0d) {  		step = numer / denom;  	}  	else {  		// test failed.  		step = 1.0e30d;  	}  	// If shrinking' and within bounds' then use the parabolic  	// estimate.  	if ((Math.Abs (step) < Math.Abs (0.5d * testdist)) && (step + xbest > xlow) && (step + xbest < xhigh)) {  		xrecent = xbest + step;  		// If very close to known bounds.  		if ((xrecent - xlow < tol2) || (xhigh - xrecent < tol2)) {  			if (xbest < xmid) {  				step = tol1;  			}  			else {  				step = -tol1;  			}  		}  	}  	else {  		// Parabolic estimate poor' so use golden section  		prevdist = (xbest >= xmid) ? xlow - xbest : xhigh - xbest;  		step = Cgold * prevdist;  	}  }  else {  	// prevdist did not exceed tol1: we did not move far  	// enough  	// to justify a parabolic fit. Use golden section.  	prevdist = (xbest >= xmid) ? xlow - xbest : xhigh - xbest;  	step = .3819660d * prevdist;  }  
Magic Number,Encog.Neural.Networks.Training.Propagation,Propagation,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\Propagation\Propagation.cs,Init,The following statement contains a magic number: if (FixFlatSpot) {  	for (int i = 0; i < _flat.ActivationFunctions.Length; i++) {  		IActivationFunction af = _flat.ActivationFunctions [i];  		if (af is ActivationSigmoid) {  			_flatSpot [i] = 0.1;  		}  		else {  			_flatSpot [i] = 0.0;  		}  	}  }  else {  	EngineArray.Fill (_flatSpot' 0.0);  }  
Magic Number,Encog.Neural.Networks.Training.Propagation,Propagation,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\Propagation\Propagation.cs,Init,The following statement contains a magic number: for (int i = 0; i < _flat.ActivationFunctions.Length; i++) {  	IActivationFunction af = _flat.ActivationFunctions [i];  	if (af is ActivationSigmoid) {  		_flatSpot [i] = 0.1;  	}  	else {  		_flatSpot [i] = 0.0;  	}  }  
Magic Number,Encog.Neural.Networks.Training.Propagation,Propagation,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\Propagation\Propagation.cs,Init,The following statement contains a magic number: if (af is ActivationSigmoid) {  	_flatSpot [i] = 0.1;  }  else {  	_flatSpot [i] = 0.0;  }  
Magic Number,Encog.Neural.Networks.Training.Propagation,Propagation,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\Propagation\Propagation.cs,Init,The following statement contains a magic number: _flatSpot [i] = 0.1;  
Magic Number,Encog.Neural.Networks.Training.Propagation.SCG,ScaledConjugateGradient,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\Propagation\SCG\ScaledConjugateGradient.cs,Iteration,The following statement contains a magic number: if (_delta <= 0) {  	_lambda2 = 2 * (_lambda - _delta / _magP);  	_delta = _lambda * _magP - _delta;  	_lambda = _lambda2;  }  
Magic Number,Encog.Neural.Networks.Training.Propagation.SCG,ScaledConjugateGradient,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\Propagation\SCG\ScaledConjugateGradient.cs,Iteration,The following statement contains a magic number: _lambda2 = 2 * (_lambda - _delta / _magP);  
Magic Number,Encog.Neural.Networks.Training.Simple,TrainAdaline,C:\repos\neismit_emds\encog-core-cs\Neural\Networks\Training\Simple\TrainAdaline.cs,TrainAdaline,The following statement contains a magic number: if (network.LayerCount > 2) {  	throw new NeuralNetworkError ("An ADALINE network only has two layers.");  }  
Magic Number,Encog.ML.Train.Strategy.End,EndMinutesStrategy,C:\repos\neismit_emds\encog-core-cs\ML\Train\Strategy\End\EndMinutesStrategy.cs,PostIteration,The following statement contains a magic number: lock (this) {  	long now = DateTime.Now.Millisecond;  	_minutesLeft = ((int)((now - _startedTime) / 60000));  }  
Magic Number,Encog.ML.Train.Strategy.End,EndMinutesStrategy,C:\repos\neismit_emds\encog-core-cs\ML\Train\Strategy\End\EndMinutesStrategy.cs,PostIteration,The following statement contains a magic number: _minutesLeft = ((int)((now - _startedTime) / 60000));  
Magic Number,Encog.Neural.Pattern,ART1Pattern,C:\repos\neismit_emds\encog-core-cs\Neural\Pattern\ART1Pattern.cs,ART1Pattern,The following statement contains a magic number: _c1 = 5;  
Magic Number,Encog.Neural.Pattern,ART1Pattern,C:\repos\neismit_emds\encog-core-cs\Neural\Pattern\ART1Pattern.cs,ART1Pattern,The following statement contains a magic number: _l = 3;  
Magic Number,Encog.Neural.Pattern,BoltzmannPattern,C:\repos\neismit_emds\encog-core-cs\Neural\Pattern\BoltzmannPattern.cs,BoltzmannPattern,The following statement contains a magic number: _annealCycles = 100;  
Magic Number,Encog.Neural.Pattern,BoltzmannPattern,C:\repos\neismit_emds\encog-core-cs\Neural\Pattern\BoltzmannPattern.cs,BoltzmannPattern,The following statement contains a magic number: _runCycles = 1000;  
Magic Number,Encog.Neural.PNN,AbstractPNN,C:\repos\neismit_emds\encog-core-cs\Neural\PNN\AbstractPNN.cs,AbstractPNN,The following statement contains a magic number: Error = -1000;  
Magic Number,Encog.Neural.Prune,PruneIncremental,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneIncremental.cs,Init,The following statement contains a magic number: if (_hidden.Count == 1) {  	_hidden1Size = (_hidden [0].Max - _hidden [0].Min) + 1;  	_hidden2Size = 0;  	_results = EngineArray.AllocateDouble2D (_hidden1Size' 1);  }  else if (_hidden.Count == 2) {  	// handle display for two layers  	_hidden1Size = (_hidden [0].Max - _hidden [0].Min) + 1;  	_hidden2Size = (_hidden [1].Max - _hidden [1].Min) + 1;  	_results = EngineArray.AllocateDouble2D (_hidden1Size' _hidden2Size);  }  else {  	// we don't handle displays for more than two layers  	_hidden1Size = 0;  	_hidden2Size = 0;  	_results = null;  }  
Magic Number,Encog.Neural.Prune,PruneIncremental,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneIncremental.cs,Init,The following statement contains a magic number: if (_hidden.Count == 2) {  	// handle display for two layers  	_hidden1Size = (_hidden [0].Max - _hidden [0].Min) + 1;  	_hidden2Size = (_hidden [1].Max - _hidden [1].Min) + 1;  	_results = EngineArray.AllocateDouble2D (_hidden1Size' _hidden2Size);  }  else {  	// we don't handle displays for more than two layers  	_hidden1Size = 0;  	_hidden2Size = 0;  	_results = null;  }  
Magic Number,Encog.Neural.Prune,PruneIncremental,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneIncremental.cs,PerformJobUnit,The following statement contains a magic number: for (int z = 0; z < _weightTries; z++) {  	network.Reset ();  	Propagation train = new ResilientPropagation (network' useTraining);  	var strat = new StopTrainingStrategy (0.001d' 5);  	train.AddStrategy (strat);  	train.ThreadCount = 1;  	// force single thread mode  	for (int i = 0; (i < _iterations) && !ShouldStop && !strat.ShouldStop (); i++) {  		train.Iteration ();  	}  	error = Math.Min (error' train.Error);  }  
Magic Number,Encog.Neural.Prune,PruneIncremental,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneIncremental.cs,PerformJobUnit,The following statement contains a magic number: if (!ShouldStop) {  	// update min and max  	_high = Math.Max (_high' error);  	_low = Math.Min (_low' error);  	if (_hidden1Size > 0) {  		int networkHidden1Count;  		int networkHidden2Count;  		if (network.LayerCount > 3) {  			networkHidden2Count = network.GetLayerNeuronCount (2);  			networkHidden1Count = network.GetLayerNeuronCount (1);  		}  		else {  			networkHidden2Count = 0;  			networkHidden1Count = network.GetLayerNeuronCount (1);  		}  		int row' col;  		if (_hidden2Size == 0) {  			row = networkHidden1Count - _hidden [0].Min;  			col = 0;  		}  		else {  			row = networkHidden1Count - _hidden [0].Min;  			col = networkHidden2Count - _hidden [1].Min;  		}  		if ((row < 0) || (col < 0)) {  			Console.Out.WriteLine ("STOP");  		}  		_results [row] [col] = error;  	}  	// report status  	_currentTry++;  	UpdateBest (network' error);  	ReportStatus (context' "Current: " + NetworkToString (network) + "; Best: " + NetworkToString (_bestNetwork));  }  
Magic Number,Encog.Neural.Prune,PruneIncremental,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneIncremental.cs,PerformJobUnit,The following statement contains a magic number: if (!ShouldStop) {  	// update min and max  	_high = Math.Max (_high' error);  	_low = Math.Min (_low' error);  	if (_hidden1Size > 0) {  		int networkHidden1Count;  		int networkHidden2Count;  		if (network.LayerCount > 3) {  			networkHidden2Count = network.GetLayerNeuronCount (2);  			networkHidden1Count = network.GetLayerNeuronCount (1);  		}  		else {  			networkHidden2Count = 0;  			networkHidden1Count = network.GetLayerNeuronCount (1);  		}  		int row' col;  		if (_hidden2Size == 0) {  			row = networkHidden1Count - _hidden [0].Min;  			col = 0;  		}  		else {  			row = networkHidden1Count - _hidden [0].Min;  			col = networkHidden2Count - _hidden [1].Min;  		}  		if ((row < 0) || (col < 0)) {  			Console.Out.WriteLine ("STOP");  		}  		_results [row] [col] = error;  	}  	// report status  	_currentTry++;  	UpdateBest (network' error);  	ReportStatus (context' "Current: " + NetworkToString (network) + "; Best: " + NetworkToString (_bestNetwork));  }  
Magic Number,Encog.Neural.Prune,PruneIncremental,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneIncremental.cs,PerformJobUnit,The following statement contains a magic number: if (_hidden1Size > 0) {  	int networkHidden1Count;  	int networkHidden2Count;  	if (network.LayerCount > 3) {  		networkHidden2Count = network.GetLayerNeuronCount (2);  		networkHidden1Count = network.GetLayerNeuronCount (1);  	}  	else {  		networkHidden2Count = 0;  		networkHidden1Count = network.GetLayerNeuronCount (1);  	}  	int row' col;  	if (_hidden2Size == 0) {  		row = networkHidden1Count - _hidden [0].Min;  		col = 0;  	}  	else {  		row = networkHidden1Count - _hidden [0].Min;  		col = networkHidden2Count - _hidden [1].Min;  	}  	if ((row < 0) || (col < 0)) {  		Console.Out.WriteLine ("STOP");  	}  	_results [row] [col] = error;  }  
Magic Number,Encog.Neural.Prune,PruneIncremental,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneIncremental.cs,PerformJobUnit,The following statement contains a magic number: if (_hidden1Size > 0) {  	int networkHidden1Count;  	int networkHidden2Count;  	if (network.LayerCount > 3) {  		networkHidden2Count = network.GetLayerNeuronCount (2);  		networkHidden1Count = network.GetLayerNeuronCount (1);  	}  	else {  		networkHidden2Count = 0;  		networkHidden1Count = network.GetLayerNeuronCount (1);  	}  	int row' col;  	if (_hidden2Size == 0) {  		row = networkHidden1Count - _hidden [0].Min;  		col = 0;  	}  	else {  		row = networkHidden1Count - _hidden [0].Min;  		col = networkHidden2Count - _hidden [1].Min;  	}  	if ((row < 0) || (col < 0)) {  		Console.Out.WriteLine ("STOP");  	}  	_results [row] [col] = error;  }  
Magic Number,Encog.Neural.Prune,PruneIncremental,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneIncremental.cs,PerformJobUnit,The following statement contains a magic number: if (network.LayerCount > 3) {  	networkHidden2Count = network.GetLayerNeuronCount (2);  	networkHidden1Count = network.GetLayerNeuronCount (1);  }  else {  	networkHidden2Count = 0;  	networkHidden1Count = network.GetLayerNeuronCount (1);  }  
Magic Number,Encog.Neural.Prune,PruneIncremental,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneIncremental.cs,PerformJobUnit,The following statement contains a magic number: if (network.LayerCount > 3) {  	networkHidden2Count = network.GetLayerNeuronCount (2);  	networkHidden1Count = network.GetLayerNeuronCount (1);  }  else {  	networkHidden2Count = 0;  	networkHidden1Count = network.GetLayerNeuronCount (1);  }  
Magic Number,Encog.Neural.Prune,PruneIncremental,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneIncremental.cs,PerformJobUnit,The following statement contains a magic number: networkHidden2Count = network.GetLayerNeuronCount (2);  
Magic Number,Encog.Neural.Prune,PruneSelective,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneSelective.cs,IncreaseNeuronCount,The following statement contains a magic number: for (int fromLayer = flat.LayerCounts.Length - 2; fromLayer >= 0; fromLayer--) {  	int fromNeuronCount = _network.GetLayerTotalNeuronCount (fromLayer);  	int toNeuronCount = _network.GetLayerNeuronCount (fromLayer + 1);  	int toLayer = fromLayer + 1;  	for (int toNeuron = 0; toNeuron < toNeuronCount; toNeuron++) {  		for (int fromNeuron = 0; fromNeuron < fromNeuronCount; fromNeuron++) {  			if ((toLayer == targetLayer) && (toNeuron >= oldNeuronCount)) {  				newWeights [weightsIndex++] = 0;  			}  			else if ((fromLayer == targetLayer) && (fromNeuron > oldNeuronCount)) {  				newWeights [weightsIndex++] = 0;  			}  			else {  				newWeights [weightsIndex++] = _network.Flat.Weights [oldWeightsIndex++];  			}  		}  	}  }  
Magic Number,Encog.Neural.Prune,PruneSelective,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneSelective.cs,Prune,The following statement contains a magic number: for (int fromLayer = flat.LayerCounts.Length - 2; fromLayer >= 0; fromLayer--) {  	int fromNeuronCount = _network.GetLayerTotalNeuronCount (fromLayer);  	int toNeuronCount = _network.GetLayerNeuronCount (fromLayer + 1);  	int toLayer = fromLayer + 1;  	for (int toNeuron = 0; toNeuron < toNeuronCount; toNeuron++) {  		for (int fromNeuron = 0; fromNeuron < fromNeuronCount; fromNeuron++) {  			bool skip = false;  			if ((toLayer == targetLayer) && (toNeuron == neuron)) {  				skip = true;  			}  			else if ((fromLayer == targetLayer) && (fromNeuron == neuron)) {  				skip = true;  			}  			if (!skip) {  				newWeights [weightsIndex++] = _network.GetWeight (fromLayer' fromNeuron' toNeuron);  			}  		}  	}  }  
Magic Number,Encog.Neural.Prune,PruneSelective,C:\repos\neismit_emds\encog-core-cs\Neural\Prune\PruneSelective.cs,RandomizeNeuron,The following statement contains a magic number: for (int fromLayer = flat.LayerCounts.Length - 2; fromLayer >= 0; fromLayer--) {  	int fromNeuronCount = _network.GetLayerTotalNeuronCount (fromLayer);  	int toNeuronCount = _network.GetLayerNeuronCount (fromLayer + 1);  	int toLayer = fromLayer + 1;  	for (int toNeuron = 0; toNeuron < toNeuronCount; toNeuron++) {  		for (int fromNeuron = 0; fromNeuron < fromNeuronCount; fromNeuron++) {  			bool randomize = false;  			if ((toLayer == targetLayer) && (toNeuron == neuron)) {  				randomize = true;  			}  			else if ((fromLayer == targetLayer) && (fromNeuron == neuron)) {  				randomize = true;  			}  			double weight = _network.GetWeight (fromLayer' fromNeuron' toNeuron);  			if (randomize) {  				weight = d.Randomize (weight);  			}  			newWeights [weightsIndex++] = weight;  		}  	}  }  
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("PARAMS")) {  		IDictionary<String' String> paras = section.ParseParams ();  		EngineArray.PutAll (paras' result.Properties);  	}  	if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("NETWORK")) {  		IDictionary<String' String> p = section.ParseParams ();  		flat.BeginTraining = EncogFileSection.ParseInt (p' BasicNetwork.TagBeginTraining);  		flat.ConnectionLimit = EncogFileSection.ParseDouble (p' BasicNetwork.TagConnectionLimit);  		flat.ContextTargetOffset = EncogFileSection.ParseIntArray (p' BasicNetwork.TagContextTargetOffset);  		flat.ContextTargetSize = EncogFileSection.ParseIntArray (p' BasicNetwork.TagContextTargetSize);  		flat.EndTraining = EncogFileSection.ParseInt (p' BasicNetwork.TagEndTraining);  		flat.HasContext = EncogFileSection.ParseBoolean (p' BasicNetwork.TagHasContext);  		flat.InputCount = EncogFileSection.ParseInt (p' PersistConst.InputCount);  		flat.LayerCounts = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerCounts);  		flat.LayerFeedCounts = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerFeedCounts);  		flat.LayerContextCount = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerContextCount);  		flat.LayerIndex = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerIndex);  		flat.LayerOutput = section.ParseDoubleArray (p' PersistConst.Output);  		flat.LayerSums = new double[flat.LayerOutput.Length];  		flat.OutputCount = EncogFileSection.ParseInt (p' PersistConst.OutputCount);  		flat.WeightIndex = EncogFileSection.ParseIntArray (p' BasicNetwork.TagWeightIndex);  		flat.Weights = section.ParseDoubleArray (p' PersistConst.Weights);  		flat.BiasActivation = section.ParseDoubleArray (p' BasicNetwork.TagBiasActivation);  	}  	else if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("ACTIVATION")) {  		int index = 0;  		flat.ActivationFunctions = new IActivationFunction[flat.LayerCounts.Length];  		foreach (String line in section.Lines) {  			IActivationFunction af;  			IList<String> cols = EncogFileSection.SplitColumns (line);  			String name = ReflectionUtil.AfPath + cols [0];  			try {  				af = (IActivationFunction)ReflectionUtil.LoadObject (name);  			}  			catch (Exception e) {  				throw new PersistError (e);  			}  			for (int i = 0; i < af.ParamNames.Length; i++) {  				af.Params [i] = CSVFormat.EgFormat.Parse (cols [i + 1]);  			}  			flat.ActivationFunctions [index++] = af;  		}  	}  	else if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("RBF")) {  		int index = 0;  		int hiddenCount = flat.LayerCounts [1];  		int inputCount = flat.LayerCounts [2];  		flat.RBF = new IRadialBasisFunction[hiddenCount];  		foreach (String line in section.Lines) {  			IRadialBasisFunction rbf;  			IList<String> cols = EncogFileSection.SplitColumns (line);  			String name = ReflectionUtil.RBFPath + cols [0];  			try {  				rbf = (IRadialBasisFunction)ReflectionUtil.LoadObject (name);  			}  			catch (TypeLoadException ex) {  				throw new PersistError (ex);  			}  			catch (TargetException ex) {  				throw new PersistError (ex);  			}  			catch (MemberAccessException ex) {  				throw new PersistError (ex);  			}  			rbf.Width = CSVFormat.EgFormat.Parse (cols [1]);  			rbf.Peak = CSVFormat.EgFormat.Parse (cols [2]);  			rbf.Centers = new double[inputCount];  			for (int i = 0; i < inputCount; i++) {  				rbf.Centers [i] = CSVFormat.EgFormat.Parse (cols [i + 3]);  			}  			flat.RBF [index++] = rbf;  		}  	}  }  
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("PARAMS")) {  		IDictionary<String' String> paras = section.ParseParams ();  		EngineArray.PutAll (paras' result.Properties);  	}  	if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("NETWORK")) {  		IDictionary<String' String> p = section.ParseParams ();  		flat.BeginTraining = EncogFileSection.ParseInt (p' BasicNetwork.TagBeginTraining);  		flat.ConnectionLimit = EncogFileSection.ParseDouble (p' BasicNetwork.TagConnectionLimit);  		flat.ContextTargetOffset = EncogFileSection.ParseIntArray (p' BasicNetwork.TagContextTargetOffset);  		flat.ContextTargetSize = EncogFileSection.ParseIntArray (p' BasicNetwork.TagContextTargetSize);  		flat.EndTraining = EncogFileSection.ParseInt (p' BasicNetwork.TagEndTraining);  		flat.HasContext = EncogFileSection.ParseBoolean (p' BasicNetwork.TagHasContext);  		flat.InputCount = EncogFileSection.ParseInt (p' PersistConst.InputCount);  		flat.LayerCounts = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerCounts);  		flat.LayerFeedCounts = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerFeedCounts);  		flat.LayerContextCount = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerContextCount);  		flat.LayerIndex = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerIndex);  		flat.LayerOutput = section.ParseDoubleArray (p' PersistConst.Output);  		flat.LayerSums = new double[flat.LayerOutput.Length];  		flat.OutputCount = EncogFileSection.ParseInt (p' PersistConst.OutputCount);  		flat.WeightIndex = EncogFileSection.ParseIntArray (p' BasicNetwork.TagWeightIndex);  		flat.Weights = section.ParseDoubleArray (p' PersistConst.Weights);  		flat.BiasActivation = section.ParseDoubleArray (p' BasicNetwork.TagBiasActivation);  	}  	else if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("ACTIVATION")) {  		int index = 0;  		flat.ActivationFunctions = new IActivationFunction[flat.LayerCounts.Length];  		foreach (String line in section.Lines) {  			IActivationFunction af;  			IList<String> cols = EncogFileSection.SplitColumns (line);  			String name = ReflectionUtil.AfPath + cols [0];  			try {  				af = (IActivationFunction)ReflectionUtil.LoadObject (name);  			}  			catch (Exception e) {  				throw new PersistError (e);  			}  			for (int i = 0; i < af.ParamNames.Length; i++) {  				af.Params [i] = CSVFormat.EgFormat.Parse (cols [i + 1]);  			}  			flat.ActivationFunctions [index++] = af;  		}  	}  	else if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("RBF")) {  		int index = 0;  		int hiddenCount = flat.LayerCounts [1];  		int inputCount = flat.LayerCounts [2];  		flat.RBF = new IRadialBasisFunction[hiddenCount];  		foreach (String line in section.Lines) {  			IRadialBasisFunction rbf;  			IList<String> cols = EncogFileSection.SplitColumns (line);  			String name = ReflectionUtil.RBFPath + cols [0];  			try {  				rbf = (IRadialBasisFunction)ReflectionUtil.LoadObject (name);  			}  			catch (TypeLoadException ex) {  				throw new PersistError (ex);  			}  			catch (TargetException ex) {  				throw new PersistError (ex);  			}  			catch (MemberAccessException ex) {  				throw new PersistError (ex);  			}  			rbf.Width = CSVFormat.EgFormat.Parse (cols [1]);  			rbf.Peak = CSVFormat.EgFormat.Parse (cols [2]);  			rbf.Centers = new double[inputCount];  			for (int i = 0; i < inputCount; i++) {  				rbf.Centers [i] = CSVFormat.EgFormat.Parse (cols [i + 3]);  			}  			flat.RBF [index++] = rbf;  		}  	}  }  
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection ()) != null) {  	if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("PARAMS")) {  		IDictionary<String' String> paras = section.ParseParams ();  		EngineArray.PutAll (paras' result.Properties);  	}  	if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("NETWORK")) {  		IDictionary<String' String> p = section.ParseParams ();  		flat.BeginTraining = EncogFileSection.ParseInt (p' BasicNetwork.TagBeginTraining);  		flat.ConnectionLimit = EncogFileSection.ParseDouble (p' BasicNetwork.TagConnectionLimit);  		flat.ContextTargetOffset = EncogFileSection.ParseIntArray (p' BasicNetwork.TagContextTargetOffset);  		flat.ContextTargetSize = EncogFileSection.ParseIntArray (p' BasicNetwork.TagContextTargetSize);  		flat.EndTraining = EncogFileSection.ParseInt (p' BasicNetwork.TagEndTraining);  		flat.HasContext = EncogFileSection.ParseBoolean (p' BasicNetwork.TagHasContext);  		flat.InputCount = EncogFileSection.ParseInt (p' PersistConst.InputCount);  		flat.LayerCounts = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerCounts);  		flat.LayerFeedCounts = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerFeedCounts);  		flat.LayerContextCount = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerContextCount);  		flat.LayerIndex = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerIndex);  		flat.LayerOutput = section.ParseDoubleArray (p' PersistConst.Output);  		flat.LayerSums = new double[flat.LayerOutput.Length];  		flat.OutputCount = EncogFileSection.ParseInt (p' PersistConst.OutputCount);  		flat.WeightIndex = EncogFileSection.ParseIntArray (p' BasicNetwork.TagWeightIndex);  		flat.Weights = section.ParseDoubleArray (p' PersistConst.Weights);  		flat.BiasActivation = section.ParseDoubleArray (p' BasicNetwork.TagBiasActivation);  	}  	else if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("ACTIVATION")) {  		int index = 0;  		flat.ActivationFunctions = new IActivationFunction[flat.LayerCounts.Length];  		foreach (String line in section.Lines) {  			IActivationFunction af;  			IList<String> cols = EncogFileSection.SplitColumns (line);  			String name = ReflectionUtil.AfPath + cols [0];  			try {  				af = (IActivationFunction)ReflectionUtil.LoadObject (name);  			}  			catch (Exception e) {  				throw new PersistError (e);  			}  			for (int i = 0; i < af.ParamNames.Length; i++) {  				af.Params [i] = CSVFormat.EgFormat.Parse (cols [i + 1]);  			}  			flat.ActivationFunctions [index++] = af;  		}  	}  	else if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("RBF")) {  		int index = 0;  		int hiddenCount = flat.LayerCounts [1];  		int inputCount = flat.LayerCounts [2];  		flat.RBF = new IRadialBasisFunction[hiddenCount];  		foreach (String line in section.Lines) {  			IRadialBasisFunction rbf;  			IList<String> cols = EncogFileSection.SplitColumns (line);  			String name = ReflectionUtil.RBFPath + cols [0];  			try {  				rbf = (IRadialBasisFunction)ReflectionUtil.LoadObject (name);  			}  			catch (TypeLoadException ex) {  				throw new PersistError (ex);  			}  			catch (TargetException ex) {  				throw new PersistError (ex);  			}  			catch (MemberAccessException ex) {  				throw new PersistError (ex);  			}  			rbf.Width = CSVFormat.EgFormat.Parse (cols [1]);  			rbf.Peak = CSVFormat.EgFormat.Parse (cols [2]);  			rbf.Centers = new double[inputCount];  			for (int i = 0; i < inputCount; i++) {  				rbf.Centers [i] = CSVFormat.EgFormat.Parse (cols [i + 3]);  			}  			flat.RBF [index++] = rbf;  		}  	}  }  
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("NETWORK")) {  	IDictionary<String' String> p = section.ParseParams ();  	flat.BeginTraining = EncogFileSection.ParseInt (p' BasicNetwork.TagBeginTraining);  	flat.ConnectionLimit = EncogFileSection.ParseDouble (p' BasicNetwork.TagConnectionLimit);  	flat.ContextTargetOffset = EncogFileSection.ParseIntArray (p' BasicNetwork.TagContextTargetOffset);  	flat.ContextTargetSize = EncogFileSection.ParseIntArray (p' BasicNetwork.TagContextTargetSize);  	flat.EndTraining = EncogFileSection.ParseInt (p' BasicNetwork.TagEndTraining);  	flat.HasContext = EncogFileSection.ParseBoolean (p' BasicNetwork.TagHasContext);  	flat.InputCount = EncogFileSection.ParseInt (p' PersistConst.InputCount);  	flat.LayerCounts = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerCounts);  	flat.LayerFeedCounts = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerFeedCounts);  	flat.LayerContextCount = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerContextCount);  	flat.LayerIndex = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerIndex);  	flat.LayerOutput = section.ParseDoubleArray (p' PersistConst.Output);  	flat.LayerSums = new double[flat.LayerOutput.Length];  	flat.OutputCount = EncogFileSection.ParseInt (p' PersistConst.OutputCount);  	flat.WeightIndex = EncogFileSection.ParseIntArray (p' BasicNetwork.TagWeightIndex);  	flat.Weights = section.ParseDoubleArray (p' PersistConst.Weights);  	flat.BiasActivation = section.ParseDoubleArray (p' BasicNetwork.TagBiasActivation);  }  else if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("ACTIVATION")) {  	int index = 0;  	flat.ActivationFunctions = new IActivationFunction[flat.LayerCounts.Length];  	foreach (String line in section.Lines) {  		IActivationFunction af;  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = ReflectionUtil.AfPath + cols [0];  		try {  			af = (IActivationFunction)ReflectionUtil.LoadObject (name);  		}  		catch (Exception e) {  			throw new PersistError (e);  		}  		for (int i = 0; i < af.ParamNames.Length; i++) {  			af.Params [i] = CSVFormat.EgFormat.Parse (cols [i + 1]);  		}  		flat.ActivationFunctions [index++] = af;  	}  }  else if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("RBF")) {  	int index = 0;  	int hiddenCount = flat.LayerCounts [1];  	int inputCount = flat.LayerCounts [2];  	flat.RBF = new IRadialBasisFunction[hiddenCount];  	foreach (String line in section.Lines) {  		IRadialBasisFunction rbf;  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = ReflectionUtil.RBFPath + cols [0];  		try {  			rbf = (IRadialBasisFunction)ReflectionUtil.LoadObject (name);  		}  		catch (TypeLoadException ex) {  			throw new PersistError (ex);  		}  		catch (TargetException ex) {  			throw new PersistError (ex);  		}  		catch (MemberAccessException ex) {  			throw new PersistError (ex);  		}  		rbf.Width = CSVFormat.EgFormat.Parse (cols [1]);  		rbf.Peak = CSVFormat.EgFormat.Parse (cols [2]);  		rbf.Centers = new double[inputCount];  		for (int i = 0; i < inputCount; i++) {  			rbf.Centers [i] = CSVFormat.EgFormat.Parse (cols [i + 3]);  		}  		flat.RBF [index++] = rbf;  	}  }  
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("NETWORK")) {  	IDictionary<String' String> p = section.ParseParams ();  	flat.BeginTraining = EncogFileSection.ParseInt (p' BasicNetwork.TagBeginTraining);  	flat.ConnectionLimit = EncogFileSection.ParseDouble (p' BasicNetwork.TagConnectionLimit);  	flat.ContextTargetOffset = EncogFileSection.ParseIntArray (p' BasicNetwork.TagContextTargetOffset);  	flat.ContextTargetSize = EncogFileSection.ParseIntArray (p' BasicNetwork.TagContextTargetSize);  	flat.EndTraining = EncogFileSection.ParseInt (p' BasicNetwork.TagEndTraining);  	flat.HasContext = EncogFileSection.ParseBoolean (p' BasicNetwork.TagHasContext);  	flat.InputCount = EncogFileSection.ParseInt (p' PersistConst.InputCount);  	flat.LayerCounts = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerCounts);  	flat.LayerFeedCounts = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerFeedCounts);  	flat.LayerContextCount = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerContextCount);  	flat.LayerIndex = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerIndex);  	flat.LayerOutput = section.ParseDoubleArray (p' PersistConst.Output);  	flat.LayerSums = new double[flat.LayerOutput.Length];  	flat.OutputCount = EncogFileSection.ParseInt (p' PersistConst.OutputCount);  	flat.WeightIndex = EncogFileSection.ParseIntArray (p' BasicNetwork.TagWeightIndex);  	flat.Weights = section.ParseDoubleArray (p' PersistConst.Weights);  	flat.BiasActivation = section.ParseDoubleArray (p' BasicNetwork.TagBiasActivation);  }  else if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("ACTIVATION")) {  	int index = 0;  	flat.ActivationFunctions = new IActivationFunction[flat.LayerCounts.Length];  	foreach (String line in section.Lines) {  		IActivationFunction af;  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = ReflectionUtil.AfPath + cols [0];  		try {  			af = (IActivationFunction)ReflectionUtil.LoadObject (name);  		}  		catch (Exception e) {  			throw new PersistError (e);  		}  		for (int i = 0; i < af.ParamNames.Length; i++) {  			af.Params [i] = CSVFormat.EgFormat.Parse (cols [i + 1]);  		}  		flat.ActivationFunctions [index++] = af;  	}  }  else if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("RBF")) {  	int index = 0;  	int hiddenCount = flat.LayerCounts [1];  	int inputCount = flat.LayerCounts [2];  	flat.RBF = new IRadialBasisFunction[hiddenCount];  	foreach (String line in section.Lines) {  		IRadialBasisFunction rbf;  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = ReflectionUtil.RBFPath + cols [0];  		try {  			rbf = (IRadialBasisFunction)ReflectionUtil.LoadObject (name);  		}  		catch (TypeLoadException ex) {  			throw new PersistError (ex);  		}  		catch (TargetException ex) {  			throw new PersistError (ex);  		}  		catch (MemberAccessException ex) {  			throw new PersistError (ex);  		}  		rbf.Width = CSVFormat.EgFormat.Parse (cols [1]);  		rbf.Peak = CSVFormat.EgFormat.Parse (cols [2]);  		rbf.Centers = new double[inputCount];  		for (int i = 0; i < inputCount; i++) {  			rbf.Centers [i] = CSVFormat.EgFormat.Parse (cols [i + 3]);  		}  		flat.RBF [index++] = rbf;  	}  }  
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("NETWORK")) {  	IDictionary<String' String> p = section.ParseParams ();  	flat.BeginTraining = EncogFileSection.ParseInt (p' BasicNetwork.TagBeginTraining);  	flat.ConnectionLimit = EncogFileSection.ParseDouble (p' BasicNetwork.TagConnectionLimit);  	flat.ContextTargetOffset = EncogFileSection.ParseIntArray (p' BasicNetwork.TagContextTargetOffset);  	flat.ContextTargetSize = EncogFileSection.ParseIntArray (p' BasicNetwork.TagContextTargetSize);  	flat.EndTraining = EncogFileSection.ParseInt (p' BasicNetwork.TagEndTraining);  	flat.HasContext = EncogFileSection.ParseBoolean (p' BasicNetwork.TagHasContext);  	flat.InputCount = EncogFileSection.ParseInt (p' PersistConst.InputCount);  	flat.LayerCounts = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerCounts);  	flat.LayerFeedCounts = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerFeedCounts);  	flat.LayerContextCount = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerContextCount);  	flat.LayerIndex = EncogFileSection.ParseIntArray (p' BasicNetwork.TagLayerIndex);  	flat.LayerOutput = section.ParseDoubleArray (p' PersistConst.Output);  	flat.LayerSums = new double[flat.LayerOutput.Length];  	flat.OutputCount = EncogFileSection.ParseInt (p' PersistConst.OutputCount);  	flat.WeightIndex = EncogFileSection.ParseIntArray (p' BasicNetwork.TagWeightIndex);  	flat.Weights = section.ParseDoubleArray (p' PersistConst.Weights);  	flat.BiasActivation = section.ParseDoubleArray (p' BasicNetwork.TagBiasActivation);  }  else if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("ACTIVATION")) {  	int index = 0;  	flat.ActivationFunctions = new IActivationFunction[flat.LayerCounts.Length];  	foreach (String line in section.Lines) {  		IActivationFunction af;  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = ReflectionUtil.AfPath + cols [0];  		try {  			af = (IActivationFunction)ReflectionUtil.LoadObject (name);  		}  		catch (Exception e) {  			throw new PersistError (e);  		}  		for (int i = 0; i < af.ParamNames.Length; i++) {  			af.Params [i] = CSVFormat.EgFormat.Parse (cols [i + 1]);  		}  		flat.ActivationFunctions [index++] = af;  	}  }  else if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("RBF")) {  	int index = 0;  	int hiddenCount = flat.LayerCounts [1];  	int inputCount = flat.LayerCounts [2];  	flat.RBF = new IRadialBasisFunction[hiddenCount];  	foreach (String line in section.Lines) {  		IRadialBasisFunction rbf;  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = ReflectionUtil.RBFPath + cols [0];  		try {  			rbf = (IRadialBasisFunction)ReflectionUtil.LoadObject (name);  		}  		catch (TypeLoadException ex) {  			throw new PersistError (ex);  		}  		catch (TargetException ex) {  			throw new PersistError (ex);  		}  		catch (MemberAccessException ex) {  			throw new PersistError (ex);  		}  		rbf.Width = CSVFormat.EgFormat.Parse (cols [1]);  		rbf.Peak = CSVFormat.EgFormat.Parse (cols [2]);  		rbf.Centers = new double[inputCount];  		for (int i = 0; i < inputCount; i++) {  			rbf.Centers [i] = CSVFormat.EgFormat.Parse (cols [i + 3]);  		}  		flat.RBF [index++] = rbf;  	}  }  
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("ACTIVATION")) {  	int index = 0;  	flat.ActivationFunctions = new IActivationFunction[flat.LayerCounts.Length];  	foreach (String line in section.Lines) {  		IActivationFunction af;  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = ReflectionUtil.AfPath + cols [0];  		try {  			af = (IActivationFunction)ReflectionUtil.LoadObject (name);  		}  		catch (Exception e) {  			throw new PersistError (e);  		}  		for (int i = 0; i < af.ParamNames.Length; i++) {  			af.Params [i] = CSVFormat.EgFormat.Parse (cols [i + 1]);  		}  		flat.ActivationFunctions [index++] = af;  	}  }  else if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("RBF")) {  	int index = 0;  	int hiddenCount = flat.LayerCounts [1];  	int inputCount = flat.LayerCounts [2];  	flat.RBF = new IRadialBasisFunction[hiddenCount];  	foreach (String line in section.Lines) {  		IRadialBasisFunction rbf;  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = ReflectionUtil.RBFPath + cols [0];  		try {  			rbf = (IRadialBasisFunction)ReflectionUtil.LoadObject (name);  		}  		catch (TypeLoadException ex) {  			throw new PersistError (ex);  		}  		catch (TargetException ex) {  			throw new PersistError (ex);  		}  		catch (MemberAccessException ex) {  			throw new PersistError (ex);  		}  		rbf.Width = CSVFormat.EgFormat.Parse (cols [1]);  		rbf.Peak = CSVFormat.EgFormat.Parse (cols [2]);  		rbf.Centers = new double[inputCount];  		for (int i = 0; i < inputCount; i++) {  			rbf.Centers [i] = CSVFormat.EgFormat.Parse (cols [i + 3]);  		}  		flat.RBF [index++] = rbf;  	}  }  
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("ACTIVATION")) {  	int index = 0;  	flat.ActivationFunctions = new IActivationFunction[flat.LayerCounts.Length];  	foreach (String line in section.Lines) {  		IActivationFunction af;  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = ReflectionUtil.AfPath + cols [0];  		try {  			af = (IActivationFunction)ReflectionUtil.LoadObject (name);  		}  		catch (Exception e) {  			throw new PersistError (e);  		}  		for (int i = 0; i < af.ParamNames.Length; i++) {  			af.Params [i] = CSVFormat.EgFormat.Parse (cols [i + 1]);  		}  		flat.ActivationFunctions [index++] = af;  	}  }  else if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("RBF")) {  	int index = 0;  	int hiddenCount = flat.LayerCounts [1];  	int inputCount = flat.LayerCounts [2];  	flat.RBF = new IRadialBasisFunction[hiddenCount];  	foreach (String line in section.Lines) {  		IRadialBasisFunction rbf;  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = ReflectionUtil.RBFPath + cols [0];  		try {  			rbf = (IRadialBasisFunction)ReflectionUtil.LoadObject (name);  		}  		catch (TypeLoadException ex) {  			throw new PersistError (ex);  		}  		catch (TargetException ex) {  			throw new PersistError (ex);  		}  		catch (MemberAccessException ex) {  			throw new PersistError (ex);  		}  		rbf.Width = CSVFormat.EgFormat.Parse (cols [1]);  		rbf.Peak = CSVFormat.EgFormat.Parse (cols [2]);  		rbf.Centers = new double[inputCount];  		for (int i = 0; i < inputCount; i++) {  			rbf.Centers [i] = CSVFormat.EgFormat.Parse (cols [i + 3]);  		}  		flat.RBF [index++] = rbf;  	}  }  
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("ACTIVATION")) {  	int index = 0;  	flat.ActivationFunctions = new IActivationFunction[flat.LayerCounts.Length];  	foreach (String line in section.Lines) {  		IActivationFunction af;  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = ReflectionUtil.AfPath + cols [0];  		try {  			af = (IActivationFunction)ReflectionUtil.LoadObject (name);  		}  		catch (Exception e) {  			throw new PersistError (e);  		}  		for (int i = 0; i < af.ParamNames.Length; i++) {  			af.Params [i] = CSVFormat.EgFormat.Parse (cols [i + 1]);  		}  		flat.ActivationFunctions [index++] = af;  	}  }  else if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("RBF")) {  	int index = 0;  	int hiddenCount = flat.LayerCounts [1];  	int inputCount = flat.LayerCounts [2];  	flat.RBF = new IRadialBasisFunction[hiddenCount];  	foreach (String line in section.Lines) {  		IRadialBasisFunction rbf;  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = ReflectionUtil.RBFPath + cols [0];  		try {  			rbf = (IRadialBasisFunction)ReflectionUtil.LoadObject (name);  		}  		catch (TypeLoadException ex) {  			throw new PersistError (ex);  		}  		catch (TargetException ex) {  			throw new PersistError (ex);  		}  		catch (MemberAccessException ex) {  			throw new PersistError (ex);  		}  		rbf.Width = CSVFormat.EgFormat.Parse (cols [1]);  		rbf.Peak = CSVFormat.EgFormat.Parse (cols [2]);  		rbf.Centers = new double[inputCount];  		for (int i = 0; i < inputCount; i++) {  			rbf.Centers [i] = CSVFormat.EgFormat.Parse (cols [i + 3]);  		}  		flat.RBF [index++] = rbf;  	}  }  
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("RBF")) {  	int index = 0;  	int hiddenCount = flat.LayerCounts [1];  	int inputCount = flat.LayerCounts [2];  	flat.RBF = new IRadialBasisFunction[hiddenCount];  	foreach (String line in section.Lines) {  		IRadialBasisFunction rbf;  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = ReflectionUtil.RBFPath + cols [0];  		try {  			rbf = (IRadialBasisFunction)ReflectionUtil.LoadObject (name);  		}  		catch (TypeLoadException ex) {  			throw new PersistError (ex);  		}  		catch (TargetException ex) {  			throw new PersistError (ex);  		}  		catch (MemberAccessException ex) {  			throw new PersistError (ex);  		}  		rbf.Width = CSVFormat.EgFormat.Parse (cols [1]);  		rbf.Peak = CSVFormat.EgFormat.Parse (cols [2]);  		rbf.Centers = new double[inputCount];  		for (int i = 0; i < inputCount; i++) {  			rbf.Centers [i] = CSVFormat.EgFormat.Parse (cols [i + 3]);  		}  		flat.RBF [index++] = rbf;  	}  }  
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("RBF")) {  	int index = 0;  	int hiddenCount = flat.LayerCounts [1];  	int inputCount = flat.LayerCounts [2];  	flat.RBF = new IRadialBasisFunction[hiddenCount];  	foreach (String line in section.Lines) {  		IRadialBasisFunction rbf;  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = ReflectionUtil.RBFPath + cols [0];  		try {  			rbf = (IRadialBasisFunction)ReflectionUtil.LoadObject (name);  		}  		catch (TypeLoadException ex) {  			throw new PersistError (ex);  		}  		catch (TargetException ex) {  			throw new PersistError (ex);  		}  		catch (MemberAccessException ex) {  			throw new PersistError (ex);  		}  		rbf.Width = CSVFormat.EgFormat.Parse (cols [1]);  		rbf.Peak = CSVFormat.EgFormat.Parse (cols [2]);  		rbf.Centers = new double[inputCount];  		for (int i = 0; i < inputCount; i++) {  			rbf.Centers [i] = CSVFormat.EgFormat.Parse (cols [i + 3]);  		}  		flat.RBF [index++] = rbf;  	}  }  
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: if (section.SectionName.Equals ("RBF-NETWORK") && section.SubSectionName.Equals ("RBF")) {  	int index = 0;  	int hiddenCount = flat.LayerCounts [1];  	int inputCount = flat.LayerCounts [2];  	flat.RBF = new IRadialBasisFunction[hiddenCount];  	foreach (String line in section.Lines) {  		IRadialBasisFunction rbf;  		IList<String> cols = EncogFileSection.SplitColumns (line);  		String name = ReflectionUtil.RBFPath + cols [0];  		try {  			rbf = (IRadialBasisFunction)ReflectionUtil.LoadObject (name);  		}  		catch (TypeLoadException ex) {  			throw new PersistError (ex);  		}  		catch (TargetException ex) {  			throw new PersistError (ex);  		}  		catch (MemberAccessException ex) {  			throw new PersistError (ex);  		}  		rbf.Width = CSVFormat.EgFormat.Parse (cols [1]);  		rbf.Peak = CSVFormat.EgFormat.Parse (cols [2]);  		rbf.Centers = new double[inputCount];  		for (int i = 0; i < inputCount; i++) {  			rbf.Centers [i] = CSVFormat.EgFormat.Parse (cols [i + 3]);  		}  		flat.RBF [index++] = rbf;  	}  }  
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IRadialBasisFunction rbf;  	IList<String> cols = EncogFileSection.SplitColumns (line);  	String name = ReflectionUtil.RBFPath + cols [0];  	try {  		rbf = (IRadialBasisFunction)ReflectionUtil.LoadObject (name);  	}  	catch (TypeLoadException ex) {  		throw new PersistError (ex);  	}  	catch (TargetException ex) {  		throw new PersistError (ex);  	}  	catch (MemberAccessException ex) {  		throw new PersistError (ex);  	}  	rbf.Width = CSVFormat.EgFormat.Parse (cols [1]);  	rbf.Peak = CSVFormat.EgFormat.Parse (cols [2]);  	rbf.Centers = new double[inputCount];  	for (int i = 0; i < inputCount; i++) {  		rbf.Centers [i] = CSVFormat.EgFormat.Parse (cols [i + 3]);  	}  	flat.RBF [index++] = rbf;  }  
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: foreach (String line in section.Lines) {  	IRadialBasisFunction rbf;  	IList<String> cols = EncogFileSection.SplitColumns (line);  	String name = ReflectionUtil.RBFPath + cols [0];  	try {  		rbf = (IRadialBasisFunction)ReflectionUtil.LoadObject (name);  	}  	catch (TypeLoadException ex) {  		throw new PersistError (ex);  	}  	catch (TargetException ex) {  		throw new PersistError (ex);  	}  	catch (MemberAccessException ex) {  		throw new PersistError (ex);  	}  	rbf.Width = CSVFormat.EgFormat.Parse (cols [1]);  	rbf.Peak = CSVFormat.EgFormat.Parse (cols [2]);  	rbf.Centers = new double[inputCount];  	for (int i = 0; i < inputCount; i++) {  		rbf.Centers [i] = CSVFormat.EgFormat.Parse (cols [i + 3]);  	}  	flat.RBF [index++] = rbf;  }  
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: rbf.Peak = CSVFormat.EgFormat.Parse (cols [2]);  
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: for (int i = 0; i < inputCount; i++) {  	rbf.Centers [i] = CSVFormat.EgFormat.Parse (cols [i + 3]);  }  
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: rbf.Centers [i] = CSVFormat.EgFormat.Parse (cols [i + 3]);  
Magic Number,Encog.Neural.RBF,RBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\RBFNetwork.cs,SetRBFCentersAndWidthsEqualSpacing,The following statement contains a magic number: if (expectedSideLength != cmp) {  	throw new NeuralNetworkError ("Total number of RBF neurons must be some integer to the power of 'dimensions'.\n" + Format.FormatDouble (expectedSideLength' 5) + " <> " + Format.FormatDouble (cmp' 5));  }  
Magic Number,Encog.Neural.RBF,RBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\RBFNetwork.cs,SetRBFCentersAndWidthsEqualSpacing,The following statement contains a magic number: if (expectedSideLength != cmp) {  	throw new NeuralNetworkError ("Total number of RBF neurons must be some integer to the power of 'dimensions'.\n" + Format.FormatDouble (expectedSideLength' 5) + " <> " + Format.FormatDouble (cmp' 5));  }  
Magic Number,Encog.Neural.RBF,RBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\RBFNetwork.cs,SetRBFCentersAndWidthsEqualSpacing,The following statement contains a magic number: throw new NeuralNetworkError ("Total number of RBF neurons must be some integer to the power of 'dimensions'.\n" + Format.FormatDouble (expectedSideLength' 5) + " <> " + Format.FormatDouble (cmp' 5));  
Magic Number,Encog.Neural.RBF,RBFNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\RBFNetwork.cs,SetRBFCentersAndWidthsEqualSpacing,The following statement contains a magic number: throw new NeuralNetworkError ("Total number of RBF neurons must be some integer to the power of 'dimensions'.\n" + Format.FormatDouble (expectedSideLength' 5) + " <> " + Format.FormatDouble (cmp' 5));  
Magic Number,Encog.Neural.RBF.Training,SVD,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,The following statement contains a magic number: for (i = 0; i < n; i++) {  	l = i + 2;  	rv1 [i] = scale * g;  	g = s = scale = 0.0d;  	if (i < m) {  		for (k = i; k < m; k++)  			scale += Math.Abs (a [k] [i]);  		if (scale != 0.0d) {  			for (k = i; k < m; k++) {  				a [k] [i] /= scale;  				s += a [k] [i] * a [k] [i];  			}  			f = a [i] [i];  			g = -SIGN (Math.Sqrt (s)' f);  			h = f * g - s;  			a [i] [i] = f - g;  			for (j = l - 1; j < n; j++) {  				for (s = 0.0d' k = i; k < m; k++)  					s += a [k] [i] * a [k] [j];  				f = s / h;  				for (k = i; k < m; k++)  					a [k] [j] += f * a [k] [i];  			}  			for (k = i; k < m; k++)  				a [k] [i] *= scale;  		}  	}  	w [i] = scale * g;  	g = s = scale = 0.0d;  	if (i + 1 <= m && i + 1 != n) {  		for (k = l - 1; k < n; k++)  			scale += Math.Abs (a [i] [k]);  		if (scale != 0.0d) {  			for (k = l - 1; k < n; k++) {  				a [i] [k] /= scale;  				s += a [i] [k] * a [i] [k];  			}  			f = a [i] [l - 1];  			g = -SIGN (Math.Sqrt (s)' f);  			h = f * g - s;  			a [i] [l - 1] = f - g;  			for (k = l - 1; k < n; k++)  				rv1 [k] = a [i] [k] / h;  			for (j = l - 1; j < m; j++) {  				for (s = 0.0d' k = l - 1; k < n; k++)  					s += a [j] [k] * a [i] [k];  				for (k = l - 1; k < n; k++)  					a [j] [k] += s * rv1 [k];  			}  			for (k = l - 1; k < n; k++)  				a [i] [k] *= scale;  		}  	}  	anorm = MAX (anorm' (Math.Abs (w [i]) + Math.Abs (rv1 [i])));  }  
Magic Number,Encog.Neural.RBF.Training,SVD,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,The following statement contains a magic number: l = i + 2;  
Magic Number,Encog.Neural.RBF.Training,SVD,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,The following statement contains a magic number: for (k = n - 1; k >= 0; k--) {  	for (its = 0; its < 30; its++) {  		flag = true;  		for (l = k; l >= 0; l--) {  			nm = l - 1;  			if (Math.Abs (rv1 [l]) + anorm == anorm) {  				flag = false;  				break;  			}  			if (Math.Abs (w [nm]) + anorm == anorm)  				break;  		}  		if (flag) {  			c = 0.0d;  			s = 1.0d;  			for (i = l; i < k + 1; i++) {  				f = s * rv1 [i];  				rv1 [i] = c * rv1 [i];  				if (Math.Abs (f) + anorm == anorm)  					break;  				g = w [i];  				h = Pythag (f' g);  				w [i] = h;  				h = 1.0d / h;  				c = g * h;  				s = -f * h;  				for (j = 0; j < m; j++) {  					y = a [j] [nm];  					z = a [j] [i];  					a [j] [nm] = y * c + z * s;  					a [j] [i] = z * c - y * s;  				}  			}  		}  		z = w [k];  		if (l == k) {  			if (z < 0.0d) {  				w [k] = -z;  				for (j = 0; j < n; j++)  					v [j] [k] = -v [j] [k];  			}  			break;  		}  		if (its == 29) {  			//	Debug.Print("no convergence in 30 svdcmp iterations");  		}  		x = w [l];  		nm = k - 1;  		y = w [nm];  		g = rv1 [nm];  		h = rv1 [k];  		f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0d * h * y);  		g = Pythag (f' 1.0d);  		f = ((x - z) * (x + z) + h * ((y / (f + SIGN (g' f))) - h)) / x;  		c = s = 1.0d;  		for (j = l; j <= nm; j++) {  			i = j + 1;  			g = rv1 [i];  			y = w [i];  			h = s * g;  			g = c * g;  			z = Pythag (f' h);  			rv1 [j] = z;  			c = f / z;  			s = h / z;  			f = x * c + g * s;  			g = g * c - x * s;  			h = y * s;  			y *= c;  			for (jj = 0; jj < n; jj++) {  				x = v [jj] [j];  				z = v [jj] [i];  				v [jj] [j] = x * c + z * s;  				v [jj] [i] = z * c - x * s;  			}  			z = Pythag (f' h);  			w [j] = z;  			if (z != 0) {  				z = 1.0d / z;  				c = f * z;  				s = h * z;  			}  			f = c * g + s * y;  			x = c * y - s * g;  			for (jj = 0; jj < m; jj++) {  				y = a [jj] [j];  				z = a [jj] [i];  				a [jj] [j] = y * c + z * s;  				a [jj] [i] = z * c - y * s;  			}  		}  		rv1 [l] = 0.0d;  		rv1 [k] = f;  		w [k] = x;  	}  }  
Magic Number,Encog.Neural.RBF.Training,SVD,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,The following statement contains a magic number: for (k = n - 1; k >= 0; k--) {  	for (its = 0; its < 30; its++) {  		flag = true;  		for (l = k; l >= 0; l--) {  			nm = l - 1;  			if (Math.Abs (rv1 [l]) + anorm == anorm) {  				flag = false;  				break;  			}  			if (Math.Abs (w [nm]) + anorm == anorm)  				break;  		}  		if (flag) {  			c = 0.0d;  			s = 1.0d;  			for (i = l; i < k + 1; i++) {  				f = s * rv1 [i];  				rv1 [i] = c * rv1 [i];  				if (Math.Abs (f) + anorm == anorm)  					break;  				g = w [i];  				h = Pythag (f' g);  				w [i] = h;  				h = 1.0d / h;  				c = g * h;  				s = -f * h;  				for (j = 0; j < m; j++) {  					y = a [j] [nm];  					z = a [j] [i];  					a [j] [nm] = y * c + z * s;  					a [j] [i] = z * c - y * s;  				}  			}  		}  		z = w [k];  		if (l == k) {  			if (z < 0.0d) {  				w [k] = -z;  				for (j = 0; j < n; j++)  					v [j] [k] = -v [j] [k];  			}  			break;  		}  		if (its == 29) {  			//	Debug.Print("no convergence in 30 svdcmp iterations");  		}  		x = w [l];  		nm = k - 1;  		y = w [nm];  		g = rv1 [nm];  		h = rv1 [k];  		f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0d * h * y);  		g = Pythag (f' 1.0d);  		f = ((x - z) * (x + z) + h * ((y / (f + SIGN (g' f))) - h)) / x;  		c = s = 1.0d;  		for (j = l; j <= nm; j++) {  			i = j + 1;  			g = rv1 [i];  			y = w [i];  			h = s * g;  			g = c * g;  			z = Pythag (f' h);  			rv1 [j] = z;  			c = f / z;  			s = h / z;  			f = x * c + g * s;  			g = g * c - x * s;  			h = y * s;  			y *= c;  			for (jj = 0; jj < n; jj++) {  				x = v [jj] [j];  				z = v [jj] [i];  				v [jj] [j] = x * c + z * s;  				v [jj] [i] = z * c - x * s;  			}  			z = Pythag (f' h);  			w [j] = z;  			if (z != 0) {  				z = 1.0d / z;  				c = f * z;  				s = h * z;  			}  			f = c * g + s * y;  			x = c * y - s * g;  			for (jj = 0; jj < m; jj++) {  				y = a [jj] [j];  				z = a [jj] [i];  				a [jj] [j] = y * c + z * s;  				a [jj] [i] = z * c - y * s;  			}  		}  		rv1 [l] = 0.0d;  		rv1 [k] = f;  		w [k] = x;  	}  }  
Magic Number,Encog.Neural.RBF.Training,SVD,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,The following statement contains a magic number: for (its = 0; its < 30; its++) {  	flag = true;  	for (l = k; l >= 0; l--) {  		nm = l - 1;  		if (Math.Abs (rv1 [l]) + anorm == anorm) {  			flag = false;  			break;  		}  		if (Math.Abs (w [nm]) + anorm == anorm)  			break;  	}  	if (flag) {  		c = 0.0d;  		s = 1.0d;  		for (i = l; i < k + 1; i++) {  			f = s * rv1 [i];  			rv1 [i] = c * rv1 [i];  			if (Math.Abs (f) + anorm == anorm)  				break;  			g = w [i];  			h = Pythag (f' g);  			w [i] = h;  			h = 1.0d / h;  			c = g * h;  			s = -f * h;  			for (j = 0; j < m; j++) {  				y = a [j] [nm];  				z = a [j] [i];  				a [j] [nm] = y * c + z * s;  				a [j] [i] = z * c - y * s;  			}  		}  	}  	z = w [k];  	if (l == k) {  		if (z < 0.0d) {  			w [k] = -z;  			for (j = 0; j < n; j++)  				v [j] [k] = -v [j] [k];  		}  		break;  	}  	if (its == 29) {  		//	Debug.Print("no convergence in 30 svdcmp iterations");  	}  	x = w [l];  	nm = k - 1;  	y = w [nm];  	g = rv1 [nm];  	h = rv1 [k];  	f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0d * h * y);  	g = Pythag (f' 1.0d);  	f = ((x - z) * (x + z) + h * ((y / (f + SIGN (g' f))) - h)) / x;  	c = s = 1.0d;  	for (j = l; j <= nm; j++) {  		i = j + 1;  		g = rv1 [i];  		y = w [i];  		h = s * g;  		g = c * g;  		z = Pythag (f' h);  		rv1 [j] = z;  		c = f / z;  		s = h / z;  		f = x * c + g * s;  		g = g * c - x * s;  		h = y * s;  		y *= c;  		for (jj = 0; jj < n; jj++) {  			x = v [jj] [j];  			z = v [jj] [i];  			v [jj] [j] = x * c + z * s;  			v [jj] [i] = z * c - x * s;  		}  		z = Pythag (f' h);  		w [j] = z;  		if (z != 0) {  			z = 1.0d / z;  			c = f * z;  			s = h * z;  		}  		f = c * g + s * y;  		x = c * y - s * g;  		for (jj = 0; jj < m; jj++) {  			y = a [jj] [j];  			z = a [jj] [i];  			a [jj] [j] = y * c + z * s;  			a [jj] [i] = z * c - y * s;  		}  	}  	rv1 [l] = 0.0d;  	rv1 [k] = f;  	w [k] = x;  }  
Magic Number,Encog.Neural.RBF.Training,SVD,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,The following statement contains a magic number: for (its = 0; its < 30; its++) {  	flag = true;  	for (l = k; l >= 0; l--) {  		nm = l - 1;  		if (Math.Abs (rv1 [l]) + anorm == anorm) {  			flag = false;  			break;  		}  		if (Math.Abs (w [nm]) + anorm == anorm)  			break;  	}  	if (flag) {  		c = 0.0d;  		s = 1.0d;  		for (i = l; i < k + 1; i++) {  			f = s * rv1 [i];  			rv1 [i] = c * rv1 [i];  			if (Math.Abs (f) + anorm == anorm)  				break;  			g = w [i];  			h = Pythag (f' g);  			w [i] = h;  			h = 1.0d / h;  			c = g * h;  			s = -f * h;  			for (j = 0; j < m; j++) {  				y = a [j] [nm];  				z = a [j] [i];  				a [j] [nm] = y * c + z * s;  				a [j] [i] = z * c - y * s;  			}  		}  	}  	z = w [k];  	if (l == k) {  		if (z < 0.0d) {  			w [k] = -z;  			for (j = 0; j < n; j++)  				v [j] [k] = -v [j] [k];  		}  		break;  	}  	if (its == 29) {  		//	Debug.Print("no convergence in 30 svdcmp iterations");  	}  	x = w [l];  	nm = k - 1;  	y = w [nm];  	g = rv1 [nm];  	h = rv1 [k];  	f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0d * h * y);  	g = Pythag (f' 1.0d);  	f = ((x - z) * (x + z) + h * ((y / (f + SIGN (g' f))) - h)) / x;  	c = s = 1.0d;  	for (j = l; j <= nm; j++) {  		i = j + 1;  		g = rv1 [i];  		y = w [i];  		h = s * g;  		g = c * g;  		z = Pythag (f' h);  		rv1 [j] = z;  		c = f / z;  		s = h / z;  		f = x * c + g * s;  		g = g * c - x * s;  		h = y * s;  		y *= c;  		for (jj = 0; jj < n; jj++) {  			x = v [jj] [j];  			z = v [jj] [i];  			v [jj] [j] = x * c + z * s;  			v [jj] [i] = z * c - x * s;  		}  		z = Pythag (f' h);  		w [j] = z;  		if (z != 0) {  			z = 1.0d / z;  			c = f * z;  			s = h * z;  		}  		f = c * g + s * y;  		x = c * y - s * g;  		for (jj = 0; jj < m; jj++) {  			y = a [jj] [j];  			z = a [jj] [i];  			a [jj] [j] = y * c + z * s;  			a [jj] [i] = z * c - y * s;  		}  	}  	rv1 [l] = 0.0d;  	rv1 [k] = f;  	w [k] = x;  }  
Magic Number,Encog.Neural.RBF.Training,SVD,C:\repos\neismit_emds\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,The following statement contains a magic number: if (its == 29) {  	//	Debug.Print("no convergence in 30 svdcmp iterations");  }  
Magic Number,Encog.Neural.SOM,SOMNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\SOMNetwork.cs,CalculateError,The following statement contains a magic number: return bmu.WorstDistance / 100.0;  
Magic Number,Encog.Neural.SOM.Training.Neighborhood,BasicTrainSOM,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\BasicTrainSOM.cs,Iteration,The following statement contains a magic number: Error = _bmuUtil.WorstDistance / 100.0;  
Magic Number,Encog.Neural.SOM.Training.Neighborhood,BasicTrainSOM,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\BasicTrainSOM.cs,ToString,The following statement contains a magic number: result.Append (Format.FormatDouble (_radius' 2));  
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type) {  case RBFEnum.Gaussian:  	_rbf = new GaussianFunction (2);  	break;  case RBFEnum.InverseMultiquadric:  	_rbf = new InverseMultiquadricFunction (2);  	break;  case RBFEnum.Multiquadric:  	_rbf = new MultiquadricFunction (2);  	break;  case RBFEnum.MexicanHat:  	_rbf = new MexicanHatFunction (2);  	break;  }  
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type) {  case RBFEnum.Gaussian:  	_rbf = new GaussianFunction (2);  	break;  case RBFEnum.InverseMultiquadric:  	_rbf = new InverseMultiquadricFunction (2);  	break;  case RBFEnum.Multiquadric:  	_rbf = new MultiquadricFunction (2);  	break;  case RBFEnum.MexicanHat:  	_rbf = new MexicanHatFunction (2);  	break;  }  
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type) {  case RBFEnum.Gaussian:  	_rbf = new GaussianFunction (2);  	break;  case RBFEnum.InverseMultiquadric:  	_rbf = new InverseMultiquadricFunction (2);  	break;  case RBFEnum.Multiquadric:  	_rbf = new MultiquadricFunction (2);  	break;  case RBFEnum.MexicanHat:  	_rbf = new MexicanHatFunction (2);  	break;  }  
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type) {  case RBFEnum.Gaussian:  	_rbf = new GaussianFunction (2);  	break;  case RBFEnum.InverseMultiquadric:  	_rbf = new InverseMultiquadricFunction (2);  	break;  case RBFEnum.Multiquadric:  	_rbf = new MultiquadricFunction (2);  	break;  case RBFEnum.MexicanHat:  	_rbf = new MexicanHatFunction (2);  	break;  }  
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: _rbf = new GaussianFunction (2);  
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: _rbf = new InverseMultiquadricFunction (2);  
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: _rbf = new MultiquadricFunction (2);  
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: _rbf = new MexicanHatFunction (2);  
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type) {  case RBFEnum.Gaussian:  	_rbf = new GaussianFunction (2);  	break;  case RBFEnum.InverseMultiquadric:  	_rbf = new InverseMultiquadricFunction (2);  	break;  case RBFEnum.Multiquadric:  	_rbf = new MultiquadricFunction (2);  	break;  case RBFEnum.MexicanHat:  	_rbf = new MexicanHatFunction (2);  	break;  }  
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type) {  case RBFEnum.Gaussian:  	_rbf = new GaussianFunction (2);  	break;  case RBFEnum.InverseMultiquadric:  	_rbf = new InverseMultiquadricFunction (2);  	break;  case RBFEnum.Multiquadric:  	_rbf = new MultiquadricFunction (2);  	break;  case RBFEnum.MexicanHat:  	_rbf = new MexicanHatFunction (2);  	break;  }  
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type) {  case RBFEnum.Gaussian:  	_rbf = new GaussianFunction (2);  	break;  case RBFEnum.InverseMultiquadric:  	_rbf = new InverseMultiquadricFunction (2);  	break;  case RBFEnum.Multiquadric:  	_rbf = new MultiquadricFunction (2);  	break;  case RBFEnum.MexicanHat:  	_rbf = new MexicanHatFunction (2);  	break;  }  
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type) {  case RBFEnum.Gaussian:  	_rbf = new GaussianFunction (2);  	break;  case RBFEnum.InverseMultiquadric:  	_rbf = new InverseMultiquadricFunction (2);  	break;  case RBFEnum.Multiquadric:  	_rbf = new MultiquadricFunction (2);  	break;  case RBFEnum.MexicanHat:  	_rbf = new MexicanHatFunction (2);  	break;  }  
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: _rbf = new GaussianFunction (2);  
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: _rbf = new InverseMultiquadricFunction (2);  
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: _rbf = new MultiquadricFunction (2);  
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: _rbf = new MexicanHatFunction (2);  
Magic Number,Encog.Neural.Thermal,BoltzmannMachine,C:\repos\neismit_emds\encog-core-cs\Neural\Thermal\BoltzmannMachine.cs,BoltzmannMachine,The following statement contains a magic number: _annealCycles = 100;  
Magic Number,Encog.Neural.Thermal,BoltzmannMachine,C:\repos\neismit_emds\encog-core-cs\Neural\Thermal\BoltzmannMachine.cs,BoltzmannMachine,The following statement contains a magic number: _runCycles = 1000;  
Magic Number,Encog.Neural.Thermal,BoltzmannMachine,C:\repos\neismit_emds\encog-core-cs\Neural\Thermal\BoltzmannMachine.cs,BoltzmannMachine,The following statement contains a magic number: _annealCycles = 100;  
Magic Number,Encog.Neural.Thermal,BoltzmannMachine,C:\repos\neismit_emds\encog-core-cs\Neural\Thermal\BoltzmannMachine.cs,BoltzmannMachine,The following statement contains a magic number: _runCycles = 1000;  
Magic Number,Encog.Neural.Thermal,ThermalNetwork,C:\repos\neismit_emds\encog-core-cs\Neural\Thermal\ThermalNetwork.cs,CalculateEnergy,The following statement contains a magic number: return -1 * tempE / 2;  
Magic Number,Encog.Persist,EncogDirectoryPersistence,C:\repos\neismit_emds\encog-core-cs\Persist\EncogDirectoryPersistence.cs,LoadObject,The following statement contains a magic number: if (p.FileVersion < Int32.Parse (paras [4])) {  	throw new PersistError ("The file you are trying to read is from a later version of Encog.  Please upgrade Encog to read this file.");  }  
Magic Number,Encog.Persist,EncogDirectoryPersistence,C:\repos\neismit_emds\encog-core-cs\Persist\EncogDirectoryPersistence.cs,ReadLine,The following statement contains a magic number: try {  	var result = new StringBuilder ();  	char ch;  	do {  		int b = mask0.ReadByte ();  		if (b == -1) {  			return result.ToString ();  		}  		ch = (char)b;  		if ((ch != 13) && (ch != 10)) {  			result.Append (ch);  		}  	}  	while (ch != 10);  	return result.ToString ();  }  catch (IOException ex) {  	throw new PersistError (ex);  }  
Magic Number,Encog.Persist,EncogDirectoryPersistence,C:\repos\neismit_emds\encog-core-cs\Persist\EncogDirectoryPersistence.cs,ReadLine,The following statement contains a magic number: try {  	var result = new StringBuilder ();  	char ch;  	do {  		int b = mask0.ReadByte ();  		if (b == -1) {  			return result.ToString ();  		}  		ch = (char)b;  		if ((ch != 13) && (ch != 10)) {  			result.Append (ch);  		}  	}  	while (ch != 10);  	return result.ToString ();  }  catch (IOException ex) {  	throw new PersistError (ex);  }  
Magic Number,Encog.Persist,EncogDirectoryPersistence,C:\repos\neismit_emds\encog-core-cs\Persist\EncogDirectoryPersistence.cs,ReadLine,The following statement contains a magic number: try {  	var result = new StringBuilder ();  	char ch;  	do {  		int b = mask0.ReadByte ();  		if (b == -1) {  			return result.ToString ();  		}  		ch = (char)b;  		if ((ch != 13) && (ch != 10)) {  			result.Append (ch);  		}  	}  	while (ch != 10);  	return result.ToString ();  }  catch (IOException ex) {  	throw new PersistError (ex);  }  
Magic Number,Encog.Persist,EncogDirectoryPersistence,C:\repos\neismit_emds\encog-core-cs\Persist\EncogDirectoryPersistence.cs,ReadLine,The following statement contains a magic number: do {  	int b = mask0.ReadByte ();  	if (b == -1) {  		return result.ToString ();  	}  	ch = (char)b;  	if ((ch != 13) && (ch != 10)) {  		result.Append (ch);  	}  }  while (ch != 10);  
Magic Number,Encog.Persist,EncogDirectoryPersistence,C:\repos\neismit_emds\encog-core-cs\Persist\EncogDirectoryPersistence.cs,ReadLine,The following statement contains a magic number: do {  	int b = mask0.ReadByte ();  	if (b == -1) {  		return result.ToString ();  	}  	ch = (char)b;  	if ((ch != 13) && (ch != 10)) {  		result.Append (ch);  	}  }  while (ch != 10);  
Magic Number,Encog.Persist,EncogDirectoryPersistence,C:\repos\neismit_emds\encog-core-cs\Persist\EncogDirectoryPersistence.cs,ReadLine,The following statement contains a magic number: do {  	int b = mask0.ReadByte ();  	if (b == -1) {  		return result.ToString ();  	}  	ch = (char)b;  	if ((ch != 13) && (ch != 10)) {  		result.Append (ch);  	}  }  while (ch != 10);  
Magic Number,Encog.Persist,EncogDirectoryPersistence,C:\repos\neismit_emds\encog-core-cs\Persist\EncogDirectoryPersistence.cs,ReadLine,The following statement contains a magic number: if ((ch != 13) && (ch != 10)) {  	result.Append (ch);  }  
Magic Number,Encog.Persist,EncogDirectoryPersistence,C:\repos\neismit_emds\encog-core-cs\Persist\EncogDirectoryPersistence.cs,ReadLine,The following statement contains a magic number: if ((ch != 13) && (ch != 10)) {  	result.Append (ch);  }  
Magic Number,Encog.Persist,EncogDirectoryPersistence,C:\repos\neismit_emds\encog-core-cs\Persist\EncogDirectoryPersistence.cs,SaveObject,The following statement contains a magic number: try {  	IEncogPersistor p = PersistorRegistry.Instance.GetPersistor (obj.GetType ());  	if (p == null) {  		throw new PersistError ("Do not know how to persist object: " + obj.GetType ().Name);  	}  	os.Flush ();  	var pw = new StreamWriter (os);  	DateTime now = DateTime.Now;  	pw.WriteLine ("encog'" + p.PersistClassString + "'java'" + EncogFramework.Version + "'" + p.FileVersion + "'" + (now.Ticks / 10000));  	pw.Flush ();  	p.Save (os' obj);  }  catch (IOException ex) {  	throw new PersistError (ex);  }  
Magic Number,Encog.Persist,EncogDirectoryPersistence,C:\repos\neismit_emds\encog-core-cs\Persist\EncogDirectoryPersistence.cs,SaveObject,The following statement contains a magic number: pw.WriteLine ("encog'" + p.PersistClassString + "'java'" + EncogFramework.Version + "'" + p.FileVersion + "'" + (now.Ticks / 10000));  
Magic Number,Encog.Persist,EncogFileSection,C:\repos\neismit_emds\encog-core-cs\Persist\EncogFileSection.cs,ParseDoubleArray,The following statement contains a magic number: try {  	if (!paras.ContainsKey (name)) {  		throw new PersistError ("Missing property: " + name);  	}  	v = paras [name];  	if (v.StartsWith ("##")) {  		int i = int.Parse (v.Substring (2));  		return _largeArrays [i];  	}  	else {  		return NumberList.FromList (CSVFormat.EgFormat' v);  	}  }  catch (FormatException) {  	throw new PersistError ("Field: " + name + "' " + "invalid integer: " + v);  }  
Magic Number,Encog.Persist,EncogFileSection,C:\repos\neismit_emds\encog-core-cs\Persist\EncogFileSection.cs,ParseDoubleArray,The following statement contains a magic number: if (v.StartsWith ("##")) {  	int i = int.Parse (v.Substring (2));  	return _largeArrays [i];  }  else {  	return NumberList.FromList (CSVFormat.EgFormat' v);  }  
Magic Number,Encog.Persist,EncogReadHelper,C:\repos\neismit_emds\encog-core-cs\Persist\EncogReadHelper.cs,ReadNextSection,The following statement contains a magic number: try {  	String line;  	var largeArrays = new List<double[]> ();  	while ((line = reader.ReadLine ()) != null) {  		line = line.Trim ();  		// is it a comment  		if (line.StartsWith ("//")) {  			continue;  		}  		// is it a section or subsection  		else if (line.StartsWith ("[")) {  			// handle previous section  			section = new EncogFileSection (currentSectionName' currentSubSectionName);  			foreach (String str in lines) {  				section.Lines.Add (str);  			}  			// now begin the new section  			lines.Clear ();  			String s = line.Substring (1).Trim ();  			if (!s.EndsWith ("]")) {  				throw new PersistError ("Invalid section: " + line);  			}  			s = s.Substring (0' (line.Length - 2) - (0));  			int idx = s.IndexOf (':');  			if (idx == -1) {  				currentSectionName = s;  				currentSubSectionName = "";  			}  			else {  				if (currentSectionName.Length < 1) {  					throw new PersistError ("Can't begin subsection when a section has not yet been defined: " + line);  				}  				String newSection = s.Substring (0' (idx) - (0));  				String newSubSection = s.Substring (idx + 1);  				if (!newSection.Equals (currentSectionName)) {  					throw new PersistError ("Can't begin subsection " + line + "' while we are still in the section: " + currentSectionName);  				}  				currentSubSectionName = newSubSection;  			}  			section.LargeArrays = largeArrays;  			return section;  		}  		else if (line.Length < 1) {  			continue;  		}  		else if (line.StartsWith ("##double")) {  			double[] d = ReadLargeArray (line);  			largeArrays.Add (d);  		}  		else {  			if (currentSectionName.Length < 1) {  				throw new PersistError ("Unknown command before first section: " + line);  			}  			lines.Add (line);  		}  	}  	if (currentSectionName.Length == 0) {  		return null;  	}  	section = new EncogFileSection (currentSectionName' currentSubSectionName);  	foreach (String l in lines) {  		section.Lines.Add (l);  	}  	currentSectionName = "";  	currentSubSectionName = "";  	section.LargeArrays = largeArrays;  	return section;  }  catch (IOException ex) {  	throw new PersistError (ex);  }  
Magic Number,Encog.Persist,EncogReadHelper,C:\repos\neismit_emds\encog-core-cs\Persist\EncogReadHelper.cs,ReadNextSection,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	line = line.Trim ();  	// is it a comment  	if (line.StartsWith ("//")) {  		continue;  	}  	// is it a section or subsection  	else if (line.StartsWith ("[")) {  		// handle previous section  		section = new EncogFileSection (currentSectionName' currentSubSectionName);  		foreach (String str in lines) {  			section.Lines.Add (str);  		}  		// now begin the new section  		lines.Clear ();  		String s = line.Substring (1).Trim ();  		if (!s.EndsWith ("]")) {  			throw new PersistError ("Invalid section: " + line);  		}  		s = s.Substring (0' (line.Length - 2) - (0));  		int idx = s.IndexOf (':');  		if (idx == -1) {  			currentSectionName = s;  			currentSubSectionName = "";  		}  		else {  			if (currentSectionName.Length < 1) {  				throw new PersistError ("Can't begin subsection when a section has not yet been defined: " + line);  			}  			String newSection = s.Substring (0' (idx) - (0));  			String newSubSection = s.Substring (idx + 1);  			if (!newSection.Equals (currentSectionName)) {  				throw new PersistError ("Can't begin subsection " + line + "' while we are still in the section: " + currentSectionName);  			}  			currentSubSectionName = newSubSection;  		}  		section.LargeArrays = largeArrays;  		return section;  	}  	else if (line.Length < 1) {  		continue;  	}  	else if (line.StartsWith ("##double")) {  		double[] d = ReadLargeArray (line);  		largeArrays.Add (d);  	}  	else {  		if (currentSectionName.Length < 1) {  			throw new PersistError ("Unknown command before first section: " + line);  		}  		lines.Add (line);  	}  }  
Magic Number,Encog.Persist,EncogReadHelper,C:\repos\neismit_emds\encog-core-cs\Persist\EncogReadHelper.cs,ReadNextSection,The following statement contains a magic number: if (line.StartsWith ("//")) {  	continue;  }  // is it a section or subsection  else if (line.StartsWith ("[")) {  	// handle previous section  	section = new EncogFileSection (currentSectionName' currentSubSectionName);  	foreach (String str in lines) {  		section.Lines.Add (str);  	}  	// now begin the new section  	lines.Clear ();  	String s = line.Substring (1).Trim ();  	if (!s.EndsWith ("]")) {  		throw new PersistError ("Invalid section: " + line);  	}  	s = s.Substring (0' (line.Length - 2) - (0));  	int idx = s.IndexOf (':');  	if (idx == -1) {  		currentSectionName = s;  		currentSubSectionName = "";  	}  	else {  		if (currentSectionName.Length < 1) {  			throw new PersistError ("Can't begin subsection when a section has not yet been defined: " + line);  		}  		String newSection = s.Substring (0' (idx) - (0));  		String newSubSection = s.Substring (idx + 1);  		if (!newSection.Equals (currentSectionName)) {  			throw new PersistError ("Can't begin subsection " + line + "' while we are still in the section: " + currentSectionName);  		}  		currentSubSectionName = newSubSection;  	}  	section.LargeArrays = largeArrays;  	return section;  }  else if (line.Length < 1) {  	continue;  }  else if (line.StartsWith ("##double")) {  	double[] d = ReadLargeArray (line);  	largeArrays.Add (d);  }  else {  	if (currentSectionName.Length < 1) {  		throw new PersistError ("Unknown command before first section: " + line);  	}  	lines.Add (line);  }  
Magic Number,Encog.Persist,EncogReadHelper,C:\repos\neismit_emds\encog-core-cs\Persist\EncogReadHelper.cs,ReadNextSection,The following statement contains a magic number: if (line.StartsWith ("[")) {  	// handle previous section  	section = new EncogFileSection (currentSectionName' currentSubSectionName);  	foreach (String str in lines) {  		section.Lines.Add (str);  	}  	// now begin the new section  	lines.Clear ();  	String s = line.Substring (1).Trim ();  	if (!s.EndsWith ("]")) {  		throw new PersistError ("Invalid section: " + line);  	}  	s = s.Substring (0' (line.Length - 2) - (0));  	int idx = s.IndexOf (':');  	if (idx == -1) {  		currentSectionName = s;  		currentSubSectionName = "";  	}  	else {  		if (currentSectionName.Length < 1) {  			throw new PersistError ("Can't begin subsection when a section has not yet been defined: " + line);  		}  		String newSection = s.Substring (0' (idx) - (0));  		String newSubSection = s.Substring (idx + 1);  		if (!newSection.Equals (currentSectionName)) {  			throw new PersistError ("Can't begin subsection " + line + "' while we are still in the section: " + currentSectionName);  		}  		currentSubSectionName = newSubSection;  	}  	section.LargeArrays = largeArrays;  	return section;  }  else if (line.Length < 1) {  	continue;  }  else if (line.StartsWith ("##double")) {  	double[] d = ReadLargeArray (line);  	largeArrays.Add (d);  }  else {  	if (currentSectionName.Length < 1) {  		throw new PersistError ("Unknown command before first section: " + line);  	}  	lines.Add (line);  }  
Magic Number,Encog.Persist,EncogReadHelper,C:\repos\neismit_emds\encog-core-cs\Persist\EncogReadHelper.cs,ReadNextSection,The following statement contains a magic number: s = s.Substring (0' (line.Length - 2) - (0));  
Magic Number,Encog.Persist,EncogWriteHelper,C:\repos\neismit_emds\encog-core-cs\Persist\EncogWriteHelper.cs,WriteProperty,The following statement contains a magic number: if (d.Length < 2048) {  	var result = new StringBuilder ();  	NumberList.ToList (CSVFormat.EgFormat' result' d);  	WriteProperty (name' result.ToString ());  }  else {  	xout.Write (name);  	xout.Write ("=##");  	xout.WriteLine (_largeArrayNumber++);  	xout.Write ("##double#");  	xout.WriteLine (d.Length);  	int index = 0;  	while (index < d.Length) {  		bool first = true;  		for (int i = 0; (i < 2048) && (index < d.Length); i++) {  			if (!first) {  				xout.Write ("'");  			}  			else {  				xout.Write ("   ");  			}  			xout.Write (CSVFormat.EgFormat.Format (d [index]' EncogFramework.DefaultPrecision));  			index++;  			first = false;  		}  		xout.WriteLine ();  	}  	xout.WriteLine ("##end");  }  
Magic Number,Encog.Persist,EncogWriteHelper,C:\repos\neismit_emds\encog-core-cs\Persist\EncogWriteHelper.cs,WriteProperty,The following statement contains a magic number: if (d.Length < 2048) {  	var result = new StringBuilder ();  	NumberList.ToList (CSVFormat.EgFormat' result' d);  	WriteProperty (name' result.ToString ());  }  else {  	xout.Write (name);  	xout.Write ("=##");  	xout.WriteLine (_largeArrayNumber++);  	xout.Write ("##double#");  	xout.WriteLine (d.Length);  	int index = 0;  	while (index < d.Length) {  		bool first = true;  		for (int i = 0; (i < 2048) && (index < d.Length); i++) {  			if (!first) {  				xout.Write ("'");  			}  			else {  				xout.Write ("   ");  			}  			xout.Write (CSVFormat.EgFormat.Format (d [index]' EncogFramework.DefaultPrecision));  			index++;  			first = false;  		}  		xout.WriteLine ();  	}  	xout.WriteLine ("##end");  }  
Magic Number,Encog.Persist,EncogWriteHelper,C:\repos\neismit_emds\encog-core-cs\Persist\EncogWriteHelper.cs,WriteProperty,The following statement contains a magic number: while (index < d.Length) {  	bool first = true;  	for (int i = 0; (i < 2048) && (index < d.Length); i++) {  		if (!first) {  			xout.Write ("'");  		}  		else {  			xout.Write ("   ");  		}  		xout.Write (CSVFormat.EgFormat.Format (d [index]' EncogFramework.DefaultPrecision));  		index++;  		first = false;  	}  	xout.WriteLine ();  }  
Magic Number,Encog.Persist,EncogWriteHelper,C:\repos\neismit_emds\encog-core-cs\Persist\EncogWriteHelper.cs,WriteProperty,The following statement contains a magic number: for (int i = 0; (i < 2048) && (index < d.Length); i++) {  	if (!first) {  		xout.Write ("'");  	}  	else {  		xout.Write ("   ");  	}  	xout.Write (CSVFormat.EgFormat.Format (d [index]' EncogFramework.DefaultPrecision));  	index++;  	first = false;  }  
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\neismit_emds\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: _report.Report (Steps' Step1' "Evaluate CPU' tiny= " + Format.FormatInteger (small / 100));  
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\neismit_emds\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: _report.Report (Steps' Step1' "Evaluate CPU' small= " + Format.FormatInteger (medium / 30));  
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\neismit_emds\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalMemory,The following statement contains a magic number: iterations /= 100000;  
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\neismit_emds\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalBinary,The following statement contains a magic number: iterations /= 100000;  
Magic Number,Encog.Util.Banchmark,Evaluate,C:\repos\neismit_emds\encog-core-cs\Util\Banchmark\Evaluate.cs,EvaluateTrain,The following statement contains a magic number: while (watch.ElapsedMilliseconds < (10 * Milis)) {  	iterations++;  	train.Iteration ();  }  
Magic Number,Encog.Util.Concurrency,DetermineWorkload,C:\repos\neismit_emds\encog-core-cs\Util\Concurrency\DetermineWorkload.cs,DetermineWorkload,The following statement contains a magic number: if (threads == 0) {  	var num = (int)(Math.Log (((int)Process.GetCurrentProcess ().ProcessorAffinity + 1)' 2));  	// if there is more than one processor' use processor count +1  	if (num != 1) {  		num++;  	}  	// if there is a single processor' just use one thread  	// Now see how big the training sets are going to be.  	// We want at least 100 training elements in each.  	// This method will likely be further "tuned" in future versions.  	long recordCount = _workloadSize;  	long workPerThread = recordCount / num;  	if (workPerThread < 100) {  		num = Math.Max (1' (int)(recordCount / 100));  	}  	_threadCount = num;  }  else {  	_threadCount = Math.Min (threads' workloadSize);  }  
Magic Number,Encog.Util.Concurrency,DetermineWorkload,C:\repos\neismit_emds\encog-core-cs\Util\Concurrency\DetermineWorkload.cs,DetermineWorkload,The following statement contains a magic number: if (threads == 0) {  	var num = (int)(Math.Log (((int)Process.GetCurrentProcess ().ProcessorAffinity + 1)' 2));  	// if there is more than one processor' use processor count +1  	if (num != 1) {  		num++;  	}  	// if there is a single processor' just use one thread  	// Now see how big the training sets are going to be.  	// We want at least 100 training elements in each.  	// This method will likely be further "tuned" in future versions.  	long recordCount = _workloadSize;  	long workPerThread = recordCount / num;  	if (workPerThread < 100) {  		num = Math.Max (1' (int)(recordCount / 100));  	}  	_threadCount = num;  }  else {  	_threadCount = Math.Min (threads' workloadSize);  }  
Magic Number,Encog.Util.Concurrency,DetermineWorkload,C:\repos\neismit_emds\encog-core-cs\Util\Concurrency\DetermineWorkload.cs,DetermineWorkload,The following statement contains a magic number: if (threads == 0) {  	var num = (int)(Math.Log (((int)Process.GetCurrentProcess ().ProcessorAffinity + 1)' 2));  	// if there is more than one processor' use processor count +1  	if (num != 1) {  		num++;  	}  	// if there is a single processor' just use one thread  	// Now see how big the training sets are going to be.  	// We want at least 100 training elements in each.  	// This method will likely be further "tuned" in future versions.  	long recordCount = _workloadSize;  	long workPerThread = recordCount / num;  	if (workPerThread < 100) {  		num = Math.Max (1' (int)(recordCount / 100));  	}  	_threadCount = num;  }  else {  	_threadCount = Math.Min (threads' workloadSize);  }  
Magic Number,Encog.Util.Concurrency,DetermineWorkload,C:\repos\neismit_emds\encog-core-cs\Util\Concurrency\DetermineWorkload.cs,DetermineWorkload,The following statement contains a magic number: if (workPerThread < 100) {  	num = Math.Max (1' (int)(recordCount / 100));  }  
Magic Number,Encog.Util.Concurrency,DetermineWorkload,C:\repos\neismit_emds\encog-core-cs\Util\Concurrency\DetermineWorkload.cs,DetermineWorkload,The following statement contains a magic number: if (workPerThread < 100) {  	num = Math.Max (1' (int)(recordCount / 100));  }  
Magic Number,Encog.Util.Concurrency,DetermineWorkload,C:\repos\neismit_emds\encog-core-cs\Util\Concurrency\DetermineWorkload.cs,DetermineWorkload,The following statement contains a magic number: num = Math.Max (1' (int)(recordCount / 100));  
Magic Number,Encog.Util,Format,C:\repos\neismit_emds\encog-core-cs\Util\Format.cs,FormatMemory,The following statement contains a magic number: if (memory < MemoryMeg) {  	return FormatDouble ((memory) / ((double)MemoryK)' 2) + " KB";  }  
Magic Number,Encog.Util,Format,C:\repos\neismit_emds\encog-core-cs\Util\Format.cs,FormatMemory,The following statement contains a magic number: return FormatDouble ((memory) / ((double)MemoryK)' 2) + " KB";  
Magic Number,Encog.Util,Format,C:\repos\neismit_emds\encog-core-cs\Util\Format.cs,FormatMemory,The following statement contains a magic number: if (memory < MemoryGig) {  	return FormatDouble ((memory) / ((double)MemoryMeg)' 2) + " MB";  }  
Magic Number,Encog.Util,Format,C:\repos\neismit_emds\encog-core-cs\Util\Format.cs,FormatMemory,The following statement contains a magic number: return FormatDouble ((memory) / ((double)MemoryMeg)' 2) + " MB";  
Magic Number,Encog.Util,Format,C:\repos\neismit_emds\encog-core-cs\Util\Format.cs,FormatMemory,The following statement contains a magic number: if (memory < MemoryTera) {  	return FormatDouble ((memory) / ((double)MemoryGig)' 2) + " GB";  }  
Magic Number,Encog.Util,Format,C:\repos\neismit_emds\encog-core-cs\Util\Format.cs,FormatMemory,The following statement contains a magic number: return FormatDouble ((memory) / ((double)MemoryGig)' 2) + " GB";  
Magic Number,Encog.Util,Format,C:\repos\neismit_emds\encog-core-cs\Util\Format.cs,FormatMemory,The following statement contains a magic number: return FormatDouble ((memory) / ((double)MemoryTera)' 2) + " TB";  
Magic Number,Encog.Util,Format,C:\repos\neismit_emds\encog-core-cs\Util\Format.cs,FormatPercent,The following statement contains a magic number: return (e * 100.0).ToString ("N6") + "%";  
Magic Number,Encog.Util,Format,C:\repos\neismit_emds\encog-core-cs\Util\Format.cs,FormatPercentWhole,The following statement contains a magic number: return (e * 100.0).ToString ("N0") + "%";  
Magic Number,Encog.Util,DirectoryUtil,C:\repos\neismit_emds\encog-core-cs\Util\DirectoryUtil.cs,ReadStream,The following statement contains a magic number: try {  	var sb = new StringBuilder (1024);  	var chars = new byte[BufferSize];  	while ((istream.Read (chars' 0' chars.Length)) > -1) {  		string s = Encoding.ASCII.GetString (chars);  		sb.Append (s);  	}  	return sb.ToString ();  }  catch (IOException e) {  	#if logging  	                LOGGER.Error("Exception"' e); #endif  	throw new EncogError (e);  }  
Magic Number,Encog.Util,StringUtil,C:\repos\neismit_emds\encog-core-cs\Util\StringUtil.cs,FromBytes,The following statement contains a magic number: for (int i = 0; i < b.Length; i++) {  	b2 [i * 2] = b [i];  	b2 [(i * 2) + 1] = 0;  }  
Magic Number,Encog.Util,StringUtil,C:\repos\neismit_emds\encog-core-cs\Util\StringUtil.cs,FromBytes,The following statement contains a magic number: for (int i = 0; i < b.Length; i++) {  	b2 [i * 2] = b [i];  	b2 [(i * 2) + 1] = 0;  }  
Magic Number,Encog.Util,StringUtil,C:\repos\neismit_emds\encog-core-cs\Util\StringUtil.cs,FromBytes,The following statement contains a magic number: b2 [i * 2] = b [i];  
Magic Number,Encog.Util,StringUtil,C:\repos\neismit_emds\encog-core-cs\Util\StringUtil.cs,FromBytes,The following statement contains a magic number: b2 [(i * 2) + 1] = 0;  
Magic Number,Encog.Util,YahooSearch,C:\repos\neismit_emds\encog-core-cs\Util\YahooSearch.cs,Search,The following statement contains a magic number: while (!done) {  	try {  		result = DoSearch (uri);  		done = true;  	}  	catch (IOException e) {  		if (tries == 5) {  			throw;  		}  		Thread.Sleep (5000);  	}  	tries++;  }  
Magic Number,Encog.Util,YahooSearch,C:\repos\neismit_emds\encog-core-cs\Util\YahooSearch.cs,Search,The following statement contains a magic number: while (!done) {  	try {  		result = DoSearch (uri);  		done = true;  	}  	catch (IOException e) {  		if (tries == 5) {  			throw;  		}  		Thread.Sleep (5000);  	}  	tries++;  }  
Magic Number,Encog.Util,YahooSearch,C:\repos\neismit_emds\encog-core-cs\Util\YahooSearch.cs,Search,The following statement contains a magic number: try {  	result = DoSearch (uri);  	done = true;  }  catch (IOException e) {  	if (tries == 5) {  		throw;  	}  	Thread.Sleep (5000);  }  
Magic Number,Encog.Util,YahooSearch,C:\repos\neismit_emds\encog-core-cs\Util\YahooSearch.cs,Search,The following statement contains a magic number: try {  	result = DoSearch (uri);  	done = true;  }  catch (IOException e) {  	if (tries == 5) {  		throw;  	}  	Thread.Sleep (5000);  }  
Magic Number,Encog.Util,YahooSearch,C:\repos\neismit_emds\encog-core-cs\Util\YahooSearch.cs,Search,The following statement contains a magic number: if (tries == 5) {  	throw;  }  
Magic Number,Encog.Util,YahooSearch,C:\repos\neismit_emds\encog-core-cs\Util\YahooSearch.cs,Search,The following statement contains a magic number: Thread.Sleep (5000);  
Magic Number,Encog.Util.File,Directory,C:\repos\neismit_emds\encog-core-cs\Util\File\Directory.cs,ReadStream,The following statement contains a magic number: try {  	var sb = new StringBuilder (1024);  	TextReader reader = new StreamReader (mask0);  	var chars = new char[BufferSize];  	int numRead;  	while ((numRead = reader.Read (chars' 0' chars.Length)) > -1) {  		sb.Append (new String (chars' 0' numRead));  	}  	reader.Close ();  	return sb.ToString ();  }  catch (IOException e) {  	throw new EncogError (e);  }  
Magic Number,Encog.Util.File,FileUtil,C:\repos\neismit_emds\encog-core-cs\Util\File\FileUtil.cs,ReadFileAsString,The following statement contains a magic number: while ((numRead = reader.Read (buf' 0' buf.Length)) != -1) {  	var readData = new string (buf' 0' numRead);  	fileData.Append (readData);  	buf = new char[1024];  }  
Magic Number,Encog.Util.File,FileUtil,C:\repos\neismit_emds\encog-core-cs\Util\File\FileUtil.cs,ReadFileAsString,The following statement contains a magic number: buf = new char[1024];  
Magic Number,Encog.Util.NetworkUtil,NetworkUtility,C:\repos\neismit_emds\encog-core-cs\Util\NetworkUtil\NetworkUtility.cs,DetermineAngle,The following statement contains a magic number: if (result < 0)  	result += 360;  
Magic Number,Encog.Util.NetworkUtil,NetworkUtility,C:\repos\neismit_emds\encog-core-cs\Util\NetworkUtil\NetworkUtility.cs,DetermineAngle,The following statement contains a magic number: result += 360;  
Magic Number,Encog.Util.NetworkUtil,NetworkUtility,C:\repos\neismit_emds\encog-core-cs\Util\NetworkUtil\NetworkUtility.cs,BuildTrainNeatNetwork,The following statement contains a magic number: step.Center = 0.5;  
Magic Number,Encog.Util.NetworkUtil,NetworkUtility,C:\repos\neismit_emds\encog-core-cs\Util\NetworkUtil\NetworkUtility.cs,AveragePercents,The following statement contains a magic number: return Math.Abs (first - second) / (first + second) * 100;  
Magic Number,Encog.Util.Normalize,DataNormalization,C:\repos\neismit_emds\encog-core-cs\Util\Normalize\DataNormalization.cs,ReportResult,The following statement contains a magic number: if (_lastReport >= 10000) {  	_report.Report (total' current' message);  	_lastReport = 0;  }  
Magic Number,Encog.Util.Normalize.Output.Nominal,OutputEquilateral,C:\repos\neismit_emds\encog-core-cs\Util\Normalize\Output\Nominal\OutputEquilateral.cs,AddItem,The following statement contains a magic number: AddItem (inputField' value - 0.1' value + 0.1);  
Magic Number,Encog.Util.Normalize.Output.Nominal,OutputEquilateral,C:\repos\neismit_emds\encog-core-cs\Util\Normalize\Output\Nominal\OutputEquilateral.cs,AddItem,The following statement contains a magic number: AddItem (inputField' value - 0.1' value + 0.1);  
Magic Number,Encog.Util.Normalize.Output.Nominal,OutputOneOf,C:\repos\neismit_emds\encog-core-cs\Util\Normalize\Output\Nominal\OutputOneOf.cs,AddItem,The following statement contains a magic number: AddItem (inputField' value - 0.5' value + 0.5);  
Magic Number,Encog.Util.Normalize.Output.Nominal,OutputOneOf,C:\repos\neismit_emds\encog-core-cs\Util\Normalize\Output\Nominal\OutputOneOf.cs,AddItem,The following statement contains a magic number: AddItem (inputField' value - 0.5' value + 0.5);  
Magic Number,Encog.Util.Simple,EncogUtility,C:\repos\neismit_emds\encog-core-cs\Util\Simple\EncogUtility.cs,FormatNeuralData,The following statement contains a magic number: for (int i = 0; i < data.Count; i++) {  	if (i != 0) {  		result.Append (''');  	}  	result.Append (Format.FormatDouble (data [i]' 4));  }  
Magic Number,Encog.Util.Simple,EncogUtility,C:\repos\neismit_emds\encog-core-cs\Util\Simple\EncogUtility.cs,FormatNeuralData,The following statement contains a magic number: result.Append (Format.FormatDouble (data [i]' 4));  
Magic Number,Encog.Util.Simple,EncogUtility,C:\repos\neismit_emds\encog-core-cs\Util\Simple\EncogUtility.cs,TrainConsole,The following statement contains a magic number: do {  	train.Iteration ();  	long current = Environment.TickCount;  	long elapsed = (current - start) / 1000;  	remaining = minutes - elapsed / 60;  	Console.WriteLine (@"Iteration #" + Format.FormatInteger (epoch) + @" Error:" + Format.FormatPercent (train.Error) + @" elapsed time = " + Format.FormatTimeSpan ((int)elapsed) + @" time left = " + Format.FormatTimeSpan ((int)remaining * 60));  	epoch++;  }  while (remaining > 0 && !train.TrainingDone);  
Magic Number,Encog.Util.Simple,EncogUtility,C:\repos\neismit_emds\encog-core-cs\Util\Simple\EncogUtility.cs,TrainConsole,The following statement contains a magic number: do {  	train.Iteration ();  	long current = Environment.TickCount;  	long elapsed = (current - start) / 1000;  	remaining = minutes - elapsed / 60;  	Console.WriteLine (@"Iteration #" + Format.FormatInteger (epoch) + @" Error:" + Format.FormatPercent (train.Error) + @" elapsed time = " + Format.FormatTimeSpan ((int)elapsed) + @" time left = " + Format.FormatTimeSpan ((int)remaining * 60));  	epoch++;  }  while (remaining > 0 && !train.TrainingDone);  
Magic Number,Encog.Util.Simple,EncogUtility,C:\repos\neismit_emds\encog-core-cs\Util\Simple\EncogUtility.cs,TrainConsole,The following statement contains a magic number: do {  	train.Iteration ();  	long current = Environment.TickCount;  	long elapsed = (current - start) / 1000;  	remaining = minutes - elapsed / 60;  	Console.WriteLine (@"Iteration #" + Format.FormatInteger (epoch) + @" Error:" + Format.FormatPercent (train.Error) + @" elapsed time = " + Format.FormatTimeSpan ((int)elapsed) + @" time left = " + Format.FormatTimeSpan ((int)remaining * 60));  	epoch++;  }  while (remaining > 0 && !train.TrainingDone);  
Magic Number,Encog.Util.Simple,EncogUtility,C:\repos\neismit_emds\encog-core-cs\Util\Simple\EncogUtility.cs,TrainConsole,The following statement contains a magic number: remaining = minutes - elapsed / 60;  
Magic Number,Encog.Util.Simple,EncogUtility,C:\repos\neismit_emds\encog-core-cs\Util\Simple\EncogUtility.cs,TrainConsole,The following statement contains a magic number: Console.WriteLine (@"Iteration #" + Format.FormatInteger (epoch) + @" Error:" + Format.FormatPercent (train.Error) + @" elapsed time = " + Format.FormatTimeSpan ((int)elapsed) + @" time left = " + Format.FormatTimeSpan ((int)remaining * 60));  
Magic Number,Encog.Util.Simple,EncogUtility,C:\repos\neismit_emds\encog-core-cs\Util\Simple\EncogUtility.cs,TrainConsole,The following statement contains a magic number: do {  	train.Iteration ();  	double current = Environment.TickCount;  	double elapsed = (current - start) / 1000;  	remaining = seconds - elapsed;  	Console.WriteLine (@"Iteration #" + Format.FormatInteger (epoch) + @" Error:" + Format.FormatPercent (train.Error) + @" elapsed time = " + Format.FormatTimeSpan ((int)elapsed) + @" time left = " + Format.FormatTimeSpan ((int)remaining));  	epoch++;  }  while (remaining > 0 && !train.TrainingDone);  
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\neismit_emds\encog-core-cs\Util\Simple\TrainingDialog.cs,ThreadProcess,The following statement contains a magic number: do {  	Train.Iteration ();  	long current = Environment.TickCount;  	long elapsed = (current - start);  	elapsed /= 1000;  	var obj = new object[3];  	obj [0] = "" + Format.FormatInteger (epoch);  	obj [1] = "" + Format.FormatPercent (Train.Error);  	obj [2] = "" + Format.FormatTimeSpan ((int)elapsed);  	BeginInvoke (new StatsDelegate (UpdateStats)' obj);  	epoch++;  }  while (!ShouldStop);  
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\neismit_emds\encog-core-cs\Util\Simple\TrainingDialog.cs,ThreadProcess,The following statement contains a magic number: do {  	Train.Iteration ();  	long current = Environment.TickCount;  	long elapsed = (current - start);  	elapsed /= 1000;  	var obj = new object[3];  	obj [0] = "" + Format.FormatInteger (epoch);  	obj [1] = "" + Format.FormatPercent (Train.Error);  	obj [2] = "" + Format.FormatTimeSpan ((int)elapsed);  	BeginInvoke (new StatsDelegate (UpdateStats)' obj);  	epoch++;  }  while (!ShouldStop);  
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\neismit_emds\encog-core-cs\Util\Simple\TrainingDialog.cs,ThreadProcess,The following statement contains a magic number: do {  	Train.Iteration ();  	long current = Environment.TickCount;  	long elapsed = (current - start);  	elapsed /= 1000;  	var obj = new object[3];  	obj [0] = "" + Format.FormatInteger (epoch);  	obj [1] = "" + Format.FormatPercent (Train.Error);  	obj [2] = "" + Format.FormatTimeSpan ((int)elapsed);  	BeginInvoke (new StatsDelegate (UpdateStats)' obj);  	epoch++;  }  while (!ShouldStop);  
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\neismit_emds\encog-core-cs\Util\Simple\TrainingDialog.cs,ThreadProcess,The following statement contains a magic number: elapsed /= 1000;  
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\neismit_emds\encog-core-cs\Util\Simple\TrainingDialog.cs,ThreadProcess,The following statement contains a magic number: obj [2] = "" + Format.FormatTimeSpan ((int)elapsed);  
Magic Number,Encog.Util.Time,NumericDateUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\NumericDateUtil.cs,Combine,The following statement contains a magic number: return (date * 1000000) + time;  
Magic Number,Encog.Util.Time,NumericDateUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: switch (t.DayOfWeek) {  case DayOfWeek.Sunday:  	return 0;  case DayOfWeek.Monday:  	return 1;  case DayOfWeek.Tuesday:  	return 2;  case DayOfWeek.Wednesday:  	return 3;  case DayOfWeek.Thursday:  	return 4;  case DayOfWeek.Friday:  	return 5;  case DayOfWeek.Saturday:  	return 6;  default:  	// no way this should happen!  	return -1;  }  
Magic Number,Encog.Util.Time,NumericDateUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: switch (t.DayOfWeek) {  case DayOfWeek.Sunday:  	return 0;  case DayOfWeek.Monday:  	return 1;  case DayOfWeek.Tuesday:  	return 2;  case DayOfWeek.Wednesday:  	return 3;  case DayOfWeek.Thursday:  	return 4;  case DayOfWeek.Friday:  	return 5;  case DayOfWeek.Saturday:  	return 6;  default:  	// no way this should happen!  	return -1;  }  
Magic Number,Encog.Util.Time,NumericDateUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: switch (t.DayOfWeek) {  case DayOfWeek.Sunday:  	return 0;  case DayOfWeek.Monday:  	return 1;  case DayOfWeek.Tuesday:  	return 2;  case DayOfWeek.Wednesday:  	return 3;  case DayOfWeek.Thursday:  	return 4;  case DayOfWeek.Friday:  	return 5;  case DayOfWeek.Saturday:  	return 6;  default:  	// no way this should happen!  	return -1;  }  
Magic Number,Encog.Util.Time,NumericDateUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: switch (t.DayOfWeek) {  case DayOfWeek.Sunday:  	return 0;  case DayOfWeek.Monday:  	return 1;  case DayOfWeek.Tuesday:  	return 2;  case DayOfWeek.Wednesday:  	return 3;  case DayOfWeek.Thursday:  	return 4;  case DayOfWeek.Friday:  	return 5;  case DayOfWeek.Saturday:  	return 6;  default:  	// no way this should happen!  	return -1;  }  
Magic Number,Encog.Util.Time,NumericDateUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: switch (t.DayOfWeek) {  case DayOfWeek.Sunday:  	return 0;  case DayOfWeek.Monday:  	return 1;  case DayOfWeek.Tuesday:  	return 2;  case DayOfWeek.Wednesday:  	return 3;  case DayOfWeek.Thursday:  	return 4;  case DayOfWeek.Friday:  	return 5;  case DayOfWeek.Saturday:  	return 6;  default:  	// no way this should happen!  	return -1;  }  
Magic Number,Encog.Util.Time,NumericDateUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: return 2;  
Magic Number,Encog.Util.Time,NumericDateUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: return 3;  
Magic Number,Encog.Util.Time,NumericDateUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: return 4;  
Magic Number,Encog.Util.Time,NumericDateUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: return 5;  
Magic Number,Encog.Util.Time,NumericDateUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: return 6;  
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanMinutes,The following statement contains a magic number: return GetSpanSeconds () / 60;  
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanHours,The following statement contains a magic number: return GetSpanMinutes () / 60;  
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanDays,The following statement contains a magic number: return GetSpanHours () / 24;  
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanWeeks,The following statement contains a magic number: return GetSpanDays () / 7;  
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanFortnights,The following statement contains a magic number: return GetSpanWeeks () / 2;  
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanMonths,The following statement contains a magic number: return (_to.Month - _from.Month) + (_to.Year - _from.Year) * 12;  
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanYears,The following statement contains a magic number: return GetSpanMonths () / 12;  
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanScores,The following statement contains a magic number: return GetSpanYears () / 20;  
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanCenturies,The following statement contains a magic number: return GetSpanYears () / 100;  
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\neismit_emds\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanMillennia,The following statement contains a magic number: return GetSpanYears () / 1000;  
Magic Number,Encog.Parse,PeekableInputStream,C:\repos\neismit_emds\encog-core-cs\Parse\PeekableInputStream.cs,PeekableInputStream,The following statement contains a magic number: _peekBytes = new byte[10];  
Magic Number,Encog.Parse,PeekableInputStream,C:\repos\neismit_emds\encog-core-cs\Parse\PeekableInputStream.cs,Peek,The following statement contains a magic number: if (_peekBytes.Length <= depth) {  	var temp = new byte[depth + 10];  	for (int i = 0; i < _peekBytes.Length; i++) {  		temp [i] = _peekBytes [i];  	}  	_peekBytes = temp;  }  
Magic Number,Encog.Util.CSV,NumberList,C:\repos\neismit_emds\encog-core-cs\Util\CSV\NumberList.cs,ToList,The following statement contains a magic number: ToList (format' 20' result' data);  
Magic Number,Encog.Util.DownSample,RGBDownsample,C:\repos\neismit_emds\encog-core-cs\Util\DownSample\RGBDownsample.cs,HLineClear,The following statement contains a magic number: for (int i = 0; i < _imageWidth; i++) {  	Color pixel = Image.GetPixel (i' y);  	if (pixel.R < 250 || pixel.G < 250 || pixel.B < 250) {  		return false;  	}  }  
Magic Number,Encog.Util.DownSample,RGBDownsample,C:\repos\neismit_emds\encog-core-cs\Util\DownSample\RGBDownsample.cs,HLineClear,The following statement contains a magic number: for (int i = 0; i < _imageWidth; i++) {  	Color pixel = Image.GetPixel (i' y);  	if (pixel.R < 250 || pixel.G < 250 || pixel.B < 250) {  		return false;  	}  }  
Magic Number,Encog.Util.DownSample,RGBDownsample,C:\repos\neismit_emds\encog-core-cs\Util\DownSample\RGBDownsample.cs,HLineClear,The following statement contains a magic number: for (int i = 0; i < _imageWidth; i++) {  	Color pixel = Image.GetPixel (i' y);  	if (pixel.R < 250 || pixel.G < 250 || pixel.B < 250) {  		return false;  	}  }  
Magic Number,Encog.Util.DownSample,RGBDownsample,C:\repos\neismit_emds\encog-core-cs\Util\DownSample\RGBDownsample.cs,HLineClear,The following statement contains a magic number: if (pixel.R < 250 || pixel.G < 250 || pixel.B < 250) {  	return false;  }  
Magic Number,Encog.Util.DownSample,RGBDownsample,C:\repos\neismit_emds\encog-core-cs\Util\DownSample\RGBDownsample.cs,HLineClear,The following statement contains a magic number: if (pixel.R < 250 || pixel.G < 250 || pixel.B < 250) {  	return false;  }  
Magic Number,Encog.Util.DownSample,RGBDownsample,C:\repos\neismit_emds\encog-core-cs\Util\DownSample\RGBDownsample.cs,HLineClear,The following statement contains a magic number: if (pixel.R < 250 || pixel.G < 250 || pixel.B < 250) {  	return false;  }  
Magic Number,Encog.Util.DownSample,RGBDownsample,C:\repos\neismit_emds\encog-core-cs\Util\DownSample\RGBDownsample.cs,VLineClear,The following statement contains a magic number: for (int i = 0; i < _imageHeight; i++) {  	Color pixel = Image.GetPixel (x' i);  	if (pixel.R < 250 || pixel.G < 250 || pixel.B < 250) {  		return false;  	}  }  
Magic Number,Encog.Util.DownSample,RGBDownsample,C:\repos\neismit_emds\encog-core-cs\Util\DownSample\RGBDownsample.cs,VLineClear,The following statement contains a magic number: for (int i = 0; i < _imageHeight; i++) {  	Color pixel = Image.GetPixel (x' i);  	if (pixel.R < 250 || pixel.G < 250 || pixel.B < 250) {  		return false;  	}  }  
Magic Number,Encog.Util.DownSample,RGBDownsample,C:\repos\neismit_emds\encog-core-cs\Util\DownSample\RGBDownsample.cs,VLineClear,The following statement contains a magic number: for (int i = 0; i < _imageHeight; i++) {  	Color pixel = Image.GetPixel (x' i);  	if (pixel.R < 250 || pixel.G < 250 || pixel.B < 250) {  		return false;  	}  }  
Magic Number,Encog.Util.DownSample,RGBDownsample,C:\repos\neismit_emds\encog-core-cs\Util\DownSample\RGBDownsample.cs,VLineClear,The following statement contains a magic number: if (pixel.R < 250 || pixel.G < 250 || pixel.B < 250) {  	return false;  }  
Magic Number,Encog.Util.DownSample,RGBDownsample,C:\repos\neismit_emds\encog-core-cs\Util\DownSample\RGBDownsample.cs,VLineClear,The following statement contains a magic number: if (pixel.R < 250 || pixel.G < 250 || pixel.B < 250) {  	return false;  }  
Magic Number,Encog.Util.DownSample,RGBDownsample,C:\repos\neismit_emds\encog-core-cs\Util\DownSample\RGBDownsample.cs,VLineClear,The following statement contains a magic number: if (pixel.R < 250 || pixel.G < 250 || pixel.B < 250) {  	return false;  }  
Magic Number,Encog.Util.DownSample,SimpleIntensityDownsample,C:\repos\neismit_emds\encog-core-cs\Util\DownSample\SimpleIntensityDownsample.cs,DownSample,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	for (int x = 0; x < width; x++) {  		DownSampleRegion (x' y);  		result [index++] = (CurrentRed + CurrentBlue + CurrentGreen) / 3;  	}  }  
Magic Number,Encog.Util.DownSample,SimpleIntensityDownsample,C:\repos\neismit_emds\encog-core-cs\Util\DownSample\SimpleIntensityDownsample.cs,DownSample,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	DownSampleRegion (x' y);  	result [index++] = (CurrentRed + CurrentBlue + CurrentGreen) / 3;  }  
Magic Number,Encog.Util.DownSample,SimpleIntensityDownsample,C:\repos\neismit_emds\encog-core-cs\Util\DownSample\SimpleIntensityDownsample.cs,DownSample,The following statement contains a magic number: result [index++] = (CurrentRed + CurrentBlue + CurrentGreen) / 3;  
Magic Number,Encog.Util.HTTP,FormUtility,C:\repos\neismit_emds\encog-core-cs\Util\HTTP\FormUtility.cs,AddFile,The following statement contains a magic number: if (_boundary != null) {  	Boundary ();  	WriteName (name);  	Write ("; filename=\"");  	Write (file);  	Write ("\"");  	Newline ();  	Write ("Content-Type: ");  	Writeln (type);  	Newline ();  	var buf = new byte[8192];  	int nread;  	_writer.Flush ();  	_os.Flush ();  	Stream istream = new FileStream (file' FileMode.Open);  	while ((nread = istream.Read (buf' 0' buf.Length)) > 0) {  		_os.Write (buf' 0' nread);  	}  	_os.Flush ();  	Newline ();  }  
Magic Number,Encog.Util.HTTP,URLUtility,C:\repos\neismit_emds\encog-core-cs\Util\HTTP\URLUtility.cs,ConstructURL,The following statement contains a magic number: if (port == 80 && String.Compare (protocol' "http") != 0) {  	sb.Append (':');  	sb.Append ("80");  }  else if (port == 443 && String.Compare (protocol' "https") != 0) {  	sb.Append (':');  	sb.Append ("443");  }  
Magic Number,Encog.Util.HTTP,URLUtility,C:\repos\neismit_emds\encog-core-cs\Util\HTTP\URLUtility.cs,ConstructURL,The following statement contains a magic number: if (port == 80 && String.Compare (protocol' "http") != 0) {  	sb.Append (':');  	sb.Append ("80");  }  else if (port == 443 && String.Compare (protocol' "https") != 0) {  	sb.Append (':');  	sb.Append ("443");  }  
Magic Number,Encog.Util.HTTP,URLUtility,C:\repos\neismit_emds\encog-core-cs\Util\HTTP\URLUtility.cs,ConstructURL,The following statement contains a magic number: if (port == 443 && String.Compare (protocol' "https") != 0) {  	sb.Append (':');  	sb.Append ("443");  }  
Magic Number,Encog.Util.HTTP,URLUtility,C:\repos\neismit_emds\encog-core-cs\Util\HTTP\URLUtility.cs,ContainsInvalidURLCharacters,The following statement contains a magic number: return url.Any (ch => ch > 255);  
Missing Default,Encog.MathUtil.LIBSVM,svm,C:\repos\neismit_emds\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train_one,The following switch statement is missing a default case: switch (param.svm_type) {  case svm_parameter.C_SVC:  	solve_c_svc (prob' param' alpha' si' Cp' Cn);  	break;  case svm_parameter.NU_SVC:  	solve_nu_svc (prob' param' alpha' si);  	break;  case svm_parameter.ONE_CLASS:  	solve_one_class (prob' param' alpha' si);  	break;  case svm_parameter.EPSILON_SVR:  	solve_epsilon_svr (prob' param' alpha' si);  	break;  case svm_parameter.NU_SVR:  	solve_nu_svr (prob' param' alpha' si);  	break;  }  
Missing Default,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\neismit_emds\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following switch statement is missing a default case: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [p - 1];  					vmatrix [i] [p - 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [p - 1];  					vmatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = EncogMath.Hypot (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [k - 1];  					umatrix [i] [k - 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [k - 1];  					umatrix [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0) {  				shift = -shift;  			}  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = EncogMath.Hypot (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k) {  				e [j - 1] = t;  			}  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * vmatrix [i] [j] + sn * vmatrix [i] [j + 1];  					vmatrix [i] [j + 1] = -sn * vmatrix [i] [j] + cs * vmatrix [i] [j + 1];  					vmatrix [i] [j] = t;  				}  			}  			t = EncogMath.Hypot (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * umatrix [i] [j] + sn * umatrix [i] [j + 1];  					umatrix [i] [j + 1] = -sn * umatrix [i] [j] + cs * umatrix [i] [j + 1];  					umatrix [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv) {  				for (int i = 0; i <= pp; i++) {  					vmatrix [i] [k] = -vmatrix [i] [k];  				}  			}  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1]) {  				break;  			}  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1)) {  				for (int i = 0; i < n; i++) {  					t = vmatrix [i] [k + 1];  					vmatrix [i] [k + 1] = vmatrix [i] [k];  					vmatrix [i] [k] = t;  				}  			}  			if (wantu && (k < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = umatrix [i] [k + 1];  					umatrix [i] [k + 1] = umatrix [i] [k];  					umatrix [i] [k] = t;  				}  			}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Missing Default,Encog.ML.Bayesian.Query,BasicQuery,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Query\BasicQuery.cs,LocateEventTypes,The following switch statement is missing a default case: switch (GetEventType (e)) {  case EventType.Evidence:  	_evidenceEvents.Add (e);  	break;  case EventType.Outcome:  	_outcomeEvents.Add (e);  	break;  }  
Missing Default,Encog.ML.Bayesian.Training,TrainBayesian,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Training\TrainBayesian.cs,IterationInit,The following switch statement is missing a default case: switch (_initNetwork) {  case BayesianInit.InitEmpty:  	_network.RemoveAllRelations ();  	_network.FinalizeStructure ();  	break;  case BayesianInit.InitNoChange:  	break;  case BayesianInit.InitNaiveBayes:  	InitNaiveBayes ();  	break;  }  
Missing Default,Encog.ML.Bayesian.Training,TrainBayesian,C:\repos\neismit_emds\encog-core-cs\ML\Bayesian\Training\TrainBayesian.cs,Iteration,The following switch statement is missing a default case: switch (_p) {  case Phase.Init:  	IterationInit ();  	break;  case Phase.Search:  	IterationSearch ();  	break;  case Phase.SearchDone:  	IterationSearchDone ();  	break;  case Phase.Probability:  	IterationProbability ();  	break;  case Phase.Finish:  	IterationFinish ();  	break;  }  
Missing Default,Encog.Neural.NEAT,NEATNeuron,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\NEATNeuron.cs,String2NeuronType,The following switch statement is missing a default case: switch ((int)type [0]) {  case 'i':  	return NEATNeuronType.Input;  case 'o':  	return NEATNeuronType.Output;  case 'h':  	return NEATNeuronType.Hidden;  case 'b':  	return NEATNeuronType.Bias;  case 'n':  	return NEATNeuronType.None;  }  
Missing Default,Encog.Neural.NEAT.Training,NEATInnovation,C:\repos\neismit_emds\encog-core-cs\Neural\NEAT\Training\NEATInnovation.cs,ToString,The following switch statement is missing a default case: switch (innovationType) {  case NEATInnovationType.NewLink:  	result.Append ("link");  	break;  case NEATInnovationType.NewNeuron:  	result.Append ("neuron");  	break;  }  
Missing Default,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following switch statement is missing a default case: switch (type) {  case RBFEnum.Gaussian:  	_rbf = new GaussianFunction (2);  	break;  case RBFEnum.InverseMultiquadric:  	_rbf = new InverseMultiquadricFunction (2);  	break;  case RBFEnum.Multiquadric:  	_rbf = new MultiquadricFunction (2);  	break;  case RBFEnum.MexicanHat:  	_rbf = new MexicanHatFunction (2);  	break;  }  
Missing Default,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\neismit_emds\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following switch statement is missing a default case: switch (type) {  case RBFEnum.Gaussian:  	_rbf = new GaussianFunction (2);  	break;  case RBFEnum.InverseMultiquadric:  	_rbf = new InverseMultiquadricFunction (2);  	break;  case RBFEnum.Multiquadric:  	_rbf = new MultiquadricFunction (2);  	break;  case RBFEnum.MexicanHat:  	_rbf = new MexicanHatFunction (2);  	break;  }  
