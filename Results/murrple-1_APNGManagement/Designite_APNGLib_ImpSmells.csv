Implementation smell,Namespace,Class,File,Method,Description
Complex Method,APNGLib,APNG,C:\repos\murrple-1_APNGManagement\APNGLib\APNG.cs,HandleChunk,Cyclomatic complexity of the method is 13
Complex Method,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,AssembleAPNG,Cyclomatic complexity of the method is 10
Complex Method,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,Cyclomatic complexity of the method is 18
Complex Method,APNGLib,ImageRender,C:\repos\murrple-1_APNGManagement\APNGLib\ImageRender.cs,DisposeBuffer,Cyclomatic complexity of the method is 13
Complex Method,APNGLib,ImageRender,C:\repos\murrple-1_APNGManagement\APNGLib\ImageRender.cs,RenderNextFrame,Cyclomatic complexity of the method is 10
Complex Method,APNGLib,PNG,C:\repos\murrple-1_APNGManagement\APNGLib\PNG.cs,HandleChunk,Cyclomatic complexity of the method is 55
Complex Method,APNGLib,PNG,C:\repos\murrple-1_APNGManagement\APNGLib\PNG.cs,Handle_bKGD,Cyclomatic complexity of the method is 18
Complex Method,APNGLib,PNG,C:\repos\murrple-1_APNGManagement\APNGLib\PNG.cs,Handle_sBIT,Cyclomatic complexity of the method is 18
Complex Method,APNGLib,PNG,C:\repos\murrple-1_APNGManagement\APNGLib\PNG.cs,Handle_tRNS,Cyclomatic complexity of the method is 15
Long Parameter List,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,CreateFrame,The method has 7 parameters.
Long Statement,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The length of the statement  "		data = source.LockBits (new Rectangle (0' 0' source.Width' source.Height)' ImageLockMode.ReadOnly' PixelFormat.Format32bppArgb); " is 128.
Long Statement,APNGLib,PNG,C:\repos\murrple-1_APNGManagement\APNGLib\PNG.cs,GetNextChunk,The length of the statement  "		throw new ApplicationException (String.Format ("APNG Chunk CRC Mismatch.  Chunk CRC = {0}' Calculated CRC = {1}."' readCRC' calcCRC)); " is 134.
Long Statement,APNGLib,PNGUtils,C:\repos\murrple-1_APNGManagement\APNGLib\PNGUtils.cs,ParseUshort,The length of the statement  "		throw new ArgumentException (String.Format ("buffer is not long enough to extract {0} bytes at offset {1}"' sizeof(ushort)' offset)); " is 133.
Long Statement,APNGLib,PNGUtils,C:\repos\murrple-1_APNGManagement\APNGLib\PNGUtils.cs,ParseUint,The length of the statement  "		throw new ArgumentException (String.Format ("buffer is not long enough to extract {0} bytes at offset {1}"' sizeof(uint)' offset)); " is 131.
Long Statement,APNGLib,PNGUtils,C:\repos\murrple-1_APNGManagement\APNGLib\PNGUtils.cs,ParseString,The length of the statement  "		throw new ArgumentException (String.Format ("buffer is not long enough to extract {0} bytes at offset {1}"' length' offset)); " is 125.
Long Statement,APNGLib,PNGUtils,C:\repos\murrple-1_APNGManagement\APNGLib\PNGUtils.cs,ParseByteArray,The length of the statement  "		throw new ArgumentException (String.Format ("buffer is not long enough to extract {0} bytes at offset {1}"' length' offset)); " is 125.
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: try {  	data = source.LockBits (new Rectangle (0' 0' source.Width' source.Height)' ImageLockMode.ReadOnly' PixelFormat.Format32bppArgb);  	byte[] buffer = new byte[data.Height * data.Stride];  	System.Runtime.InteropServices.Marshal.Copy (data.Scan0' buffer' 0' buffer.Length);  	int xMin = int.MaxValue' xMax = int.MinValue' yMin = int.MaxValue' yMax = int.MinValue;  	bool foundPixel = false;  	// Find xMin  	for (int x = 0; x < data.Width; x++) {  		bool stop = false;  		for (int y = 0; y < data.Height; y++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				xMin = x;  				stop = true;  				foundPixel = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	if (!foundPixel) {  		// Image is empty...  		p = new Point (0' 0);  		return new Bitmap (1' 1);  	}  	// Find yMin  	for (int y = 0; y < data.Height; y++) {  		bool stop = false;  		for (int x = xMin; x < data.Width; x++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				yMin = y;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	// Find xMax  	for (int x = data.Width - 1; x >= xMin; x--) {  		bool stop = false;  		for (int y = yMin; y < data.Height; y++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				xMax = x;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	// Find yMax  	for (int y = data.Height - 1; y >= yMin; y--) {  		bool stop = false;  		for (int x = xMin; x <= xMax; x++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				yMax = y;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	srcRect = Rectangle.FromLTRB (xMin' yMin' xMax' yMax);  	p = new Point (xMin' yMin);  }  finally {  	if (data != null) {  		source.UnlockBits (data);  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: try {  	data = source.LockBits (new Rectangle (0' 0' source.Width' source.Height)' ImageLockMode.ReadOnly' PixelFormat.Format32bppArgb);  	byte[] buffer = new byte[data.Height * data.Stride];  	System.Runtime.InteropServices.Marshal.Copy (data.Scan0' buffer' 0' buffer.Length);  	int xMin = int.MaxValue' xMax = int.MinValue' yMin = int.MaxValue' yMax = int.MinValue;  	bool foundPixel = false;  	// Find xMin  	for (int x = 0; x < data.Width; x++) {  		bool stop = false;  		for (int y = 0; y < data.Height; y++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				xMin = x;  				stop = true;  				foundPixel = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	if (!foundPixel) {  		// Image is empty...  		p = new Point (0' 0);  		return new Bitmap (1' 1);  	}  	// Find yMin  	for (int y = 0; y < data.Height; y++) {  		bool stop = false;  		for (int x = xMin; x < data.Width; x++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				yMin = y;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	// Find xMax  	for (int x = data.Width - 1; x >= xMin; x--) {  		bool stop = false;  		for (int y = yMin; y < data.Height; y++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				xMax = x;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	// Find yMax  	for (int y = data.Height - 1; y >= yMin; y--) {  		bool stop = false;  		for (int x = xMin; x <= xMax; x++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				yMax = y;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	srcRect = Rectangle.FromLTRB (xMin' yMin' xMax' yMax);  	p = new Point (xMin' yMin);  }  finally {  	if (data != null) {  		source.UnlockBits (data);  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: try {  	data = source.LockBits (new Rectangle (0' 0' source.Width' source.Height)' ImageLockMode.ReadOnly' PixelFormat.Format32bppArgb);  	byte[] buffer = new byte[data.Height * data.Stride];  	System.Runtime.InteropServices.Marshal.Copy (data.Scan0' buffer' 0' buffer.Length);  	int xMin = int.MaxValue' xMax = int.MinValue' yMin = int.MaxValue' yMax = int.MinValue;  	bool foundPixel = false;  	// Find xMin  	for (int x = 0; x < data.Width; x++) {  		bool stop = false;  		for (int y = 0; y < data.Height; y++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				xMin = x;  				stop = true;  				foundPixel = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	if (!foundPixel) {  		// Image is empty...  		p = new Point (0' 0);  		return new Bitmap (1' 1);  	}  	// Find yMin  	for (int y = 0; y < data.Height; y++) {  		bool stop = false;  		for (int x = xMin; x < data.Width; x++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				yMin = y;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	// Find xMax  	for (int x = data.Width - 1; x >= xMin; x--) {  		bool stop = false;  		for (int y = yMin; y < data.Height; y++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				xMax = x;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	// Find yMax  	for (int y = data.Height - 1; y >= yMin; y--) {  		bool stop = false;  		for (int x = xMin; x <= xMax; x++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				yMax = y;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	srcRect = Rectangle.FromLTRB (xMin' yMin' xMax' yMax);  	p = new Point (xMin' yMin);  }  finally {  	if (data != null) {  		source.UnlockBits (data);  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: try {  	data = source.LockBits (new Rectangle (0' 0' source.Width' source.Height)' ImageLockMode.ReadOnly' PixelFormat.Format32bppArgb);  	byte[] buffer = new byte[data.Height * data.Stride];  	System.Runtime.InteropServices.Marshal.Copy (data.Scan0' buffer' 0' buffer.Length);  	int xMin = int.MaxValue' xMax = int.MinValue' yMin = int.MaxValue' yMax = int.MinValue;  	bool foundPixel = false;  	// Find xMin  	for (int x = 0; x < data.Width; x++) {  		bool stop = false;  		for (int y = 0; y < data.Height; y++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				xMin = x;  				stop = true;  				foundPixel = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	if (!foundPixel) {  		// Image is empty...  		p = new Point (0' 0);  		return new Bitmap (1' 1);  	}  	// Find yMin  	for (int y = 0; y < data.Height; y++) {  		bool stop = false;  		for (int x = xMin; x < data.Width; x++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				yMin = y;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	// Find xMax  	for (int x = data.Width - 1; x >= xMin; x--) {  		bool stop = false;  		for (int y = yMin; y < data.Height; y++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				xMax = x;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	// Find yMax  	for (int y = data.Height - 1; y >= yMin; y--) {  		bool stop = false;  		for (int x = xMin; x <= xMax; x++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				yMax = y;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	srcRect = Rectangle.FromLTRB (xMin' yMin' xMax' yMax);  	p = new Point (xMin' yMin);  }  finally {  	if (data != null) {  		source.UnlockBits (data);  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: try {  	data = source.LockBits (new Rectangle (0' 0' source.Width' source.Height)' ImageLockMode.ReadOnly' PixelFormat.Format32bppArgb);  	byte[] buffer = new byte[data.Height * data.Stride];  	System.Runtime.InteropServices.Marshal.Copy (data.Scan0' buffer' 0' buffer.Length);  	int xMin = int.MaxValue' xMax = int.MinValue' yMin = int.MaxValue' yMax = int.MinValue;  	bool foundPixel = false;  	// Find xMin  	for (int x = 0; x < data.Width; x++) {  		bool stop = false;  		for (int y = 0; y < data.Height; y++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				xMin = x;  				stop = true;  				foundPixel = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	if (!foundPixel) {  		// Image is empty...  		p = new Point (0' 0);  		return new Bitmap (1' 1);  	}  	// Find yMin  	for (int y = 0; y < data.Height; y++) {  		bool stop = false;  		for (int x = xMin; x < data.Width; x++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				yMin = y;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	// Find xMax  	for (int x = data.Width - 1; x >= xMin; x--) {  		bool stop = false;  		for (int y = yMin; y < data.Height; y++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				xMax = x;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	// Find yMax  	for (int y = data.Height - 1; y >= yMin; y--) {  		bool stop = false;  		for (int x = xMin; x <= xMax; x++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				yMax = y;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	srcRect = Rectangle.FromLTRB (xMin' yMin' xMax' yMax);  	p = new Point (xMin' yMin);  }  finally {  	if (data != null) {  		source.UnlockBits (data);  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: try {  	data = source.LockBits (new Rectangle (0' 0' source.Width' source.Height)' ImageLockMode.ReadOnly' PixelFormat.Format32bppArgb);  	byte[] buffer = new byte[data.Height * data.Stride];  	System.Runtime.InteropServices.Marshal.Copy (data.Scan0' buffer' 0' buffer.Length);  	int xMin = int.MaxValue' xMax = int.MinValue' yMin = int.MaxValue' yMax = int.MinValue;  	bool foundPixel = false;  	// Find xMin  	for (int x = 0; x < data.Width; x++) {  		bool stop = false;  		for (int y = 0; y < data.Height; y++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				xMin = x;  				stop = true;  				foundPixel = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	if (!foundPixel) {  		// Image is empty...  		p = new Point (0' 0);  		return new Bitmap (1' 1);  	}  	// Find yMin  	for (int y = 0; y < data.Height; y++) {  		bool stop = false;  		for (int x = xMin; x < data.Width; x++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				yMin = y;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	// Find xMax  	for (int x = data.Width - 1; x >= xMin; x--) {  		bool stop = false;  		for (int y = yMin; y < data.Height; y++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				xMax = x;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	// Find yMax  	for (int y = data.Height - 1; y >= yMin; y--) {  		bool stop = false;  		for (int x = xMin; x <= xMax; x++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				yMax = y;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	srcRect = Rectangle.FromLTRB (xMin' yMin' xMax' yMax);  	p = new Point (xMin' yMin);  }  finally {  	if (data != null) {  		source.UnlockBits (data);  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: try {  	data = source.LockBits (new Rectangle (0' 0' source.Width' source.Height)' ImageLockMode.ReadOnly' PixelFormat.Format32bppArgb);  	byte[] buffer = new byte[data.Height * data.Stride];  	System.Runtime.InteropServices.Marshal.Copy (data.Scan0' buffer' 0' buffer.Length);  	int xMin = int.MaxValue' xMax = int.MinValue' yMin = int.MaxValue' yMax = int.MinValue;  	bool foundPixel = false;  	// Find xMin  	for (int x = 0; x < data.Width; x++) {  		bool stop = false;  		for (int y = 0; y < data.Height; y++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				xMin = x;  				stop = true;  				foundPixel = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	if (!foundPixel) {  		// Image is empty...  		p = new Point (0' 0);  		return new Bitmap (1' 1);  	}  	// Find yMin  	for (int y = 0; y < data.Height; y++) {  		bool stop = false;  		for (int x = xMin; x < data.Width; x++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				yMin = y;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	// Find xMax  	for (int x = data.Width - 1; x >= xMin; x--) {  		bool stop = false;  		for (int y = yMin; y < data.Height; y++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				xMax = x;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	// Find yMax  	for (int y = data.Height - 1; y >= yMin; y--) {  		bool stop = false;  		for (int x = xMin; x <= xMax; x++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				yMax = y;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	srcRect = Rectangle.FromLTRB (xMin' yMin' xMax' yMax);  	p = new Point (xMin' yMin);  }  finally {  	if (data != null) {  		source.UnlockBits (data);  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: try {  	data = source.LockBits (new Rectangle (0' 0' source.Width' source.Height)' ImageLockMode.ReadOnly' PixelFormat.Format32bppArgb);  	byte[] buffer = new byte[data.Height * data.Stride];  	System.Runtime.InteropServices.Marshal.Copy (data.Scan0' buffer' 0' buffer.Length);  	int xMin = int.MaxValue' xMax = int.MinValue' yMin = int.MaxValue' yMax = int.MinValue;  	bool foundPixel = false;  	// Find xMin  	for (int x = 0; x < data.Width; x++) {  		bool stop = false;  		for (int y = 0; y < data.Height; y++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				xMin = x;  				stop = true;  				foundPixel = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	if (!foundPixel) {  		// Image is empty...  		p = new Point (0' 0);  		return new Bitmap (1' 1);  	}  	// Find yMin  	for (int y = 0; y < data.Height; y++) {  		bool stop = false;  		for (int x = xMin; x < data.Width; x++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				yMin = y;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	// Find xMax  	for (int x = data.Width - 1; x >= xMin; x--) {  		bool stop = false;  		for (int y = yMin; y < data.Height; y++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				xMax = x;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	// Find yMax  	for (int y = data.Height - 1; y >= yMin; y--) {  		bool stop = false;  		for (int x = xMin; x <= xMax; x++) {  			byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  			if (alpha != 0) {  				yMax = y;  				stop = true;  				break;  			}  		}  		if (stop) {  			break;  		}  	}  	srcRect = Rectangle.FromLTRB (xMin' yMin' xMax' yMax);  	p = new Point (xMin' yMin);  }  finally {  	if (data != null) {  		source.UnlockBits (data);  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: for (int x = 0; x < data.Width; x++) {  	bool stop = false;  	for (int y = 0; y < data.Height; y++) {  		byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  		if (alpha != 0) {  			xMin = x;  			stop = true;  			foundPixel = true;  			break;  		}  	}  	if (stop) {  		break;  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: for (int x = 0; x < data.Width; x++) {  	bool stop = false;  	for (int y = 0; y < data.Height; y++) {  		byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  		if (alpha != 0) {  			xMin = x;  			stop = true;  			foundPixel = true;  			break;  		}  	}  	if (stop) {  		break;  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: for (int y = 0; y < data.Height; y++) {  	byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  	if (alpha != 0) {  		xMin = x;  		stop = true;  		foundPixel = true;  		break;  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: for (int y = 0; y < data.Height; y++) {  	byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  	if (alpha != 0) {  		xMin = x;  		stop = true;  		foundPixel = true;  		break;  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: for (int y = 0; y < data.Height; y++) {  	bool stop = false;  	for (int x = xMin; x < data.Width; x++) {  		byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  		if (alpha != 0) {  			yMin = y;  			stop = true;  			break;  		}  	}  	if (stop) {  		break;  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: for (int y = 0; y < data.Height; y++) {  	bool stop = false;  	for (int x = xMin; x < data.Width; x++) {  		byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  		if (alpha != 0) {  			yMin = y;  			stop = true;  			break;  		}  	}  	if (stop) {  		break;  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: for (int x = xMin; x < data.Width; x++) {  	byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  	if (alpha != 0) {  		yMin = y;  		stop = true;  		break;  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: for (int x = xMin; x < data.Width; x++) {  	byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  	if (alpha != 0) {  		yMin = y;  		stop = true;  		break;  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: for (int x = data.Width - 1; x >= xMin; x--) {  	bool stop = false;  	for (int y = yMin; y < data.Height; y++) {  		byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  		if (alpha != 0) {  			xMax = x;  			stop = true;  			break;  		}  	}  	if (stop) {  		break;  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: for (int x = data.Width - 1; x >= xMin; x--) {  	bool stop = false;  	for (int y = yMin; y < data.Height; y++) {  		byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  		if (alpha != 0) {  			xMax = x;  			stop = true;  			break;  		}  	}  	if (stop) {  		break;  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: for (int y = yMin; y < data.Height; y++) {  	byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  	if (alpha != 0) {  		xMax = x;  		stop = true;  		break;  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: for (int y = yMin; y < data.Height; y++) {  	byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  	if (alpha != 0) {  		xMax = x;  		stop = true;  		break;  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: for (int y = data.Height - 1; y >= yMin; y--) {  	bool stop = false;  	for (int x = xMin; x <= xMax; x++) {  		byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  		if (alpha != 0) {  			yMax = y;  			stop = true;  			break;  		}  	}  	if (stop) {  		break;  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: for (int y = data.Height - 1; y >= yMin; y--) {  	bool stop = false;  	for (int x = xMin; x <= xMax; x++) {  		byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  		if (alpha != 0) {  			yMax = y;  			stop = true;  			break;  		}  	}  	if (stop) {  		break;  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: for (int x = xMin; x <= xMax; x++) {  	byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  	if (alpha != 0) {  		yMax = y;  		stop = true;  		break;  	}  }  
Magic Number,APNGLib,APNGAssembler,C:\repos\murrple-1_APNGManagement\APNGLib\APNGAssembler.cs,TrimBitmap,The following statement contains a magic number: for (int x = xMin; x <= xMax; x++) {  	byte alpha = buffer [(y * data.Stride) + (4 * x) + 3];  	if (alpha != 0) {  		yMax = y;  		stop = true;  		break;  	}  }  
Magic Number,APNGLib,CRC,C:\repos\murrple-1_APNGManagement\APNGLib\CRC.cs,MakeCRCTable,The following statement contains a magic number: crcTable = new uint[256];  
Magic Number,APNGLib,CRC,C:\repos\murrple-1_APNGManagement\APNGLib\CRC.cs,MakeCRCTable,The following statement contains a magic number: for (n = 0; n < crcTable.Length; n++) {  	c = n;  	for (k = 0; k < 8; k++) {  		if ((c & 1) != 0) {  			c = 0xedb88320 ^ (c >> 1);  		}  		else {  			c = c >> 1;  		}  	}  	crcTable [n] = c;  }  
Magic Number,APNGLib,CRC,C:\repos\murrple-1_APNGManagement\APNGLib\CRC.cs,MakeCRCTable,The following statement contains a magic number: for (k = 0; k < 8; k++) {  	if ((c & 1) != 0) {  		c = 0xedb88320 ^ (c >> 1);  	}  	else {  		c = c >> 1;  	}  }  
Magic Number,APNGLib,CRC,C:\repos\murrple-1_APNGManagement\APNGLib\CRC.cs,UpdateCRC,The following statement contains a magic number: for (n = 0; n < bytes.Length; n++) {  	c = crcTable [(c ^ bytes [n]) & 0xff] ^ (c >> 8);  }  
Magic Number,APNGLib,CRC,C:\repos\murrple-1_APNGManagement\APNGLib\CRC.cs,UpdateCRC,The following statement contains a magic number: c = crcTable [(c ^ bytes [n]) & 0xff] ^ (c >> 8);  
Magic Number,APNGLib,PNG,C:\repos\murrple-1_APNGManagement\APNGLib\PNG.cs,GetNextChunk,The following statement contains a magic number: stream.Read (type' 0' 4);  
Magic Number,APNGLib,PNG,C:\repos\murrple-1_APNGManagement\APNGLib\PNG.cs,GetNextChunk,The following statement contains a magic number: value.ChunkType = PNGUtils.ParseString (type' 4);  
Magic Number,APNGLib,PNG,C:\repos\murrple-1_APNGManagement\APNGLib\PNG.cs,Handle_bKGD,The following statement contains a magic number: switch (IHDR.ColorType) {  case 0:  	bKGD = new bKGDChunkType0 ();  	break;  case 2:  	bKGD = new bKGDChunkType2 ();  	break;  case 3:  	bKGD = new bKGDChunkType3 ();  	break;  case 4:  	bKGD = new bKGDChunkType4 ();  	break;  case 6:  	bKGD = new bKGDChunkType6 ();  	break;  default:  	throw new ApplicationException ("Colour type is not supported");  }  
Magic Number,APNGLib,PNG,C:\repos\murrple-1_APNGManagement\APNGLib\PNG.cs,Handle_bKGD,The following statement contains a magic number: switch (IHDR.ColorType) {  case 0:  	bKGD = new bKGDChunkType0 ();  	break;  case 2:  	bKGD = new bKGDChunkType2 ();  	break;  case 3:  	bKGD = new bKGDChunkType3 ();  	break;  case 4:  	bKGD = new bKGDChunkType4 ();  	break;  case 6:  	bKGD = new bKGDChunkType6 ();  	break;  default:  	throw new ApplicationException ("Colour type is not supported");  }  
Magic Number,APNGLib,PNG,C:\repos\murrple-1_APNGManagement\APNGLib\PNG.cs,Handle_bKGD,The following statement contains a magic number: switch (IHDR.ColorType) {  case 0:  	bKGD = new bKGDChunkType0 ();  	break;  case 2:  	bKGD = new bKGDChunkType2 ();  	break;  case 3:  	bKGD = new bKGDChunkType3 ();  	break;  case 4:  	bKGD = new bKGDChunkType4 ();  	break;  case 6:  	bKGD = new bKGDChunkType6 ();  	break;  default:  	throw new ApplicationException ("Colour type is not supported");  }  
Magic Number,APNGLib,PNG,C:\repos\murrple-1_APNGManagement\APNGLib\PNG.cs,Handle_bKGD,The following statement contains a magic number: switch (IHDR.ColorType) {  case 0:  	bKGD = new bKGDChunkType0 ();  	break;  case 2:  	bKGD = new bKGDChunkType2 ();  	break;  case 3:  	bKGD = new bKGDChunkType3 ();  	break;  case 4:  	bKGD = new bKGDChunkType4 ();  	break;  case 6:  	bKGD = new bKGDChunkType6 ();  	break;  default:  	throw new ApplicationException ("Colour type is not supported");  }  
Magic Number,APNGLib,PNG,C:\repos\murrple-1_APNGManagement\APNGLib\PNG.cs,Handle_sBIT,The following statement contains a magic number: switch (IHDR.ColorType) {  case 0:  	sBIT = new sBITChunkType0 ();  	break;  case 2:  	sBIT = new sBITChunkType2 ();  	break;  case 3:  	sBIT = new sBITChunkType3 ();  	break;  case 4:  	sBIT = new sBITChunkType4 ();  	break;  case 6:  	sBIT = new sBITChunkType6 ();  	break;  default:  	throw new ApplicationException ("Colour type is not supported");  }  
Magic Number,APNGLib,PNG,C:\repos\murrple-1_APNGManagement\APNGLib\PNG.cs,Handle_sBIT,The following statement contains a magic number: switch (IHDR.ColorType) {  case 0:  	sBIT = new sBITChunkType0 ();  	break;  case 2:  	sBIT = new sBITChunkType2 ();  	break;  case 3:  	sBIT = new sBITChunkType3 ();  	break;  case 4:  	sBIT = new sBITChunkType4 ();  	break;  case 6:  	sBIT = new sBITChunkType6 ();  	break;  default:  	throw new ApplicationException ("Colour type is not supported");  }  
Magic Number,APNGLib,PNG,C:\repos\murrple-1_APNGManagement\APNGLib\PNG.cs,Handle_sBIT,The following statement contains a magic number: switch (IHDR.ColorType) {  case 0:  	sBIT = new sBITChunkType0 ();  	break;  case 2:  	sBIT = new sBITChunkType2 ();  	break;  case 3:  	sBIT = new sBITChunkType3 ();  	break;  case 4:  	sBIT = new sBITChunkType4 ();  	break;  case 6:  	sBIT = new sBITChunkType6 ();  	break;  default:  	throw new ApplicationException ("Colour type is not supported");  }  
Magic Number,APNGLib,PNG,C:\repos\murrple-1_APNGManagement\APNGLib\PNG.cs,Handle_sBIT,The following statement contains a magic number: switch (IHDR.ColorType) {  case 0:  	sBIT = new sBITChunkType0 ();  	break;  case 2:  	sBIT = new sBITChunkType2 ();  	break;  case 3:  	sBIT = new sBITChunkType3 ();  	break;  case 4:  	sBIT = new sBITChunkType4 ();  	break;  case 6:  	sBIT = new sBITChunkType6 ();  	break;  default:  	throw new ApplicationException ("Colour type is not supported");  }  
Magic Number,APNGLib,PNG,C:\repos\murrple-1_APNGManagement\APNGLib\PNG.cs,Handle_tRNS,The following statement contains a magic number: switch (IHDR.ColorType) {  case 0:  	tRNS = new tRNSChunkType0 ();  	break;  case 2:  	tRNS = new tRNSChunkType2 ();  	break;  case 3:  	tRNS = new tRNSChunkType3 ();  	break;  case 4:  case 6:  	throw new ApplicationException ("tRNS chunk encountered' Colour type does not support");  default:  	throw new ApplicationException ("Colour type is not supported");  }  
Magic Number,APNGLib,PNG,C:\repos\murrple-1_APNGManagement\APNGLib\PNG.cs,Handle_tRNS,The following statement contains a magic number: switch (IHDR.ColorType) {  case 0:  	tRNS = new tRNSChunkType0 ();  	break;  case 2:  	tRNS = new tRNSChunkType2 ();  	break;  case 3:  	tRNS = new tRNSChunkType3 ();  	break;  case 4:  case 6:  	throw new ApplicationException ("tRNS chunk encountered' Colour type does not support");  default:  	throw new ApplicationException ("Colour type is not supported");  }  
Magic Number,APNGLib,PNG,C:\repos\murrple-1_APNGManagement\APNGLib\PNG.cs,Handle_tRNS,The following statement contains a magic number: switch (IHDR.ColorType) {  case 0:  	tRNS = new tRNSChunkType0 ();  	break;  case 2:  	tRNS = new tRNSChunkType2 ();  	break;  case 3:  	tRNS = new tRNSChunkType3 ();  	break;  case 4:  case 6:  	throw new ApplicationException ("tRNS chunk encountered' Colour type does not support");  default:  	throw new ApplicationException ("Colour type is not supported");  }  
Magic Number,APNGLib,PNG,C:\repos\murrple-1_APNGManagement\APNGLib\PNG.cs,Handle_tRNS,The following statement contains a magic number: switch (IHDR.ColorType) {  case 0:  	tRNS = new tRNSChunkType0 ();  	break;  case 2:  	tRNS = new tRNSChunkType2 ();  	break;  case 3:  	tRNS = new tRNSChunkType3 ();  	break;  case 4:  case 6:  	throw new ApplicationException ("tRNS chunk encountered' Colour type does not support");  default:  	throw new ApplicationException ("Colour type is not supported");  }  
Magic Number,APNGLib,PNGChunk,C:\repos\murrple-1_APNGManagement\APNGLib\PNGChunk.cs,IsPrintable,The following statement contains a magic number: return ((c >= 32 && c <= 126) || (c >= 161 && c <= 255));  
Magic Number,APNGLib,PNGChunk,C:\repos\murrple-1_APNGManagement\APNGLib\PNGChunk.cs,IsPrintable,The following statement contains a magic number: return ((c >= 32 && c <= 126) || (c >= 161 && c <= 255));  
Magic Number,APNGLib,PNGChunk,C:\repos\murrple-1_APNGManagement\APNGLib\PNGChunk.cs,IsPrintable,The following statement contains a magic number: return ((c >= 32 && c <= 126) || (c >= 161 && c <= 255));  
Magic Number,APNGLib,PNGChunk,C:\repos\murrple-1_APNGManagement\APNGLib\PNGChunk.cs,IsPrintable,The following statement contains a magic number: return ((c >= 32 && c <= 126) || (c >= 161 && c <= 255));  
Magic Number,APNGLib,PNGUtils,C:\repos\murrple-1_APNGManagement\APNGLib\PNGUtils.cs,ParseUshort,The following statement contains a magic number: for (int i = offset + sizeof(ushort) - 1' j = 0; i >= offset; i--' j++) {  	value |= (ushort)(buffer [i] << (8 * j));  }  
Magic Number,APNGLib,PNGUtils,C:\repos\murrple-1_APNGManagement\APNGLib\PNGUtils.cs,ParseUshort,The following statement contains a magic number: value |= (ushort)(buffer [i] << (8 * j));  
Magic Number,APNGLib,PNGUtils,C:\repos\murrple-1_APNGManagement\APNGLib\PNGUtils.cs,ParseUint,The following statement contains a magic number: for (int i = offset + sizeof(uint) - 1' j = 0; i >= offset; i--' j++) {  	value |= (uint)(buffer [i] << (8 * j));  }  
Magic Number,APNGLib,PNGUtils,C:\repos\murrple-1_APNGManagement\APNGLib\PNGUtils.cs,ParseUint,The following statement contains a magic number: value |= (uint)(buffer [i] << (8 * j));  
