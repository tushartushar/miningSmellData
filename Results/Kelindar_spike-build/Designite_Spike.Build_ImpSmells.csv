Implementation smell,Namespace,Class,File,Method,Description
Long Method,Spike.Build.AS3,AS3Template,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.AS3\AS3Builder.cs,TransformText,The method has 1062 lines of code.
Long Method,Spike.Build.CSharp5,CSharp5Template,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.CSharp5\CSharp5BuilderBase.cs,TransformText,The method has 1327 lines of code.
Long Method,Spike.Build.Go,GoTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Go\GoTemplate.cs,TransformText,The method has 1065 lines of code.
Long Method,Spike.Build.JavaScript,JavaScriptTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.JavaScript\JavaScriptBuilder.cs,TransformText,The method has 2279 lines of code.
Long Method,Spike.Build.Java,AbstractTcpChannelTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Java\AbstractTcpChannelTemplate.cs,TransformText,The method has 277 lines of code.
Long Method,Spike.Build.Java,TcpChannelTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Java\TcpChannelTemplate.cs,TransformText,The method has 368 lines of code.
Long Method,Spike.Build,Model,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Model.cs,Load,The method has 110 lines of code.
Long Method,Spike.Build,Program,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Program.cs,Main,The method has 129 lines of code.
Long Method,Spike.Build.Minifiers,ColorSlice,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssColorName.cs,ColorSlice,The method has 151 lines of code.
Long Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseMediaQuery,The method has 108 lines of code.
Long Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseDeclarationList,The method has 120 lines of code.
Long Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseTerm,The method has 193 lines of code.
Long Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseRgb,The method has 183 lines of code.
Long Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,Append,The method has 430 lines of code.
Long Method,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,NextToken,The method has 138 lines of code.
Long Method,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,ScanComment,The method has 144 lines of code.
Long Method,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,ScanAtKeyword,The method has 108 lines of code.
Long Method,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,ScanUnicodeRange,The method has 123 lines of code.
Long Method,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,ScanNum,The method has 117 lines of code.
Long Method,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,GetString,The method has 117 lines of code.
Long Method,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,GetNum,The method has 103 lines of code.
Long Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The method has 106 lines of code.
Long Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,CombineReturnWithExpression,The method has 131 lines of code.
Long Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The method has 790 lines of code.
Long Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The method has 280 lines of code.
Long Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The method has 105 lines of code.
Long Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The method has 209 lines of code.
Long Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The method has 197 lines of code.
Long Method,Spike.Build.Minifiers,JsConstantWrapper,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsConstantWrapper.cs,EscapeString,The method has 134 lines of code.
Long Method,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalThisOperator,The method has 100 lines of code.
Long Method,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalToTheLeft,The method has 142 lines of code.
Long Method,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalToTheRight,The method has 115 lines of code.
Long Method,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoBinaryOperator,The method has 182 lines of code.
Long Method,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The method has 118 lines of code.
Long Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The method has 174 lines of code.
Long Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The method has 102 lines of code.
Long Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The method has 104 lines of code.
Long Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,EscapeString,The method has 165 lines of code.
Long Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,Parse,The method has 131 lines of code.
Long Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseStatements,The method has 109 lines of code.
Long Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseStatement,The method has 266 lines of code.
Long Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseIdentifierInitializer,The method has 164 lines of code.
Long Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseIfStatement,The method has 159 lines of code.
Long Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseForStatement,The method has 304 lines of code.
Long Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseDoStatement,The method has 130 lines of code.
Long Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseSwitchStatement,The method has 238 lines of code.
Long Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseTryStatement,The method has 200 lines of code.
Long Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseFunction,The method has 289 lines of code.
Long Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseExpression,The method has 136 lines of code.
Long Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseUnaryExpression,The method has 264 lines of code.
Long Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseLeftHandSideExpression,The method has 535 lines of code.
Long Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ConvertNumericLiteralToDouble,The method has 109 lines of code.
Long Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,MemberExpression,The method has 193 lines of code.
Long Method,Spike.Build.Minifiers,JsReorderScopeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsReorderScopeVisitor.cs,RelocateVar,The method has 144 lines of code.
Long Method,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanNextToken,The method has 656 lines of code.
Long Method,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanNumber,The method has 145 lines of code.
Long Method,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanString,The method has 313 lines of code.
Long Method,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PPSkipToDirective,The method has 101 lines of code.
Long Method,Spike.Build.Minifiers,MinifierParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\MinifierParser.cs,ToArguments,The method has 119 lines of code.
Long Method,Spike.Build.Minifiers,MinifierParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\MinifierParser.cs,Parse,The method has 1238 lines of code.
Long Method,Spike.Build.WinRT,WinRTTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.WinRT\WinRTTemplate.cs,TransformText,The method has 1309 lines of code.
Complex Method,Spike.Build.AS3,AS3Template,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.AS3\AS3Builder.cs,TransformText,Cyclomatic complexity of the method is 26
Complex Method,Spike.Build.AS3,AS3Builder,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.AS3\AS3Builder.cs,GetNativeType,Cyclomatic complexity of the method is 17
Complex Method,Spike.Build.AS3,AS3Builder,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.AS3\AS3Builder.cs,Build,Cyclomatic complexity of the method is 9
Complex Method,Spike.Build.CSharp5,CSharp5Template,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.CSharp5\CSharp5BuilderBase.cs,TransformText,Cyclomatic complexity of the method is 27
Complex Method,Spike.Build.CSharp5,CSharp5BuilderBase,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.CSharp5\CSharp5BuilderBase.cs,GetNativeType,Cyclomatic complexity of the method is 14
Complex Method,Spike.Build.CSharp5,CSharp5Builder,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.CSharp5\CSharp5Builder.cs,Build,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Go,GoTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Go\GoTemplate.cs,TransformText,Cyclomatic complexity of the method is 29
Complex Method,Spike.Build.Go,GoBuilder,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Go\GoBuilder.cs,GetNativeType,Cyclomatic complexity of the method is 15
Complex Method,Spike.Build.JavaScript,JavaScriptTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.JavaScript\JavaScriptBuilder.cs,TransformText,Cyclomatic complexity of the method is 18
Complex Method,Spike.Build.JavaScript,JavaScriptBuilder,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.JavaScript\JavaScriptBuilder.cs,GetNativeType,Cyclomatic complexity of the method is 15
Complex Method,Spike.Build.Java,JavaBuilder,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Java\JavaBuilder.cs,GetNativeType,Cyclomatic complexity of the method is 11
Complex Method,Spike.Build.Java,TcpChannelTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Java\TcpChannelTemplate.cs,TransformText,Cyclomatic complexity of the method is 12
Complex Method,Spike.Build,Extentions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,Indent,Cyclomatic complexity of the method is 17
Complex Method,Spike.Build,Model,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Model.cs,Load,Cyclomatic complexity of the method is 16
Complex Method,Spike.Build,Program,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Program.cs,Main,Cyclomatic complexity of the method is 27
Complex Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseKeyFrames,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseKeyFrameSelectors,Cyclomatic complexity of the method is 9
Complex Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseMedia,Cyclomatic complexity of the method is 10
Complex Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseMediaQuery,Cyclomatic complexity of the method is 11
Complex Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseMediaQueryExpression,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseDeclarationList,Cyclomatic complexity of the method is 18
Complex Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseRule,Cyclomatic complexity of the method is 12
Complex Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseSelector,Cyclomatic complexity of the method is 9
Complex Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseAttrib,Cyclomatic complexity of the method is 9
Complex Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParsePseudo,Cyclomatic complexity of the method is 10
Complex Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseDeclaration,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseTerm,Cyclomatic complexity of the method is 32
Complex Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseFunction,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseRgb,Cyclomatic complexity of the method is 22
Complex Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseExpressionFunction,Cyclomatic complexity of the method is 9
Complex Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseUnit,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,NextSignificantToken,Cyclomatic complexity of the method is 12
Complex Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,SkipToClose,Cyclomatic complexity of the method is 11
Complex Method,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,Append,Cyclomatic complexity of the method is 58
Complex Method,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,ScanComment,Cyclomatic complexity of the method is 19
Complex Method,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,ScanAtKeyword,Cyclomatic complexity of the method is 28
Complex Method,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,ScanUnicodeRange,Cyclomatic complexity of the method is 17
Complex Method,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,ScanNum,Cyclomatic complexity of the method is 12
Complex Method,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,GetString,Cyclomatic complexity of the method is 13
Complex Method,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,GetNum,Cyclomatic complexity of the method is 14
Complex Method,Spike.Build.Minifiers,JsActivationObject,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsActivationObject.cs,DefineField,Cyclomatic complexity of the method is 9
Complex Method,Spike.Build.Minifiers,JsActivationObject,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsActivationObject.cs,UnreferencedVariable,Cyclomatic complexity of the method is 10
Complex Method,Spike.Build.Minifiers,JsActivationObject,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsActivationObject.cs,ManualRenameFields,Cyclomatic complexity of the method is 9
Complex Method,Spike.Build.Minifiers,JsActivationObject,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsActivationObject.cs,AutoRenameFields,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 17
Complex Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,CombineReturnWithExpression,Cyclomatic complexity of the method is 13
Complex Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 85
Complex Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 31
Complex Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 11
Complex Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 11
Complex Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 15
Complex Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 24
Complex Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 10
Complex Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 25
Complex Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 13
Complex Method,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 15
Complex Method,Spike.Build.Minifiers,JsBinaryOperator,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsBinaryOperator.cs,FindPrimitiveType,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,JsConstantWrapper,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsConstantWrapper.cs,EscapeString,Cyclomatic complexity of the method is 20
Complex Method,Spike.Build.Minifiers,JsConstantWrapper,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsConstantWrapper.cs,ToNumber,Cyclomatic complexity of the method is 10
Complex Method,Spike.Build.Minifiers,ReferenceComparer,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsCrunchEnumerator.cs,Compare,Cyclomatic complexity of the method is 12
Complex Method,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalThisOperator,Cyclomatic complexity of the method is 26
Complex Method,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalToTheLeft,Cyclomatic complexity of the method is 24
Complex Method,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalFarToTheLeft,Cyclomatic complexity of the method is 18
Complex Method,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalToTheRight,Cyclomatic complexity of the method is 20
Complex Method,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalFarToTheRight,Cyclomatic complexity of the method is 20
Complex Method,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Equal,Cyclomatic complexity of the method is 9
Complex Method,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,NotEqual,Cyclomatic complexity of the method is 9
Complex Method,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,StrictEqual,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,StrictNotEqual,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoBinaryOperator,Cyclomatic complexity of the method is 26
Complex Method,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,Cyclomatic complexity of the method is 19
Complex Method,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoWhileNode,Cyclomatic complexity of the method is 10
Complex Method,Spike.Build.Minifiers,JsKeyword,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsKeyword.cs,CanBeIdentifier,Cyclomatic complexity of the method is 13
Complex Method,Spike.Build.Minifiers,JsLogicalNot,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsLogicalNot.cs,MeasureBinaryOperator,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,JsLogicalNot,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsLogicalNot.cs,ConvertBinaryOperator,Cyclomatic complexity of the method is 11
Complex Method,Spike.Build.Minifiers,JsonOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsonOutputVisitor.cs,OutputString,Cyclomatic complexity of the method is 9
Complex Method,Spike.Build.Minifiers,JsonOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsonOutputVisitor.cs,GetSmallestRep,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 21
Complex Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 13
Complex Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 13
Complex Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 10
Complex Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 11
Complex Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 11
Complex Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 13
Complex Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 14
Complex Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 10
Complex Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,WriteToStream,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,OperatorString,Cyclomatic complexity of the method is 46
Complex Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,OutputFunctionArgsAndBody,Cyclomatic complexity of the method is 13
Complex Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,GetSmallestRep,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,EscapeString,Cyclomatic complexity of the method is 22
Complex Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,Parse,Cyclomatic complexity of the method is 10
Complex Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseStatements,Cyclomatic complexity of the method is 10
Complex Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseStatement,Cyclomatic complexity of the method is 45
Complex Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseVariableStatement,Cyclomatic complexity of the method is 11
Complex Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseIdentifierInitializer,Cyclomatic complexity of the method is 17
Complex Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseIfStatement,Cyclomatic complexity of the method is 9
Complex Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseForStatement,Cyclomatic complexity of the method is 21
Complex Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseContinueStatement,Cyclomatic complexity of the method is 12
Complex Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseBreakStatement,Cyclomatic complexity of the method is 11
Complex Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseSwitchStatement,Cyclomatic complexity of the method is 10
Complex Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseTryStatement,Cyclomatic complexity of the method is 12
Complex Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseFunction,Cyclomatic complexity of the method is 25
Complex Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseExpression,Cyclomatic complexity of the method is 11
Complex Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseUnaryExpression,Cyclomatic complexity of the method is 21
Complex Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseLeftHandSideExpression,Cyclomatic complexity of the method is 54
Complex Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ConvertNumericLiteralToDouble,Cyclomatic complexity of the method is 11
Complex Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,MemberExpression,Cyclomatic complexity of the method is 14
Complex Method,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseExpressionList,Cyclomatic complexity of the method is 10
Complex Method,Spike.Build.Minifiers,JsReorderScopeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsReorderScopeVisitor.cs,Apply,Cyclomatic complexity of the method is 12
Complex Method,Spike.Build.Minifiers,JsReorderScopeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsReorderScopeVisitor.cs,RelocateVar,Cyclomatic complexity of the method is 13
Complex Method,Spike.Build.Minifiers,JsReorderScopeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsReorderScopeVisitor.cs,UnnestBlocks,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,JsReorderScopeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsReorderScopeVisitor.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,JsReorderScopeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsReorderScopeVisitor.cs,Visit,Cyclomatic complexity of the method is 13
Complex Method,Spike.Build.Minifiers,JsReorderScopeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsReorderScopeVisitor.cs,IsMinificationHint,Cyclomatic complexity of the method is 9
Complex Method,Spike.Build.Minifiers,JsResolutionVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsResolutionVisitor.cs,ResolveLookup,Cyclomatic complexity of the method is 11
Complex Method,Spike.Build.Minifiers,JsResolutionVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsResolutionVisitor.cs,ResolveGhostedFunctions,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,JsResolutionVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsResolutionVisitor.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanNextToken,Cyclomatic complexity of the method is 106
Complex Method,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanNumber,Cyclomatic complexity of the method is 27
Complex Method,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanRegExp,Cyclomatic complexity of the method is 9
Complex Method,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanAspNetBlock,Cyclomatic complexity of the method is 11
Complex Method,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanString,Cyclomatic complexity of the method is 48
Complex Method,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,SkipMultilineComment,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,IsIdentifierStartChar,Cyclomatic complexity of the method is 10
Complex Method,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PPSkipToDirective,Cyclomatic complexity of the method is 15
Complex Method,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanPreprocessingDirective,Cyclomatic complexity of the method is 10
Complex Method,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanIfDirective,Cyclomatic complexity of the method is 10
Complex Method,Spike.Build.Minifiers,JsV3SourceMap,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsV3SourceMap.cs,OutputEscapedString,Cyclomatic complexity of the method is 9
Complex Method,Spike.Build.Minifiers,JsVariableField,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsVariableField.cs,SetFieldsBasedOnType,Cyclomatic complexity of the method is 10
Complex Method,Spike.Build.Minifiers,MinifierError,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\MinifierError.cs,ToString,Cyclomatic complexity of the method is 10
Complex Method,Spike.Build.Minifiers,MinifierParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\MinifierParser.cs,ToArguments,Cyclomatic complexity of the method is 17
Complex Method,Spike.Build.Minifiers,MinifierParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\MinifierParser.cs,Parse,Cyclomatic complexity of the method is 187
Complex Method,Spike.Build.WinRT,WinRTTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.WinRT\WinRTTemplate.cs,TransformText,Cyclomatic complexity of the method is 27
Complex Method,Spike.Build.WinRT,WinRTBuilder,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.WinRT\WinRTBuilder.cs,Build,Cyclomatic complexity of the method is 8
Complex Method,Spike.Build.Xamarin,XamarinBuilder,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Xamarin\XamarinBuilder.cs,Build,Cyclomatic complexity of the method is 8
Long Parameter List,Spike.Build.Minifiers,CssException,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,CssException,The method has 6 parameters. Parameters: errorNum' source' severity' line' pos' message
Long Parameter List,Spike.Build.Minifiers,IJsSourceMap,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\IJsSourceMap.cs,MarkSegment,The method has 5 parameters. Parameters: node' startLine' startColumn' name' context
Long Parameter List,Spike.Build.Minifiers,JsContext,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsContext.cs,JsContext,The method has 8 parameters. Parameters: document' startLineNumber' startLinePosition' startPosition' endLineNumber' endLinePosition' endPosition' token
Long Parameter List,Spike.Build.Minifiers,JsScriptSharpSourceMap,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScriptSharpSourceMap.cs,MarkSegment,The method has 5 parameters. Parameters: node' startLine' startColumn' name' context
Long Parameter List,Spike.Build.Minifiers,JsV3SourceMap,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsV3SourceMap.cs,MarkSegment,The method has 5 parameters. Parameters: node' startLine' startColumn' name' context
Long Parameter List,Spike.Build.Minifiers,JsV3SourceMap,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsV3SourceMap.cs,CreateSegment,The method has 6 parameters. Parameters: destinationLine' destinationColumn' sourceLine' sourceColumn' fileName' symbolName
Long Parameter List,Spike.Build.Minifiers,MinifierError,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\MinifierError.cs,MinifierError,The method has 11 parameters. Parameters: isError' severity' subcategory' errorCode' helpKeyword' file' startLine' startColumn' endLine' endColumn' message
Long Identifier,Spike.Build.Minifiers,NoSkipTokenSet,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,,The length of the parameter s_BlockConditionNoSkipTokenSet is 30.
Long Identifier,Spike.Build.Minifiers,NoSkipTokenSet,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,,The length of the parameter s_EndOfStatementNoSkipTokenSet is 30.
Long Identifier,Spike.Build.Minifiers,NoSkipTokenSet,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,,The length of the parameter s_ExpressionListNoSkipTokenSet is 30.
Long Identifier,Spike.Build.Minifiers,NoSkipTokenSet,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,,The length of the parameter s_PostfixExpressionNoSkipTokenSet is 33.
Long Identifier,Spike.Build.Minifiers,NoSkipTokenSet,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,,The length of the parameter s_StartStatementNoSkipTokenSet is 30.
Long Identifier,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanNextToken,The length of the parameter scanForRegularExpressionLiterals is 32.
Long Identifier,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,,The length of the parameter m_conditionalCompilationIfLevel is 31.
Long Statement,Spike.Build.AS3,AS3Template,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.AS3\AS3Builder.cs,TransformText,The length of the statement  "                    "\t\t\t\t\t\t\tdo\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\toidx++;\r\n\t\t\t\t\t\t\t\toutput.writeByte(input[iidx + lit]" + " is 120.
Long Statement,Spike.Build.AS3,AS3Template,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.AS3\AS3Builder.cs,TransformText,The length of the statement  "                    ");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\twhile ((++lit) != 0);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tlen -= 2;\r\n\t\t" + " is 130.
Long Statement,Spike.Build.AS3,AS3Template,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.AS3\AS3Builder.cs,TransformText,The length of the statement  "                    "\t\t\t\tiidx++;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (len < 7)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\toidx++;\r\n\t\t\t\t\t\t\toutput." + " is 130.
Long Statement,Spike.Build.AS3,AS3Template,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.AS3\AS3Builder.cs,TransformText,The length of the statement  "                    " copy */\r\n\t\t\t\tlit++;\r\n\t\t\t\tiidx++;\r\n\t\t\t\t\r\n\t\t\t\tif (lit == MAX_LIT)\r\n\t\t\t\t{\r\n\t\t\t\t\toi" + " is 121.
Long Statement,Spike.Build.AS3,AS3Template,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.AS3\AS3Builder.cs,TransformText,The length of the statement  "                    "(++lit) != 0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (lit != 0)\r\n\t\t\t{\r\n\t\t\t\toidx++;\r\n\t\t\t\toutpu" + " is 122.
Long Statement,Spike.Build.AS3,AS3Template,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.AS3\AS3Builder.cs,TransformText,The length of the statement  "                    "*/\r\n\t\t\t\t{\r\n\t\t\t\t\tctrl++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tdo\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\toidx++;\r\n\t\t\t\t\t\toutput.wri" + " is 134.
Long Statement,Spike.Build.AS3,AS3Template,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.AS3\AS3Builder.cs,TransformText,The length of the statement  "                    ";\r\n\t\t\t        partialRecord = true;\r\n\t\t\t    }\r\n\t\t\t\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t\r\n\t\t/**\r\n\t\t" + " is 124.
Long Statement,Spike.Build.AS3,AS3TemplateBase,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.AS3\AS3Template.cs,Write,The length of the statement  "            textToAppend = textToAppend.Replace(global::System.Environment.NewLine' (global::System.Environment.NewLine + this.currentIndentField)); " is 136.
Long Statement,Spike.Build.CSharp5,CSharp5Template,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.CSharp5\CSharp5BuilderBase.cs,TransformText,The length of the statement  "                    "len)\r\n\t\t\t\t\t\t\treturn 0;\r\n\r\n\t\t\t\t\t\tdo\r\n\t\t\t\t\t\t\tlen++;\r\n\t\t\t\t\t\twhile (len < maxlen && " + " is 120.
Long Statement,Spike.Build.CSharp5,CSharp5Template,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.CSharp5\CSharp5BuilderBase.cs,TransformText,The length of the statement  "                    "\t\t\t\t\t\tlen -= 2;\r\n\t\t\t\t\t\tiidx++;\r\n\r\n\t\t\t\t\t\tif (len < 7)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tout_data[" + " is 126.
Long Statement,Spike.Build.CSharp5,CSharp5Template,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.CSharp5\CSharp5BuilderBase.cs,TransformText,The length of the statement  "                    "ue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\telse if (iidx == in_len)\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t/* one mo" + " is 120.
Long Statement,Spike.Build.CSharp5,CSharp5Template,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.CSharp5\CSharp5BuilderBase.cs,TransformText,The length of the statement  "                    "RNO (E2BIG);\r\n\t\t\t\t\t\treturn 0;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (reference < 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t" + " is 123.
Long Statement,Spike.Build.CSharp5,CSharp5TemplateBase,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.CSharp5\CSharp5Template.cs,Write,The length of the statement  "            textToAppend = textToAppend.Replace(global::System.Environment.NewLine' (global::System.Environment.NewLine + this.currentIndentField)); " is 136.
Long Statement,Spike.Build.Go,GoTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Go\GoTemplate.cs,TransformText,The length of the statement  "                    "\r\n\t\t\t\treturn nil\r\n\t\t\t}\r\n\r\n\t\t\tif backref < 0 {\r\n\t\t\t\treturn nil\r\n\t\t\t}\r\n\r\n\t\t\toutput" + " is 120.
Long Statement,Spike.Build.Go,GoTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Go\GoTemplate.cs,TransformText,The length of the statement  "            this.Write("import (\r\n\t\"encoding/binary\"\r\n\t\"bytes\"\r\n\t\"time\"\r\n\t\"errors\"\r\n) \r\n\r\n\r\n// Represents" + " is 124.
Long Statement,Spike.Build.Go,GoTemplateBase,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Go\GoTemplate.cs,Write,The length of the statement  "            textToAppend = textToAppend.Replace(global::System.Environment.NewLine' (global::System.Environment.NewLine + this.currentIndentField)); " is 136.
Long Statement,Spike.Build.JavaScript,JavaScriptTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.JavaScript\JavaScriptBuilder.cs,TransformText,The length of the statement  "                    "\n\t\t\t\t\t\toutput.writeByte(lit - 1);\r\n\t\t\t\t\t\tlit = -lit;\r\n\t\t\t\t\t\tdo\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t" + " is 124.
Long Statement,Spike.Build.JavaScript,JavaScriptTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.JavaScript\JavaScriptBuilder.cs,TransformText,The length of the statement  "                    " ((++lit) != 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tlen -= 2;\r\n\t\t\t\t\tiidx++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (l" + " is 126.
Long Statement,Spike.Build.JavaScript,JavaScriptTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.JavaScript\JavaScriptBuilder.cs,TransformText,The length of the statement  "                    "\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\toidx++;\r\n\t\t\t\t\t\toidx++;\r\n\t\t\t\t\t\toutput.writeByt" + " is 129.
Long Statement,Spike.Build.JavaScript,JavaScriptTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.JavaScript\JavaScriptBuilder.cs,TransformText,The length of the statement  "                    "\n\t\t\t\treference++;\r\n\t\t\t\toidx++;\r\n\t\t\t\t\r\n\t\t\t\tdo\r\n\t\t\t\t{\r\n\t\t\t\t\toutput.writeByte(outpu" + " is 120.
Long Statement,Spike.Build.JavaScript,JavaScriptTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.JavaScript\JavaScriptBuilder.cs,TransformText,The length of the statement  "                    "Int64\");\r\n\t\t\t\tthis.writeInt64(value);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t" + " is 120.
Long Statement,Spike.Build.JavaScript,JavaScriptTemplateBase,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.JavaScript\JavaScriptTemplate.cs,Write,The length of the statement  "            textToAppend = textToAppend.Replace(global::System.Environment.NewLine' (global::System.Environment.NewLine + this.currentIndentField)); " is 136.
Long Statement,Spike.Build.Java,CustomTypeTemplateBase,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Java\CustomTypeTemplate.cs,Write,The length of the statement  "            textToAppend = textToAppend.Replace(global::System.Environment.NewLine' (global::System.Environment.NewLine + this.currentIndentField)); " is 136.
Long Statement,Spike.Build.Java,PacketTemplateBase,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Java\PacketTemplate.cs,Write,The length of the statement  "            textToAppend = textToAppend.Replace(global::System.Environment.NewLine' (global::System.Environment.NewLine + this.currentIndentField)); " is 136.
Long Statement,Spike.Build.Java,AbstractTcpChannelTemplateBase,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Java\AbstractTcpChannelTemplate.cs,Write,The length of the statement  "            textToAppend = textToAppend.Replace(global::System.Environment.NewLine' (global::System.Environment.NewLine + this.currentIndentField)); " is 136.
Long Statement,Spike.Build.Java,CLZFTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Java\CLZFTemplate.cs,TransformText,The length of the statement  "                    "\r\n\r\n\t\t\t\t\tlen -= 2;\r\n\t\t\t\t\tiidx++;\r\n\r\n\t\t\t\t\tif (len < 7)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tout_data[oi" + " is 124.
Long Statement,Spike.Build.Java,CLZFTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Java\CLZFTemplate.cs,TransformText,The length of the statement  "                    "\r\n\t\t\t\t\thtab[IDX (hval)] = iidx;\r\n\t\t\t\t\tiidx++;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\te" + " is 121.
Long Statement,Spike.Build.Java,CLZFTemplateBase,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Java\CLZFTemplate.cs,Write,The length of the statement  "            textToAppend = textToAppend.Replace(global::System.Environment.NewLine' (global::System.Environment.NewLine + this.currentIndentField)); " is 136.
Long Statement,Spike.Build.Java,ConnectionHandlerTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Java\ConnectionHandlerTemplate.cs,TransformText,The length of the statement  " * The listener interface for receiving connection events. The class must define a method of no arguments called onConnect.  " is 122.
Long Statement,Spike.Build.Java,ConnectionHandlerTemplateBase,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Java\ConnectionHandlerTemplate.cs,Write,The length of the statement  "            textToAppend = textToAppend.Replace(global::System.Environment.NewLine' (global::System.Environment.NewLine + this.currentIndentField)); " is 136.
Long Statement,Spike.Build.Java,DisconnectionHandlerTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Java\DisconnectionHandlerTemplate.cs,TransformText,The length of the statement  " * The listener interface for receiving disconnection events. The class must define a method of no arguments called onDisconnect.  " is 128.
Long Statement,Spike.Build.Java,DisconnectionHandlerTemplateBase,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Java\DisconnectionHandlerTemplate.cs,Write,The length of the statement  "            textToAppend = textToAppend.Replace(global::System.Environment.NewLine' (global::System.Environment.NewLine + this.currentIndentField)); " is 136.
Long Statement,Spike.Build.Java,PacketHandlerTemplateBase,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Java\PacketHandlerTemplate.cs,Write,The length of the statement  "            textToAppend = textToAppend.Replace(global::System.Environment.NewLine' (global::System.Environment.NewLine + this.currentIndentField)); " is 136.
Long Statement,Spike.Build.Java,TcpChannelTemplateBase,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Java\TcpChannelTemplate.cs,Write,The length of the statement  "            textToAppend = textToAppend.Replace(global::System.Environment.NewLine' (global::System.Environment.NewLine + this.currentIndentField)); " is 136.
Long Statement,Spike.Build,Model,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Model.cs,Load,The length of the statement  "                            .Select(member => member.IsList ? string.Format("ListOf{0}"' member.IsCustom ? "ComplexType" : member.Type) : member.IsCustom ? "ComplexType" : member.Type).Aggregate((type1' type2) => string.Format("{0}.{1}"' type1' type2))); " is 226.
Long Statement,Spike.Build,Model,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Model.cs,Load,The length of the statement  "                            .Select(member => member.IsList ? string.Format("ListOf{0}"' member.IsCustom ? "ComplexType" : member.Type) : member.IsCustom ? "ComplexType" : member.Type).Aggregate((type1' type2) => string.Format("{0}.{1}"' type1' type2))); " is 226.
Long Statement,Spike.Build,Program,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Program.cs,Main,The length of the statement  "                Console.WriteLine("{0}' Version {1}"' currentAssembly.GetCustomAttribute<AssemblyTitleAttribute>().Title' currentAssembly.GetName().Version.ToString()); " is 152.
Long Statement,Spike.Build,Program,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Program.cs,Main,The length of the statement  "                                var protocols = result.Content.ReadAsStringAsync().Result.Split(new char[] { '|' }' StringSplitOptions.RemoveEmptyEntries); " is 123.
Long Statement,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseProduct,The length of the statement  "                    || (CurrentTokenType == TokenType.Identifier && string.Compare(CurrentTokenText' "mod"' StringComparison.OrdinalIgnoreCase) == 0)) " is 130.
Long Statement,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ReportError,The length of the statement  "            string message = CssStrings.ResourceManager.GetString(errorNumber.ToString()' CssStrings.Culture).FormatInvariant(arguments); " is 125.
Long Statement,Spike.Build.Minifiers,JsActivationObject,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsActivationObject.cs,IsIterativeReference,The length of the statement  "                || (regExp != null && regExp.PatternSwitches != null && regExp.PatternSwitches.IndexOf("g"' StringComparison.OrdinalIgnoreCase) >= 0)) " is 134.
Long Statement,Spike.Build.Minifiers,JsActivationObject,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsActivationObject.cs,AutoRenameFields,The length of the statement  "                            || (field.OuterField != null && !field.IsGenerated && field.OwningScope != null && !field.OwningScope.IsKnownAtCompileTime)) " is 124.
Long Statement,Spike.Build.Minifiers,JsActivationObject,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsActivationObject.cs,AutoRenameFields,The length of the statement  "                            || !(m_settings.RemoveFunctionExpressionNames && m_settings.IsModificationAllowed(JsTreeModifications.RemoveFunctionExpressionNames)))) " is 135.
Long Statement,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,CombineTwoExpressions,The length of the statement  "                    var binOp = new JsBinaryOperator(prevBinary.Operand2.Context.Clone().CombineWith(curBinary.Operand2.Context)' prevBinary.Parser) " is 128.
Long Statement,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,CombineTwoExpressions,The length of the statement  "                    var binOp = JsCommaOperator.CombineWithComma(prevBinary.Context.Clone().CombineWith(curBinary.Context)' m_parser' prevBinary' curBinary); " is 137.
Long Statement,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,CombineTwoExpressions,The length of the statement  "                var binOp = JsCommaOperator.CombineWithComma(node[ndx - 1].Context.Clone().CombineWith(node[ndx].Context)' m_parser' node[ndx - 1]' node[ndx]); " is 143.
Long Statement,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The length of the statement  "                if (m_parser.Settings.StripDebugStatements && m_parser.Settings.IsModificationAllowed(JsTreeModifications.StripDebugStatements)) " is 128.
Long Statement,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The length of the statement  "                        node.Parent.ReplaceChild(node' new JsConstantWrapper(double.PositiveInfinity' JsPrimitiveType.Number' node.Context' m_parser)); " is 127.
Long Statement,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The length of the statement  "                if (node.IsCCSpecialCase && m_parser.Settings.IsModificationAllowed(JsTreeModifications.RemoveUnnecessaryCCOnStatements)) " is 121.
Long Statement,Spike.Build.Minifiers,JsContext,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsContext.cs,HandleError,The length of the statement  "            if ((errorId != JsError.UndeclaredVariable && errorId != JsError.UndeclaredFunction) || !Document.HasAlreadySeenErrorFor(Code)) " is 127.
Long Statement,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,ReplaceMemberBracketWithDot,The length of the statement  "                        if (JsScanner.IsSafeIdentifier(combinedString) && !JsScanner.IsKeyword(combinedString' parentCall.EnclosingScope.UseStrict)) " is 124.
Long Statement,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalToTheLeft,The length of the statement  "                && (node.OperatorToken == JsToken.BitwiseAnd || node.OperatorToken == JsToken.BitwiseOr || node.OperatorToken == JsToken.BitwiseXor)) " is 133.
Long Statement,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,LessThan,The length of the statement  "                        newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) < 0' JsPrimitiveType.Boolean' null' m_parser); " is 138.
Long Statement,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,LessThanOrEqual,The length of the statement  "                        newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) <= 0' JsPrimitiveType.Boolean' null' m_parser); " is 139.
Long Statement,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,GreaterThan,The length of the statement  "                        newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) > 0' JsPrimitiveType.Boolean' null' m_parser); " is 138.
Long Statement,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,GreaterThanOrEqual,The length of the statement  "                        newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) >= 0' JsPrimitiveType.Boolean' null' m_parser); " is 139.
Long Statement,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Equal,The length of the statement  "                                newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) == 0' JsPrimitiveType.Boolean' null' m_parser); " is 139.
Long Statement,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,NotEqual,The length of the statement  "                                newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) != 0' JsPrimitiveType.Boolean' null' m_parser); " is 139.
Long Statement,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,StrictEqual,The length of the statement  "                                newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) == 0' JsPrimitiveType.Boolean' null' m_parser); " is 139.
Long Statement,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,StrictNotEqual,The length of the statement  "                                newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) != 0' JsPrimitiveType.Boolean' null' m_parser); " is 139.
Long Statement,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoBinaryOperator,The length of the statement  "                                        new JsConstantWrapper(node.OperatorToken == JsToken.StrictEqual ? false : true' JsPrimitiveType.Boolean' node.Context' m_parser)); " is 130.
Long Statement,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The length of the statement  "                                ReplaceNodeWithLiteral(node' new JsConstantWrapper(literalOperand.ToNumber()' JsPrimitiveType.Number' node.Context' m_parser)); " is 127.
Long Statement,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The length of the statement  "                                ReplaceNodeWithLiteral(node' new JsConstantWrapper(-literalOperand.ToNumber()' JsPrimitiveType.Number' node.Context' m_parser)); " is 128.
Long Statement,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The length of the statement  "                                ReplaceNodeWithLiteral(node' new JsConstantWrapper(Convert.ToDouble(~literalOperand.ToInt32())' JsPrimitiveType.Number' node.Context' m_parser)); " is 145.
Long Statement,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The length of the statement  "                                ReplaceNodeWithLiteral(node' new JsConstantWrapper(!literalOperand.ToBoolean()' JsPrimitiveType.Boolean' node.Context' m_parser)); " is 130.
Long Statement,Spike.Build.Minifiers,JsGlobalScope,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsGlobalScope.cs,SetAssumedGlobals,The length of the statement  "                m_assumedGlobals = settings.KnownGlobalCollection == null ? new HashSet<string>() : new HashSet<string>(settings.KnownGlobalCollection); " is 136.
Long Statement,Spike.Build.Minifiers,JsonOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsonOutputVisitor.cs,GetSmallestRep,The length of the statement  "                    if (int.TryParse(match.Result("${eng}") + match.Result("${pow}")' NumberStyles.Integer' CultureInfo.InvariantCulture' out exponent)) " is 132.
Long Statement,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Apply,The length of the statement  "                settings.IfNotNull(s => s.SymbolsMap.IfNotNull(m => m.EndOutputRun(outputVisitor.m_lineCount' outputVisitor.m_lineLength))); " is 124.
Long Statement,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The length of the statement  "                    && (node.FalseBlock == null || (!node.TrueBlock.EncloseBlock(EncloseBlockType.IfWithoutElse) && !node.TrueBlock.EncloseBlock(EncloseBlockType.SingleDoWhile))) " is 158.
Long Statement,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The length of the statement  "                            || (node.ConditionalCommentContainsOn && !m_settings.IsModificationAllowed(JsTreeModifications.RemoveUnnecessaryCCOnStatements))) " is 129.
Long Statement,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,InsertSpaceIfNeeded,The length of the statement  "                else if ((m_lastCharacter == '@' || JsScanner.IsValidIdentifierPart(m_lastCharacter)) && JsScanner.IsValidIdentifierPart(ch)) " is 125.
Long Statement,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,InsertSpaceIfNeeded,The length of the statement  "            else if ((m_lastCharacter == '@' || JsScanner.IsValidIdentifierPart(m_lastCharacter)) && JsScanner.IsValidIdentifierPart(text)) " is 127.
Long Statement,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseStatements,The length of the statement  "                                } while (m_currentToken.Token != JsToken.EndOfFile && !TokenInList(NoSkipTokenSet.s_TopLevelNoSkipTokenSet' m_currentToken.Token) " is 129.
Long Statement,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseForStatement,The length of the statement  "                                            condOrColl = new JsConstantWrapper(true' JsPrimitiveType.Boolean' CurrentPositionContext()' this); // what could we put here? " is 125.
Long Statement,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseContinueStatement,The length of the statement  "            if (!m_foundEndOfLine && (JsToken.Identifier == m_currentToken.Token || (label = JsKeyword.CanBeIdentifier(m_currentToken.Token)) != null)) " is 139.
Long Statement,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseBreakStatement,The length of the statement  "            if (!m_foundEndOfLine && (JsToken.Identifier == m_currentToken.Token || (label = JsKeyword.CanBeIdentifier(m_currentToken.Token)) != null)) " is 139.
Long Statement,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseSwitchStatement,The length of the statement  "                                while (JsToken.RightCurly != m_currentToken.Token && JsToken.Case != m_currentToken.Token && JsToken.Default != m_currentToken.Token) " is 133.
Long Statement,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseLeftHandSideExpression,The length of the statement  "                                        if (ConvertNumericLiteralToDouble(m_currentToken.Code' (m_currentToken.Token == JsToken.IntegerLiteral)' out doubleValue)) " is 122.
Long Statement,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ScanNextToken,The length of the statement  "                EchoWriter.IfNotNull(w => { if (!Settings.PreprocessOnly || nextToken.Token != JsToken.PreprocessorDirective) w.Write(nextToken.Code); }); " is 138.
Long Statement,Spike.Build.Minifiers,JsResolutionVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsResolutionVisitor.cs,Visit,The length of the statement  "                node.FunctionScope = new JsFunctionScope(parentScope' node.FunctionType != JsFunctionType.Declaration' m_settings' node) " is 120.
Long Statement,Spike.Build.Minifiers,JsResolutionVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsResolutionVisitor.cs,Visit,The length of the statement  "                    node.CatchBlock.BlockScope = new JsCatchScope(CurrentLexicalScope' node.CatchBlock.Context' m_settings' node.CatchParameter) " is 124.
Long Statement,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanString,The length of the statement  "                m_decodedString = m_strSourceCode.Substring(m_currentToken.StartPosition + 1' m_currentPosition - m_currentToken.StartPosition - numDelimiters); " is 144.
Long Statement,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,GetOperatorPrecedence,The length of the statement  "            return op == null || op.Token == JsToken.None ? JsOperatorPrecedence.None : JsScanner.s_OperatorsPrec[op.Token - JsToken.FirstBinaryOperator]; " is 142.
Long Statement,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,InitOperatorsPrec,The length of the statement  "            JsOperatorPrecedence[] operatorsPrec = new JsOperatorPrecedence[JsToken.LastOperator - JsToken.FirstBinaryOperator + 1]; " is 120.
Long Statement,Spike.Build.Minifiers,JsScriptSharpSourceMap,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScriptSharpSourceMap.cs,StartSymbol,The length of the statement  "                return JavaScriptSymbol.StartNew(node' startLine + m_lineOffset' startColumn + m_columnOffset' GetSourceFileIndex(node.Context.Document.FileContext)); " is 150.
Long Statement,Spike.Build.Minifiers,JsScriptSharpSourceMap,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScriptSharpSourceMap.cs,MarkSegment,The length of the statement  "                var nameSymbol = JavaScriptSymbol.StartNew(fakeLookup' startLine' startColumn' GetSourceFileIndex(functionObject.Context.Document.FileContext)); " is 144.
Long Statement,Spike.Build.Minifiers,JsSourceMapFactory,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsSourceMapFactory.cs,Create,The length of the statement  "            else if (string.Compare(implementationName' JsScriptSharpSourceMap.ImplementationName' StringComparison.OrdinalIgnoreCase) == 0) " is 128.
Long Statement,Spike.Build.Minifiers,JsV3SourceMap,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsV3SourceMap.cs,CreateSegment,The length of the statement  "                DestinationColumn = m_lastDestinationColumn < 0 || m_lastDestinationLine < destinationLine ? destinationColumn : destinationColumn - m_lastDestinationColumn' " is 157.
Long Statement,Spike.Build.WinRT,WinRTTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.WinRT\WinRTTemplate.cs,TransformText,The length of the statement  "                    "len)\r\n\t\t\t\t\t\t\treturn 0;\r\n\r\n\t\t\t\t\t\tdo\r\n\t\t\t\t\t\t\tlen++;\r\n\t\t\t\t\t\twhile (len < maxlen && " + " is 120.
Long Statement,Spike.Build.WinRT,WinRTTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.WinRT\WinRTTemplate.cs,TransformText,The length of the statement  "                    "\t\t\t\t\t\tlen -= 2;\r\n\t\t\t\t\t\tiidx++;\r\n\r\n\t\t\t\t\t\tif (len < 7)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tout_data[" + " is 126.
Long Statement,Spike.Build.WinRT,WinRTTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.WinRT\WinRTTemplate.cs,TransformText,The length of the statement  "                    "ue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\telse if (iidx == in_len)\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t/* one mo" + " is 120.
Long Statement,Spike.Build.WinRT,WinRTTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.WinRT\WinRTTemplate.cs,TransformText,The length of the statement  "                    "RNO (E2BIG);\r\n\t\t\t\t\t\treturn 0;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (reference < 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t" + " is 123.
Long Statement,Spike.Build.WinRT,WinRTTemplateBase,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.WinRT\WinRTTemplate.cs,Write,The length of the statement  "            textToAppend = textToAppend.Replace(global::System.Environment.NewLine' (global::System.Environment.NewLine + this.currentIndentField)); " is 136.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,HandleCharset,The conditional expression  "string.CompareOrdinal(source' 3' charsetAscii' 0' charsetAscii.Length) != 0                      || (source[3 + charsetAscii.Length] != '"' && source[3 + charsetAscii.Length] != '\'')                      || string.Compare(source' 4 + charsetAscii.Length' "ascii"' 0' 5' StringComparison.OrdinalIgnoreCase) != 0"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseStylesheet,The conditional expression  "ParseRule() == Parsed.True                || ParseMedia() == Parsed.True                || ParsePage() == Parsed.True                || ParseFontFace() == Parsed.True                || ParseKeyFrames() == Parsed.True                || ParseAtKeyword() == Parsed.True  			  || ParseAspNetBlock() == Parsed.True"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseStylesheet,The conditional expression  "ParseRule() == Parsed.True                    || ParseMedia() == Parsed.True                    || ParsePage() == Parsed.True                    || ParseFontFace() == Parsed.True                    || ParseAtKeyword() == Parsed.True  				  || ParseAspNetBlock() == Parsed.True"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseSCDOCDCComments,The conditional expression  "CurrentTokenType == TokenType.Space                || CurrentTokenType == TokenType.Comment                || CurrentTokenType == TokenType.CommentOpen                || CurrentTokenType == TokenType.CommentClose                || (CurrentTokenType == TokenType.Character && CurrentTokenText == ";")"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseMedia,The conditional expression  "ParseRule() == Parsed.True                            || ParseMedia() == Parsed.True                            || ParsePage() == Parsed.True                            || ParseFontFace() == Parsed.True                            || ParseAtKeyword() == Parsed.True                            || ParseAspNetBlock() == Parsed.True"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseMediaQuery,The conditional expression  "(CurrentTokenType == TokenType.Identifier                  && string.Compare(CurrentTokenText' "AND"' StringComparison.OrdinalIgnoreCase) == 0)                  || (CurrentTokenType == TokenType.Function                  && string.Compare(CurrentTokenText' "AND("' StringComparison.OrdinalIgnoreCase) == 0)"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseDeclarationList,The conditional expression  "(CurrentTokenType != TokenType.Character                          || (CurrentTokenText != ";" && CurrentTokenText != "}"))                          && !m_scanner.EndOfFile"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseDeclarationList,The conditional expression  "CurrentTokenType != TokenType.Character                              || (CurrentTokenText != "}" && CurrentTokenText != ";")                              || (comments.Length > 0 && comments != "/* */" && comments != "/**/")"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseCombinator,The conditional expression  "CurrentTokenType == TokenType.Character                && (CurrentTokenText == "+" || CurrentTokenText == ">" || CurrentTokenText == "~")"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseAttrib,The conditional expression  "(CurrentTokenType == TokenType.Character && CurrentTokenText == "=")                    || (CurrentTokenType == TokenType.Includes)                    || (CurrentTokenType == TokenType.DashMatch)                    || (CurrentTokenType == TokenType.PrefixMatch)                    || (CurrentTokenType == TokenType.SuffixMatch)                    || (CurrentTokenType == TokenType.SubstringMatch)"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseExpressionFunction,The conditional expression  "!m_scanner.EndOfFile                    && (CurrentTokenType != TokenType.Character                      || CurrentTokenText != ")"                      || parenLevel > 0)"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseHexcolor,The conditional expression  "(colorHash.Length == 5 || colorHash.Length == 8 || colorHash.Length == 10)                      && colorHash.EndsWith("\t"' StringComparison.Ordinal)"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseProduct,The conditional expression  "(CurrentTokenType == TokenType.Character && (CurrentTokenText == "*" || CurrentTokenText == "/"))                      || (CurrentTokenType == TokenType.Identifier && string.Compare(CurrentTokenText' "mod"' StringComparison.OrdinalIgnoreCase) == 0)"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,SkipToEndOfStatement,The conditional expression  "CurrentTokenType == TokenType.Character                      && (CurrentTokenText == "(" || CurrentTokenText == "[" || CurrentTokenText == "{")"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,SkipToEndOfDeclaration,The conditional expression  "!m_scanner.EndOfFile                  && (CurrentTokenType != TokenType.Character                    || (CurrentTokenText != ";" && CurrentTokenText != "}"))"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,SkipToEndOfDeclaration,The conditional expression  "CurrentTokenType == TokenType.Character                      && (CurrentTokenText == "(" || CurrentTokenText == "[" || CurrentTokenText == "{")"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,SkipToClose,The conditional expression  "CurrentTokenType == TokenType.Character                      && (CurrentTokenText == "(" || CurrentTokenText == "[" || CurrentTokenText == "{")"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,Append,The conditional expression  "(firstChar < 'A' || 'Z' < firstChar)                                  && (firstChar < 'a' || 'z' < firstChar)                                  && firstChar != '\\'"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,Append,The conditional expression  "nextChar != '-'                                  && nextChar != '_'                                  && nextChar != ' '                                  && ('0' > nextChar || nextChar > '9')                                  && ('a' > nextChar || nextChar > 'z')                                  && ('A' > nextChar || nextChar > 'Z')"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,Append,The conditional expression  "(protectNextHexCharacter && CssScanner.IsH(unescapedSubstring[0]))                                          || (textEndsInEscapeSequence && unescapedSubstring[0] == ' ')"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,ScanUnicodeRange,The conditional expression  "m_currentChar != '\0'                  && count < 6                  && (m_currentChar == '?' || (!hasQuestions && IsH(m_currentChar)))"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,ScanNum,The conditional expression  "num == "0"                               && tokenType != TokenType.Dimension                              && tokenType != TokenType.Angle                              && tokenType != TokenType.Time                              && tokenType != TokenType.Frequency                              && tokenType != TokenType.Resolution"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,GetNmStart,The conditional expression  "IsNonAscii(m_currentChar)                    || (m_currentChar == '_')                    || ('a' <= m_currentChar && m_currentChar <= 'z')                    || ('A' <= m_currentChar && m_currentChar <= 'Z')"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,GetString,The conditional expression  "(m_currentChar == ' ')                        || (m_currentChar == '\t')                        || (m_currentChar == '!')                        || (m_currentChar == '#')                        || (m_currentChar == '$')                        || (m_currentChar == '%')                        || (m_currentChar == '&')                        || ('(' <= m_currentChar && m_currentChar <= '~')                        || (m_currentChar == (delimiter == '"' ? '\'' : '"'))"  is complex.
Complex Conditional,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,GetUrl,The conditional expression  "IsNonAscii(m_currentChar)                    || (m_currentChar == '!')                    || (m_currentChar == '#')                    || (m_currentChar == '$')                    || (m_currentChar == '%')                    || (m_currentChar == '&')                    || ('*' <= m_currentChar && m_currentChar <= '~')"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsActivationObject,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsActivationObject.cs,AnalyzeNonGlobalScope,The conditional expression  "!variableField.IsReferenced                      && !variableField.IsGenerated                      && variableField.OuterField == null                      && variableField.FieldType != JsFieldType.CatchError                      && variableField.FieldType != JsFieldType.GhostCatch                      && variableField.OriginalContext != null"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsActivationObject,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsActivationObject.cs,AnalyzeNonGlobalScope,The conditional expression  "variableField.RefCount == 1                      && this.IsKnownAtCompileTime                      && m_settings.RemoveUnneededCode                      && m_settings.IsModificationAllowed(JsTreeModifications.RemoveUnusedVariables)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsActivationObject,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsActivationObject.cs,UnreferencedFunction,The conditional expression  "this.IsKnownAtCompileTime                          && m_settings.MinifyCode                          && m_settings.RemoveUnneededCode                          && !(this is JsBlockScope)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsActivationObject,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsActivationObject.cs,SingleReferenceVariableField,The conditional expression  "!reference.IsAssignment                              && reference.VariableField != null                              && reference.VariableField.OuterField == null                              && reference.VariableField.CanCrunch                              && varDecl.Index < reference.Index                              && !IsIterativeReference(varDecl.Initializer' reference)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsActivationObject,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsActivationObject.cs,IsIterativeReference,The conditional expression  "initializer is JsArrayLiteral                   || initializer is JsObjectLiteral                  || (regExp != null && regExp.PatternSwitches != null && regExp.PatternSwitches.IndexOf("g"' StringComparison.OrdinalIgnoreCase) >= 0)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsActivationObject,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsActivationObject.cs,AutoRenameFields,The conditional expression  "!field.CanCrunch || field.CrunchedName != null                              || (field.OuterField != null && !field.IsGenerated && field.OwningScope != null && !field.OwningScope.IsKnownAtCompileTime)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsActivationObject,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsActivationObject.cs,AutoRenameFields,The conditional expression  "localField.CanCrunch                              && (localField.RefCount > 0 || localField.IsDeclared || localField.IsPlaceholder                              || !(m_settings.RemoveFunctionExpressionNames && m_settings.IsModificationAllowed(JsTreeModifications.RemoveFunctionExpressionNames)))"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsActivationObject,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsActivationObject.cs,GetUncrunchedLocals,The conditional expression  "variableField != null && variableField.OuterField == null && variableField.CrunchedName == null                      && variableField.CanCrunch && !variableField.WasRemoved"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsActivationObject,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsActivationObject.cs,GetUncrunchedLocals,The conditional expression  "(m_settings.LocalRenaming == JsLocalRenaming.CrunchAll                          || !variableField.Name.StartsWith("L_"' StringComparison.Ordinal))                          && !(m_settings.PreserveFunctionNames && variableField.IsFunction)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "(node.Parent is JsBlock || (node.Parent is JsCommaOperator && node.Parent.Parent is JsBlock))                      && (node.OperatorToken == JsToken.LogicalOr || node.OperatorToken == JsToken.LogicalAnd)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,CombineTwoExpressions,The conditional expression  "prevBinary != null                  && curBinary != null                  && prevBinary.IsAssign                  && curBinary.IsAssign                  && curBinary.OperatorToken != JsToken.Assign                  && (lookup = curBinary.Operand1 as JsLookup) != null                  && prevBinary.Operand1.IsEquivalentTo(curBinary.Operand1)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,CombineWithPreviousVar,The conditional expression  "binaryOp != null                  && binaryOp.IsAssign                  && (lookup = binaryOp.Operand1 as JsLookup) != null                  && lookup.VariableField != null                  && !ContainsReference(binaryOp.Operand2' lookup.VariableField)                  && previousVar[previousVar.Count - 1].VariableField == lookup.VariableField"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "ifNode != null                              && ifNode.TrueBlock != null                              && ifNode.TrueBlock.Count > 0                              && ifNode.FalseBlock != null"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "node[ndx] is JsReturnNode                              || node[ndx] is JsBreak                              || node[ndx] is JsContinueNode                              || node[ndx] is JsThrowNode"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "ifNode != null && ifNode.FalseBlock == null                          && ifNode.TrueBlock.Count == 1                          && (returnNode = ifNode.TrueBlock[0] as JsReturnNode) != null"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "indexPrevious >= 0                           && lastReturn != null                          && (previousIf = node[indexPrevious] as JsIfNode) != null                          && previousIf.TrueBlock != null && previousIf.TrueBlock.Count == 1                          && previousIf.FalseBlock == null"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "ifNode != null                              && ifNode.FalseBlock == null                              && ifNode.TrueBlock != null                              && ifNode.TrueBlock.Count == 1"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "ifNode != null                                  && ifNode.FalseBlock == null                                  && ifNode.TrueBlock != null                                  && ifNode.TrueBlock.Count == 1"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,IsIfReturnExpr,The conditional expression  "ifNode != null                  && ifNode.FalseBlock == null                  && ifNode.TrueBlock != null                  && ifNode.TrueBlock.Count == 1"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "node.Arguments == null                                || node.Arguments.Count != 1                                || (constWrapper != null && !constWrapper.IsNumericLiteral)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "m_parser.Settings.HasRenamePairs && m_parser.Settings.ManualRenamesProperties                              && m_parser.Settings.IsModificationAllowed(JsTreeModifications.PropertyRenaming)                              && !string.IsNullOrEmpty(newName = m_parser.Settings.GetNewName(argText))"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "callNode != null                          && callNode.InBrackets                          && callNode.Function.IsWindowLookup                          && callNode.Arguments.IsSingleConstantArgument("eval")"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Optimize,The conditional expression  "unary != null && unary.OperatorToken == JsToken.LogicalNot                  && !unary.OperatorInConditionalCompilationComment                  && m_parser.Settings.IsModificationAllowed(JsTreeModifications.IfNotTrueFalseToIfFalseTrue)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "node.PrimitiveType == JsPrimitiveType.String                      && node.Parser.Settings.ErrorIfNotInlineSafe                      && node.Context != null                      && StringSourceIsNotInlineSafe(node.Context.Code)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "m_parser.Settings.StripDebugStatements                       && m_parser.Settings.IsModificationAllowed(JsTreeModifications.StripDebugStatements)                       && node.Body != null                       && node.Body.IsDebuggerStatement"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "m_parser.Settings.StripDebugStatements                       && m_parser.Settings.IsModificationAllowed(JsTreeModifications.StripDebugStatements)                       && node.Body != null                       && node.Body.IsDebuggerStatement                       && node.Body.BlockScope == null"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "m_parser.Settings.StripDebugStatements                       && m_parser.Settings.IsModificationAllowed(JsTreeModifications.StripDebugStatements)                       && node.Body != null                       && node.Body.BlockScope == null                       && node.Body.IsDebuggerStatement"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "node.Name.IsNullOrWhiteSpace()                      || (node.IsExpression                          && node.RefCount == 0                          && m_parser.Settings.RemoveFunctionExpressionNames                          && m_parser.Settings.IsModificationAllowed(JsTreeModifications.RemoveFunctionExpressionNames))"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "node.FalseBlock == null                      && node.TrueBlock != null                      && node.TrueBlock.Count == 1                      && m_parser.Settings.IsModificationAllowed(JsTreeModifications.CombineNestedIfs)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "node.PrimitiveType == JsPrimitiveType.String                      && m_parser.Settings.HasRenamePairs && m_parser.Settings.ManualRenamesProperties                      && m_parser.Settings.IsModificationAllowed(JsTreeModifications.PropertyRenaming)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "lookup != null                          && lookup.VariableField != null                          && lookup.VariableField.OuterField == null                          && (binaryOp = lookup.Parent as JsBinaryOperator) != null                          && binaryOp.IsAssign                          && !lookup.VariableField.IsReferencedInnerScope"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "!(lastStatement is JsBreak) && !(lastStatement is JsContinueNode)                                                && !(lastStatement is JsReturnNode) && !(lastStatement is JsThrowNode)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "node.FinallyBlock != null && node.FinallyBlock.Count == 0 && node.CatchBlock != null                      && m_parser.Settings.IsModificationAllowed(JsTreeModifications.RemoveEmptyFinally)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "lookup.VariableField == null                                  || lookup.VariableField.FieldType == JsFieldType.UndefinedGlobal                                  || lookup.VariableField.FieldType == JsFieldType.Arguments                                  || (lookup.VariableField.FieldType == JsFieldType.Predefined && string.CompareOrdinal(lookup.Name' "eval") == 0)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "m_parser.Settings.StripDebugStatements                       && m_parser.Settings.IsModificationAllowed(JsTreeModifications.StripDebugStatements)                       && node.Body != null                       && node.Body.IsDebuggerStatement"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsAnalyzeNodeVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "m_parser.Settings.StripDebugStatements                       && m_parser.Settings.IsModificationAllowed(JsTreeModifications.StripDebugStatements)                       && node.Body != null                       && node.Body.IsDebuggerStatement"  is complex.
Complex Conditional,Spike.Build.Minifiers,ReferenceComparer,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsCrunchEnumerator.cs,Compare,The conditional expression  "(left.FieldType == JsFieldType.Argument || left.FieldType == JsFieldType.CatchError)                  && (right.FieldType == JsFieldType.Argument || right.FieldType == JsFieldType.CatchError)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,ReplaceMemberBracketWithDot,The conditional expression  "m_parser.Settings.HasRenamePairs && m_parser.Settings.ManualRenamesProperties                          && m_parser.Settings.IsModificationAllowed(JsTreeModifications.PropertyRenaming)                          && !string.IsNullOrEmpty(newName = m_parser.Settings.GetNewName(combinedString))"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalToTheLeft,The conditional expression  "(leftOperator.OperatorToken == JsToken.Multiply && node.OperatorToken == JsToken.Divide)                  || (leftOperator.OperatorToken == JsToken.Divide && node.OperatorToken == JsToken.Multiply)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalToTheLeft,The conditional expression  "otherOverThis != null && NoMultiplicativeOverOrUnderFlow(otherConstant' thisConstant' otherOverThis)                          && (thisOverOther == null || otherOverThisLength < thisOverOtherLength)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalToTheLeft,The conditional expression  "node.OperatorToken == leftOperator.OperatorToken                  && (node.OperatorToken == JsToken.BitwiseAnd || node.OperatorToken == JsToken.BitwiseOr || node.OperatorToken == JsToken.BitwiseXor)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalFarToTheLeft,The conditional expression  "otherOverThis != null && NoMultiplicativeOverOrUnderFlow(otherConstant' thisConstant' otherOverThis)                          && (thisOverOther == null || otherOverThisLength < thisOverOtherLength)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalToTheRight,The conditional expression  "leftOverRight != null && NoMultiplicativeOverOrUnderFlow(thisConstant' otherConstant' leftOverRight)                          && (rightOverLeft == null || leftOverRightLength < rightOverLeftLength)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalFarToTheRight,The conditional expression  "otherOverThis != null && NoMultiplicativeOverOrUnderFlow(otherConstant' thisConstant' otherOverThis)                          && (thisOverOther == null || otherOverThisLength < thisOverOtherLength)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoBinaryOperator,The conditional expression  "lookup != null && node.OperatorToken == JsToken.Minus && right.IsIntegerLiteral && right.ToNumber() == 0"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsFinalPassVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsFinalPassVisitor.cs,Visit,The conditional expression  "node.OperatorToken == JsToken.Comma                      && m_parser.Settings.IsModificationAllowed(JsTreeModifications.UnfoldCommaExpressionStatements)                      && ((parentBlock = node.Parent as JsBlock) != null)                      && (parentBlock.Parent == null                          || parentBlock.Parent is JsFunctionObject                          || parentBlock.Parent is JsTryNode                          || parentBlock.Parent is JsSwitchCase                          || parentBlock.Count > 1)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsMatchPropertiesVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsMatchPropertiesVisitor.cs,Visit,The conditional expression  "node != null                  && m_index > 0                  && node.InBrackets                  && node.Arguments != null                  && node.Arguments.Count == 1"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsMatchPropertiesVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsMatchPropertiesVisitor.cs,Visit,The conditional expression  "string.CompareOrdinal(node.Name' m_parts[0]) == 0                      && (node.VariableField == null || node.VariableField.FieldType == JsFieldType.UndefinedGlobal                       || node.VariableField.FieldType == JsFieldType.Global)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The conditional expression  "newExpression != null && newExpression.IsConstructor                                  && (newExpression.Arguments == null || newExpression.Arguments.Count == 0)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The conditional expression  "node.Context == null || !node.Context.HasCode                              || (!node.MayHaveIssues && m_settings.IsModificationAllowed(JsTreeModifications.MinifyNumericLiterals))"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The conditional expression  "node.TrueBlock.Count == 1                      && (node.FalseBlock == null || (!node.TrueBlock.EncloseBlock(EncloseBlockType.IfWithoutElse) && !node.TrueBlock.EncloseBlock(EncloseBlockType.SingleDoWhile)))                      && (!m_settings.MacSafariQuirks || !(node.TrueBlock[0] is JsFunctionObject))"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The conditional expression  "constantWrapper.Context == null                              || !constantWrapper.Context.HasCode                              || (m_settings.IsModificationAllowed(JsTreeModifications.MinifyNumericLiterals) && !constantWrapper.MayHaveIssues)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The conditional expression  "callNode != null                                  && callNode.IsConstructor                                  && (callNode.Arguments == null || callNode.Arguments.Count == 0)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseForStatement,The conditional expression  "isLHS && (JsToken.In == m_currentToken.Token                                  || (m_currentToken.Token == JsToken.Identifier && string.CompareOrdinal(m_currentToken.Code' "of") == 0))"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseFunction,The conditional expression  "m_currentToken.Token != JsToken.LeftParenthesis                          && m_currentToken.Token != JsToken.LeftCurly                          && m_currentToken.Token != JsToken.Semicolon                          && m_currentToken.Token != JsToken.EndOfFile"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseExpression,The conditional expression  "JsScanner.IsProcessableOperator(m_currentToken.Token)                          && inToken != m_currentToken.Token                          && (!single || m_currentToken.Token != JsToken.Comma)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ScanNextToken,The conditional expression  "nextToken.Token == JsToken.WhiteSpace                  || nextToken.Token == JsToken.EndOfLine                  || nextToken.Token == JsToken.SingleLineComment                  || nextToken.Token == JsToken.MultipleLineComment                  || nextToken.Token == JsToken.Error                  || nextToken.Token == JsToken.PreprocessorDirective"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ScanNextToken,The conditional expression  "nextToken.HasCode                           && ((nextToken.Code.Length > 2 && nextToken.Code[2] == '!')                           || (nextToken.Code.IndexOf("@preserve"' StringComparison.OrdinalIgnoreCase) >= 0)                          || (nextToken.Code.IndexOf("@license"' StringComparison.OrdinalIgnoreCase) >= 0))"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,PeekToken,The conditional expression  "peekToken.Token == JsToken.WhiteSpace                  || peekToken.Token == JsToken.EndOfLine                  || peekToken.Token == JsToken.Error                  || peekToken.Token == JsToken.SingleLineComment                  || peekToken.Token == JsToken.MultipleLineComment                  || peekToken.Token == JsToken.PreprocessorDirective                  || peekToken.Token == JsToken.ConditionalCommentEnd                  || peekToken.Token == JsToken.ConditionalCommentStart                  || peekToken.Token == JsToken.ConditionalCompilationElse                  || peekToken.Token == JsToken.ConditionalCompilationElseIf                  || peekToken.Token == JsToken.ConditionalCompilationEnd                  || peekToken.Token == JsToken.ConditionalCompilationIf                  || peekToken.Token == JsToken.ConditionalCompilationOn                  || peekToken.Token == JsToken.ConditionalCompilationSet                  || peekToken.Token == JsToken.ConditionalCompilationVariable                  || peekToken.Token == JsToken.ConditionalIf"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsResolutionVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsResolutionVisitor.cs,ResolveLookup,The conditional expression  "callNode != null && callNode.InBrackets                              && callNode.Arguments.Count == 1                              && callNode.Arguments[0] is JsConstantWrapper                              && callNode.Arguments[0].FindPrimitiveType() == JsPrimitiveType.String"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsResolutionVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsResolutionVisitor.cs,ResolveGhostedFunctions,The conditional expression  "parentAssignment == null || parentAssignment.OperatorToken != JsToken.Assign                              || parentAssignment.Operand2 != funcObject                              || (lookup = parentAssignment.Operand1 as JsLookup) == null                              || lookup.Name != funcObject.Name"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsResolutionVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsResolutionVisitor.cs,Visit,The conditional expression  "node.BlockScope == null                      && node.Parent != null                      && !(node.Parent is JsSwitchCase)                      && !(node.Parent is JsFunctionObject)                      && !(node.Parent is JsConditionalCompilationComment)"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsResolutionVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsResolutionVisitor.cs,Visit,The conditional expression  "node.BlockScope != null                      && !(node.BlockScope is JsWithScope)                      && !(node.BlockScope is JsCatchScope)                      && node.BlockScope.LexicallyDeclaredNames.Count == 0"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanLineTerminator,The conditional expression  "(ch = GetChar(m_currentPosition)) == '\r' || ch == '\n' || ch == '\u2028' || ch == '\u2029'"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,SkipToEndOfLine,The conditional expression  "c != 0                  && c != '\n'                  && c != '\r'                  && c != '\x2028'                  && c != '\x2029'"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,IsValidIdentifierStart,The conditional expression  "('a' <= letter && letter <= 'z') || ('A' <= letter && letter <= 'Z') || letter == '_' || letter == '$'"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,IsSafeIdentifierStart,The conditional expression  "('a' <= letter && letter <= 'z') || ('A' <= letter && letter <= 'Z') || letter == '_' || letter == '$'"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,IsValidIdentifierPart,The conditional expression  "('a' <= letter && letter <= 'z')                  || ('A' <= letter && letter <= 'Z')                  || ('0' <= letter && letter <= '9')                  || letter == '_'                  || letter == '$'                  || letter == 0x200c                      || letter == 0x200d"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,IsSafeIdentifierPart,The conditional expression  "('a' <= letter && letter <= 'z')                  || ('A' <= letter && letter <= 'Z')                  || ('0' <= letter && letter <= '9')                  || letter == '_'                  || letter == '$'"  is complex.
Complex Conditional,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The conditional expression  "str[1] == 'u'                       && IsHexDigit(str[2])                      && IsHexDigit(str[3])                      && IsHexDigit(str[4])                      && IsHexDigit(str[5])"  is complex.
Complex Conditional,Spike.Build.Minifiers,MinifierParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\MinifierParser.cs,Parse,The conditional expression  "thisArg.Length > 1                        && (thisArg.StartsWith("-"' StringComparison.Ordinal) // this is a normal hyphen (minus character)                        || thisArg.StartsWith(""' StringComparison.Ordinal) // this character is what Word will convert a hyphen to                        || (!m_isMono && thisArg.StartsWith("/"' StringComparison.Ordinal)))"  is complex.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Multiply,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Divide,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Modulo,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,NumericAddition,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Minus,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,LeftShift,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,RightShift,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,UnsignedRightShift,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,LessThan,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,LessThanOrEqual,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,GreaterThan,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,GreaterThanOrEqual,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Equal,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Equal,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,NotEqual,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,NotEqual,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,StrictEqual,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,StrictNotEqual,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,BitwiseAnd,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,BitwiseOr,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,BitwiseXor,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,LogicalAnd,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,LogicalOr,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoConditional,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoConditionalCompilationElseIf,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoConditionalCompilationIf,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoDoWhile,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoForNode,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoIfNode,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoWhileNode,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseStatements,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsScriptSharpSourceMap,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScriptSharpSourceMap.cs,MakeRelative,The method has an empty catch block.
Empty Catch Block,Spike.Build.Minifiers,JsV3SourceMap,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsV3SourceMap.cs,MakeRelative,The method has an empty catch block.
Magic Number,Spike.Build,Extentions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,WithoutInform,The following statement contains a magic number: return text.Substring(0' text.Length - 6);
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,GetMurmurHash3,The following statement contains a magic number: k1 = (uint)(data[currentIndex++]                    | data[currentIndex++] << 8                    | data[currentIndex++] << 16                    | data[currentIndex++] << 24);
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,GetMurmurHash3,The following statement contains a magic number: k1 = (uint)(data[currentIndex++]                    | data[currentIndex++] << 8                    | data[currentIndex++] << 16                    | data[currentIndex++] << 24);
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,GetMurmurHash3,The following statement contains a magic number: k1 = (uint)(data[currentIndex++]                    | data[currentIndex++] << 8                    | data[currentIndex++] << 16                    | data[currentIndex++] << 24);
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,GetMurmurHash3,The following statement contains a magic number: k1 = Rotl32(k1' 15);
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,GetMurmurHash3,The following statement contains a magic number: h1 = Rotl32(h1' 13);
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,GetMurmurHash3,The following statement contains a magic number: h1 = h1 * 5 + 0xe6546b64;
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,GetMurmurHash3,The following statement contains a magic number: curLength -= 4;
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,GetMurmurHash3,The following statement contains a magic number: curLength >= 4
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,GetMurmurHash3,The following statement contains a magic number: switch (curLength)              {                  case 3:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8                        | data[currentIndex++] << 16);                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 2:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8);                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 1:                      k1 = data[currentIndex++];                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;              }
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,GetMurmurHash3,The following statement contains a magic number: switch (curLength)              {                  case 3:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8                        | data[currentIndex++] << 16);                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 2:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8);                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 1:                      k1 = data[currentIndex++];                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;              }
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,GetMurmurHash3,The following statement contains a magic number: switch (curLength)              {                  case 3:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8                        | data[currentIndex++] << 16);                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 2:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8);                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 1:                      k1 = data[currentIndex++];                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;              }
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,GetMurmurHash3,The following statement contains a magic number: switch (curLength)              {                  case 3:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8                        | data[currentIndex++] << 16);                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 2:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8);                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 1:                      k1 = data[currentIndex++];                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;              }
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,GetMurmurHash3,The following statement contains a magic number: switch (curLength)              {                  case 3:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8                        | data[currentIndex++] << 16);                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 2:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8);                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 1:                      k1 = data[currentIndex++];                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;              }
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,GetMurmurHash3,The following statement contains a magic number: switch (curLength)              {                  case 3:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8                        | data[currentIndex++] << 16);                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 2:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8);                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 1:                      k1 = data[currentIndex++];                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;              }
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,GetMurmurHash3,The following statement contains a magic number: switch (curLength)              {                  case 3:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8                        | data[currentIndex++] << 16);                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 2:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8);                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 1:                      k1 = data[currentIndex++];                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;              }
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,GetMurmurHash3,The following statement contains a magic number: switch (curLength)              {                  case 3:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8                        | data[currentIndex++] << 16);                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 2:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8);                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 1:                      k1 = data[currentIndex++];                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;              }
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,Rotl32,The following statement contains a magic number: return (x << r) | (x >> (32 - r));
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,Mix,The following statement contains a magic number: h ^= h >> 16;
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,Mix,The following statement contains a magic number: h ^= h >> 13;
Magic Number,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,Mix,The following statement contains a magic number: h ^= h >> 16;
Magic Number,Spike.Build,Model,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Model.cs,GetMember,The following statement contains a magic number: type = type.Substring(6);
Magic Number,Spike.Build,Program,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Program.cs,Main,The following statement contains a magic number: var baseUrl = modelFile.Substring(0' modelFile.Length - 4);
Magic Number,Spike.Build.Minifiers,CssEncoderFallbackBuffer,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\CssEncoderFallback.cs,GetEncoding,The following statement contains a magic number: hexValue.Length > 6
Magic Number,Spike.Build.Minifiers,CssEncoderFallbackBuffer,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\CssEncoderFallback.cs,GetEncoding,The following statement contains a magic number: return "\\{0}{1}".FormatInvariant(hexValue' (hexValue.Length < 6 ? " " : string.Empty));
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,HandleCharset,The following statement contains a magic number: string.CompareOrdinal(source' 3' charsetAscii' 0' charsetAscii.Length) != 0                      || (source[3 + charsetAscii.Length] != '"' && source[3 + charsetAscii.Length] != '\'')                      || string.Compare(source' 4 + charsetAscii.Length' "ascii"' 0' 5' StringComparison.OrdinalIgnoreCase) != 0
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,HandleCharset,The following statement contains a magic number: string.CompareOrdinal(source' 3' charsetAscii' 0' charsetAscii.Length) != 0                      || (source[3 + charsetAscii.Length] != '"' && source[3 + charsetAscii.Length] != '\'')                      || string.Compare(source' 4 + charsetAscii.Length' "ascii"' 0' 5' StringComparison.OrdinalIgnoreCase) != 0
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,HandleCharset,The following statement contains a magic number: string.CompareOrdinal(source' 3' charsetAscii' 0' charsetAscii.Length) != 0                      || (source[3 + charsetAscii.Length] != '"' && source[3 + charsetAscii.Length] != '\'')                      || string.Compare(source' 4 + charsetAscii.Length' "ascii"' 0' 5' StringComparison.OrdinalIgnoreCase) != 0
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,HandleCharset,The following statement contains a magic number: string.CompareOrdinal(source' 3' charsetAscii' 0' charsetAscii.Length) != 0                      || (source[3 + charsetAscii.Length] != '"' && source[3 + charsetAscii.Length] != '\'')                      || string.Compare(source' 4 + charsetAscii.Length' "ascii"' 0' 5' StringComparison.OrdinalIgnoreCase) != 0
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,HandleCharset,The following statement contains a magic number: string.CompareOrdinal(source' 3' charsetAscii' 0' charsetAscii.Length) != 0                      || (source[3 + charsetAscii.Length] != '"' && source[3 + charsetAscii.Length] != '\'')                      || string.Compare(source' 4 + charsetAscii.Length' "ascii"' 0' 5' StringComparison.OrdinalIgnoreCase) != 0
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,HandleCharset,The following statement contains a magic number: source = source.Substring(3);
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseAtKeyword,The following statement contains a magic number: ReportError(2' CssErrorCode.UnexpectedAtKeyword' CurrentTokenText);
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseRule,The following statement contains a magic number: ReportError(4' CssErrorCode.ExpectedSelector' CurrentTokenText);
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseSelector,The following statement contains a magic number: ReportError(4' CssErrorCode.HackGeneratesInvalidCss' currentContext' possibleCombinator);
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseDeclaration,The following statement contains a magic number: ReportError(4' CssErrorCode.HackGeneratesInvalidCss' CurrentTokenText);
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParsePrio,The following statement contains a magic number: ReportError(4' CssErrorCode.HackGeneratesInvalidCss' CurrentTokenText);
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseTerm,The following statement contains a magic number: switch (CurrentTokenType)              {                  case TokenType.Hash:                      if (hasUnary)                      {                          ReportError(0' CssErrorCode.HashAfterUnaryNotAllowed' CurrentTokenText);                      }                        if (wasEmpty)                      {                          Append(' ');                          wasEmpty = false;                      }                      if (ParseHexcolor() == Parsed.False)                      {                          ReportError(0' CssErrorCode.ExpectedHexColor' CurrentTokenText);                            // we expected the hash token to be a proper color -- but it's not.                          // we threw an error -- go ahead and output the token as-is and keep going.                          AppendCurrent();                          NextToken();                      }                      parsed = Parsed.True;                      break;                    case TokenType.String:                  case TokenType.Identifier:                  case TokenType.Uri:                  //case TokenType.RGB:                  case TokenType.UnicodeRange:                      if (hasUnary)                      {                          ReportError(0' CssErrorCode.TokenAfterUnaryNotAllowed' CurrentTokenText);                      }                        // wasEmpty will be false if we DIDN'T find an operator                      // as the last token. If we had an operator' then we can ignore                      // any whitespace; but if we DIDN'T find an operator' then we                      // will need to preserve a whitespace character to keep them                       // separated.                      if (wasEmpty)                      {                          // if we had skipped any space' then add one now                          if (m_skippedSpace)                          {                              Append(' ');                          }                                                    wasEmpty = false;                      }                        AppendCurrent();                      SkipSpace();                      parsed = Parsed.True;                      break;                    case TokenType.Dimension:                      ReportError(2' CssErrorCode.UnexpectedDimension' CurrentTokenText);                      goto case TokenType.Number;                    case TokenType.Number:                  case TokenType.Percentage:                  case TokenType.AbsoluteLength:                  case TokenType.RelativeLength:                  case TokenType.Angle:                  case TokenType.Time:                  case TokenType.Frequency:                  case TokenType.Resolution:                      if (wasEmpty)                      {                          Append(' ');                          wasEmpty = false;                      }                        AppendCurrent();                      SkipSpace();                      parsed = Parsed.True;                      break;                    case TokenType.ProgId:                      if (wasEmpty)                      {                          Append(' ');                          wasEmpty = false;                      }                      if (ParseProgId() == Parsed.False)                      {                          ReportError(0' CssErrorCode.ExpectedProgId' CurrentTokenText);                      }                      parsed = Parsed.True;                      break;                    case TokenType.Function:                      if (wasEmpty)                      {                          Append(' ');                          wasEmpty = false;                      }                      if (ParseFunction() == Parsed.False)                      {                          ReportError(0' CssErrorCode.ExpectedFunction' CurrentTokenText);                      }                      parsed = Parsed.True;                      break;                    case TokenType.Character:                      if (CurrentTokenText == "(")                      {                          // the term starts with an opening paren.                          // parse an expression followed by the close paren.                          if (wasEmpty)                          {                              if (m_skippedSpace)                              {                                  Append(' ');                              }                                wasEmpty = false;                          }                            AppendCurrent();                          SkipSpace();                            if (ParseExpr() == Parsed.False)                          {                              ReportError(0' CssErrorCode.ExpectedExpression' CurrentTokenText);                          }                            if (CurrentTokenType == TokenType.Character                              && CurrentTokenText == ")")                          {                              AppendCurrent();                              parsed = Parsed.True;                                // the closing paren can only be followed IMMEDIATELY by the opening brace                              // without any space if it's a repeat syntax.                              m_skippedSpace = false;                              NextRawToken();                              if (CurrentTokenType == TokenType.Space)                              {                                  m_skippedSpace = true;                              }                                // if the next token is an opening brace' then this might be                              // a repeat operator                              if (CurrentTokenType == TokenType.Character                                  && CurrentTokenText == "[")                              {                                  AppendCurrent();                                  SkipSpace();                                    if (CurrentTokenType == TokenType.Number)                                  {                                      AppendCurrent();                                      SkipSpace();                                        if (CurrentTokenType == TokenType.Character                                          && CurrentTokenText == "]")                                      {                                          AppendCurrent();                                          SkipSpace();                                      }                                      else                                      {                                          ReportError(0' CssErrorCode.ExpectedClosingBracket' CurrentTokenText);                                          parsed = Parsed.False;                                      }                                  }                                  else                                  {                                      ReportError(0' CssErrorCode.ExpectedNumber' CurrentTokenText);                                      parsed = Parsed.False;                                  }                              }                          }                          else                          {                              ReportError(0' CssErrorCode.ExpectedClosingParenthesis' CurrentTokenText);                          }                      }                      else                      {                          goto default;                      }                      break;                    default:                      if (hasUnary)                      {                          ReportError(0' CssErrorCode.UnexpectedToken' CurrentTokenText);                      }                      break;              }
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseProgId,The following statement contains a magic number: ReportError(4' CssErrorCode.ProgIdIEOnly);
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseRgb,The following statement contains a magic number: var rgb = new int[3];
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseRgb,The following statement contains a magic number: ndx < 3
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseHexcolor,The following statement contains a magic number: (colorHash.Length == 5 || colorHash.Length == 8 || colorHash.Length == 10)                      && colorHash.EndsWith("\t"' StringComparison.Ordinal)
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseHexcolor,The following statement contains a magic number: (colorHash.Length == 5 || colorHash.Length == 8 || colorHash.Length == 10)                      && colorHash.EndsWith("\t"' StringComparison.Ordinal)
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseHexcolor,The following statement contains a magic number: (colorHash.Length == 5 || colorHash.Length == 8 || colorHash.Length == 10)                      && colorHash.EndsWith("\t"' StringComparison.Ordinal)
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseHexcolor,The following statement contains a magic number: colorHash.Length == 4 || colorHash.Length == 7 || colorHash.Length == 9
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseHexcolor,The following statement contains a magic number: colorHash.Length == 4 || colorHash.Length == 7 || colorHash.Length == 9
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseHexcolor,The following statement contains a magic number: colorHash.Length == 4 || colorHash.Length == 7 || colorHash.Length == 9
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,EscapeCharacter,The following statement contains a magic number: return hex.Length < 7;
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,OnCssError,The following statement contains a magic number: CssError(this' new CssErrorEventArgs(exception'                          new MinifierError(                              exception.Severity < 2'                               exception.Severity'                              GetSeverityString(exception.Severity)'                               errorCode'                              null'                              FileContext'                               exception.Line'                               exception.Char'                               0'                               0'                               exception.Message)));
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,GetSeverityString,The following statement contains a magic number: switch (severity)              {                  case 0:                      return CssStrings.Severity0;                    case 1:                      return CssStrings.Severity1;                    case 2:                      return CssStrings.Severity2;                    case 3:                      return CssStrings.Severity3;                    case 4:                      return CssStrings.Severity4;                    default:                      return CssStrings.SeverityUnknown.FormatInvariant(severity);              }
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,GetSeverityString,The following statement contains a magic number: switch (severity)              {                  case 0:                      return CssStrings.Severity0;                    case 1:                      return CssStrings.Severity1;                    case 2:                      return CssStrings.Severity2;                    case 3:                      return CssStrings.Severity3;                    case 4:                      return CssStrings.Severity4;                    default:                      return CssStrings.SeverityUnknown.FormatInvariant(severity);              }
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,GetSeverityString,The following statement contains a magic number: switch (severity)              {                  case 0:                      return CssStrings.Severity0;                    case 1:                      return CssStrings.Severity1;                    case 2:                      return CssStrings.Severity2;                    case 3:                      return CssStrings.Severity3;                    case 4:                      return CssStrings.Severity4;                    default:                      return CssStrings.SeverityUnknown.FormatInvariant(severity);              }
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,NormalizeImportantComment,The following statement contains a magic number: source = "/*" + source.Substring(3);
Magic Number,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,NormalizeImportantComment,The following statement contains a magic number: source[3] == '/' && source.EndsWith("/**/"' StringComparison.Ordinal)
Magic Number,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,ScanComment,The following statement contains a magic number: string.Compare(comment' 2' "/#SOURCE"' 0' 8' StringComparison.OrdinalIgnoreCase) == 0
Magic Number,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,ScanComment,The following statement contains a magic number: string.Compare(comment' 2' "/#SOURCE"' 0' 8' StringComparison.OrdinalIgnoreCase) == 0
Magic Number,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,ScanString,The following statement contains a magic number: bool isValidString = (stringLiteral.Length >= 2                  && stringLiteral[0] == stringLiteral[stringLiteral.Length - 1]);
Magic Number,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,ScanUnicodeRange,The following statement contains a magic number: firstValue = firstValue*16 + HValue('F');
Magic Number,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,ScanUnicodeRange,The following statement contains a magic number: m_currentChar != '\0'                  && count < 6                  && (m_currentChar == '?' || (!hasQuestions && IsH(m_currentChar)))
Magic Number,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,HValue,The following statement contains a magic number: return (ch - 'a') + 10;
Magic Number,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,HValue,The following statement contains a magic number: return (ch - 'A') + 10;
Magic Number,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,IsNonAscii,The following statement contains a magic number: return (128 <= ch && ch <= 65535);
Magic Number,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,IsNonAscii,The following statement contains a magic number: return (128 <= ch && ch <= 65535);
Magic Number,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,GetUnicodeEncodingValue,The following statement contains a magic number: unicodeValue = (unicodeValue * 16) + HValue(m_currentChar);
Magic Number,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,GetUnicodeEncodingValue,The following statement contains a magic number: m_currentChar != '\0' && count++ < 6 && IsH(m_currentChar)
Magic Number,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,GetNmStart,The following statement contains a magic number: ReportError(                            4'                            CssErrorCode.UnderscoreNotValid                            );
Magic Number,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,GetNmChar,The following statement contains a magic number: ReportError(                            4'                            CssErrorCode.UnderscoreNotValid                            );
Magic Number,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,DirectiveScanInteger,The following statement contains a magic number: number = number * 10 + (m_currentChar - '0');
Magic Number,Spike.Build.Minifiers,JsConstantWrapper,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsConstantWrapper.cs,EscapeString,The following statement contains a magic number: switch (c)                      {                          // explicit escape sequences                          // if this is for a string parameter to a RegExp object' then we want to use                          // explicit hex-values' not the escape sequences                          case '\b':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x08" : @"\b"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\t':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x09" : @"\t"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\n':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0a" : @"\n"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\v':                              if (!useW3Strict)                              {                                  goto default;                              }                                AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0b" : @"\v"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\f':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0c" : @"\f"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\r':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0d" : @"\r"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\\':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' @"\\"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\'':                          case '"':                              // whichever character we're using as the delimiter' we need                              // to escape inside the string                              if (delimiter == c)                              {                                  AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' "\\"' ref sb);                                  sb.Append(c);                                  startOfStretch = ndx + 1;                              }                                // otherwise' we're going to output the character as-is' so just keep going                              break;                            case '\x2028':                          case '\x2029':                              // issue #14398 - unescaped' these characters (Unicode LineSeparator and ParagraphSeparator)                              // would introduce a line-break in the string.  they ALWAYS need to be escaped'                               // no matter what output encoding we may use.                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' @"\u"' ref sb);                              sb.Append("{0:x}".FormatInvariant((int)c));                              startOfStretch = ndx + 1;                              break;                            default:                              if (' ' <= c && c <= 0x7e)                              {                                  // regular ascii character                                  break;                              }                                if (c < ' ')                              {                                  // ECMA strict mode can't use octal' either                                  if (isRegularExpression || useStrict)                                  {                                      // for regular expression strings' \1 through \9 are always backreferences'                                       // and \10 through \40 are backreferences if they correspond to existing                                       // backreference groups. So we can't use octal for the characters with values                                      // between 0 and 31. encode with a hexadecimal escape sequence                                      AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' "\\x{0:x2}".FormatInvariant((int)c)' ref sb);                                      startOfStretch = ndx + 1;                                  }                                  else                                  {                                      // we're not a regular expression string. And character with a value between                                       // 0 and 31 can be represented in octal with two to three characters (\0 - \37)'                                      // whereas it would always take four characters to do it in hex: \x00 - \x1f.                                      // so let's go with octal since we aren't in strict mode                                      AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' "\\"' ref sb);                                      int intValue = (int)c;                                      if (intValue < 8)                                      {                                          // single octal digit                                          sb.Append(intValue.ToStringInvariant());                                      }                                      else                                      {                                          // two octal digits                                          sb.Append((intValue / 8).ToStringInvariant());                                          sb.Append((intValue % 8).ToStringInvariant());                                      }                                        startOfStretch = ndx + 1;                                  }                              }                                break;                      }
Magic Number,Spike.Build.Minifiers,JsConstantWrapper,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsConstantWrapper.cs,EscapeString,The following statement contains a magic number: switch (c)                      {                          // explicit escape sequences                          // if this is for a string parameter to a RegExp object' then we want to use                          // explicit hex-values' not the escape sequences                          case '\b':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x08" : @"\b"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\t':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x09" : @"\t"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\n':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0a" : @"\n"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\v':                              if (!useW3Strict)                              {                                  goto default;                              }                                AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0b" : @"\v"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\f':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0c" : @"\f"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\r':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0d" : @"\r"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\\':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' @"\\"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\'':                          case '"':                              // whichever character we're using as the delimiter' we need                              // to escape inside the string                              if (delimiter == c)                              {                                  AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' "\\"' ref sb);                                  sb.Append(c);                                  startOfStretch = ndx + 1;                              }                                // otherwise' we're going to output the character as-is' so just keep going                              break;                            case '\x2028':                          case '\x2029':                              // issue #14398 - unescaped' these characters (Unicode LineSeparator and ParagraphSeparator)                              // would introduce a line-break in the string.  they ALWAYS need to be escaped'                               // no matter what output encoding we may use.                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' @"\u"' ref sb);                              sb.Append("{0:x}".FormatInvariant((int)c));                              startOfStretch = ndx + 1;                              break;                            default:                              if (' ' <= c && c <= 0x7e)                              {                                  // regular ascii character                                  break;                              }                                if (c < ' ')                              {                                  // ECMA strict mode can't use octal' either                                  if (isRegularExpression || useStrict)                                  {                                      // for regular expression strings' \1 through \9 are always backreferences'                                       // and \10 through \40 are backreferences if they correspond to existing                                       // backreference groups. So we can't use octal for the characters with values                                      // between 0 and 31. encode with a hexadecimal escape sequence                                      AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' "\\x{0:x2}".FormatInvariant((int)c)' ref sb);                                      startOfStretch = ndx + 1;                                  }                                  else                                  {                                      // we're not a regular expression string. And character with a value between                                       // 0 and 31 can be represented in octal with two to three characters (\0 - \37)'                                      // whereas it would always take four characters to do it in hex: \x00 - \x1f.                                      // so let's go with octal since we aren't in strict mode                                      AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' "\\"' ref sb);                                      int intValue = (int)c;                                      if (intValue < 8)                                      {                                          // single octal digit                                          sb.Append(intValue.ToStringInvariant());                                      }                                      else                                      {                                          // two octal digits                                          sb.Append((intValue / 8).ToStringInvariant());                                          sb.Append((intValue % 8).ToStringInvariant());                                      }                                        startOfStretch = ndx + 1;                                  }                              }                                break;                      }
Magic Number,Spike.Build.Minifiers,JsConstantWrapper,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsConstantWrapper.cs,EscapeString,The following statement contains a magic number: switch (c)                      {                          // explicit escape sequences                          // if this is for a string parameter to a RegExp object' then we want to use                          // explicit hex-values' not the escape sequences                          case '\b':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x08" : @"\b"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\t':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x09" : @"\t"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\n':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0a" : @"\n"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\v':                              if (!useW3Strict)                              {                                  goto default;                              }                                AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0b" : @"\v"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\f':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0c" : @"\f"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\r':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0d" : @"\r"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\\':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' @"\\"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\'':                          case '"':                              // whichever character we're using as the delimiter' we need                              // to escape inside the string                              if (delimiter == c)                              {                                  AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' "\\"' ref sb);                                  sb.Append(c);                                  startOfStretch = ndx + 1;                              }                                // otherwise' we're going to output the character as-is' so just keep going                              break;                            case '\x2028':                          case '\x2029':                              // issue #14398 - unescaped' these characters (Unicode LineSeparator and ParagraphSeparator)                              // would introduce a line-break in the string.  they ALWAYS need to be escaped'                               // no matter what output encoding we may use.                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' @"\u"' ref sb);                              sb.Append("{0:x}".FormatInvariant((int)c));                              startOfStretch = ndx + 1;                              break;                            default:                              if (' ' <= c && c <= 0x7e)                              {                                  // regular ascii character                                  break;                              }                                if (c < ' ')                              {                                  // ECMA strict mode can't use octal' either                                  if (isRegularExpression || useStrict)                                  {                                      // for regular expression strings' \1 through \9 are always backreferences'                                       // and \10 through \40 are backreferences if they correspond to existing                                       // backreference groups. So we can't use octal for the characters with values                                      // between 0 and 31. encode with a hexadecimal escape sequence                                      AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' "\\x{0:x2}".FormatInvariant((int)c)' ref sb);                                      startOfStretch = ndx + 1;                                  }                                  else                                  {                                      // we're not a regular expression string. And character with a value between                                       // 0 and 31 can be represented in octal with two to three characters (\0 - \37)'                                      // whereas it would always take four characters to do it in hex: \x00 - \x1f.                                      // so let's go with octal since we aren't in strict mode                                      AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' "\\"' ref sb);                                      int intValue = (int)c;                                      if (intValue < 8)                                      {                                          // single octal digit                                          sb.Append(intValue.ToStringInvariant());                                      }                                      else                                      {                                          // two octal digits                                          sb.Append((intValue / 8).ToStringInvariant());                                          sb.Append((intValue % 8).ToStringInvariant());                                      }                                        startOfStretch = ndx + 1;                                  }                              }                                break;                      }
Magic Number,Spike.Build.Minifiers,JsConstantWrapper,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsConstantWrapper.cs,ToNumber,The following statement contains a magic number: switch(PrimitiveType)              {                  case JsPrimitiveType.Number:                      // pass-through the double as-is                      return (double)Value;                    case JsPrimitiveType.Null:                      // converting null to a number returns +0                      return 0;                    case JsPrimitiveType.Boolean:                      // converting boolean to number: true is 1' false is +0                      return (bool)Value ? 1 : 0;                    case JsPrimitiveType.Other:                      // don't convert others to numbers                      throw new InvalidCastException("Cannot convert 'other' primitives to number");                    default:                      // otherwise this must be a string                      try                      {                          string stringValue = Value.ToString();                          if (stringValue == null || string.IsNullOrEmpty(stringValue.Trim()))                          {                              // empty string or string of nothing but whitespace returns +0                              return 0;                          }                            // see if this is a hex number representation                          Match match;                          if (MayHaveIssues)                          {                              throw new InvalidCastException("cross-browser conversion issues");                          }                          else if ((match = s_hexNumberFormat.Match(stringValue)).Success)                          {                              // if we matched a sign' then we are in a cross-browser gray area.                              // the ECMA spec says that isn't allowed. IE and Safari correctly return NaN.                              // But Firefox' Opera' and Chrome will apply the sign to the parsed hex value.                              if (!string.IsNullOrEmpty(match.Result("${sign}")))                              {                                  throw new InvalidCastException("Cross-browser error converting signed hex string to number");                              }                                // parse the hexadecimal digits portion                              // can't use NumberStyles.HexNumber in double.Parse' so we need to do the conversion manually                              double doubleValue = 0;                              string hexRep = match.Result("${hex}");                                // loop from the start of the string to the end' converting the hex digits to a binary                              // value. As soon as we hit an overflow condition' we can bail.                              for (int ndx = 0; ndx < hexRep.Length && !double.IsInfinity(doubleValue); ++ndx)                              {                                  // we already know from the regular expression match that the hex rep is ONLY                                  // 0-9' a-f or A-F' so we don't need to test for outside those ranges.                                  char ch = hexRep[ndx];                                  doubleValue = (doubleValue * 16) + (ch <= '9' ? ch & 0xf : (ch & 0xf) + 9);                              }                              return doubleValue;                          }                          else                          {                              // not a hex number -- try doing a regular decimal float conversion                              return double.Parse(stringValue' NumberStyles.Float' CultureInfo.InvariantCulture);                          }                      }                      catch (FormatException)                      {                          // string isn't a number' return NaN                          return double.NaN;                      }                      catch (OverflowException)                      {                          // if the string starts with optional white-space followed by a minus sign'                          // then it's a negative-infinity overflow. Otherwise it's a positive infinity overflow.                          Regex negativeSign = new Regex(@"^\s*-");                          return (negativeSign.IsMatch(Value.ToString()))                              ? double.NegativeInfinity                              : double.PositiveInfinity;                      }              }
Magic Number,Spike.Build.Minifiers,JsConstantWrapper,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsConstantWrapper.cs,ToNumber,The following statement contains a magic number: switch(PrimitiveType)              {                  case JsPrimitiveType.Number:                      // pass-through the double as-is                      return (double)Value;                    case JsPrimitiveType.Null:                      // converting null to a number returns +0                      return 0;                    case JsPrimitiveType.Boolean:                      // converting boolean to number: true is 1' false is +0                      return (bool)Value ? 1 : 0;                    case JsPrimitiveType.Other:                      // don't convert others to numbers                      throw new InvalidCastException("Cannot convert 'other' primitives to number");                    default:                      // otherwise this must be a string                      try                      {                          string stringValue = Value.ToString();                          if (stringValue == null || string.IsNullOrEmpty(stringValue.Trim()))                          {                              // empty string or string of nothing but whitespace returns +0                              return 0;                          }                            // see if this is a hex number representation                          Match match;                          if (MayHaveIssues)                          {                              throw new InvalidCastException("cross-browser conversion issues");                          }                          else if ((match = s_hexNumberFormat.Match(stringValue)).Success)                          {                              // if we matched a sign' then we are in a cross-browser gray area.                              // the ECMA spec says that isn't allowed. IE and Safari correctly return NaN.                              // But Firefox' Opera' and Chrome will apply the sign to the parsed hex value.                              if (!string.IsNullOrEmpty(match.Result("${sign}")))                              {                                  throw new InvalidCastException("Cross-browser error converting signed hex string to number");                              }                                // parse the hexadecimal digits portion                              // can't use NumberStyles.HexNumber in double.Parse' so we need to do the conversion manually                              double doubleValue = 0;                              string hexRep = match.Result("${hex}");                                // loop from the start of the string to the end' converting the hex digits to a binary                              // value. As soon as we hit an overflow condition' we can bail.                              for (int ndx = 0; ndx < hexRep.Length && !double.IsInfinity(doubleValue); ++ndx)                              {                                  // we already know from the regular expression match that the hex rep is ONLY                                  // 0-9' a-f or A-F' so we don't need to test for outside those ranges.                                  char ch = hexRep[ndx];                                  doubleValue = (doubleValue * 16) + (ch <= '9' ? ch & 0xf : (ch & 0xf) + 9);                              }                              return doubleValue;                          }                          else                          {                              // not a hex number -- try doing a regular decimal float conversion                              return double.Parse(stringValue' NumberStyles.Float' CultureInfo.InvariantCulture);                          }                      }                      catch (FormatException)                      {                          // string isn't a number' return NaN                          return double.NaN;                      }                      catch (OverflowException)                      {                          // if the string starts with optional white-space followed by a minus sign'                          // then it's a negative-infinity overflow. Otherwise it's a positive infinity overflow.                          Regex negativeSign = new Regex(@"^\s*-");                          return (negativeSign.IsMatch(Value.ToString()))                              ? double.NegativeInfinity                              : double.PositiveInfinity;                      }              }
Magic Number,Spike.Build.Minifiers,JsDirectivePrologue,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsDirectivePrologue.cs,JsDirectivePrologue,The following statement contains a magic number: UseStrict = string.CompareOrdinal(Context.Code' 1' "use strict"' 0' 10) == 0;
Magic Number,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Visit,The following statement contains a magic number: combinedJoin.Length + 2 < node.ToCode().Length
Magic Number,Spike.Build.Minifiers,JsException,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsException.cs,GetSeverity,The following statement contains a magic number: switch (errorCode)              {                  case JsError.AmbiguousCatchVar:                  case JsError.AmbiguousNamedFunctionExpression:                  case JsError.NumericOverflow:                  case JsError.StrictComparisonIsAlwaysTrueOrFalse:                      return 1;                    case JsError.ArrayLiteralTrailingComma:                  case JsError.DuplicateCatch:                  case JsError.DuplicateConstantDeclaration:                  case JsError.DuplicateLexicalDeclaration:                  case JsError.KeywordUsedAsIdentifier:                  case JsError.MisplacedFunctionDeclaration:                  case JsError.ObjectLiteralKeyword:                      return 2;                    case JsError.ArgumentNotReferenced:                  case JsError.DuplicateName:                  case JsError.FunctionNotReferenced:                  case JsError.UndeclaredFunction:                  case JsError.UndeclaredVariable:                  case JsError.VariableDefinedNotReferenced:                      return 3;                    case JsError.StatementBlockExpected:                  case JsError.SuspectAssignment:                  case JsError.SuspectSemicolon:                  case JsError.SuspectEquality:                  case JsError.WithNotRecommended:                  case JsError.ObjectConstructorTakesNoArguments:                  case JsError.NumericMaximum:                  case JsError.NumericMinimum:                  case JsError.OctalLiteralsDeprecated:                  case JsError.FunctionNameMustBeIdentifier:                  case JsError.SemicolonInsertion:                      return 4;                    default:                      // all others                      return 0;              }
Magic Number,Spike.Build.Minifiers,JsException,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsException.cs,GetSeverity,The following statement contains a magic number: switch (errorCode)              {                  case JsError.AmbiguousCatchVar:                  case JsError.AmbiguousNamedFunctionExpression:                  case JsError.NumericOverflow:                  case JsError.StrictComparisonIsAlwaysTrueOrFalse:                      return 1;                    case JsError.ArrayLiteralTrailingComma:                  case JsError.DuplicateCatch:                  case JsError.DuplicateConstantDeclaration:                  case JsError.DuplicateLexicalDeclaration:                  case JsError.KeywordUsedAsIdentifier:                  case JsError.MisplacedFunctionDeclaration:                  case JsError.ObjectLiteralKeyword:                      return 2;                    case JsError.ArgumentNotReferenced:                  case JsError.DuplicateName:                  case JsError.FunctionNotReferenced:                  case JsError.UndeclaredFunction:                  case JsError.UndeclaredVariable:                  case JsError.VariableDefinedNotReferenced:                      return 3;                    case JsError.StatementBlockExpected:                  case JsError.SuspectAssignment:                  case JsError.SuspectSemicolon:                  case JsError.SuspectEquality:                  case JsError.WithNotRecommended:                  case JsError.ObjectConstructorTakesNoArguments:                  case JsError.NumericMaximum:                  case JsError.NumericMinimum:                  case JsError.OctalLiteralsDeprecated:                  case JsError.FunctionNameMustBeIdentifier:                  case JsError.SemicolonInsertion:                      return 4;                    default:                      // all others                      return 0;              }
Magic Number,Spike.Build.Minifiers,JsException,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsException.cs,GetSeverity,The following statement contains a magic number: switch (errorCode)              {                  case JsError.AmbiguousCatchVar:                  case JsError.AmbiguousNamedFunctionExpression:                  case JsError.NumericOverflow:                  case JsError.StrictComparisonIsAlwaysTrueOrFalse:                      return 1;                    case JsError.ArrayLiteralTrailingComma:                  case JsError.DuplicateCatch:                  case JsError.DuplicateConstantDeclaration:                  case JsError.DuplicateLexicalDeclaration:                  case JsError.KeywordUsedAsIdentifier:                  case JsError.MisplacedFunctionDeclaration:                  case JsError.ObjectLiteralKeyword:                      return 2;                    case JsError.ArgumentNotReferenced:                  case JsError.DuplicateName:                  case JsError.FunctionNotReferenced:                  case JsError.UndeclaredFunction:                  case JsError.UndeclaredVariable:                  case JsError.VariableDefinedNotReferenced:                      return 3;                    case JsError.StatementBlockExpected:                  case JsError.SuspectAssignment:                  case JsError.SuspectSemicolon:                  case JsError.SuspectEquality:                  case JsError.WithNotRecommended:                  case JsError.ObjectConstructorTakesNoArguments:                  case JsError.NumericMaximum:                  case JsError.NumericMinimum:                  case JsError.OctalLiteralsDeprecated:                  case JsError.FunctionNameMustBeIdentifier:                  case JsError.SemicolonInsertion:                      return 4;                    default:                      // all others                      return 0;              }
Magic Number,Spike.Build.Minifiers,JsKeyword,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsKeyword.cs,InitKeywords,The following statement contains a magic number: JsKeyword[] keywords = new JsKeyword[26];
Magic Number,Spike.Build.Minifiers,JsLogicalNot,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsLogicalNot.cs,MeasureBinaryOperator,The following statement contains a magic number: switch (node.OperatorToken)              {                  case JsToken.Equal:                  case JsToken.NotEqual:                  case JsToken.StrictEqual:                  case JsToken.StrictNotEqual:                      // these operators can be turned into a logical not without any                      // delta in code size. == becomes !=' etc.                      break;                    case JsToken.LessThan:                  case JsToken.GreaterThan:                  // these operators would add another character when turnbed into a not.                  // for example' < becomes >=' etc                  //++m_delta;                  //break;                    case JsToken.LessThanEqual:                  case JsToken.GreaterThanEqual:                  // these operators would subtract another character when turnbed into a not.                  // for example' <= becomes >' etc                  //--m_delta;                  //break;                    case JsToken.Assign:                  case JsToken.PlusAssign:                  case JsToken.MinusAssign:                  case JsToken.MultiplyAssign:                  case JsToken.DivideAssign:                  case JsToken.ModuloAssign:                  case JsToken.BitwiseAndAssign:                  case JsToken.BitwiseOrAssign:                  case JsToken.BitwiseXorAssign:                  case JsToken.LeftShiftAssign:                  case JsToken.RightShiftAssign:                  case JsToken.UnsignedRightShiftAssign:                  case JsToken.BitwiseAnd:                  case JsToken.BitwiseOr:                  case JsToken.BitwiseXor:                  case JsToken.Divide:                  case JsToken.Multiply:                  case JsToken.Modulo:                  case JsToken.Minus:                  case JsToken.Plus:                  case JsToken.LeftShift:                  case JsToken.RightShift:                  case JsToken.UnsignedRightShift:                  case JsToken.In:                  case JsToken.InstanceOf:                      // these operators have no logical not' which means we need to wrap them in                      // a unary logical-not operator. And since they have a lower precedence than                      // the unary logical-not' they'll have to be wrapped in parens. So that means                      // logical-not'ing these guys adds three characters                      m_delta += 3;                      break;                    case JsToken.Comma:                      // to logical-not a comma-operator' we just need to logical-not the                      // right-hand side                      node.Operand2.Accept(this);                      break;                    case JsToken.LogicalAnd:                  case JsToken.LogicalOr:                      if (node.Parent is JsBlock || (node.Parent is JsCommaOperator && node.Parent.Parent is JsBlock))                      {                          // if the parent is a block' then this is a simple expression statement:                          // expr1 || expr2; or expr1 && expr2; If so' then the result isn't                          // used anywhere and we're just using the || or && operator as a                          // shorter if-statement. So we don't need to negate the right-hand                          // side' just the left-hand side.                          if (node.Operand1 != null)                          {                              node.Operand1.Accept(this);                          }                      }                      else                      {                          // the logical-not of a logical-and or logical-or operation is the                           // other operation against the not of each operand. Since the opposite                          // operator is the same length as this operator' then we just need                          // to recurse both operands to find the true delta.                          if (node.Operand1 != null)                          {                              node.Operand1.Accept(this);                          }                            if (node.Operand2 != null)                          {                              node.Operand2.Accept(this);                          }                      }                      break;              }
Magic Number,Spike.Build.Minifiers,JsLogicalNot,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsLogicalNot.cs,Visit,The following statement contains a magic number: m_delta += (costNottingBoth > 3) ? 3 : costNottingBoth;
Magic Number,Spike.Build.Minifiers,JsLogicalNot,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsLogicalNot.cs,Visit,The following statement contains a magic number: m_delta += (costNottingBoth > 3) ? 3 : costNottingBoth;
Magic Number,Spike.Build.Minifiers,JsLogicalNot,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsLogicalNot.cs,Visit,The following statement contains a magic number: m_delta -= 2;
Magic Number,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,SetLastCharState,The following statement contains a magic number: m_lastCountOdd = (text.Length % 2 == 1) ^ m_lastCountOdd;
Magic Number,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,WriteToStream,The following statement contains a magic number: return 6;
Magic Number,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,NormalOrHexIfSmaller,The following statement contains a magic number: int maxValue = normal.Length - 2;
Magic Number,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,NormalOrHexIfSmaller,The following statement contains a magic number: int digit = (int)(doubleValue % 16);
Magic Number,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,NormalOrHexIfSmaller,The following statement contains a magic number: charArray[--position] = (char)((digit < 10 ? '0' : 'a' - 10) + digit);
Magic Number,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,NormalOrHexIfSmaller,The following statement contains a magic number: charArray[--position] = (char)((digit < 10 ? '0' : 'a' - 10) + digit);
Magic Number,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,NormalOrHexIfSmaller,The following statement contains a magic number: doubleValue = Math.Floor(doubleValue / 16);
Magic Number,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,GetSeverityString,The following statement contains a magic number: switch (severity)              {                  case 0:                      return JScript.Severity0;                    case 1:                      return JScript.Severity1;                    case 2:                      return JScript.Severity2;                    case 3:                      return JScript.Severity3;                    case 4:                      return JScript.Severity4;                    default:                      return JScript.SeverityUnknown.FormatInvariant(severity);              }
Magic Number,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,GetSeverityString,The following statement contains a magic number: switch (severity)              {                  case 0:                      return JScript.Severity0;                    case 1:                      return JScript.Severity1;                    case 2:                      return JScript.Severity2;                    case 3:                      return JScript.Severity3;                    case 4:                      return JScript.Severity4;                    default:                      return JScript.SeverityUnknown.FormatInvariant(severity);              }
Magic Number,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,GetSeverityString,The following statement contains a magic number: switch (severity)              {                  case 0:                      return JScript.Severity0;                    case 1:                      return JScript.Severity1;                    case 2:                      return JScript.Severity2;                    case 3:                      return JScript.Severity3;                    case 4:                      return JScript.Severity4;                    default:                      return JScript.SeverityUnknown.FormatInvariant(severity);              }
Magic Number,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,JsParser,The following statement contains a magic number: m_severity = 5;
Magic Number,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,JsParser,The following statement contains a magic number: m_blockType = new List<BlockType>(16);
Magic Number,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,Parse,The following statement contains a magic number: var timePoints = m_timingPoints = new long[9];
Magic Number,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseFunction,The following statement contains a magic number: m_blockType = new List<BlockType>(16);
Magic Number,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseLeftHandSideExpression,The following statement contains a magic number: newContexts = new List<JsContext>(4);
Magic Number,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ConvertNumericLiteralToDouble,The following statement contains a magic number: str.Length == 2
Magic Number,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ConvertNumericLiteralToDouble,The following statement contains a magic number: doubleValue = (double)System.Convert.ToInt64(str' 16);
Magic Number,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,GetNextToken,The following statement contains a magic number: m_breakRecursion++ > 10
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,JsScanner,The following statement contains a magic number: m_identifier = new StringBuilder(128);
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,JsScanner,The following statement contains a magic number: m_identifier = new StringBuilder(128);
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanNextToken,The following statement contains a magic number: switch (c)              {                  case '\n':                  case '\r':                      token = ScanLineTerminator(c);                      break;                    case '\t':                  case '\v':                  case '\f':                  case ' ':                      // we are asking for raw tokens' and this is the start of a stretch of whitespace.                      // advance to the end of the whitespace' and return that as the token                      token = JsToken.WhiteSpace;                      while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                      {                          ++m_currentPosition;                      }                        break;                    case '!':                      token = JsToken.LogicalNot;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.NotEqual;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictNotEqual;                          }                      }                        break;                    case '"':                  case '\'':                      token = JsToken.StringLiteral;                      ScanString(c);                      break;                    case '$':                  case '_':                      ScanIdentifier();                      token = JsToken.Identifier;                      break;                    case '%':                      token = JsToken.Modulo;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.ModuloAssign;                      }                        break;                    case '&':                      token = JsToken.BitwiseAnd;                      c = GetChar(m_currentPosition);                      if ('&' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalAnd;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseAndAssign;                      }                        break;                    case '(':                      token = JsToken.LeftParenthesis;                      break;                    case ')':                      token = JsToken.RightParenthesis;                      break;                    case '*':                      token = JsToken.Multiply;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.MultiplyAssign;                      }                        break;                    case '+':                      token = JsToken.Plus;                      c = GetChar(m_currentPosition);                      if ('+' == c)                      {                          m_currentPosition++;                          token = JsToken.Increment;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.PlusAssign;                      }                        break;                    case ''':                      token = JsToken.Comma;                      break;                    case '-':                      token = JsToken.Minus;                      c = GetChar(m_currentPosition);                      if ('-' == c)                      {                          m_currentPosition++;                          token = JsToken.Decrement;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.MinusAssign;                      }                        break;                    case '.':                      token = JsToken.AccessField;                      c = GetChar(m_currentPosition);                      if (JsScanner.IsDigit(c))                      {                          token = ScanNumber('.');                      }                        break;                    case '/':                      token = JsToken.Divide;                      c = GetChar(m_currentPosition);                      switch (c)                      {                          case '/':                              token = JsToken.SingleLineComment;                              m_inSingleLineComment = true;                              c = GetChar(++m_currentPosition);                                // see if there is a THIRD slash character                              if (c == '/')                              {                                  // advance past the slash and see if we have one of our special preprocessing directives                                  ++m_currentPosition;                                  if (GetChar(m_currentPosition) == '#')                                  {                                      // scan preprocessing directives                                      token = JsToken.PreprocessorDirective;                                        if (!ScanPreprocessingDirective())                                      {                                          // if it returns false' we don't want to skip the rest of                                          // the comment line; just exit                                          break;                                      }                                  }                              }                              else if (c == '@' && !IgnoreConditionalCompilation)                              {                                  // we got //@                                  // if we have not turned on conditional-compilation yet' then check to see if that's                                  // what we're trying to do now.                                  // we are currently on the @ -- start peeking from there                                  if (m_conditionalCompilationOn                                      || CheckSubstring(m_currentPosition + 1' "cc_on"))                                  {                                      // if the NEXT character is not an identifier character' then we need to skip                                      // the @ character -- otherwise leave it there                                      if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                      {                                          ++m_currentPosition;                                      }                                        // we are now in a conditional comment                                      m_inConditionalComment = true;                                      token = JsToken.ConditionalCommentStart;                                      break;                                  }                              }                                SkipSingleLineComment();                                // if we're still in a multiple-line comment' then we must've been in                              // a multi-line CONDITIONAL comment' in which case this normal one-line comment                              // won't turn off conditional comments just because we hit the end of line.                              if (!m_inMultipleLineComment && m_inConditionalComment)                              {                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                              }                                break;                            case '*':                              m_inMultipleLineComment = true;                              if (GetChar(++m_currentPosition) == '@' && !IgnoreConditionalCompilation)                              {                                  // we have /*@                                  // if we have not turned on conditional-compilation yet' then let's peek to see if the next                                  // few characters are cc_on -- if so' turn it on.                                  if (!m_conditionalCompilationOn)                                  {                                      // we are currently on the @ -- start peeking from there                                      if (!CheckSubstring(m_currentPosition + 1' "cc_on"))                                      {                                          // we aren't turning on conditional comments. We need to ignore this comment                                          // as just another multi-line comment                                          SkipMultilineComment();                                          token = JsToken.MultipleLineComment;                                          break;                                      }                                  }                                    // if the NEXT character is not an identifier character' then we need to skip                                  // the @ character -- otherwise leave it there                                  if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                  {                                      ++m_currentPosition;                                  }                                    // we are now in a conditional comment                                  m_inConditionalComment = true;                                  token = JsToken.ConditionalCommentStart;                                  break;                              }                                SkipMultilineComment();                              token = JsToken.MultipleLineComment;                              break;                            default:                              // if we were passed the hint that we prefer regular expressions                              // over divide operators' then try parsing one now.                              if (scanForRegularExpressionLiterals)                              {                                  // we think this is probably a regular expression.                                  // if it is...                                  if (ScanRegExp() != null)                                  {                                      // also scan the flags (if any)                                      ScanRegExpFlags();                                      token = JsToken.RegularExpression;                                  }                                  else if (c == '=')                                  {                                      m_currentPosition++;                                      token = JsToken.DivideAssign;                                  }                              }                              else if (c == '=')                              {                                  m_currentPosition++;                                  token = JsToken.DivideAssign;                              }                              break;                      }                        break;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      token = ScanNumber(c);                      break;                    case ':':                      token = JsToken.Colon;                      break;                    case ';':                      token = JsToken.Semicolon;                      break;                    case '<':                      if (AllowEmbeddedAspNetBlocks &&                          '%' == GetChar(m_currentPosition))                      {                          token = ScanAspNetBlock();                      }                      else                      {                          token = JsToken.LessThan;                          if ('<' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.LeftShift;                          }                            if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              if (token == JsToken.LessThan)                              {                                  token = JsToken.LessThanEqual;                              }                              else                              {                                  token = JsToken.LeftShiftAssign;                              }                          }                      }                        break;                    case '=':                      token = JsToken.Assign;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.Equal;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictEqual;                          }                      }                        break;                    case '>':                      token = JsToken.GreaterThan;                      if ('>' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.RightShift;                          if ('>' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.UnsignedRightShift;                          }                      }                        if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = token == JsToken.GreaterThan ? JsToken.GreaterThanEqual                              : token == JsToken.RightShift ? JsToken.RightShiftAssign                              : token == JsToken.UnsignedRightShift ? JsToken.UnsignedRightShiftAssign                              : JsToken.Error;                      }                        break;                    case '?':                      token = JsToken.ConditionalIf;                      break;                    case '@':                      if (IgnoreConditionalCompilation)                      {                          // if the switch to ignore conditional compilation is on' then we don't know                          // anything about conditional-compilation statements' and the @-sign character                          // is illegal at this spot.                          token = IllegalCharacter();                          break;                      }                        // see if the @-sign is immediately followed by an identifier. If it is'                      // we'll see which one so we can tell if it's a conditional-compilation statement                      // need to make sure the context INCLUDES the @ sign                      int startPosition = m_currentPosition;                      m_currentToken.StartPosition = startPosition - 1;                      m_currentToken.StartLineNumber = m_currentLine;                      m_currentToken.StartLinePosition = m_startLinePosition;                      ScanIdentifier();                      switch (m_currentPosition - startPosition)                      {                          case 0:                              // look for '@*/'.                              if ('*' == GetChar(m_currentPosition) && '/' == GetChar(++m_currentPosition))                              {                                  m_currentPosition++;                                  m_inMultipleLineComment = false;                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                                  break;                              }                                // otherwise we just have a @ sitting by itself!                              // throw an error and loop back to the next token.                              token = IllegalCharacter();                              break;                            case 2:                              if (CheckSubstring(startPosition' "if"))                              {                                  token = JsToken.ConditionalCompilationIf;                                    // increment the if-level                                  ++m_conditionalCompilationIfLevel;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @if statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 3:                              if (CheckSubstring(startPosition' "set"))                              {                                  token = JsToken.ConditionalCompilationSet;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @set statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "end"))                              {                                  token = JsToken.ConditionalCompilationEnd;                                  if (m_conditionalCompilationIfLevel > 0)                                  {                                      // down one more @if level                                      m_conditionalCompilationIfLevel--;                                  }                                  else                                  {                                      // not corresponding @if -- invalid @end statement                                      HandleError(JsError.CCInvalidEnd);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 4:                              if (CheckSubstring(startPosition' "else"))                              {                                  token = JsToken.ConditionalCompilationElse;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElse);                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "elif"))                              {                                  token = JsToken.ConditionalCompilationElseIf;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElseIf);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 5:                              if (CheckSubstring(startPosition' "cc_on"))                              {                                  // turn it on and return the @cc_on token                                  m_conditionalCompilationOn = true;                                  token = JsToken.ConditionalCompilationOn;                                  break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            default:                              // we have @[id]' where [id] is a valid identifier.                              // if we haven't explicitly turned on conditional compilation'                              // we'll keep processing' but we need to fire an error to indicate                              // that the code should turn it on first.                              if (!m_conditionalCompilationOn)                              {                                  HandleError(JsError.CCOff);                              }                                token = JsToken.ConditionalCompilationVariable;                              break;                      }                        break;                    case 'A':                  case 'B':                  case 'C':                  case 'D':                  case 'E':                  case 'F':                  case 'G':                  case 'H':                  case 'I':                  case 'J':                  case 'K':                  case 'L':                  case 'M':                  case 'N':                  case 'O':                  case 'P':                  case 'Q':                  case 'R':                  case 'S':                  case 'T':                  case 'U':                  case 'V':                  case 'W':                  case 'X':                  case 'Y':                  case 'Z':                      token = JsToken.Identifier;                      ScanIdentifier();                      break;                    case '[':                      token = JsToken.LeftBracket;                      break;                    case '\\':                      // try decoding a unicode escape sequence. We read the backslash and                      // now the "current" character is the "u"                      if (PeekUnicodeEscape(m_currentPosition' ref c))                      {                          // advance past the escape characters                          m_currentPosition += 5;                            // valid unicode escape sequence                          if (IsValidIdentifierStart(c))                          {                              // use the unescaped character as the first character of the                              // decoded identifier' and current character is now the last position                              // on the builder                              m_identifier.Append(c);                              m_lastPosOnBuilder = m_currentPosition;                                // scan the rest of the identifier                              ScanIdentifier();                                // because it STARTS with an escaped character it cannot be a keyword                              token = JsToken.Identifier;                              break;                          }                      }                      else                      {                          // not a valid unicode escape sequence                          // see if the next character is a valid identifier character                          if (IsValidIdentifierStart(GetChar(m_currentPosition)))                          {                              // we're going to just assume this is an escaped identifier character                              // because some older browsers allow things like \foo ("foo") and                               // \while to be an identifer "while" and not the reserved word                              ScanIdentifier();                              token = JsToken.Identifier;                              break;                          }                      }                        HandleError(JsError.IllegalChar);                      break;                    case ']':                      token = JsToken.RightBracket;                      break;                    case '^':                      token = JsToken.BitwiseXor;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.BitwiseXorAssign;                      }                        break;                    case '#':                  case '`':                      token = IllegalCharacter();                      break;                    case 'a':                  case 'b':                  case 'c':                  case 'd':                  case 'e':                  case 'f':                  case 'g':                  case 'h':                  case 'i':                  case 'j':                  case 'k':                  case 'l':                  case 'm':                  case 'n':                  case 'o':                  case 'p':                  case 'q':                  case 'r':                  case 's':                  case 't':                  case 'u':                  case 'v':                  case 'w':                  case 'x':                  case 'y':                  case 'z':                      JsKeyword keyword = s_Keywords[c - 'a'];                      if (null != keyword)                      {                          token = ScanKeyword(keyword);                      }                      else                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      break;                    case '{':                      token = JsToken.LeftCurly;                      break;                    case '|':                      token = JsToken.BitwiseOr;                      c = GetChar(m_currentPosition);                      if ('|' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalOr;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseOrAssign;                      }                        break;                    case '}':                      token = JsToken.RightCurly;                      break;                    case '~':                      token = JsToken.BitwiseNot;                      break;                    default:                      if (c == '\0')                      {                          if (IsEndOfFile)                          {                              token = JsToken.EndOfFile;                              m_currentPosition--;                              if (m_conditionalCompilationIfLevel > 0)                              {                                  m_currentToken.EndLineNumber = m_currentLine;                                  m_currentToken.EndLinePosition = m_startLinePosition;                                  m_currentToken.EndPosition = m_currentPosition;                                  HandleError(JsError.NoCCEnd);                              }                          }                          else                          {                              token = IllegalCharacter();                          }                      }                      else if (c == '\u2028' || c == '\u2029')                      {                          // more line terminator                          token = ScanLineTerminator(c);                      }                      else if (IsValidIdentifierStart(c))                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      else if (IsBlankSpace(c))                      {                          // we are asking for raw tokens' and this is the start of a stretch of whitespace.                          // advance to the end of the whitespace' and return that as the token                          while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                          {                              ++m_currentPosition;                          }                          token = JsToken.WhiteSpace;                      }                      else                      {                          token = IllegalCharacter();                      }                        break;              }
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanNextToken,The following statement contains a magic number: switch (c)              {                  case '\n':                  case '\r':                      token = ScanLineTerminator(c);                      break;                    case '\t':                  case '\v':                  case '\f':                  case ' ':                      // we are asking for raw tokens' and this is the start of a stretch of whitespace.                      // advance to the end of the whitespace' and return that as the token                      token = JsToken.WhiteSpace;                      while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                      {                          ++m_currentPosition;                      }                        break;                    case '!':                      token = JsToken.LogicalNot;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.NotEqual;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictNotEqual;                          }                      }                        break;                    case '"':                  case '\'':                      token = JsToken.StringLiteral;                      ScanString(c);                      break;                    case '$':                  case '_':                      ScanIdentifier();                      token = JsToken.Identifier;                      break;                    case '%':                      token = JsToken.Modulo;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.ModuloAssign;                      }                        break;                    case '&':                      token = JsToken.BitwiseAnd;                      c = GetChar(m_currentPosition);                      if ('&' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalAnd;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseAndAssign;                      }                        break;                    case '(':                      token = JsToken.LeftParenthesis;                      break;                    case ')':                      token = JsToken.RightParenthesis;                      break;                    case '*':                      token = JsToken.Multiply;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.MultiplyAssign;                      }                        break;                    case '+':                      token = JsToken.Plus;                      c = GetChar(m_currentPosition);                      if ('+' == c)                      {                          m_currentPosition++;                          token = JsToken.Increment;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.PlusAssign;                      }                        break;                    case ''':                      token = JsToken.Comma;                      break;                    case '-':                      token = JsToken.Minus;                      c = GetChar(m_currentPosition);                      if ('-' == c)                      {                          m_currentPosition++;                          token = JsToken.Decrement;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.MinusAssign;                      }                        break;                    case '.':                      token = JsToken.AccessField;                      c = GetChar(m_currentPosition);                      if (JsScanner.IsDigit(c))                      {                          token = ScanNumber('.');                      }                        break;                    case '/':                      token = JsToken.Divide;                      c = GetChar(m_currentPosition);                      switch (c)                      {                          case '/':                              token = JsToken.SingleLineComment;                              m_inSingleLineComment = true;                              c = GetChar(++m_currentPosition);                                // see if there is a THIRD slash character                              if (c == '/')                              {                                  // advance past the slash and see if we have one of our special preprocessing directives                                  ++m_currentPosition;                                  if (GetChar(m_currentPosition) == '#')                                  {                                      // scan preprocessing directives                                      token = JsToken.PreprocessorDirective;                                        if (!ScanPreprocessingDirective())                                      {                                          // if it returns false' we don't want to skip the rest of                                          // the comment line; just exit                                          break;                                      }                                  }                              }                              else if (c == '@' && !IgnoreConditionalCompilation)                              {                                  // we got //@                                  // if we have not turned on conditional-compilation yet' then check to see if that's                                  // what we're trying to do now.                                  // we are currently on the @ -- start peeking from there                                  if (m_conditionalCompilationOn                                      || CheckSubstring(m_currentPosition + 1' "cc_on"))                                  {                                      // if the NEXT character is not an identifier character' then we need to skip                                      // the @ character -- otherwise leave it there                                      if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                      {                                          ++m_currentPosition;                                      }                                        // we are now in a conditional comment                                      m_inConditionalComment = true;                                      token = JsToken.ConditionalCommentStart;                                      break;                                  }                              }                                SkipSingleLineComment();                                // if we're still in a multiple-line comment' then we must've been in                              // a multi-line CONDITIONAL comment' in which case this normal one-line comment                              // won't turn off conditional comments just because we hit the end of line.                              if (!m_inMultipleLineComment && m_inConditionalComment)                              {                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                              }                                break;                            case '*':                              m_inMultipleLineComment = true;                              if (GetChar(++m_currentPosition) == '@' && !IgnoreConditionalCompilation)                              {                                  // we have /*@                                  // if we have not turned on conditional-compilation yet' then let's peek to see if the next                                  // few characters are cc_on -- if so' turn it on.                                  if (!m_conditionalCompilationOn)                                  {                                      // we are currently on the @ -- start peeking from there                                      if (!CheckSubstring(m_currentPosition + 1' "cc_on"))                                      {                                          // we aren't turning on conditional comments. We need to ignore this comment                                          // as just another multi-line comment                                          SkipMultilineComment();                                          token = JsToken.MultipleLineComment;                                          break;                                      }                                  }                                    // if the NEXT character is not an identifier character' then we need to skip                                  // the @ character -- otherwise leave it there                                  if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                  {                                      ++m_currentPosition;                                  }                                    // we are now in a conditional comment                                  m_inConditionalComment = true;                                  token = JsToken.ConditionalCommentStart;                                  break;                              }                                SkipMultilineComment();                              token = JsToken.MultipleLineComment;                              break;                            default:                              // if we were passed the hint that we prefer regular expressions                              // over divide operators' then try parsing one now.                              if (scanForRegularExpressionLiterals)                              {                                  // we think this is probably a regular expression.                                  // if it is...                                  if (ScanRegExp() != null)                                  {                                      // also scan the flags (if any)                                      ScanRegExpFlags();                                      token = JsToken.RegularExpression;                                  }                                  else if (c == '=')                                  {                                      m_currentPosition++;                                      token = JsToken.DivideAssign;                                  }                              }                              else if (c == '=')                              {                                  m_currentPosition++;                                  token = JsToken.DivideAssign;                              }                              break;                      }                        break;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      token = ScanNumber(c);                      break;                    case ':':                      token = JsToken.Colon;                      break;                    case ';':                      token = JsToken.Semicolon;                      break;                    case '<':                      if (AllowEmbeddedAspNetBlocks &&                          '%' == GetChar(m_currentPosition))                      {                          token = ScanAspNetBlock();                      }                      else                      {                          token = JsToken.LessThan;                          if ('<' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.LeftShift;                          }                            if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              if (token == JsToken.LessThan)                              {                                  token = JsToken.LessThanEqual;                              }                              else                              {                                  token = JsToken.LeftShiftAssign;                              }                          }                      }                        break;                    case '=':                      token = JsToken.Assign;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.Equal;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictEqual;                          }                      }                        break;                    case '>':                      token = JsToken.GreaterThan;                      if ('>' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.RightShift;                          if ('>' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.UnsignedRightShift;                          }                      }                        if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = token == JsToken.GreaterThan ? JsToken.GreaterThanEqual                              : token == JsToken.RightShift ? JsToken.RightShiftAssign                              : token == JsToken.UnsignedRightShift ? JsToken.UnsignedRightShiftAssign                              : JsToken.Error;                      }                        break;                    case '?':                      token = JsToken.ConditionalIf;                      break;                    case '@':                      if (IgnoreConditionalCompilation)                      {                          // if the switch to ignore conditional compilation is on' then we don't know                          // anything about conditional-compilation statements' and the @-sign character                          // is illegal at this spot.                          token = IllegalCharacter();                          break;                      }                        // see if the @-sign is immediately followed by an identifier. If it is'                      // we'll see which one so we can tell if it's a conditional-compilation statement                      // need to make sure the context INCLUDES the @ sign                      int startPosition = m_currentPosition;                      m_currentToken.StartPosition = startPosition - 1;                      m_currentToken.StartLineNumber = m_currentLine;                      m_currentToken.StartLinePosition = m_startLinePosition;                      ScanIdentifier();                      switch (m_currentPosition - startPosition)                      {                          case 0:                              // look for '@*/'.                              if ('*' == GetChar(m_currentPosition) && '/' == GetChar(++m_currentPosition))                              {                                  m_currentPosition++;                                  m_inMultipleLineComment = false;                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                                  break;                              }                                // otherwise we just have a @ sitting by itself!                              // throw an error and loop back to the next token.                              token = IllegalCharacter();                              break;                            case 2:                              if (CheckSubstring(startPosition' "if"))                              {                                  token = JsToken.ConditionalCompilationIf;                                    // increment the if-level                                  ++m_conditionalCompilationIfLevel;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @if statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 3:                              if (CheckSubstring(startPosition' "set"))                              {                                  token = JsToken.ConditionalCompilationSet;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @set statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "end"))                              {                                  token = JsToken.ConditionalCompilationEnd;                                  if (m_conditionalCompilationIfLevel > 0)                                  {                                      // down one more @if level                                      m_conditionalCompilationIfLevel--;                                  }                                  else                                  {                                      // not corresponding @if -- invalid @end statement                                      HandleError(JsError.CCInvalidEnd);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 4:                              if (CheckSubstring(startPosition' "else"))                              {                                  token = JsToken.ConditionalCompilationElse;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElse);                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "elif"))                              {                                  token = JsToken.ConditionalCompilationElseIf;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElseIf);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 5:                              if (CheckSubstring(startPosition' "cc_on"))                              {                                  // turn it on and return the @cc_on token                                  m_conditionalCompilationOn = true;                                  token = JsToken.ConditionalCompilationOn;                                  break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            default:                              // we have @[id]' where [id] is a valid identifier.                              // if we haven't explicitly turned on conditional compilation'                              // we'll keep processing' but we need to fire an error to indicate                              // that the code should turn it on first.                              if (!m_conditionalCompilationOn)                              {                                  HandleError(JsError.CCOff);                              }                                token = JsToken.ConditionalCompilationVariable;                              break;                      }                        break;                    case 'A':                  case 'B':                  case 'C':                  case 'D':                  case 'E':                  case 'F':                  case 'G':                  case 'H':                  case 'I':                  case 'J':                  case 'K':                  case 'L':                  case 'M':                  case 'N':                  case 'O':                  case 'P':                  case 'Q':                  case 'R':                  case 'S':                  case 'T':                  case 'U':                  case 'V':                  case 'W':                  case 'X':                  case 'Y':                  case 'Z':                      token = JsToken.Identifier;                      ScanIdentifier();                      break;                    case '[':                      token = JsToken.LeftBracket;                      break;                    case '\\':                      // try decoding a unicode escape sequence. We read the backslash and                      // now the "current" character is the "u"                      if (PeekUnicodeEscape(m_currentPosition' ref c))                      {                          // advance past the escape characters                          m_currentPosition += 5;                            // valid unicode escape sequence                          if (IsValidIdentifierStart(c))                          {                              // use the unescaped character as the first character of the                              // decoded identifier' and current character is now the last position                              // on the builder                              m_identifier.Append(c);                              m_lastPosOnBuilder = m_currentPosition;                                // scan the rest of the identifier                              ScanIdentifier();                                // because it STARTS with an escaped character it cannot be a keyword                              token = JsToken.Identifier;                              break;                          }                      }                      else                      {                          // not a valid unicode escape sequence                          // see if the next character is a valid identifier character                          if (IsValidIdentifierStart(GetChar(m_currentPosition)))                          {                              // we're going to just assume this is an escaped identifier character                              // because some older browsers allow things like \foo ("foo") and                               // \while to be an identifer "while" and not the reserved word                              ScanIdentifier();                              token = JsToken.Identifier;                              break;                          }                      }                        HandleError(JsError.IllegalChar);                      break;                    case ']':                      token = JsToken.RightBracket;                      break;                    case '^':                      token = JsToken.BitwiseXor;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.BitwiseXorAssign;                      }                        break;                    case '#':                  case '`':                      token = IllegalCharacter();                      break;                    case 'a':                  case 'b':                  case 'c':                  case 'd':                  case 'e':                  case 'f':                  case 'g':                  case 'h':                  case 'i':                  case 'j':                  case 'k':                  case 'l':                  case 'm':                  case 'n':                  case 'o':                  case 'p':                  case 'q':                  case 'r':                  case 's':                  case 't':                  case 'u':                  case 'v':                  case 'w':                  case 'x':                  case 'y':                  case 'z':                      JsKeyword keyword = s_Keywords[c - 'a'];                      if (null != keyword)                      {                          token = ScanKeyword(keyword);                      }                      else                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      break;                    case '{':                      token = JsToken.LeftCurly;                      break;                    case '|':                      token = JsToken.BitwiseOr;                      c = GetChar(m_currentPosition);                      if ('|' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalOr;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseOrAssign;                      }                        break;                    case '}':                      token = JsToken.RightCurly;                      break;                    case '~':                      token = JsToken.BitwiseNot;                      break;                    default:                      if (c == '\0')                      {                          if (IsEndOfFile)                          {                              token = JsToken.EndOfFile;                              m_currentPosition--;                              if (m_conditionalCompilationIfLevel > 0)                              {                                  m_currentToken.EndLineNumber = m_currentLine;                                  m_currentToken.EndLinePosition = m_startLinePosition;                                  m_currentToken.EndPosition = m_currentPosition;                                  HandleError(JsError.NoCCEnd);                              }                          }                          else                          {                              token = IllegalCharacter();                          }                      }                      else if (c == '\u2028' || c == '\u2029')                      {                          // more line terminator                          token = ScanLineTerminator(c);                      }                      else if (IsValidIdentifierStart(c))                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      else if (IsBlankSpace(c))                      {                          // we are asking for raw tokens' and this is the start of a stretch of whitespace.                          // advance to the end of the whitespace' and return that as the token                          while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                          {                              ++m_currentPosition;                          }                          token = JsToken.WhiteSpace;                      }                      else                      {                          token = IllegalCharacter();                      }                        break;              }
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanNextToken,The following statement contains a magic number: switch (c)              {                  case '\n':                  case '\r':                      token = ScanLineTerminator(c);                      break;                    case '\t':                  case '\v':                  case '\f':                  case ' ':                      // we are asking for raw tokens' and this is the start of a stretch of whitespace.                      // advance to the end of the whitespace' and return that as the token                      token = JsToken.WhiteSpace;                      while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                      {                          ++m_currentPosition;                      }                        break;                    case '!':                      token = JsToken.LogicalNot;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.NotEqual;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictNotEqual;                          }                      }                        break;                    case '"':                  case '\'':                      token = JsToken.StringLiteral;                      ScanString(c);                      break;                    case '$':                  case '_':                      ScanIdentifier();                      token = JsToken.Identifier;                      break;                    case '%':                      token = JsToken.Modulo;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.ModuloAssign;                      }                        break;                    case '&':                      token = JsToken.BitwiseAnd;                      c = GetChar(m_currentPosition);                      if ('&' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalAnd;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseAndAssign;                      }                        break;                    case '(':                      token = JsToken.LeftParenthesis;                      break;                    case ')':                      token = JsToken.RightParenthesis;                      break;                    case '*':                      token = JsToken.Multiply;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.MultiplyAssign;                      }                        break;                    case '+':                      token = JsToken.Plus;                      c = GetChar(m_currentPosition);                      if ('+' == c)                      {                          m_currentPosition++;                          token = JsToken.Increment;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.PlusAssign;                      }                        break;                    case ''':                      token = JsToken.Comma;                      break;                    case '-':                      token = JsToken.Minus;                      c = GetChar(m_currentPosition);                      if ('-' == c)                      {                          m_currentPosition++;                          token = JsToken.Decrement;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.MinusAssign;                      }                        break;                    case '.':                      token = JsToken.AccessField;                      c = GetChar(m_currentPosition);                      if (JsScanner.IsDigit(c))                      {                          token = ScanNumber('.');                      }                        break;                    case '/':                      token = JsToken.Divide;                      c = GetChar(m_currentPosition);                      switch (c)                      {                          case '/':                              token = JsToken.SingleLineComment;                              m_inSingleLineComment = true;                              c = GetChar(++m_currentPosition);                                // see if there is a THIRD slash character                              if (c == '/')                              {                                  // advance past the slash and see if we have one of our special preprocessing directives                                  ++m_currentPosition;                                  if (GetChar(m_currentPosition) == '#')                                  {                                      // scan preprocessing directives                                      token = JsToken.PreprocessorDirective;                                        if (!ScanPreprocessingDirective())                                      {                                          // if it returns false' we don't want to skip the rest of                                          // the comment line; just exit                                          break;                                      }                                  }                              }                              else if (c == '@' && !IgnoreConditionalCompilation)                              {                                  // we got //@                                  // if we have not turned on conditional-compilation yet' then check to see if that's                                  // what we're trying to do now.                                  // we are currently on the @ -- start peeking from there                                  if (m_conditionalCompilationOn                                      || CheckSubstring(m_currentPosition + 1' "cc_on"))                                  {                                      // if the NEXT character is not an identifier character' then we need to skip                                      // the @ character -- otherwise leave it there                                      if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                      {                                          ++m_currentPosition;                                      }                                        // we are now in a conditional comment                                      m_inConditionalComment = true;                                      token = JsToken.ConditionalCommentStart;                                      break;                                  }                              }                                SkipSingleLineComment();                                // if we're still in a multiple-line comment' then we must've been in                              // a multi-line CONDITIONAL comment' in which case this normal one-line comment                              // won't turn off conditional comments just because we hit the end of line.                              if (!m_inMultipleLineComment && m_inConditionalComment)                              {                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                              }                                break;                            case '*':                              m_inMultipleLineComment = true;                              if (GetChar(++m_currentPosition) == '@' && !IgnoreConditionalCompilation)                              {                                  // we have /*@                                  // if we have not turned on conditional-compilation yet' then let's peek to see if the next                                  // few characters are cc_on -- if so' turn it on.                                  if (!m_conditionalCompilationOn)                                  {                                      // we are currently on the @ -- start peeking from there                                      if (!CheckSubstring(m_currentPosition + 1' "cc_on"))                                      {                                          // we aren't turning on conditional comments. We need to ignore this comment                                          // as just another multi-line comment                                          SkipMultilineComment();                                          token = JsToken.MultipleLineComment;                                          break;                                      }                                  }                                    // if the NEXT character is not an identifier character' then we need to skip                                  // the @ character -- otherwise leave it there                                  if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                  {                                      ++m_currentPosition;                                  }                                    // we are now in a conditional comment                                  m_inConditionalComment = true;                                  token = JsToken.ConditionalCommentStart;                                  break;                              }                                SkipMultilineComment();                              token = JsToken.MultipleLineComment;                              break;                            default:                              // if we were passed the hint that we prefer regular expressions                              // over divide operators' then try parsing one now.                              if (scanForRegularExpressionLiterals)                              {                                  // we think this is probably a regular expression.                                  // if it is...                                  if (ScanRegExp() != null)                                  {                                      // also scan the flags (if any)                                      ScanRegExpFlags();                                      token = JsToken.RegularExpression;                                  }                                  else if (c == '=')                                  {                                      m_currentPosition++;                                      token = JsToken.DivideAssign;                                  }                              }                              else if (c == '=')                              {                                  m_currentPosition++;                                  token = JsToken.DivideAssign;                              }                              break;                      }                        break;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      token = ScanNumber(c);                      break;                    case ':':                      token = JsToken.Colon;                      break;                    case ';':                      token = JsToken.Semicolon;                      break;                    case '<':                      if (AllowEmbeddedAspNetBlocks &&                          '%' == GetChar(m_currentPosition))                      {                          token = ScanAspNetBlock();                      }                      else                      {                          token = JsToken.LessThan;                          if ('<' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.LeftShift;                          }                            if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              if (token == JsToken.LessThan)                              {                                  token = JsToken.LessThanEqual;                              }                              else                              {                                  token = JsToken.LeftShiftAssign;                              }                          }                      }                        break;                    case '=':                      token = JsToken.Assign;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.Equal;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictEqual;                          }                      }                        break;                    case '>':                      token = JsToken.GreaterThan;                      if ('>' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.RightShift;                          if ('>' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.UnsignedRightShift;                          }                      }                        if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = token == JsToken.GreaterThan ? JsToken.GreaterThanEqual                              : token == JsToken.RightShift ? JsToken.RightShiftAssign                              : token == JsToken.UnsignedRightShift ? JsToken.UnsignedRightShiftAssign                              : JsToken.Error;                      }                        break;                    case '?':                      token = JsToken.ConditionalIf;                      break;                    case '@':                      if (IgnoreConditionalCompilation)                      {                          // if the switch to ignore conditional compilation is on' then we don't know                          // anything about conditional-compilation statements' and the @-sign character                          // is illegal at this spot.                          token = IllegalCharacter();                          break;                      }                        // see if the @-sign is immediately followed by an identifier. If it is'                      // we'll see which one so we can tell if it's a conditional-compilation statement                      // need to make sure the context INCLUDES the @ sign                      int startPosition = m_currentPosition;                      m_currentToken.StartPosition = startPosition - 1;                      m_currentToken.StartLineNumber = m_currentLine;                      m_currentToken.StartLinePosition = m_startLinePosition;                      ScanIdentifier();                      switch (m_currentPosition - startPosition)                      {                          case 0:                              // look for '@*/'.                              if ('*' == GetChar(m_currentPosition) && '/' == GetChar(++m_currentPosition))                              {                                  m_currentPosition++;                                  m_inMultipleLineComment = false;                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                                  break;                              }                                // otherwise we just have a @ sitting by itself!                              // throw an error and loop back to the next token.                              token = IllegalCharacter();                              break;                            case 2:                              if (CheckSubstring(startPosition' "if"))                              {                                  token = JsToken.ConditionalCompilationIf;                                    // increment the if-level                                  ++m_conditionalCompilationIfLevel;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @if statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 3:                              if (CheckSubstring(startPosition' "set"))                              {                                  token = JsToken.ConditionalCompilationSet;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @set statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "end"))                              {                                  token = JsToken.ConditionalCompilationEnd;                                  if (m_conditionalCompilationIfLevel > 0)                                  {                                      // down one more @if level                                      m_conditionalCompilationIfLevel--;                                  }                                  else                                  {                                      // not corresponding @if -- invalid @end statement                                      HandleError(JsError.CCInvalidEnd);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 4:                              if (CheckSubstring(startPosition' "else"))                              {                                  token = JsToken.ConditionalCompilationElse;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElse);                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "elif"))                              {                                  token = JsToken.ConditionalCompilationElseIf;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElseIf);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 5:                              if (CheckSubstring(startPosition' "cc_on"))                              {                                  // turn it on and return the @cc_on token                                  m_conditionalCompilationOn = true;                                  token = JsToken.ConditionalCompilationOn;                                  break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            default:                              // we have @[id]' where [id] is a valid identifier.                              // if we haven't explicitly turned on conditional compilation'                              // we'll keep processing' but we need to fire an error to indicate                              // that the code should turn it on first.                              if (!m_conditionalCompilationOn)                              {                                  HandleError(JsError.CCOff);                              }                                token = JsToken.ConditionalCompilationVariable;                              break;                      }                        break;                    case 'A':                  case 'B':                  case 'C':                  case 'D':                  case 'E':                  case 'F':                  case 'G':                  case 'H':                  case 'I':                  case 'J':                  case 'K':                  case 'L':                  case 'M':                  case 'N':                  case 'O':                  case 'P':                  case 'Q':                  case 'R':                  case 'S':                  case 'T':                  case 'U':                  case 'V':                  case 'W':                  case 'X':                  case 'Y':                  case 'Z':                      token = JsToken.Identifier;                      ScanIdentifier();                      break;                    case '[':                      token = JsToken.LeftBracket;                      break;                    case '\\':                      // try decoding a unicode escape sequence. We read the backslash and                      // now the "current" character is the "u"                      if (PeekUnicodeEscape(m_currentPosition' ref c))                      {                          // advance past the escape characters                          m_currentPosition += 5;                            // valid unicode escape sequence                          if (IsValidIdentifierStart(c))                          {                              // use the unescaped character as the first character of the                              // decoded identifier' and current character is now the last position                              // on the builder                              m_identifier.Append(c);                              m_lastPosOnBuilder = m_currentPosition;                                // scan the rest of the identifier                              ScanIdentifier();                                // because it STARTS with an escaped character it cannot be a keyword                              token = JsToken.Identifier;                              break;                          }                      }                      else                      {                          // not a valid unicode escape sequence                          // see if the next character is a valid identifier character                          if (IsValidIdentifierStart(GetChar(m_currentPosition)))                          {                              // we're going to just assume this is an escaped identifier character                              // because some older browsers allow things like \foo ("foo") and                               // \while to be an identifer "while" and not the reserved word                              ScanIdentifier();                              token = JsToken.Identifier;                              break;                          }                      }                        HandleError(JsError.IllegalChar);                      break;                    case ']':                      token = JsToken.RightBracket;                      break;                    case '^':                      token = JsToken.BitwiseXor;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.BitwiseXorAssign;                      }                        break;                    case '#':                  case '`':                      token = IllegalCharacter();                      break;                    case 'a':                  case 'b':                  case 'c':                  case 'd':                  case 'e':                  case 'f':                  case 'g':                  case 'h':                  case 'i':                  case 'j':                  case 'k':                  case 'l':                  case 'm':                  case 'n':                  case 'o':                  case 'p':                  case 'q':                  case 'r':                  case 's':                  case 't':                  case 'u':                  case 'v':                  case 'w':                  case 'x':                  case 'y':                  case 'z':                      JsKeyword keyword = s_Keywords[c - 'a'];                      if (null != keyword)                      {                          token = ScanKeyword(keyword);                      }                      else                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      break;                    case '{':                      token = JsToken.LeftCurly;                      break;                    case '|':                      token = JsToken.BitwiseOr;                      c = GetChar(m_currentPosition);                      if ('|' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalOr;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseOrAssign;                      }                        break;                    case '}':                      token = JsToken.RightCurly;                      break;                    case '~':                      token = JsToken.BitwiseNot;                      break;                    default:                      if (c == '\0')                      {                          if (IsEndOfFile)                          {                              token = JsToken.EndOfFile;                              m_currentPosition--;                              if (m_conditionalCompilationIfLevel > 0)                              {                                  m_currentToken.EndLineNumber = m_currentLine;                                  m_currentToken.EndLinePosition = m_startLinePosition;                                  m_currentToken.EndPosition = m_currentPosition;                                  HandleError(JsError.NoCCEnd);                              }                          }                          else                          {                              token = IllegalCharacter();                          }                      }                      else if (c == '\u2028' || c == '\u2029')                      {                          // more line terminator                          token = ScanLineTerminator(c);                      }                      else if (IsValidIdentifierStart(c))                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      else if (IsBlankSpace(c))                      {                          // we are asking for raw tokens' and this is the start of a stretch of whitespace.                          // advance to the end of the whitespace' and return that as the token                          while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                          {                              ++m_currentPosition;                          }                          token = JsToken.WhiteSpace;                      }                      else                      {                          token = IllegalCharacter();                      }                        break;              }
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanNextToken,The following statement contains a magic number: switch (c)              {                  case '\n':                  case '\r':                      token = ScanLineTerminator(c);                      break;                    case '\t':                  case '\v':                  case '\f':                  case ' ':                      // we are asking for raw tokens' and this is the start of a stretch of whitespace.                      // advance to the end of the whitespace' and return that as the token                      token = JsToken.WhiteSpace;                      while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                      {                          ++m_currentPosition;                      }                        break;                    case '!':                      token = JsToken.LogicalNot;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.NotEqual;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictNotEqual;                          }                      }                        break;                    case '"':                  case '\'':                      token = JsToken.StringLiteral;                      ScanString(c);                      break;                    case '$':                  case '_':                      ScanIdentifier();                      token = JsToken.Identifier;                      break;                    case '%':                      token = JsToken.Modulo;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.ModuloAssign;                      }                        break;                    case '&':                      token = JsToken.BitwiseAnd;                      c = GetChar(m_currentPosition);                      if ('&' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalAnd;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseAndAssign;                      }                        break;                    case '(':                      token = JsToken.LeftParenthesis;                      break;                    case ')':                      token = JsToken.RightParenthesis;                      break;                    case '*':                      token = JsToken.Multiply;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.MultiplyAssign;                      }                        break;                    case '+':                      token = JsToken.Plus;                      c = GetChar(m_currentPosition);                      if ('+' == c)                      {                          m_currentPosition++;                          token = JsToken.Increment;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.PlusAssign;                      }                        break;                    case ''':                      token = JsToken.Comma;                      break;                    case '-':                      token = JsToken.Minus;                      c = GetChar(m_currentPosition);                      if ('-' == c)                      {                          m_currentPosition++;                          token = JsToken.Decrement;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.MinusAssign;                      }                        break;                    case '.':                      token = JsToken.AccessField;                      c = GetChar(m_currentPosition);                      if (JsScanner.IsDigit(c))                      {                          token = ScanNumber('.');                      }                        break;                    case '/':                      token = JsToken.Divide;                      c = GetChar(m_currentPosition);                      switch (c)                      {                          case '/':                              token = JsToken.SingleLineComment;                              m_inSingleLineComment = true;                              c = GetChar(++m_currentPosition);                                // see if there is a THIRD slash character                              if (c == '/')                              {                                  // advance past the slash and see if we have one of our special preprocessing directives                                  ++m_currentPosition;                                  if (GetChar(m_currentPosition) == '#')                                  {                                      // scan preprocessing directives                                      token = JsToken.PreprocessorDirective;                                        if (!ScanPreprocessingDirective())                                      {                                          // if it returns false' we don't want to skip the rest of                                          // the comment line; just exit                                          break;                                      }                                  }                              }                              else if (c == '@' && !IgnoreConditionalCompilation)                              {                                  // we got //@                                  // if we have not turned on conditional-compilation yet' then check to see if that's                                  // what we're trying to do now.                                  // we are currently on the @ -- start peeking from there                                  if (m_conditionalCompilationOn                                      || CheckSubstring(m_currentPosition + 1' "cc_on"))                                  {                                      // if the NEXT character is not an identifier character' then we need to skip                                      // the @ character -- otherwise leave it there                                      if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                      {                                          ++m_currentPosition;                                      }                                        // we are now in a conditional comment                                      m_inConditionalComment = true;                                      token = JsToken.ConditionalCommentStart;                                      break;                                  }                              }                                SkipSingleLineComment();                                // if we're still in a multiple-line comment' then we must've been in                              // a multi-line CONDITIONAL comment' in which case this normal one-line comment                              // won't turn off conditional comments just because we hit the end of line.                              if (!m_inMultipleLineComment && m_inConditionalComment)                              {                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                              }                                break;                            case '*':                              m_inMultipleLineComment = true;                              if (GetChar(++m_currentPosition) == '@' && !IgnoreConditionalCompilation)                              {                                  // we have /*@                                  // if we have not turned on conditional-compilation yet' then let's peek to see if the next                                  // few characters are cc_on -- if so' turn it on.                                  if (!m_conditionalCompilationOn)                                  {                                      // we are currently on the @ -- start peeking from there                                      if (!CheckSubstring(m_currentPosition + 1' "cc_on"))                                      {                                          // we aren't turning on conditional comments. We need to ignore this comment                                          // as just another multi-line comment                                          SkipMultilineComment();                                          token = JsToken.MultipleLineComment;                                          break;                                      }                                  }                                    // if the NEXT character is not an identifier character' then we need to skip                                  // the @ character -- otherwise leave it there                                  if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                  {                                      ++m_currentPosition;                                  }                                    // we are now in a conditional comment                                  m_inConditionalComment = true;                                  token = JsToken.ConditionalCommentStart;                                  break;                              }                                SkipMultilineComment();                              token = JsToken.MultipleLineComment;                              break;                            default:                              // if we were passed the hint that we prefer regular expressions                              // over divide operators' then try parsing one now.                              if (scanForRegularExpressionLiterals)                              {                                  // we think this is probably a regular expression.                                  // if it is...                                  if (ScanRegExp() != null)                                  {                                      // also scan the flags (if any)                                      ScanRegExpFlags();                                      token = JsToken.RegularExpression;                                  }                                  else if (c == '=')                                  {                                      m_currentPosition++;                                      token = JsToken.DivideAssign;                                  }                              }                              else if (c == '=')                              {                                  m_currentPosition++;                                  token = JsToken.DivideAssign;                              }                              break;                      }                        break;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      token = ScanNumber(c);                      break;                    case ':':                      token = JsToken.Colon;                      break;                    case ';':                      token = JsToken.Semicolon;                      break;                    case '<':                      if (AllowEmbeddedAspNetBlocks &&                          '%' == GetChar(m_currentPosition))                      {                          token = ScanAspNetBlock();                      }                      else                      {                          token = JsToken.LessThan;                          if ('<' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.LeftShift;                          }                            if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              if (token == JsToken.LessThan)                              {                                  token = JsToken.LessThanEqual;                              }                              else                              {                                  token = JsToken.LeftShiftAssign;                              }                          }                      }                        break;                    case '=':                      token = JsToken.Assign;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.Equal;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictEqual;                          }                      }                        break;                    case '>':                      token = JsToken.GreaterThan;                      if ('>' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.RightShift;                          if ('>' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.UnsignedRightShift;                          }                      }                        if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = token == JsToken.GreaterThan ? JsToken.GreaterThanEqual                              : token == JsToken.RightShift ? JsToken.RightShiftAssign                              : token == JsToken.UnsignedRightShift ? JsToken.UnsignedRightShiftAssign                              : JsToken.Error;                      }                        break;                    case '?':                      token = JsToken.ConditionalIf;                      break;                    case '@':                      if (IgnoreConditionalCompilation)                      {                          // if the switch to ignore conditional compilation is on' then we don't know                          // anything about conditional-compilation statements' and the @-sign character                          // is illegal at this spot.                          token = IllegalCharacter();                          break;                      }                        // see if the @-sign is immediately followed by an identifier. If it is'                      // we'll see which one so we can tell if it's a conditional-compilation statement                      // need to make sure the context INCLUDES the @ sign                      int startPosition = m_currentPosition;                      m_currentToken.StartPosition = startPosition - 1;                      m_currentToken.StartLineNumber = m_currentLine;                      m_currentToken.StartLinePosition = m_startLinePosition;                      ScanIdentifier();                      switch (m_currentPosition - startPosition)                      {                          case 0:                              // look for '@*/'.                              if ('*' == GetChar(m_currentPosition) && '/' == GetChar(++m_currentPosition))                              {                                  m_currentPosition++;                                  m_inMultipleLineComment = false;                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                                  break;                              }                                // otherwise we just have a @ sitting by itself!                              // throw an error and loop back to the next token.                              token = IllegalCharacter();                              break;                            case 2:                              if (CheckSubstring(startPosition' "if"))                              {                                  token = JsToken.ConditionalCompilationIf;                                    // increment the if-level                                  ++m_conditionalCompilationIfLevel;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @if statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 3:                              if (CheckSubstring(startPosition' "set"))                              {                                  token = JsToken.ConditionalCompilationSet;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @set statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "end"))                              {                                  token = JsToken.ConditionalCompilationEnd;                                  if (m_conditionalCompilationIfLevel > 0)                                  {                                      // down one more @if level                                      m_conditionalCompilationIfLevel--;                                  }                                  else                                  {                                      // not corresponding @if -- invalid @end statement                                      HandleError(JsError.CCInvalidEnd);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 4:                              if (CheckSubstring(startPosition' "else"))                              {                                  token = JsToken.ConditionalCompilationElse;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElse);                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "elif"))                              {                                  token = JsToken.ConditionalCompilationElseIf;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElseIf);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 5:                              if (CheckSubstring(startPosition' "cc_on"))                              {                                  // turn it on and return the @cc_on token                                  m_conditionalCompilationOn = true;                                  token = JsToken.ConditionalCompilationOn;                                  break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            default:                              // we have @[id]' where [id] is a valid identifier.                              // if we haven't explicitly turned on conditional compilation'                              // we'll keep processing' but we need to fire an error to indicate                              // that the code should turn it on first.                              if (!m_conditionalCompilationOn)                              {                                  HandleError(JsError.CCOff);                              }                                token = JsToken.ConditionalCompilationVariable;                              break;                      }                        break;                    case 'A':                  case 'B':                  case 'C':                  case 'D':                  case 'E':                  case 'F':                  case 'G':                  case 'H':                  case 'I':                  case 'J':                  case 'K':                  case 'L':                  case 'M':                  case 'N':                  case 'O':                  case 'P':                  case 'Q':                  case 'R':                  case 'S':                  case 'T':                  case 'U':                  case 'V':                  case 'W':                  case 'X':                  case 'Y':                  case 'Z':                      token = JsToken.Identifier;                      ScanIdentifier();                      break;                    case '[':                      token = JsToken.LeftBracket;                      break;                    case '\\':                      // try decoding a unicode escape sequence. We read the backslash and                      // now the "current" character is the "u"                      if (PeekUnicodeEscape(m_currentPosition' ref c))                      {                          // advance past the escape characters                          m_currentPosition += 5;                            // valid unicode escape sequence                          if (IsValidIdentifierStart(c))                          {                              // use the unescaped character as the first character of the                              // decoded identifier' and current character is now the last position                              // on the builder                              m_identifier.Append(c);                              m_lastPosOnBuilder = m_currentPosition;                                // scan the rest of the identifier                              ScanIdentifier();                                // because it STARTS with an escaped character it cannot be a keyword                              token = JsToken.Identifier;                              break;                          }                      }                      else                      {                          // not a valid unicode escape sequence                          // see if the next character is a valid identifier character                          if (IsValidIdentifierStart(GetChar(m_currentPosition)))                          {                              // we're going to just assume this is an escaped identifier character                              // because some older browsers allow things like \foo ("foo") and                               // \while to be an identifer "while" and not the reserved word                              ScanIdentifier();                              token = JsToken.Identifier;                              break;                          }                      }                        HandleError(JsError.IllegalChar);                      break;                    case ']':                      token = JsToken.RightBracket;                      break;                    case '^':                      token = JsToken.BitwiseXor;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.BitwiseXorAssign;                      }                        break;                    case '#':                  case '`':                      token = IllegalCharacter();                      break;                    case 'a':                  case 'b':                  case 'c':                  case 'd':                  case 'e':                  case 'f':                  case 'g':                  case 'h':                  case 'i':                  case 'j':                  case 'k':                  case 'l':                  case 'm':                  case 'n':                  case 'o':                  case 'p':                  case 'q':                  case 'r':                  case 's':                  case 't':                  case 'u':                  case 'v':                  case 'w':                  case 'x':                  case 'y':                  case 'z':                      JsKeyword keyword = s_Keywords[c - 'a'];                      if (null != keyword)                      {                          token = ScanKeyword(keyword);                      }                      else                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      break;                    case '{':                      token = JsToken.LeftCurly;                      break;                    case '|':                      token = JsToken.BitwiseOr;                      c = GetChar(m_currentPosition);                      if ('|' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalOr;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseOrAssign;                      }                        break;                    case '}':                      token = JsToken.RightCurly;                      break;                    case '~':                      token = JsToken.BitwiseNot;                      break;                    default:                      if (c == '\0')                      {                          if (IsEndOfFile)                          {                              token = JsToken.EndOfFile;                              m_currentPosition--;                              if (m_conditionalCompilationIfLevel > 0)                              {                                  m_currentToken.EndLineNumber = m_currentLine;                                  m_currentToken.EndLinePosition = m_startLinePosition;                                  m_currentToken.EndPosition = m_currentPosition;                                  HandleError(JsError.NoCCEnd);                              }                          }                          else                          {                              token = IllegalCharacter();                          }                      }                      else if (c == '\u2028' || c == '\u2029')                      {                          // more line terminator                          token = ScanLineTerminator(c);                      }                      else if (IsValidIdentifierStart(c))                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      else if (IsBlankSpace(c))                      {                          // we are asking for raw tokens' and this is the start of a stretch of whitespace.                          // advance to the end of the whitespace' and return that as the token                          while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                          {                              ++m_currentPosition;                          }                          token = JsToken.WhiteSpace;                      }                      else                      {                          token = IllegalCharacter();                      }                        break;              }
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanNextToken,The following statement contains a magic number: switch (c)              {                  case '\n':                  case '\r':                      token = ScanLineTerminator(c);                      break;                    case '\t':                  case '\v':                  case '\f':                  case ' ':                      // we are asking for raw tokens' and this is the start of a stretch of whitespace.                      // advance to the end of the whitespace' and return that as the token                      token = JsToken.WhiteSpace;                      while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                      {                          ++m_currentPosition;                      }                        break;                    case '!':                      token = JsToken.LogicalNot;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.NotEqual;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictNotEqual;                          }                      }                        break;                    case '"':                  case '\'':                      token = JsToken.StringLiteral;                      ScanString(c);                      break;                    case '$':                  case '_':                      ScanIdentifier();                      token = JsToken.Identifier;                      break;                    case '%':                      token = JsToken.Modulo;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.ModuloAssign;                      }                        break;                    case '&':                      token = JsToken.BitwiseAnd;                      c = GetChar(m_currentPosition);                      if ('&' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalAnd;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseAndAssign;                      }                        break;                    case '(':                      token = JsToken.LeftParenthesis;                      break;                    case ')':                      token = JsToken.RightParenthesis;                      break;                    case '*':                      token = JsToken.Multiply;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.MultiplyAssign;                      }                        break;                    case '+':                      token = JsToken.Plus;                      c = GetChar(m_currentPosition);                      if ('+' == c)                      {                          m_currentPosition++;                          token = JsToken.Increment;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.PlusAssign;                      }                        break;                    case ''':                      token = JsToken.Comma;                      break;                    case '-':                      token = JsToken.Minus;                      c = GetChar(m_currentPosition);                      if ('-' == c)                      {                          m_currentPosition++;                          token = JsToken.Decrement;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.MinusAssign;                      }                        break;                    case '.':                      token = JsToken.AccessField;                      c = GetChar(m_currentPosition);                      if (JsScanner.IsDigit(c))                      {                          token = ScanNumber('.');                      }                        break;                    case '/':                      token = JsToken.Divide;                      c = GetChar(m_currentPosition);                      switch (c)                      {                          case '/':                              token = JsToken.SingleLineComment;                              m_inSingleLineComment = true;                              c = GetChar(++m_currentPosition);                                // see if there is a THIRD slash character                              if (c == '/')                              {                                  // advance past the slash and see if we have one of our special preprocessing directives                                  ++m_currentPosition;                                  if (GetChar(m_currentPosition) == '#')                                  {                                      // scan preprocessing directives                                      token = JsToken.PreprocessorDirective;                                        if (!ScanPreprocessingDirective())                                      {                                          // if it returns false' we don't want to skip the rest of                                          // the comment line; just exit                                          break;                                      }                                  }                              }                              else if (c == '@' && !IgnoreConditionalCompilation)                              {                                  // we got //@                                  // if we have not turned on conditional-compilation yet' then check to see if that's                                  // what we're trying to do now.                                  // we are currently on the @ -- start peeking from there                                  if (m_conditionalCompilationOn                                      || CheckSubstring(m_currentPosition + 1' "cc_on"))                                  {                                      // if the NEXT character is not an identifier character' then we need to skip                                      // the @ character -- otherwise leave it there                                      if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                      {                                          ++m_currentPosition;                                      }                                        // we are now in a conditional comment                                      m_inConditionalComment = true;                                      token = JsToken.ConditionalCommentStart;                                      break;                                  }                              }                                SkipSingleLineComment();                                // if we're still in a multiple-line comment' then we must've been in                              // a multi-line CONDITIONAL comment' in which case this normal one-line comment                              // won't turn off conditional comments just because we hit the end of line.                              if (!m_inMultipleLineComment && m_inConditionalComment)                              {                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                              }                                break;                            case '*':                              m_inMultipleLineComment = true;                              if (GetChar(++m_currentPosition) == '@' && !IgnoreConditionalCompilation)                              {                                  // we have /*@                                  // if we have not turned on conditional-compilation yet' then let's peek to see if the next                                  // few characters are cc_on -- if so' turn it on.                                  if (!m_conditionalCompilationOn)                                  {                                      // we are currently on the @ -- start peeking from there                                      if (!CheckSubstring(m_currentPosition + 1' "cc_on"))                                      {                                          // we aren't turning on conditional comments. We need to ignore this comment                                          // as just another multi-line comment                                          SkipMultilineComment();                                          token = JsToken.MultipleLineComment;                                          break;                                      }                                  }                                    // if the NEXT character is not an identifier character' then we need to skip                                  // the @ character -- otherwise leave it there                                  if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                  {                                      ++m_currentPosition;                                  }                                    // we are now in a conditional comment                                  m_inConditionalComment = true;                                  token = JsToken.ConditionalCommentStart;                                  break;                              }                                SkipMultilineComment();                              token = JsToken.MultipleLineComment;                              break;                            default:                              // if we were passed the hint that we prefer regular expressions                              // over divide operators' then try parsing one now.                              if (scanForRegularExpressionLiterals)                              {                                  // we think this is probably a regular expression.                                  // if it is...                                  if (ScanRegExp() != null)                                  {                                      // also scan the flags (if any)                                      ScanRegExpFlags();                                      token = JsToken.RegularExpression;                                  }                                  else if (c == '=')                                  {                                      m_currentPosition++;                                      token = JsToken.DivideAssign;                                  }                              }                              else if (c == '=')                              {                                  m_currentPosition++;                                  token = JsToken.DivideAssign;                              }                              break;                      }                        break;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      token = ScanNumber(c);                      break;                    case ':':                      token = JsToken.Colon;                      break;                    case ';':                      token = JsToken.Semicolon;                      break;                    case '<':                      if (AllowEmbeddedAspNetBlocks &&                          '%' == GetChar(m_currentPosition))                      {                          token = ScanAspNetBlock();                      }                      else                      {                          token = JsToken.LessThan;                          if ('<' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.LeftShift;                          }                            if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              if (token == JsToken.LessThan)                              {                                  token = JsToken.LessThanEqual;                              }                              else                              {                                  token = JsToken.LeftShiftAssign;                              }                          }                      }                        break;                    case '=':                      token = JsToken.Assign;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.Equal;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictEqual;                          }                      }                        break;                    case '>':                      token = JsToken.GreaterThan;                      if ('>' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.RightShift;                          if ('>' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.UnsignedRightShift;                          }                      }                        if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = token == JsToken.GreaterThan ? JsToken.GreaterThanEqual                              : token == JsToken.RightShift ? JsToken.RightShiftAssign                              : token == JsToken.UnsignedRightShift ? JsToken.UnsignedRightShiftAssign                              : JsToken.Error;                      }                        break;                    case '?':                      token = JsToken.ConditionalIf;                      break;                    case '@':                      if (IgnoreConditionalCompilation)                      {                          // if the switch to ignore conditional compilation is on' then we don't know                          // anything about conditional-compilation statements' and the @-sign character                          // is illegal at this spot.                          token = IllegalCharacter();                          break;                      }                        // see if the @-sign is immediately followed by an identifier. If it is'                      // we'll see which one so we can tell if it's a conditional-compilation statement                      // need to make sure the context INCLUDES the @ sign                      int startPosition = m_currentPosition;                      m_currentToken.StartPosition = startPosition - 1;                      m_currentToken.StartLineNumber = m_currentLine;                      m_currentToken.StartLinePosition = m_startLinePosition;                      ScanIdentifier();                      switch (m_currentPosition - startPosition)                      {                          case 0:                              // look for '@*/'.                              if ('*' == GetChar(m_currentPosition) && '/' == GetChar(++m_currentPosition))                              {                                  m_currentPosition++;                                  m_inMultipleLineComment = false;                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                                  break;                              }                                // otherwise we just have a @ sitting by itself!                              // throw an error and loop back to the next token.                              token = IllegalCharacter();                              break;                            case 2:                              if (CheckSubstring(startPosition' "if"))                              {                                  token = JsToken.ConditionalCompilationIf;                                    // increment the if-level                                  ++m_conditionalCompilationIfLevel;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @if statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 3:                              if (CheckSubstring(startPosition' "set"))                              {                                  token = JsToken.ConditionalCompilationSet;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @set statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "end"))                              {                                  token = JsToken.ConditionalCompilationEnd;                                  if (m_conditionalCompilationIfLevel > 0)                                  {                                      // down one more @if level                                      m_conditionalCompilationIfLevel--;                                  }                                  else                                  {                                      // not corresponding @if -- invalid @end statement                                      HandleError(JsError.CCInvalidEnd);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 4:                              if (CheckSubstring(startPosition' "else"))                              {                                  token = JsToken.ConditionalCompilationElse;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElse);                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "elif"))                              {                                  token = JsToken.ConditionalCompilationElseIf;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElseIf);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 5:                              if (CheckSubstring(startPosition' "cc_on"))                              {                                  // turn it on and return the @cc_on token                                  m_conditionalCompilationOn = true;                                  token = JsToken.ConditionalCompilationOn;                                  break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            default:                              // we have @[id]' where [id] is a valid identifier.                              // if we haven't explicitly turned on conditional compilation'                              // we'll keep processing' but we need to fire an error to indicate                              // that the code should turn it on first.                              if (!m_conditionalCompilationOn)                              {                                  HandleError(JsError.CCOff);                              }                                token = JsToken.ConditionalCompilationVariable;                              break;                      }                        break;                    case 'A':                  case 'B':                  case 'C':                  case 'D':                  case 'E':                  case 'F':                  case 'G':                  case 'H':                  case 'I':                  case 'J':                  case 'K':                  case 'L':                  case 'M':                  case 'N':                  case 'O':                  case 'P':                  case 'Q':                  case 'R':                  case 'S':                  case 'T':                  case 'U':                  case 'V':                  case 'W':                  case 'X':                  case 'Y':                  case 'Z':                      token = JsToken.Identifier;                      ScanIdentifier();                      break;                    case '[':                      token = JsToken.LeftBracket;                      break;                    case '\\':                      // try decoding a unicode escape sequence. We read the backslash and                      // now the "current" character is the "u"                      if (PeekUnicodeEscape(m_currentPosition' ref c))                      {                          // advance past the escape characters                          m_currentPosition += 5;                            // valid unicode escape sequence                          if (IsValidIdentifierStart(c))                          {                              // use the unescaped character as the first character of the                              // decoded identifier' and current character is now the last position                              // on the builder                              m_identifier.Append(c);                              m_lastPosOnBuilder = m_currentPosition;                                // scan the rest of the identifier                              ScanIdentifier();                                // because it STARTS with an escaped character it cannot be a keyword                              token = JsToken.Identifier;                              break;                          }                      }                      else                      {                          // not a valid unicode escape sequence                          // see if the next character is a valid identifier character                          if (IsValidIdentifierStart(GetChar(m_currentPosition)))                          {                              // we're going to just assume this is an escaped identifier character                              // because some older browsers allow things like \foo ("foo") and                               // \while to be an identifer "while" and not the reserved word                              ScanIdentifier();                              token = JsToken.Identifier;                              break;                          }                      }                        HandleError(JsError.IllegalChar);                      break;                    case ']':                      token = JsToken.RightBracket;                      break;                    case '^':                      token = JsToken.BitwiseXor;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.BitwiseXorAssign;                      }                        break;                    case '#':                  case '`':                      token = IllegalCharacter();                      break;                    case 'a':                  case 'b':                  case 'c':                  case 'd':                  case 'e':                  case 'f':                  case 'g':                  case 'h':                  case 'i':                  case 'j':                  case 'k':                  case 'l':                  case 'm':                  case 'n':                  case 'o':                  case 'p':                  case 'q':                  case 'r':                  case 's':                  case 't':                  case 'u':                  case 'v':                  case 'w':                  case 'x':                  case 'y':                  case 'z':                      JsKeyword keyword = s_Keywords[c - 'a'];                      if (null != keyword)                      {                          token = ScanKeyword(keyword);                      }                      else                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      break;                    case '{':                      token = JsToken.LeftCurly;                      break;                    case '|':                      token = JsToken.BitwiseOr;                      c = GetChar(m_currentPosition);                      if ('|' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalOr;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseOrAssign;                      }                        break;                    case '}':                      token = JsToken.RightCurly;                      break;                    case '~':                      token = JsToken.BitwiseNot;                      break;                    default:                      if (c == '\0')                      {                          if (IsEndOfFile)                          {                              token = JsToken.EndOfFile;                              m_currentPosition--;                              if (m_conditionalCompilationIfLevel > 0)                              {                                  m_currentToken.EndLineNumber = m_currentLine;                                  m_currentToken.EndLinePosition = m_startLinePosition;                                  m_currentToken.EndPosition = m_currentPosition;                                  HandleError(JsError.NoCCEnd);                              }                          }                          else                          {                              token = IllegalCharacter();                          }                      }                      else if (c == '\u2028' || c == '\u2029')                      {                          // more line terminator                          token = ScanLineTerminator(c);                      }                      else if (IsValidIdentifierStart(c))                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      else if (IsBlankSpace(c))                      {                          // we are asking for raw tokens' and this is the start of a stretch of whitespace.                          // advance to the end of the whitespace' and return that as the token                          while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                          {                              ++m_currentPosition;                          }                          token = JsToken.WhiteSpace;                      }                      else                      {                          token = IllegalCharacter();                      }                        break;              }
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanHexDigit,The following statement contains a magic number: esc = esc << 4 | (ch - '0');
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,IsBlankSpace,The following statement contains a magic number: switch (c)              {                  case '\u0009':                  case '\u000b':                  case '\u000c':                  case '\u0020':                  case '\u00a0':                  case '\ufeff': // BOM - byte order mark                      return true;                    default:                      return (c < 128) ? false : char.GetUnicodeCategory(c) == UnicodeCategory.SpaceSeparator;              }
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,IsValidIdentifierStart,The following statement contains a magic number: letter >= 128
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,IsValidIdentifierPart,The following statement contains a magic number: letter >= 128
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: ch = (char)(GetHexValue(str[2]) << 12 | GetHexValue(str[3]) << 8 | GetHexValue(str[4]) << 4 | GetHexValue(str[5]));
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: ch = (char)(GetHexValue(str[2]) << 12 | GetHexValue(str[3]) << 8 | GetHexValue(str[4]) << 4 | GetHexValue(str[5]));
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: ch = (char)(GetHexValue(str[2]) << 12 | GetHexValue(str[3]) << 8 | GetHexValue(str[4]) << 4 | GetHexValue(str[5]));
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: ch = (char)(GetHexValue(str[2]) << 12 | GetHexValue(str[3]) << 8 | GetHexValue(str[4]) << 4 | GetHexValue(str[5]));
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: ch = (char)(GetHexValue(str[2]) << 12 | GetHexValue(str[3]) << 8 | GetHexValue(str[4]) << 4 | GetHexValue(str[5]));
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: ch = (char)(GetHexValue(str[2]) << 12 | GetHexValue(str[3]) << 8 | GetHexValue(str[4]) << 4 | GetHexValue(str[5]));
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: ch = (char)(GetHexValue(str[2]) << 12 | GetHexValue(str[3]) << 8 | GetHexValue(str[4]) << 4 | GetHexValue(str[5]));
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: str[1] == 'u'                       && IsHexDigit(str[2])                      && IsHexDigit(str[3])                      && IsHexDigit(str[4])                      && IsHexDigit(str[5])
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: str[1] == 'u'                       && IsHexDigit(str[2])                      && IsHexDigit(str[3])                      && IsHexDigit(str[4])                      && IsHexDigit(str[5])
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: str[1] == 'u'                       && IsHexDigit(str[2])                      && IsHexDigit(str[3])                      && IsHexDigit(str[4])                      && IsHexDigit(str[5])
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: str[1] == 'u'                       && IsHexDigit(str[2])                      && IsHexDigit(str[3])                      && IsHexDigit(str[4])                      && IsHexDigit(str[5])
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: !string.IsNullOrEmpty(str) && ch == '\\' && str.Length >= 6
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: char h2 = GetChar(index + 2);
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: char h3 = GetChar(index + 3);
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: char h4 = GetChar(index + 4);
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: ch = (char)(GetHexValue(h1) << 12 | GetHexValue(h2) << 8 | GetHexValue(h3) << 4 | GetHexValue(h4));
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: ch = (char)(GetHexValue(h1) << 12 | GetHexValue(h2) << 8 | GetHexValue(h3) << 4 | GetHexValue(h4));
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: ch = (char)(GetHexValue(h1) << 12 | GetHexValue(h2) << 8 | GetHexValue(h3) << 4 | GetHexValue(h4));
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,IsIdentifierStartChar,The following statement contains a magic number: char h1 = GetChar(m_currentPosition + 2);
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,IsIdentifierStartChar,The following statement contains a magic number: char h2 = GetChar(m_currentPosition + 3);
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,IsIdentifierStartChar,The following statement contains a magic number: char h3 = GetChar(m_currentPosition + 4);
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,IsIdentifierStartChar,The following statement contains a magic number: char h4 = GetChar(m_currentPosition + 5);
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,IsIdentifierStartChar,The following statement contains a magic number: c = (char)(GetHexValue(h1) << 12 | GetHexValue(h2) << 8 | GetHexValue(h3) << 4 | GetHexValue(h4));
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,IsIdentifierStartChar,The following statement contains a magic number: c = (char)(GetHexValue(h1) << 12 | GetHexValue(h2) << 8 | GetHexValue(h3) << 4 | GetHexValue(h4));
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,IsIdentifierStartChar,The following statement contains a magic number: c = (char)(GetHexValue(h1) << 12 | GetHexValue(h2) << 8 | GetHexValue(h3) << 4 | GetHexValue(h4));
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,IsIdentifierStartChar,The following statement contains a magic number: m_currentPosition += 5;
Magic Number,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PPSkipToDirective,The following statement contains a magic number: switch (c)                  {                      // EOF                      case '\0':                          if (IsEndOfFile)                          {                              // adjust the scanner state                              m_currentPosition--;                              m_currentToken.EndPosition = m_currentPosition;                              m_currentToken.EndLineNumber = m_currentLine;                              m_currentToken.EndLinePosition = m_startLinePosition;                                // create a clone of the current token and set the ending to be the end of the                              // directive for which we're trying to find an end. Use THAT context for the                               // error context. Then throw an exception so we can bail.                              var contextError = m_currentToken.Clone();                              contextError.EndPosition = endPosition;                              contextError.EndLineNumber = endLineNum;                              contextError.EndLinePosition = endLinePos;                              contextError.HandleError(string.CompareOrdinal(endStrings[0]' "#ENDDEBUG") == 0                                   ? JsError.NoEndDebugDirective                                   : JsError.NoEndIfDirective);                              throw new EndOfStreamException();                          }                            break;                        // line terminator crap                      case '\r':                          if (GetChar(m_currentPosition) == '\n')                          {                              m_currentPosition++;                          }                            m_currentLine++;                          m_startLinePosition = m_currentPosition;                          break;                      case '\n':                          m_currentLine++;                          m_startLinePosition = m_currentPosition;                          break;                      case '\u2028':                          m_currentLine++;                          m_startLinePosition = m_currentPosition;                          break;                      case '\u2029':                          m_currentLine++;                          m_startLinePosition = m_currentPosition;                          break;                        // check for /// (and then followed by any one of the substrings passed to us)                      case '/':                          if (CheckSubstring(m_currentPosition' "//"))                          {                              // skip it                              m_currentPosition += 2;                                // check to see if this is the start of ANOTHER preprocessor construct. If it                              // is' then it's a NESTED statement and we'll need to recursively skip the                               // whole thing so everything stays on track                              if (CheckCaseInsensitiveSubstring("#IFDEF")                                  || CheckCaseInsensitiveSubstring("#IFNDEF")                                  || CheckCaseInsensitiveSubstring("#IF"))                              {                                  PPSkipToDirective("#ENDIF");                              }                              else                              {                                  // now check each of the ending strings that were passed to us to see if one of                                  // them is a match                                  for (var ndx = 0; ndx < endStrings.Length; ++ndx)                                  {                                      if (CheckCaseInsensitiveSubstring(endStrings[ndx]))                                      {                                          // found the ending string                                          return ndx;                                      }                                  }                                    // not something we're looking for -- but is it a simple ///#END?                                  if (CheckCaseInsensitiveSubstring("#END"))                                  {                                      // if the current character is not whitespace' then it's not a simple "#END"                                      c = GetChar(m_currentPosition);                                      if (IsBlankSpace(c) || IsAtEndOfLine)                                      {                                          // it is! Well' we were expecting either #ENDIF or #ENDDEBUG' but we found just an #END.                                          // that's not how the syntax is SUPPOSED to go. But let's let it fly.                                          // the ending token is always the first one.                                          return 0;                                      }                                  }                              }                          }                            break;                  }
Magic Number,Spike.Build.Minifiers,JsV3SourceMap,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsV3SourceMap.cs,Dispose,The following statement contains a magic number: WriteProperty("version"' 3);
Magic Number,Spike.Build.Minifiers,JsV3SourceMap,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsV3SourceMap.cs,EncodeNumber,The following statement contains a magic number: value >>= 5;
Magic Number,Spike.Build.Minifiers,MinifierParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\MinifierParser.cs,Parse,The following statement contains a magic number: switch (switchPart)                          {                              case "ANALYZE":                              case "A": // <-- old-style                                  // ignore any arguments                                  AnalyzeMode = true;                                    // by default' we have no report format                                  ReportFormat = null;                                  if (paramPartUpper != null)                                  {                                      var items = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var item in items)                                      {                                          if (string.CompareOrdinal(item' "OUT") == 0)                                          {                                              // if the analyze part is "out'" then the NEXT arg string                                              // is the output path the analyze scope report should be written to.                                              if (ndx >= args.Length - 1)                                              {                                                  // must be followed by a path                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                              else                                              {                                                  ReportPath = args[++ndx];                                              }                                          }                                          else                                          {                                              // must be a report format. There can be only one' so clobber whatever                                              // is there from before -- last one listed wins.                                              ReportFormat = item;                                          }                                      }                                  }                                    // if analyze was specified but no warning level' jack up the warning level                                  // so everything is shown                                  if (!levelSpecified)                                  {                                      // we want to analyze' and we didn't specify a particular warning level.                                      // go ahead and report all errors                                      WarningLevel = int.MaxValue;                                  }                                    break;                                case "ASPNET":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // same setting for both CSS and JS                                      JSSettings.AllowEmbeddedAspNetBlocks =                                          CssSettings.AllowEmbeddedAspNetBlocks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "BRACES":                                  if (paramPartUpper == "NEW")                                  {                                      JSSettings.BlocksStartOnSameLine =                                           CssSettings.BlocksStartOnSameLine = MinifierBlockStart.NewLine;                                  }                                  else if (paramPartUpper == "SAME")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.SameLine;                                  }                                  else if (paramPartUpper == "SOURCE")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.UseSource;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "CC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // actually' the flag is the opposite of the member -- turn CC ON and we DON'T                                      // want to ignore them; turn CC OFF and we DO want to ignore them                                      JSSettings.IgnoreConditionalCompilation = !parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "COLORS":                                  // two options: hex or names                                  if (paramPartUpper == "HEX")                                  {                                      CssSettings.ColorNames = CssColor.Hex;                                  }                                  else if (paramPartUpper == "STRICT")                                  {                                      CssSettings.ColorNames = CssColor.Strict;                                  }                                  else if (paramPartUpper == "MAJOR")                                  {                                      CssSettings.ColorNames = CssColor.Major;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnCssOnlyParameter();                                  break;                                case "COMMENTS":                                  // four options for css: none' all' important' or hacks                                  // two options for js: none' important                                  // (default is important)                                  if (paramPartUpper == "NONE")                                  {                                      CssSettings.CommentMode = CssComment.None;                                      JSSettings.PreserveImportantComments = false;                                  }                                  else if (paramPartUpper == "ALL")                                  {                                      CssSettings.CommentMode = CssComment.All;                                      OnCssOnlyParameter();                                  }                                  else if (paramPartUpper == "IMPORTANT")                                  {                                      CssSettings.CommentMode = CssComment.Important;                                      JSSettings.PreserveImportantComments = true;                                  }                                  else if (paramPartUpper == "HACKS")                                  {                                      CssSettings.CommentMode = CssComment.Hacks;                                      OnCssOnlyParameter();                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    break;                                case "CONST":                                  // options: MOZ or ES6 (ES6 is the default)                                  if (paramPartUpper == "MOZ")                                  {                                      JSSettings.ConstStatementsMozilla = true;                                  }                                  else if (paramPartUpper == "ES6")                                  {                                      JSSettings.ConstStatementsMozilla = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "CSS":                                  OnCssOnlyParameter();                                  if (paramPartUpper != null)                                  {                                      switch (paramPartUpper)                                      {                                          case "FULL":                                              CssSettings.CssType = CssType.FullStyleSheet;                                              break;                                            case "DECLS":                                              CssSettings.CssType = CssType.DeclarationList;                                              break;                                            default:                                              // not an expected value                                              OnInvalidSwitch(switchPart' paramPart);                                              break;                                      }                                  }                                  break;                                case "DEBUG":                                  // see if the param part is a comma-delimited list                                  if (paramPartUpper != null && paramPartUpper.IndexOf(''') >= 0)                                  {                                      // we have a comma-separated list.                                      // the first item is the flag (if any)' and the rest (if any) are the "debug" lookup names                                      var items = paramPart.Split(listSeparators);                                        // use the first value as the debug boolean switch.                                      // since we are splitting the non-uppercase param part' we need to                                       // make sure the first item is capitalized for our boolean test.                                      if (BooleanSwitch(items[0].ToUpperInvariant()' true' out parameterFlag))                                      {                                          // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                          // strip debug statements' and a FALSE means we DO want to strip them                                          JSSettings.StripDebugStatements = !parameterFlag;                                            // make sure we align the DEBUG define to the new switch value                                          AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                        // clear out the existing debug list                                      JSSettings.DebugLookupList = null;                                        // start with index 1' since index 0 was the flag                                      for (var item = 1; item < items.Length; ++item)                                      {                                          // get the identifier that was specified                                          var identifier = items[item];                                          if (!identifier.IsNullOrWhiteSpace())                                          {                                              if (!JSSettings.AddDebugLookup(identifier))                                              {                                                  OnInvalidSwitch(switchPart' identifier);                                              }                                          }                                      }                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // no commas -- just use the entire param part as the boolean value.                                      // just putting the debug switch on the command line without any arguments                                      // is the same as putting -debug:true and perfectly valid.                                        // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                      // strip debug statements' and a FALSE means we DO want to strip them                                      JSSettings.StripDebugStatements = !parameterFlag;                                        // make sure we align the DEBUG define to the new switch value                                      AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "DEFINE":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string define in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          string trimmedName;                                          string value;                                          var ndxEquals = define.IndexOf('=');                                          if (ndxEquals < 0)                                          {                                              trimmedName = define.Trim();                                              value = string.Empty;                                          }                                          else                                          {                                              trimmedName = define.Substring(0' ndxEquals).Trim();                                              value = define.Substring(ndxEquals + 1);                                          }                                            // better be a valid JavaScript identifier                                          if (!JsScanner.IsValidIdentifier(trimmedName))                                          {                                              OnInvalidSwitch(switchPart' define);                                          }                                          else                                          {                                              // JS Settings                                              JSSettings.PreprocessorValues[trimmedName] = value;                                                // CSS settings                                              CssSettings.PreprocessorValues[trimmedName] = value;                                          }                                            // if we're defining the DEBUG name' set the strip-debug-statements flag to false                                          if (string.Compare(trimmedName' "DEBUG"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              JSSettings.StripDebugStatements = false;                                          }                                      }                                  }                                    break;                                case "ENC":                                  // the encoding is the next argument                                  if (ndx >= args.Length - 1)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      string encoding = args[++ndx];                                        // whether this is an in or an out encoding                                      if (paramPartUpper == "IN")                                      {                                          // save the name -- we'll create the encoding later because we may                                          // override it on a file-by-file basis in an XML file                                          EncodingInputName = encoding;                                      }                                      else if (paramPartUpper == "OUT")                                      {                                          // just save the name -- we'll create the encoding later because we need                                          // to know whether we are JS or CSS to pick the right encoding fallback                                          EncodingOutputName = encoding;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "ESC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.AlwaysEscapeNonAscii = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "EVALS":                                  // three options: ignore' make immediate scope safe' or make all scopes safe                                  if (paramPartUpper == "IGNORE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  }                                  else if (paramPartUpper == "IMMEDIATE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeImmediateSafe;                                  }                                  else if (paramPartUpper == "SAFEALL")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeAllSafe;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "EXPR":                                  // two options: minify (default) or raw                                  if (paramPartUpper == "MINIFY")                                  {                                      CssSettings.MinifyExpressions = true;                                  }                                  else if (paramPartUpper == "RAW")                                  {                                      CssSettings.MinifyExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    OnCssOnlyParameter();                                  break;                                case "FNAMES":                                  // three options:                                   // LOCK    -> keep all NFE names' don't allow renaming of function names                                  // KEEP    -> keep all NFE names' but allow function names to be renamed                                  // ONLYREF -> remove unref'd NFE names' allow function named to be renamed (DEFAULT)                                  if (paramPartUpper == "LOCK")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // and preserve the names (don't allow renaming)                                      JSSettings.PreserveFunctionNames = true;                                  }                                  else if (paramPartUpper == "KEEP")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // but it's okay to rename them                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      // remove function expression names if they aren't referenced                                      JSSettings.RemoveFunctionExpressionNames = true;                                        // and rename them if we so desire                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "GLOBAL":                              case "G": // <-- old style                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string global in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddKnownGlobal(global))                                          {                                              OnInvalidSwitch(switchPart' global);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "IGNORE":                                  // list of error codes to ignore (not report)                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string errorCode in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.Compare(errorCode' "ALL"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              // we want to ignore ALL errors. So set the appropriate flag                                              JSSettings.IgnoreAllErrors =                                                  CssSettings.IgnoreAllErrors = true;                                          }                                          else                                          {                                              // don't add duplicates                                              JSSettings.IgnoreErrorCollection.Add(errorCode);                                              CssSettings.IgnoreErrorCollection.Add(errorCode);                                          }                                      }                                  }                                  break;                                case "INLINE":                                  if (string.IsNullOrEmpty(paramPart))                                  {                                      // no param parts. This defaults to inline-safe                                      JSSettings.InlineSafeStrings = true;                                  }                                  else                                  {                                      // for each comma-separated part...                                      foreach (var inlinePart in paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.CompareOrdinal(inlinePart' "FORCE") == 0)                                          {                                              // this is the force flag -- throw an error if any string literal                                              // sources are not properly escaped AND make sure the output is                                               // safe                                              JSSettings.ErrorIfNotInlineSafe = true;                                              JSSettings.InlineSafeStrings = true;                                          }                                          else if (string.CompareOrdinal(inlinePart' "NOFORCE") == 0)                                          {                                              // this is the noforce flag; don't throw an error is the source isn't inline safe.                                              // don't change whatever the output-inline-safe flag may happen to be' though                                              JSSettings.ErrorIfNotInlineSafe = false;                                          }                                          else                                          {                                              // assume it must be the boolean flag.                                              // if no param part' will return true (indicating the default)                                              // if invalid param part' will throw error                                              if (BooleanSwitch(inlinePart' true' out parameterFlag))                                              {                                                  JSSettings.InlineSafeStrings = parameterFlag;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "JS":                                  if (paramPart == null)                                  {                                      // normal settings                                      JSSettings.SourceMode = JsSourceMode.Program;                                      JSSettings.Format = JsFormat.Normal;                                  }                                  else                                  {                                      // comma-delimited list of JS settings                                      var tokens = paramPartUpper.Split('''' ';');                                      foreach (var token in tokens)                                      {                                          switch (token)                                          {                                              case "JSON":                                                  // JSON is incompatible with any other tokens' so throw an error                                                  // if it's not the only token                                                  if (tokens.Length > 1)                                                  {                                                      OnInvalidSwitch(switchPart' paramPart);                                                  }                                                    // nothing to "minify" in the JSON format' so turn off the minify flag                                                  JSSettings.MinifyCode = false;                                                    // JSON affects both the input (it's an expression) and the output                                                  // (use the JSON-output visitor)                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  JSSettings.Format = JsFormat.JSON;                                                  break;                                                case "PROG":                                                  // this is the default setting                                                  JSSettings.SourceMode = JsSourceMode.Program;                                                  break;                                                case "EXPR":                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  break;                                                case "EVT":                                                  JSSettings.SourceMode = JsSourceMode.EventHandler;                                                  break;                                                default:                                                  // later: ES5 to convert any ES6 syntax to ES5-compatible                                                  // later: ES6 to create ES6 syntax when optimizing                                                  // etc.                                                  // those two examples will affect the format property.                                                  // but for now' not supported                                                  OnInvalidSwitch(switchPart' paramPart);                                                  break;                                          }                                      }                                  }                                    OnJSOnlyParameter();                                  break;                                case "KILL":                                  killSpecified = true;                                    // optional integer switch argument                                  if (paramPartUpper == null)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      // get the numeric portion                                      long killSwitch;                                      if (paramPartUpper.StartsWith("0X"' StringComparison.OrdinalIgnoreCase))                                      {                                          // it's hex -- convert the number after the "0x"                                          if (paramPartUpper.Substring(2).TryParseLongInvariant(NumberStyles.AllowHexSpecifier' out killSwitch))                                          {                                              // save the switch for both JS and Css                                              JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                                // for CSS' we only look at the first bit: preeserve important comments                                              if ((killSwitch & 1) != 0)                                              {                                                  // we set the kill' so make sure the comments are set to none                                                  CssSettings.CommentMode = CssComment.None;                                              }                                          }                                          else                                          {                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                      else if (paramPartUpper.TryParseLongInvariant(NumberStyles.AllowLeadingSign' out killSwitch))                                      {                                          // save the switch for both JS and CSS                                          JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                            // for CSS' we only look at the first bit: preeserve important comments                                          if ((killSwitch & 1) != 0)                                          {                                              // we set the kill' so make sure the comments are set to none                                              CssSettings.CommentMode = CssComment.None;                                          }                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LINE":                              case "LINES":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // if no number specified' use the max default threshold                                      JSSettings.LineBreakThreshold =                                          CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                                                            // single-line mode                                      JSSettings.OutputMode =                                           CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                        // and four spaces per indent level                                      JSSettings.IndentSize =                                          CssSettings.IndentSize = 4;                                  }                                  else                                  {                                      // split along commas (case-insensitive)                                      var lineParts = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                        // by default' the line-break index will be 1 (the second option).                                      // we will change this index to 0 if the first parameter is multi/single                                      // instead of the line-break character count.                                      var breakIndex = 1;                                      if (lineParts.Length <= 3)                                      {                                          // if the first optional part is numeric' then it's the line threshold.                                          // might also be "multi" or "single"' thereby skipping the line threshold.                                          // (don't need to check length greater than zero -- will always be at least one element returned from Split)                                          if (!string.IsNullOrEmpty(lineParts[0]))                                          {                                              // must be an unsigned decimal integer value                                              int lineThreshold;                                              if (lineParts[0].TryParseIntInvariant(NumberStyles.None' out lineThreshold))                                              {                                                  JSSettings.LineBreakThreshold =                                                      CssSettings.LineBreakThreshold = lineThreshold;                                              }                                              else if (lineParts[0][0] == 'S')                                              {                                                  // single-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else if (lineParts[0][0] == 'M')                                              {                                                  // multiple-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' lineParts[0]);                                              }                                          }                                          else                                          {                                              // use the default                                              JSSettings.LineBreakThreshold =                                                  CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                          }                                            if (lineParts.Length > breakIndex)                                          {                                              // if the line-break index was zero' then we already processed it                                              // and we can skip the logic                                              if (breakIndex > 0)                                              {                                                  // second optional part is single or multiple line output                                                  if (string.IsNullOrEmpty(lineParts[breakIndex]) || lineParts[breakIndex][0] == 'S')                                                  {                                                      // single-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                  }                                                  else if (lineParts[breakIndex][0] == 'M')                                                  {                                                      // multiple-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                  }                                                  else                                                  {                                                      // must either be missing' or start with S (single) or M (multiple)                                                      OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                  }                                              }                                                // move on to the next part                                              ++breakIndex;                                              if (lineParts.Length > breakIndex)                                              {                                                  // third optional part is the spaces-per-indent value                                                  if (!string.IsNullOrEmpty(lineParts[breakIndex]))                                                  {                                                      // get the numeric portion; must be a decimal integer                                                      int indentSize;                                                      if (lineParts[breakIndex].TryParseIntInvariant(NumberStyles.None' out indentSize))                                                      {                                                          // same value for JS and CSS.                                                          // don't need to check for negative' because the tryparse method above does NOT                                                          // allow for a sign -- no sign' no negative.                                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                                      }                                                      else                                                      {                                                          OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                      }                                                  }                                                  else                                                  {                                                      // default of 4                                                      JSSettings.IndentSize =                                                          CssSettings.IndentSize = 4;                                                  }                                              }                                          }                                      }                                      else                                      {                                          // only 1-3 parts allowed                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LITERALS":                                  // two areas with two options each: keep or combine and eval or noeval                                  if (paramPartUpper == "KEEP")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = false;                                  }                                  else if (paramPartUpper == "COMBINE")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = true;                                  }                                  else if (paramPartUpper == "EVAL")                                  {                                      JSSettings.EvalLiteralExpressions = true;                                  }                                  else if (paramPartUpper == "NOEVAL")                                  {                                      JSSettings.EvalLiteralExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MAC":                                  // optional boolean switch                                  // no arg is valid scenario (default is true)                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.MacSafariQuirks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MINIFY":                                  minifySpecified = true;                                  if (renamingSpecified && JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      // minify can only exist if rename is set to KeepAll                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // optional boolean switch                                      // no arg is a valid scenario (default is true)                                      JSSettings.MinifyCode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NEW":                                  // two options: keep and collapse                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.CollapseToLiteral = false;                                  }                                  else if (paramPartUpper == "COLLAPSE")                                  {                                      JSSettings.CollapseToLiteral = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NFE": // <-- deprecate; use FNAMES option instead                                  if (paramPartUpper == "KEEPALL")                                  {                                      JSSettings.RemoveFunctionExpressionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      JSSettings.RemoveFunctionExpressionNames = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NORENAME":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string ident in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddNoAutoRename(ident))                                          {                                              OnInvalidSwitch(switchPart' ident);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "OBJ":                                  // two options: MINify or QUOTE                                  if (paramPartUpper == "MIN")                                  {                                      JSSettings.QuoteObjectLiteralProperties = false;                                  }                                  else if (paramPartUpper == "QUOTE")                                  {                                      JSSettings.QuoteObjectLiteralProperties = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PPONLY":                                  // just putting the pponly switch on the command line without any arguments                                  // is the same as putting -pponly:true and perfectly valid.                                  if (paramPart == null)                                  {                                      JSSettings.PreprocessOnly = true;                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.PreprocessOnly = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PRETTY":                              case "P": // <-- old style                                  // doesn't take a flag -- just set to pretty                                  PrettyPrint = true;                                                // by default' pretty mode turns off minification' which sets a bunch of other flags as well                                  JSSettings.MinifyCode = false;                                    // and some other flags for pretty-mode                                  JSSettings.OutputMode = CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                  CssSettings.KillSwitch = ~((long)JsTreeModifications.PreserveImportantComments);                                    // optional integer switch argument                                  if (paramPartUpper != null)                                  {                                      // get the numeric portion; must be a decimal integer                                      int indentSize;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out indentSize))                                      {                                          // same value for JS and CSS.                                          // don't need to check for negative' because the tryparse method above does NOT                                          // allow for a sign -- no sign' no negative.                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                      }                                      else                                       {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "RENAME":                                  if (paramPartUpper == null)                                  {                                      // treat as if it's unknown                                      ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  }                                  else if (paramPartUpper.IndexOf('=') > 0)                                  {                                      // there is at least one equal sign -- treat this as a set of JS identifier                                      // pairs. split on commas -- multiple pairs can be specified                                      var paramPairs = paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var paramPair in paramPairs)                                      {                                          // split on the equal sign -- each pair needs to have an equal sige                                          var pairParts = paramPair.Split('=');                                          if (pairParts.Length == 2)                                          {                                              // there is an equal sign. The first part is the source name and the                                              // second part is the new name to which to rename those entities.                                              string fromIdentifier = pairParts[0];                                              string toIdentifier = pairParts[1];                                                // make sure both parts are valid JS identifiers                                              var fromIsValid = JsScanner.IsValidIdentifier(fromIdentifier);                                              var toIsValid = JsScanner.IsValidIdentifier(toIdentifier);                                              if (fromIsValid && toIsValid)                                              {                                                  // create the map if it hasn't been created yet.                                                  var toExisting = JSSettings.GetNewName(fromIdentifier);                                                  if (toExisting == null)                                                  {                                                      JSSettings.AddRenamePair(fromIdentifier' toIdentifier);                                                  }                                                  else if (string.CompareOrdinal(toIdentifier' toExisting) != 0)                                                  {                                                      // from-identifier already exists' and the to-identifier doesn't match.                                                      // can't rename the same name to two different names!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                              else                                              {                                                  if (fromIsValid)                                                  {                                                      // the toIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' toIdentifier);                                                  }                                                    if (toIsValid)                                                  {                                                      // the fromIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                          }                                          else                                          {                                              // either zero or more than one equal sign. Invalid.                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                  }                                  else                                  {                                      // no equal sign; just a plain option                                      // three options: all' localization' none                                      if (paramPartUpper == "ALL")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "LOCALIZATION")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NONE")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NOPROPS")                                      {                                          // manual-renaming does not change property names                                          JSSettings.ManualRenamesProperties = false;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  if (JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      ResetRenamingKill(killSpecified);                                        // if minify was specified as turned off' then this is invalid                                      if (minifySpecified && !JSSettings.MinifyCode)                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "REORDER":                                  // default is true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.ReorderScopeDeclarations = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "STRICT":                                  // default is false' but if we specify this switch without a parameter' then                                  // we assume we are turning it ON                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.StrictMode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "TERM":                                  // optional boolean argument' defaults to true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.TermSemicolons =                                          CssSettings.TermSemicolons = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "UNUSED":                                  // two options: keep and remove                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.RemoveUnneededCode = false;                                  }                                  else if (paramPartUpper == "REMOVE")                                  {                                      JSSettings.RemoveUnneededCode = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "VAR":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      var firstLetters = paramPart;                                      string partLetters = null;                                        var commaPosition = paramPart.IndexOf(''');                                      if (commaPosition == 0)                                      {                                          // no first letters; just part letters                                          firstLetters = null;                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                      else if (commaPosition > 0)                                      {                                          // first letters and part letters                                          firstLetters = paramPart.Substring(0' commaPosition);                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                        // if we specified first letters' set them now                                      if (!string.IsNullOrEmpty(firstLetters))                                      {                                          JsCrunchEnumerator.FirstLetters = firstLetters;                                      }                                        // if we specified part letters' use it -- otherwise use the first letters.                                      if (!string.IsNullOrEmpty(partLetters))                                      {                                          JsCrunchEnumerator.PartLetters = partLetters;                                      }                                      else if (!string.IsNullOrEmpty(firstLetters))                                      {                                          // we don't have any part letters' but we do have first letters. reuse.                                          JsCrunchEnumerator.PartLetters = firstLetters;                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "WARN":                              case "W": // <-- old style                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // just "-warn" without anything else means all errors and warnings                                      WarningLevel = int.MaxValue;                                  }                                  else                                  {                                      // must be an unsigned decimal integer value                                      int warningLevel;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out warningLevel))                                      {                                          WarningLevel = warningLevel;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  levelSpecified = true;                                  break;                                //                              // Backward-compatibility switches different from new switches                              //                                case "D":                                  // equivalent to -debug:false (default behavior)                                  JSSettings.StripDebugStatements = true;                                  OnJSOnlyParameter();                                  break;                                case "E":                              case "EO":                                  // equivalent to -enc:out <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // just save the name -- we'll create the encoding later because we need                                  // to know whether we are JS or CSS to pick the right encoding fallback                                  EncodingOutputName = paramPart;                                  break;                                case "EI":                                  // equivalent to -enc:in <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // save the name                                  EncodingInputName = paramPart;                                  break;                                case "H":                                  // equivalent to -rename:all -unused:remove (default behavior)                                  JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HL":                                  // equivalent to -rename:localization -unused:remove                                  JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HC":                                  // equivalent to -literals:combine -rename:all -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "H";                                case "HLC":                              case "HCL":                                  // equivalent to -literals:combine -rename:localization -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "HL";                                case "J":                                  // equivalent to -evals:ignore (default behavior)                                  JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  OnJSOnlyParameter();                                  break;                                case "K":                                  // equivalent to -inline:true (default behavior)                                  JSSettings.InlineSafeStrings = true;                                  OnJSOnlyParameter();                                  break;                                case "L":                                  // equivalent to -new:keep (default is collapse)                                  JSSettings.CollapseToLiteral = false;                                  OnJSOnlyParameter();                                  break;                                case "M":                                  // equivalent to -mac:true (default behavior)                                  JSSettings.MacSafariQuirks = true;                                  OnJSOnlyParameter();                                  break;                                case "Z":                                  // equivalent to -term:true (default is false)                                  JSSettings.TermSemicolons =                                      CssSettings.TermSemicolons = true;                                  break;                                // end backward-compatible section                                default:                                  ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  break;                          }
Magic Number,Spike.Build.Minifiers,MinifierParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\MinifierParser.cs,Parse,The following statement contains a magic number: switch (switchPart)                          {                              case "ANALYZE":                              case "A": // <-- old-style                                  // ignore any arguments                                  AnalyzeMode = true;                                    // by default' we have no report format                                  ReportFormat = null;                                  if (paramPartUpper != null)                                  {                                      var items = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var item in items)                                      {                                          if (string.CompareOrdinal(item' "OUT") == 0)                                          {                                              // if the analyze part is "out'" then the NEXT arg string                                              // is the output path the analyze scope report should be written to.                                              if (ndx >= args.Length - 1)                                              {                                                  // must be followed by a path                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                              else                                              {                                                  ReportPath = args[++ndx];                                              }                                          }                                          else                                          {                                              // must be a report format. There can be only one' so clobber whatever                                              // is there from before -- last one listed wins.                                              ReportFormat = item;                                          }                                      }                                  }                                    // if analyze was specified but no warning level' jack up the warning level                                  // so everything is shown                                  if (!levelSpecified)                                  {                                      // we want to analyze' and we didn't specify a particular warning level.                                      // go ahead and report all errors                                      WarningLevel = int.MaxValue;                                  }                                    break;                                case "ASPNET":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // same setting for both CSS and JS                                      JSSettings.AllowEmbeddedAspNetBlocks =                                          CssSettings.AllowEmbeddedAspNetBlocks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "BRACES":                                  if (paramPartUpper == "NEW")                                  {                                      JSSettings.BlocksStartOnSameLine =                                           CssSettings.BlocksStartOnSameLine = MinifierBlockStart.NewLine;                                  }                                  else if (paramPartUpper == "SAME")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.SameLine;                                  }                                  else if (paramPartUpper == "SOURCE")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.UseSource;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "CC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // actually' the flag is the opposite of the member -- turn CC ON and we DON'T                                      // want to ignore them; turn CC OFF and we DO want to ignore them                                      JSSettings.IgnoreConditionalCompilation = !parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "COLORS":                                  // two options: hex or names                                  if (paramPartUpper == "HEX")                                  {                                      CssSettings.ColorNames = CssColor.Hex;                                  }                                  else if (paramPartUpper == "STRICT")                                  {                                      CssSettings.ColorNames = CssColor.Strict;                                  }                                  else if (paramPartUpper == "MAJOR")                                  {                                      CssSettings.ColorNames = CssColor.Major;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnCssOnlyParameter();                                  break;                                case "COMMENTS":                                  // four options for css: none' all' important' or hacks                                  // two options for js: none' important                                  // (default is important)                                  if (paramPartUpper == "NONE")                                  {                                      CssSettings.CommentMode = CssComment.None;                                      JSSettings.PreserveImportantComments = false;                                  }                                  else if (paramPartUpper == "ALL")                                  {                                      CssSettings.CommentMode = CssComment.All;                                      OnCssOnlyParameter();                                  }                                  else if (paramPartUpper == "IMPORTANT")                                  {                                      CssSettings.CommentMode = CssComment.Important;                                      JSSettings.PreserveImportantComments = true;                                  }                                  else if (paramPartUpper == "HACKS")                                  {                                      CssSettings.CommentMode = CssComment.Hacks;                                      OnCssOnlyParameter();                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    break;                                case "CONST":                                  // options: MOZ or ES6 (ES6 is the default)                                  if (paramPartUpper == "MOZ")                                  {                                      JSSettings.ConstStatementsMozilla = true;                                  }                                  else if (paramPartUpper == "ES6")                                  {                                      JSSettings.ConstStatementsMozilla = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "CSS":                                  OnCssOnlyParameter();                                  if (paramPartUpper != null)                                  {                                      switch (paramPartUpper)                                      {                                          case "FULL":                                              CssSettings.CssType = CssType.FullStyleSheet;                                              break;                                            case "DECLS":                                              CssSettings.CssType = CssType.DeclarationList;                                              break;                                            default:                                              // not an expected value                                              OnInvalidSwitch(switchPart' paramPart);                                              break;                                      }                                  }                                  break;                                case "DEBUG":                                  // see if the param part is a comma-delimited list                                  if (paramPartUpper != null && paramPartUpper.IndexOf(''') >= 0)                                  {                                      // we have a comma-separated list.                                      // the first item is the flag (if any)' and the rest (if any) are the "debug" lookup names                                      var items = paramPart.Split(listSeparators);                                        // use the first value as the debug boolean switch.                                      // since we are splitting the non-uppercase param part' we need to                                       // make sure the first item is capitalized for our boolean test.                                      if (BooleanSwitch(items[0].ToUpperInvariant()' true' out parameterFlag))                                      {                                          // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                          // strip debug statements' and a FALSE means we DO want to strip them                                          JSSettings.StripDebugStatements = !parameterFlag;                                            // make sure we align the DEBUG define to the new switch value                                          AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                        // clear out the existing debug list                                      JSSettings.DebugLookupList = null;                                        // start with index 1' since index 0 was the flag                                      for (var item = 1; item < items.Length; ++item)                                      {                                          // get the identifier that was specified                                          var identifier = items[item];                                          if (!identifier.IsNullOrWhiteSpace())                                          {                                              if (!JSSettings.AddDebugLookup(identifier))                                              {                                                  OnInvalidSwitch(switchPart' identifier);                                              }                                          }                                      }                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // no commas -- just use the entire param part as the boolean value.                                      // just putting the debug switch on the command line without any arguments                                      // is the same as putting -debug:true and perfectly valid.                                        // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                      // strip debug statements' and a FALSE means we DO want to strip them                                      JSSettings.StripDebugStatements = !parameterFlag;                                        // make sure we align the DEBUG define to the new switch value                                      AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "DEFINE":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string define in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          string trimmedName;                                          string value;                                          var ndxEquals = define.IndexOf('=');                                          if (ndxEquals < 0)                                          {                                              trimmedName = define.Trim();                                              value = string.Empty;                                          }                                          else                                          {                                              trimmedName = define.Substring(0' ndxEquals).Trim();                                              value = define.Substring(ndxEquals + 1);                                          }                                            // better be a valid JavaScript identifier                                          if (!JsScanner.IsValidIdentifier(trimmedName))                                          {                                              OnInvalidSwitch(switchPart' define);                                          }                                          else                                          {                                              // JS Settings                                              JSSettings.PreprocessorValues[trimmedName] = value;                                                // CSS settings                                              CssSettings.PreprocessorValues[trimmedName] = value;                                          }                                            // if we're defining the DEBUG name' set the strip-debug-statements flag to false                                          if (string.Compare(trimmedName' "DEBUG"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              JSSettings.StripDebugStatements = false;                                          }                                      }                                  }                                    break;                                case "ENC":                                  // the encoding is the next argument                                  if (ndx >= args.Length - 1)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      string encoding = args[++ndx];                                        // whether this is an in or an out encoding                                      if (paramPartUpper == "IN")                                      {                                          // save the name -- we'll create the encoding later because we may                                          // override it on a file-by-file basis in an XML file                                          EncodingInputName = encoding;                                      }                                      else if (paramPartUpper == "OUT")                                      {                                          // just save the name -- we'll create the encoding later because we need                                          // to know whether we are JS or CSS to pick the right encoding fallback                                          EncodingOutputName = encoding;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "ESC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.AlwaysEscapeNonAscii = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "EVALS":                                  // three options: ignore' make immediate scope safe' or make all scopes safe                                  if (paramPartUpper == "IGNORE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  }                                  else if (paramPartUpper == "IMMEDIATE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeImmediateSafe;                                  }                                  else if (paramPartUpper == "SAFEALL")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeAllSafe;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "EXPR":                                  // two options: minify (default) or raw                                  if (paramPartUpper == "MINIFY")                                  {                                      CssSettings.MinifyExpressions = true;                                  }                                  else if (paramPartUpper == "RAW")                                  {                                      CssSettings.MinifyExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    OnCssOnlyParameter();                                  break;                                case "FNAMES":                                  // three options:                                   // LOCK    -> keep all NFE names' don't allow renaming of function names                                  // KEEP    -> keep all NFE names' but allow function names to be renamed                                  // ONLYREF -> remove unref'd NFE names' allow function named to be renamed (DEFAULT)                                  if (paramPartUpper == "LOCK")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // and preserve the names (don't allow renaming)                                      JSSettings.PreserveFunctionNames = true;                                  }                                  else if (paramPartUpper == "KEEP")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // but it's okay to rename them                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      // remove function expression names if they aren't referenced                                      JSSettings.RemoveFunctionExpressionNames = true;                                        // and rename them if we so desire                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "GLOBAL":                              case "G": // <-- old style                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string global in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddKnownGlobal(global))                                          {                                              OnInvalidSwitch(switchPart' global);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "IGNORE":                                  // list of error codes to ignore (not report)                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string errorCode in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.Compare(errorCode' "ALL"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              // we want to ignore ALL errors. So set the appropriate flag                                              JSSettings.IgnoreAllErrors =                                                  CssSettings.IgnoreAllErrors = true;                                          }                                          else                                          {                                              // don't add duplicates                                              JSSettings.IgnoreErrorCollection.Add(errorCode);                                              CssSettings.IgnoreErrorCollection.Add(errorCode);                                          }                                      }                                  }                                  break;                                case "INLINE":                                  if (string.IsNullOrEmpty(paramPart))                                  {                                      // no param parts. This defaults to inline-safe                                      JSSettings.InlineSafeStrings = true;                                  }                                  else                                  {                                      // for each comma-separated part...                                      foreach (var inlinePart in paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.CompareOrdinal(inlinePart' "FORCE") == 0)                                          {                                              // this is the force flag -- throw an error if any string literal                                              // sources are not properly escaped AND make sure the output is                                               // safe                                              JSSettings.ErrorIfNotInlineSafe = true;                                              JSSettings.InlineSafeStrings = true;                                          }                                          else if (string.CompareOrdinal(inlinePart' "NOFORCE") == 0)                                          {                                              // this is the noforce flag; don't throw an error is the source isn't inline safe.                                              // don't change whatever the output-inline-safe flag may happen to be' though                                              JSSettings.ErrorIfNotInlineSafe = false;                                          }                                          else                                          {                                              // assume it must be the boolean flag.                                              // if no param part' will return true (indicating the default)                                              // if invalid param part' will throw error                                              if (BooleanSwitch(inlinePart' true' out parameterFlag))                                              {                                                  JSSettings.InlineSafeStrings = parameterFlag;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "JS":                                  if (paramPart == null)                                  {                                      // normal settings                                      JSSettings.SourceMode = JsSourceMode.Program;                                      JSSettings.Format = JsFormat.Normal;                                  }                                  else                                  {                                      // comma-delimited list of JS settings                                      var tokens = paramPartUpper.Split('''' ';');                                      foreach (var token in tokens)                                      {                                          switch (token)                                          {                                              case "JSON":                                                  // JSON is incompatible with any other tokens' so throw an error                                                  // if it's not the only token                                                  if (tokens.Length > 1)                                                  {                                                      OnInvalidSwitch(switchPart' paramPart);                                                  }                                                    // nothing to "minify" in the JSON format' so turn off the minify flag                                                  JSSettings.MinifyCode = false;                                                    // JSON affects both the input (it's an expression) and the output                                                  // (use the JSON-output visitor)                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  JSSettings.Format = JsFormat.JSON;                                                  break;                                                case "PROG":                                                  // this is the default setting                                                  JSSettings.SourceMode = JsSourceMode.Program;                                                  break;                                                case "EXPR":                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  break;                                                case "EVT":                                                  JSSettings.SourceMode = JsSourceMode.EventHandler;                                                  break;                                                default:                                                  // later: ES5 to convert any ES6 syntax to ES5-compatible                                                  // later: ES6 to create ES6 syntax when optimizing                                                  // etc.                                                  // those two examples will affect the format property.                                                  // but for now' not supported                                                  OnInvalidSwitch(switchPart' paramPart);                                                  break;                                          }                                      }                                  }                                    OnJSOnlyParameter();                                  break;                                case "KILL":                                  killSpecified = true;                                    // optional integer switch argument                                  if (paramPartUpper == null)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      // get the numeric portion                                      long killSwitch;                                      if (paramPartUpper.StartsWith("0X"' StringComparison.OrdinalIgnoreCase))                                      {                                          // it's hex -- convert the number after the "0x"                                          if (paramPartUpper.Substring(2).TryParseLongInvariant(NumberStyles.AllowHexSpecifier' out killSwitch))                                          {                                              // save the switch for both JS and Css                                              JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                                // for CSS' we only look at the first bit: preeserve important comments                                              if ((killSwitch & 1) != 0)                                              {                                                  // we set the kill' so make sure the comments are set to none                                                  CssSettings.CommentMode = CssComment.None;                                              }                                          }                                          else                                          {                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                      else if (paramPartUpper.TryParseLongInvariant(NumberStyles.AllowLeadingSign' out killSwitch))                                      {                                          // save the switch for both JS and CSS                                          JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                            // for CSS' we only look at the first bit: preeserve important comments                                          if ((killSwitch & 1) != 0)                                          {                                              // we set the kill' so make sure the comments are set to none                                              CssSettings.CommentMode = CssComment.None;                                          }                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LINE":                              case "LINES":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // if no number specified' use the max default threshold                                      JSSettings.LineBreakThreshold =                                          CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                                                            // single-line mode                                      JSSettings.OutputMode =                                           CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                        // and four spaces per indent level                                      JSSettings.IndentSize =                                          CssSettings.IndentSize = 4;                                  }                                  else                                  {                                      // split along commas (case-insensitive)                                      var lineParts = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                        // by default' the line-break index will be 1 (the second option).                                      // we will change this index to 0 if the first parameter is multi/single                                      // instead of the line-break character count.                                      var breakIndex = 1;                                      if (lineParts.Length <= 3)                                      {                                          // if the first optional part is numeric' then it's the line threshold.                                          // might also be "multi" or "single"' thereby skipping the line threshold.                                          // (don't need to check length greater than zero -- will always be at least one element returned from Split)                                          if (!string.IsNullOrEmpty(lineParts[0]))                                          {                                              // must be an unsigned decimal integer value                                              int lineThreshold;                                              if (lineParts[0].TryParseIntInvariant(NumberStyles.None' out lineThreshold))                                              {                                                  JSSettings.LineBreakThreshold =                                                      CssSettings.LineBreakThreshold = lineThreshold;                                              }                                              else if (lineParts[0][0] == 'S')                                              {                                                  // single-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else if (lineParts[0][0] == 'M')                                              {                                                  // multiple-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' lineParts[0]);                                              }                                          }                                          else                                          {                                              // use the default                                              JSSettings.LineBreakThreshold =                                                  CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                          }                                            if (lineParts.Length > breakIndex)                                          {                                              // if the line-break index was zero' then we already processed it                                              // and we can skip the logic                                              if (breakIndex > 0)                                              {                                                  // second optional part is single or multiple line output                                                  if (string.IsNullOrEmpty(lineParts[breakIndex]) || lineParts[breakIndex][0] == 'S')                                                  {                                                      // single-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                  }                                                  else if (lineParts[breakIndex][0] == 'M')                                                  {                                                      // multiple-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                  }                                                  else                                                  {                                                      // must either be missing' or start with S (single) or M (multiple)                                                      OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                  }                                              }                                                // move on to the next part                                              ++breakIndex;                                              if (lineParts.Length > breakIndex)                                              {                                                  // third optional part is the spaces-per-indent value                                                  if (!string.IsNullOrEmpty(lineParts[breakIndex]))                                                  {                                                      // get the numeric portion; must be a decimal integer                                                      int indentSize;                                                      if (lineParts[breakIndex].TryParseIntInvariant(NumberStyles.None' out indentSize))                                                      {                                                          // same value for JS and CSS.                                                          // don't need to check for negative' because the tryparse method above does NOT                                                          // allow for a sign -- no sign' no negative.                                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                                      }                                                      else                                                      {                                                          OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                      }                                                  }                                                  else                                                  {                                                      // default of 4                                                      JSSettings.IndentSize =                                                          CssSettings.IndentSize = 4;                                                  }                                              }                                          }                                      }                                      else                                      {                                          // only 1-3 parts allowed                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LITERALS":                                  // two areas with two options each: keep or combine and eval or noeval                                  if (paramPartUpper == "KEEP")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = false;                                  }                                  else if (paramPartUpper == "COMBINE")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = true;                                  }                                  else if (paramPartUpper == "EVAL")                                  {                                      JSSettings.EvalLiteralExpressions = true;                                  }                                  else if (paramPartUpper == "NOEVAL")                                  {                                      JSSettings.EvalLiteralExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MAC":                                  // optional boolean switch                                  // no arg is valid scenario (default is true)                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.MacSafariQuirks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MINIFY":                                  minifySpecified = true;                                  if (renamingSpecified && JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      // minify can only exist if rename is set to KeepAll                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // optional boolean switch                                      // no arg is a valid scenario (default is true)                                      JSSettings.MinifyCode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NEW":                                  // two options: keep and collapse                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.CollapseToLiteral = false;                                  }                                  else if (paramPartUpper == "COLLAPSE")                                  {                                      JSSettings.CollapseToLiteral = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NFE": // <-- deprecate; use FNAMES option instead                                  if (paramPartUpper == "KEEPALL")                                  {                                      JSSettings.RemoveFunctionExpressionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      JSSettings.RemoveFunctionExpressionNames = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NORENAME":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string ident in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddNoAutoRename(ident))                                          {                                              OnInvalidSwitch(switchPart' ident);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "OBJ":                                  // two options: MINify or QUOTE                                  if (paramPartUpper == "MIN")                                  {                                      JSSettings.QuoteObjectLiteralProperties = false;                                  }                                  else if (paramPartUpper == "QUOTE")                                  {                                      JSSettings.QuoteObjectLiteralProperties = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PPONLY":                                  // just putting the pponly switch on the command line without any arguments                                  // is the same as putting -pponly:true and perfectly valid.                                  if (paramPart == null)                                  {                                      JSSettings.PreprocessOnly = true;                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.PreprocessOnly = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PRETTY":                              case "P": // <-- old style                                  // doesn't take a flag -- just set to pretty                                  PrettyPrint = true;                                                // by default' pretty mode turns off minification' which sets a bunch of other flags as well                                  JSSettings.MinifyCode = false;                                    // and some other flags for pretty-mode                                  JSSettings.OutputMode = CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                  CssSettings.KillSwitch = ~((long)JsTreeModifications.PreserveImportantComments);                                    // optional integer switch argument                                  if (paramPartUpper != null)                                  {                                      // get the numeric portion; must be a decimal integer                                      int indentSize;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out indentSize))                                      {                                          // same value for JS and CSS.                                          // don't need to check for negative' because the tryparse method above does NOT                                          // allow for a sign -- no sign' no negative.                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                      }                                      else                                       {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "RENAME":                                  if (paramPartUpper == null)                                  {                                      // treat as if it's unknown                                      ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  }                                  else if (paramPartUpper.IndexOf('=') > 0)                                  {                                      // there is at least one equal sign -- treat this as a set of JS identifier                                      // pairs. split on commas -- multiple pairs can be specified                                      var paramPairs = paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var paramPair in paramPairs)                                      {                                          // split on the equal sign -- each pair needs to have an equal sige                                          var pairParts = paramPair.Split('=');                                          if (pairParts.Length == 2)                                          {                                              // there is an equal sign. The first part is the source name and the                                              // second part is the new name to which to rename those entities.                                              string fromIdentifier = pairParts[0];                                              string toIdentifier = pairParts[1];                                                // make sure both parts are valid JS identifiers                                              var fromIsValid = JsScanner.IsValidIdentifier(fromIdentifier);                                              var toIsValid = JsScanner.IsValidIdentifier(toIdentifier);                                              if (fromIsValid && toIsValid)                                              {                                                  // create the map if it hasn't been created yet.                                                  var toExisting = JSSettings.GetNewName(fromIdentifier);                                                  if (toExisting == null)                                                  {                                                      JSSettings.AddRenamePair(fromIdentifier' toIdentifier);                                                  }                                                  else if (string.CompareOrdinal(toIdentifier' toExisting) != 0)                                                  {                                                      // from-identifier already exists' and the to-identifier doesn't match.                                                      // can't rename the same name to two different names!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                              else                                              {                                                  if (fromIsValid)                                                  {                                                      // the toIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' toIdentifier);                                                  }                                                    if (toIsValid)                                                  {                                                      // the fromIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                          }                                          else                                          {                                              // either zero or more than one equal sign. Invalid.                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                  }                                  else                                  {                                      // no equal sign; just a plain option                                      // three options: all' localization' none                                      if (paramPartUpper == "ALL")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "LOCALIZATION")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NONE")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NOPROPS")                                      {                                          // manual-renaming does not change property names                                          JSSettings.ManualRenamesProperties = false;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  if (JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      ResetRenamingKill(killSpecified);                                        // if minify was specified as turned off' then this is invalid                                      if (minifySpecified && !JSSettings.MinifyCode)                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "REORDER":                                  // default is true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.ReorderScopeDeclarations = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "STRICT":                                  // default is false' but if we specify this switch without a parameter' then                                  // we assume we are turning it ON                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.StrictMode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "TERM":                                  // optional boolean argument' defaults to true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.TermSemicolons =                                          CssSettings.TermSemicolons = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "UNUSED":                                  // two options: keep and remove                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.RemoveUnneededCode = false;                                  }                                  else if (paramPartUpper == "REMOVE")                                  {                                      JSSettings.RemoveUnneededCode = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "VAR":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      var firstLetters = paramPart;                                      string partLetters = null;                                        var commaPosition = paramPart.IndexOf(''');                                      if (commaPosition == 0)                                      {                                          // no first letters; just part letters                                          firstLetters = null;                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                      else if (commaPosition > 0)                                      {                                          // first letters and part letters                                          firstLetters = paramPart.Substring(0' commaPosition);                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                        // if we specified first letters' set them now                                      if (!string.IsNullOrEmpty(firstLetters))                                      {                                          JsCrunchEnumerator.FirstLetters = firstLetters;                                      }                                        // if we specified part letters' use it -- otherwise use the first letters.                                      if (!string.IsNullOrEmpty(partLetters))                                      {                                          JsCrunchEnumerator.PartLetters = partLetters;                                      }                                      else if (!string.IsNullOrEmpty(firstLetters))                                      {                                          // we don't have any part letters' but we do have first letters. reuse.                                          JsCrunchEnumerator.PartLetters = firstLetters;                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "WARN":                              case "W": // <-- old style                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // just "-warn" without anything else means all errors and warnings                                      WarningLevel = int.MaxValue;                                  }                                  else                                  {                                      // must be an unsigned decimal integer value                                      int warningLevel;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out warningLevel))                                      {                                          WarningLevel = warningLevel;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  levelSpecified = true;                                  break;                                //                              // Backward-compatibility switches different from new switches                              //                                case "D":                                  // equivalent to -debug:false (default behavior)                                  JSSettings.StripDebugStatements = true;                                  OnJSOnlyParameter();                                  break;                                case "E":                              case "EO":                                  // equivalent to -enc:out <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // just save the name -- we'll create the encoding later because we need                                  // to know whether we are JS or CSS to pick the right encoding fallback                                  EncodingOutputName = paramPart;                                  break;                                case "EI":                                  // equivalent to -enc:in <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // save the name                                  EncodingInputName = paramPart;                                  break;                                case "H":                                  // equivalent to -rename:all -unused:remove (default behavior)                                  JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HL":                                  // equivalent to -rename:localization -unused:remove                                  JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HC":                                  // equivalent to -literals:combine -rename:all -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "H";                                case "HLC":                              case "HCL":                                  // equivalent to -literals:combine -rename:localization -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "HL";                                case "J":                                  // equivalent to -evals:ignore (default behavior)                                  JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  OnJSOnlyParameter();                                  break;                                case "K":                                  // equivalent to -inline:true (default behavior)                                  JSSettings.InlineSafeStrings = true;                                  OnJSOnlyParameter();                                  break;                                case "L":                                  // equivalent to -new:keep (default is collapse)                                  JSSettings.CollapseToLiteral = false;                                  OnJSOnlyParameter();                                  break;                                case "M":                                  // equivalent to -mac:true (default behavior)                                  JSSettings.MacSafariQuirks = true;                                  OnJSOnlyParameter();                                  break;                                case "Z":                                  // equivalent to -term:true (default is false)                                  JSSettings.TermSemicolons =                                      CssSettings.TermSemicolons = true;                                  break;                                // end backward-compatible section                                default:                                  ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  break;                          }
Magic Number,Spike.Build.Minifiers,MinifierParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\MinifierParser.cs,Parse,The following statement contains a magic number: switch (switchPart)                          {                              case "ANALYZE":                              case "A": // <-- old-style                                  // ignore any arguments                                  AnalyzeMode = true;                                    // by default' we have no report format                                  ReportFormat = null;                                  if (paramPartUpper != null)                                  {                                      var items = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var item in items)                                      {                                          if (string.CompareOrdinal(item' "OUT") == 0)                                          {                                              // if the analyze part is "out'" then the NEXT arg string                                              // is the output path the analyze scope report should be written to.                                              if (ndx >= args.Length - 1)                                              {                                                  // must be followed by a path                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                              else                                              {                                                  ReportPath = args[++ndx];                                              }                                          }                                          else                                          {                                              // must be a report format. There can be only one' so clobber whatever                                              // is there from before -- last one listed wins.                                              ReportFormat = item;                                          }                                      }                                  }                                    // if analyze was specified but no warning level' jack up the warning level                                  // so everything is shown                                  if (!levelSpecified)                                  {                                      // we want to analyze' and we didn't specify a particular warning level.                                      // go ahead and report all errors                                      WarningLevel = int.MaxValue;                                  }                                    break;                                case "ASPNET":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // same setting for both CSS and JS                                      JSSettings.AllowEmbeddedAspNetBlocks =                                          CssSettings.AllowEmbeddedAspNetBlocks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "BRACES":                                  if (paramPartUpper == "NEW")                                  {                                      JSSettings.BlocksStartOnSameLine =                                           CssSettings.BlocksStartOnSameLine = MinifierBlockStart.NewLine;                                  }                                  else if (paramPartUpper == "SAME")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.SameLine;                                  }                                  else if (paramPartUpper == "SOURCE")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.UseSource;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "CC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // actually' the flag is the opposite of the member -- turn CC ON and we DON'T                                      // want to ignore them; turn CC OFF and we DO want to ignore them                                      JSSettings.IgnoreConditionalCompilation = !parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "COLORS":                                  // two options: hex or names                                  if (paramPartUpper == "HEX")                                  {                                      CssSettings.ColorNames = CssColor.Hex;                                  }                                  else if (paramPartUpper == "STRICT")                                  {                                      CssSettings.ColorNames = CssColor.Strict;                                  }                                  else if (paramPartUpper == "MAJOR")                                  {                                      CssSettings.ColorNames = CssColor.Major;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnCssOnlyParameter();                                  break;                                case "COMMENTS":                                  // four options for css: none' all' important' or hacks                                  // two options for js: none' important                                  // (default is important)                                  if (paramPartUpper == "NONE")                                  {                                      CssSettings.CommentMode = CssComment.None;                                      JSSettings.PreserveImportantComments = false;                                  }                                  else if (paramPartUpper == "ALL")                                  {                                      CssSettings.CommentMode = CssComment.All;                                      OnCssOnlyParameter();                                  }                                  else if (paramPartUpper == "IMPORTANT")                                  {                                      CssSettings.CommentMode = CssComment.Important;                                      JSSettings.PreserveImportantComments = true;                                  }                                  else if (paramPartUpper == "HACKS")                                  {                                      CssSettings.CommentMode = CssComment.Hacks;                                      OnCssOnlyParameter();                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    break;                                case "CONST":                                  // options: MOZ or ES6 (ES6 is the default)                                  if (paramPartUpper == "MOZ")                                  {                                      JSSettings.ConstStatementsMozilla = true;                                  }                                  else if (paramPartUpper == "ES6")                                  {                                      JSSettings.ConstStatementsMozilla = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "CSS":                                  OnCssOnlyParameter();                                  if (paramPartUpper != null)                                  {                                      switch (paramPartUpper)                                      {                                          case "FULL":                                              CssSettings.CssType = CssType.FullStyleSheet;                                              break;                                            case "DECLS":                                              CssSettings.CssType = CssType.DeclarationList;                                              break;                                            default:                                              // not an expected value                                              OnInvalidSwitch(switchPart' paramPart);                                              break;                                      }                                  }                                  break;                                case "DEBUG":                                  // see if the param part is a comma-delimited list                                  if (paramPartUpper != null && paramPartUpper.IndexOf(''') >= 0)                                  {                                      // we have a comma-separated list.                                      // the first item is the flag (if any)' and the rest (if any) are the "debug" lookup names                                      var items = paramPart.Split(listSeparators);                                        // use the first value as the debug boolean switch.                                      // since we are splitting the non-uppercase param part' we need to                                       // make sure the first item is capitalized for our boolean test.                                      if (BooleanSwitch(items[0].ToUpperInvariant()' true' out parameterFlag))                                      {                                          // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                          // strip debug statements' and a FALSE means we DO want to strip them                                          JSSettings.StripDebugStatements = !parameterFlag;                                            // make sure we align the DEBUG define to the new switch value                                          AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                        // clear out the existing debug list                                      JSSettings.DebugLookupList = null;                                        // start with index 1' since index 0 was the flag                                      for (var item = 1; item < items.Length; ++item)                                      {                                          // get the identifier that was specified                                          var identifier = items[item];                                          if (!identifier.IsNullOrWhiteSpace())                                          {                                              if (!JSSettings.AddDebugLookup(identifier))                                              {                                                  OnInvalidSwitch(switchPart' identifier);                                              }                                          }                                      }                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // no commas -- just use the entire param part as the boolean value.                                      // just putting the debug switch on the command line without any arguments                                      // is the same as putting -debug:true and perfectly valid.                                        // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                      // strip debug statements' and a FALSE means we DO want to strip them                                      JSSettings.StripDebugStatements = !parameterFlag;                                        // make sure we align the DEBUG define to the new switch value                                      AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "DEFINE":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string define in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          string trimmedName;                                          string value;                                          var ndxEquals = define.IndexOf('=');                                          if (ndxEquals < 0)                                          {                                              trimmedName = define.Trim();                                              value = string.Empty;                                          }                                          else                                          {                                              trimmedName = define.Substring(0' ndxEquals).Trim();                                              value = define.Substring(ndxEquals + 1);                                          }                                            // better be a valid JavaScript identifier                                          if (!JsScanner.IsValidIdentifier(trimmedName))                                          {                                              OnInvalidSwitch(switchPart' define);                                          }                                          else                                          {                                              // JS Settings                                              JSSettings.PreprocessorValues[trimmedName] = value;                                                // CSS settings                                              CssSettings.PreprocessorValues[trimmedName] = value;                                          }                                            // if we're defining the DEBUG name' set the strip-debug-statements flag to false                                          if (string.Compare(trimmedName' "DEBUG"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              JSSettings.StripDebugStatements = false;                                          }                                      }                                  }                                    break;                                case "ENC":                                  // the encoding is the next argument                                  if (ndx >= args.Length - 1)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      string encoding = args[++ndx];                                        // whether this is an in or an out encoding                                      if (paramPartUpper == "IN")                                      {                                          // save the name -- we'll create the encoding later because we may                                          // override it on a file-by-file basis in an XML file                                          EncodingInputName = encoding;                                      }                                      else if (paramPartUpper == "OUT")                                      {                                          // just save the name -- we'll create the encoding later because we need                                          // to know whether we are JS or CSS to pick the right encoding fallback                                          EncodingOutputName = encoding;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "ESC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.AlwaysEscapeNonAscii = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "EVALS":                                  // three options: ignore' make immediate scope safe' or make all scopes safe                                  if (paramPartUpper == "IGNORE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  }                                  else if (paramPartUpper == "IMMEDIATE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeImmediateSafe;                                  }                                  else if (paramPartUpper == "SAFEALL")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeAllSafe;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "EXPR":                                  // two options: minify (default) or raw                                  if (paramPartUpper == "MINIFY")                                  {                                      CssSettings.MinifyExpressions = true;                                  }                                  else if (paramPartUpper == "RAW")                                  {                                      CssSettings.MinifyExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    OnCssOnlyParameter();                                  break;                                case "FNAMES":                                  // three options:                                   // LOCK    -> keep all NFE names' don't allow renaming of function names                                  // KEEP    -> keep all NFE names' but allow function names to be renamed                                  // ONLYREF -> remove unref'd NFE names' allow function named to be renamed (DEFAULT)                                  if (paramPartUpper == "LOCK")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // and preserve the names (don't allow renaming)                                      JSSettings.PreserveFunctionNames = true;                                  }                                  else if (paramPartUpper == "KEEP")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // but it's okay to rename them                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      // remove function expression names if they aren't referenced                                      JSSettings.RemoveFunctionExpressionNames = true;                                        // and rename them if we so desire                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "GLOBAL":                              case "G": // <-- old style                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string global in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddKnownGlobal(global))                                          {                                              OnInvalidSwitch(switchPart' global);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "IGNORE":                                  // list of error codes to ignore (not report)                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string errorCode in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.Compare(errorCode' "ALL"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              // we want to ignore ALL errors. So set the appropriate flag                                              JSSettings.IgnoreAllErrors =                                                  CssSettings.IgnoreAllErrors = true;                                          }                                          else                                          {                                              // don't add duplicates                                              JSSettings.IgnoreErrorCollection.Add(errorCode);                                              CssSettings.IgnoreErrorCollection.Add(errorCode);                                          }                                      }                                  }                                  break;                                case "INLINE":                                  if (string.IsNullOrEmpty(paramPart))                                  {                                      // no param parts. This defaults to inline-safe                                      JSSettings.InlineSafeStrings = true;                                  }                                  else                                  {                                      // for each comma-separated part...                                      foreach (var inlinePart in paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.CompareOrdinal(inlinePart' "FORCE") == 0)                                          {                                              // this is the force flag -- throw an error if any string literal                                              // sources are not properly escaped AND make sure the output is                                               // safe                                              JSSettings.ErrorIfNotInlineSafe = true;                                              JSSettings.InlineSafeStrings = true;                                          }                                          else if (string.CompareOrdinal(inlinePart' "NOFORCE") == 0)                                          {                                              // this is the noforce flag; don't throw an error is the source isn't inline safe.                                              // don't change whatever the output-inline-safe flag may happen to be' though                                              JSSettings.ErrorIfNotInlineSafe = false;                                          }                                          else                                          {                                              // assume it must be the boolean flag.                                              // if no param part' will return true (indicating the default)                                              // if invalid param part' will throw error                                              if (BooleanSwitch(inlinePart' true' out parameterFlag))                                              {                                                  JSSettings.InlineSafeStrings = parameterFlag;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "JS":                                  if (paramPart == null)                                  {                                      // normal settings                                      JSSettings.SourceMode = JsSourceMode.Program;                                      JSSettings.Format = JsFormat.Normal;                                  }                                  else                                  {                                      // comma-delimited list of JS settings                                      var tokens = paramPartUpper.Split('''' ';');                                      foreach (var token in tokens)                                      {                                          switch (token)                                          {                                              case "JSON":                                                  // JSON is incompatible with any other tokens' so throw an error                                                  // if it's not the only token                                                  if (tokens.Length > 1)                                                  {                                                      OnInvalidSwitch(switchPart' paramPart);                                                  }                                                    // nothing to "minify" in the JSON format' so turn off the minify flag                                                  JSSettings.MinifyCode = false;                                                    // JSON affects both the input (it's an expression) and the output                                                  // (use the JSON-output visitor)                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  JSSettings.Format = JsFormat.JSON;                                                  break;                                                case "PROG":                                                  // this is the default setting                                                  JSSettings.SourceMode = JsSourceMode.Program;                                                  break;                                                case "EXPR":                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  break;                                                case "EVT":                                                  JSSettings.SourceMode = JsSourceMode.EventHandler;                                                  break;                                                default:                                                  // later: ES5 to convert any ES6 syntax to ES5-compatible                                                  // later: ES6 to create ES6 syntax when optimizing                                                  // etc.                                                  // those two examples will affect the format property.                                                  // but for now' not supported                                                  OnInvalidSwitch(switchPart' paramPart);                                                  break;                                          }                                      }                                  }                                    OnJSOnlyParameter();                                  break;                                case "KILL":                                  killSpecified = true;                                    // optional integer switch argument                                  if (paramPartUpper == null)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      // get the numeric portion                                      long killSwitch;                                      if (paramPartUpper.StartsWith("0X"' StringComparison.OrdinalIgnoreCase))                                      {                                          // it's hex -- convert the number after the "0x"                                          if (paramPartUpper.Substring(2).TryParseLongInvariant(NumberStyles.AllowHexSpecifier' out killSwitch))                                          {                                              // save the switch for both JS and Css                                              JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                                // for CSS' we only look at the first bit: preeserve important comments                                              if ((killSwitch & 1) != 0)                                              {                                                  // we set the kill' so make sure the comments are set to none                                                  CssSettings.CommentMode = CssComment.None;                                              }                                          }                                          else                                          {                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                      else if (paramPartUpper.TryParseLongInvariant(NumberStyles.AllowLeadingSign' out killSwitch))                                      {                                          // save the switch for both JS and CSS                                          JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                            // for CSS' we only look at the first bit: preeserve important comments                                          if ((killSwitch & 1) != 0)                                          {                                              // we set the kill' so make sure the comments are set to none                                              CssSettings.CommentMode = CssComment.None;                                          }                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LINE":                              case "LINES":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // if no number specified' use the max default threshold                                      JSSettings.LineBreakThreshold =                                          CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                                                            // single-line mode                                      JSSettings.OutputMode =                                           CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                        // and four spaces per indent level                                      JSSettings.IndentSize =                                          CssSettings.IndentSize = 4;                                  }                                  else                                  {                                      // split along commas (case-insensitive)                                      var lineParts = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                        // by default' the line-break index will be 1 (the second option).                                      // we will change this index to 0 if the first parameter is multi/single                                      // instead of the line-break character count.                                      var breakIndex = 1;                                      if (lineParts.Length <= 3)                                      {                                          // if the first optional part is numeric' then it's the line threshold.                                          // might also be "multi" or "single"' thereby skipping the line threshold.                                          // (don't need to check length greater than zero -- will always be at least one element returned from Split)                                          if (!string.IsNullOrEmpty(lineParts[0]))                                          {                                              // must be an unsigned decimal integer value                                              int lineThreshold;                                              if (lineParts[0].TryParseIntInvariant(NumberStyles.None' out lineThreshold))                                              {                                                  JSSettings.LineBreakThreshold =                                                      CssSettings.LineBreakThreshold = lineThreshold;                                              }                                              else if (lineParts[0][0] == 'S')                                              {                                                  // single-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else if (lineParts[0][0] == 'M')                                              {                                                  // multiple-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' lineParts[0]);                                              }                                          }                                          else                                          {                                              // use the default                                              JSSettings.LineBreakThreshold =                                                  CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                          }                                            if (lineParts.Length > breakIndex)                                          {                                              // if the line-break index was zero' then we already processed it                                              // and we can skip the logic                                              if (breakIndex > 0)                                              {                                                  // second optional part is single or multiple line output                                                  if (string.IsNullOrEmpty(lineParts[breakIndex]) || lineParts[breakIndex][0] == 'S')                                                  {                                                      // single-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                  }                                                  else if (lineParts[breakIndex][0] == 'M')                                                  {                                                      // multiple-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                  }                                                  else                                                  {                                                      // must either be missing' or start with S (single) or M (multiple)                                                      OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                  }                                              }                                                // move on to the next part                                              ++breakIndex;                                              if (lineParts.Length > breakIndex)                                              {                                                  // third optional part is the spaces-per-indent value                                                  if (!string.IsNullOrEmpty(lineParts[breakIndex]))                                                  {                                                      // get the numeric portion; must be a decimal integer                                                      int indentSize;                                                      if (lineParts[breakIndex].TryParseIntInvariant(NumberStyles.None' out indentSize))                                                      {                                                          // same value for JS and CSS.                                                          // don't need to check for negative' because the tryparse method above does NOT                                                          // allow for a sign -- no sign' no negative.                                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                                      }                                                      else                                                      {                                                          OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                      }                                                  }                                                  else                                                  {                                                      // default of 4                                                      JSSettings.IndentSize =                                                          CssSettings.IndentSize = 4;                                                  }                                              }                                          }                                      }                                      else                                      {                                          // only 1-3 parts allowed                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LITERALS":                                  // two areas with two options each: keep or combine and eval or noeval                                  if (paramPartUpper == "KEEP")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = false;                                  }                                  else if (paramPartUpper == "COMBINE")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = true;                                  }                                  else if (paramPartUpper == "EVAL")                                  {                                      JSSettings.EvalLiteralExpressions = true;                                  }                                  else if (paramPartUpper == "NOEVAL")                                  {                                      JSSettings.EvalLiteralExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MAC":                                  // optional boolean switch                                  // no arg is valid scenario (default is true)                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.MacSafariQuirks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MINIFY":                                  minifySpecified = true;                                  if (renamingSpecified && JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      // minify can only exist if rename is set to KeepAll                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // optional boolean switch                                      // no arg is a valid scenario (default is true)                                      JSSettings.MinifyCode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NEW":                                  // two options: keep and collapse                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.CollapseToLiteral = false;                                  }                                  else if (paramPartUpper == "COLLAPSE")                                  {                                      JSSettings.CollapseToLiteral = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NFE": // <-- deprecate; use FNAMES option instead                                  if (paramPartUpper == "KEEPALL")                                  {                                      JSSettings.RemoveFunctionExpressionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      JSSettings.RemoveFunctionExpressionNames = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NORENAME":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string ident in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddNoAutoRename(ident))                                          {                                              OnInvalidSwitch(switchPart' ident);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "OBJ":                                  // two options: MINify or QUOTE                                  if (paramPartUpper == "MIN")                                  {                                      JSSettings.QuoteObjectLiteralProperties = false;                                  }                                  else if (paramPartUpper == "QUOTE")                                  {                                      JSSettings.QuoteObjectLiteralProperties = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PPONLY":                                  // just putting the pponly switch on the command line without any arguments                                  // is the same as putting -pponly:true and perfectly valid.                                  if (paramPart == null)                                  {                                      JSSettings.PreprocessOnly = true;                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.PreprocessOnly = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PRETTY":                              case "P": // <-- old style                                  // doesn't take a flag -- just set to pretty                                  PrettyPrint = true;                                                // by default' pretty mode turns off minification' which sets a bunch of other flags as well                                  JSSettings.MinifyCode = false;                                    // and some other flags for pretty-mode                                  JSSettings.OutputMode = CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                  CssSettings.KillSwitch = ~((long)JsTreeModifications.PreserveImportantComments);                                    // optional integer switch argument                                  if (paramPartUpper != null)                                  {                                      // get the numeric portion; must be a decimal integer                                      int indentSize;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out indentSize))                                      {                                          // same value for JS and CSS.                                          // don't need to check for negative' because the tryparse method above does NOT                                          // allow for a sign -- no sign' no negative.                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                      }                                      else                                       {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "RENAME":                                  if (paramPartUpper == null)                                  {                                      // treat as if it's unknown                                      ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  }                                  else if (paramPartUpper.IndexOf('=') > 0)                                  {                                      // there is at least one equal sign -- treat this as a set of JS identifier                                      // pairs. split on commas -- multiple pairs can be specified                                      var paramPairs = paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var paramPair in paramPairs)                                      {                                          // split on the equal sign -- each pair needs to have an equal sige                                          var pairParts = paramPair.Split('=');                                          if (pairParts.Length == 2)                                          {                                              // there is an equal sign. The first part is the source name and the                                              // second part is the new name to which to rename those entities.                                              string fromIdentifier = pairParts[0];                                              string toIdentifier = pairParts[1];                                                // make sure both parts are valid JS identifiers                                              var fromIsValid = JsScanner.IsValidIdentifier(fromIdentifier);                                              var toIsValid = JsScanner.IsValidIdentifier(toIdentifier);                                              if (fromIsValid && toIsValid)                                              {                                                  // create the map if it hasn't been created yet.                                                  var toExisting = JSSettings.GetNewName(fromIdentifier);                                                  if (toExisting == null)                                                  {                                                      JSSettings.AddRenamePair(fromIdentifier' toIdentifier);                                                  }                                                  else if (string.CompareOrdinal(toIdentifier' toExisting) != 0)                                                  {                                                      // from-identifier already exists' and the to-identifier doesn't match.                                                      // can't rename the same name to two different names!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                              else                                              {                                                  if (fromIsValid)                                                  {                                                      // the toIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' toIdentifier);                                                  }                                                    if (toIsValid)                                                  {                                                      // the fromIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                          }                                          else                                          {                                              // either zero or more than one equal sign. Invalid.                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                  }                                  else                                  {                                      // no equal sign; just a plain option                                      // three options: all' localization' none                                      if (paramPartUpper == "ALL")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "LOCALIZATION")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NONE")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NOPROPS")                                      {                                          // manual-renaming does not change property names                                          JSSettings.ManualRenamesProperties = false;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  if (JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      ResetRenamingKill(killSpecified);                                        // if minify was specified as turned off' then this is invalid                                      if (minifySpecified && !JSSettings.MinifyCode)                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "REORDER":                                  // default is true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.ReorderScopeDeclarations = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "STRICT":                                  // default is false' but if we specify this switch without a parameter' then                                  // we assume we are turning it ON                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.StrictMode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "TERM":                                  // optional boolean argument' defaults to true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.TermSemicolons =                                          CssSettings.TermSemicolons = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "UNUSED":                                  // two options: keep and remove                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.RemoveUnneededCode = false;                                  }                                  else if (paramPartUpper == "REMOVE")                                  {                                      JSSettings.RemoveUnneededCode = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "VAR":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      var firstLetters = paramPart;                                      string partLetters = null;                                        var commaPosition = paramPart.IndexOf(''');                                      if (commaPosition == 0)                                      {                                          // no first letters; just part letters                                          firstLetters = null;                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                      else if (commaPosition > 0)                                      {                                          // first letters and part letters                                          firstLetters = paramPart.Substring(0' commaPosition);                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                        // if we specified first letters' set them now                                      if (!string.IsNullOrEmpty(firstLetters))                                      {                                          JsCrunchEnumerator.FirstLetters = firstLetters;                                      }                                        // if we specified part letters' use it -- otherwise use the first letters.                                      if (!string.IsNullOrEmpty(partLetters))                                      {                                          JsCrunchEnumerator.PartLetters = partLetters;                                      }                                      else if (!string.IsNullOrEmpty(firstLetters))                                      {                                          // we don't have any part letters' but we do have first letters. reuse.                                          JsCrunchEnumerator.PartLetters = firstLetters;                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "WARN":                              case "W": // <-- old style                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // just "-warn" without anything else means all errors and warnings                                      WarningLevel = int.MaxValue;                                  }                                  else                                  {                                      // must be an unsigned decimal integer value                                      int warningLevel;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out warningLevel))                                      {                                          WarningLevel = warningLevel;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  levelSpecified = true;                                  break;                                //                              // Backward-compatibility switches different from new switches                              //                                case "D":                                  // equivalent to -debug:false (default behavior)                                  JSSettings.StripDebugStatements = true;                                  OnJSOnlyParameter();                                  break;                                case "E":                              case "EO":                                  // equivalent to -enc:out <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // just save the name -- we'll create the encoding later because we need                                  // to know whether we are JS or CSS to pick the right encoding fallback                                  EncodingOutputName = paramPart;                                  break;                                case "EI":                                  // equivalent to -enc:in <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // save the name                                  EncodingInputName = paramPart;                                  break;                                case "H":                                  // equivalent to -rename:all -unused:remove (default behavior)                                  JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HL":                                  // equivalent to -rename:localization -unused:remove                                  JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HC":                                  // equivalent to -literals:combine -rename:all -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "H";                                case "HLC":                              case "HCL":                                  // equivalent to -literals:combine -rename:localization -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "HL";                                case "J":                                  // equivalent to -evals:ignore (default behavior)                                  JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  OnJSOnlyParameter();                                  break;                                case "K":                                  // equivalent to -inline:true (default behavior)                                  JSSettings.InlineSafeStrings = true;                                  OnJSOnlyParameter();                                  break;                                case "L":                                  // equivalent to -new:keep (default is collapse)                                  JSSettings.CollapseToLiteral = false;                                  OnJSOnlyParameter();                                  break;                                case "M":                                  // equivalent to -mac:true (default behavior)                                  JSSettings.MacSafariQuirks = true;                                  OnJSOnlyParameter();                                  break;                                case "Z":                                  // equivalent to -term:true (default is false)                                  JSSettings.TermSemicolons =                                      CssSettings.TermSemicolons = true;                                  break;                                // end backward-compatible section                                default:                                  ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  break;                          }
Magic Number,Spike.Build.Minifiers,MinifierParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\MinifierParser.cs,Parse,The following statement contains a magic number: switch (switchPart)                          {                              case "ANALYZE":                              case "A": // <-- old-style                                  // ignore any arguments                                  AnalyzeMode = true;                                    // by default' we have no report format                                  ReportFormat = null;                                  if (paramPartUpper != null)                                  {                                      var items = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var item in items)                                      {                                          if (string.CompareOrdinal(item' "OUT") == 0)                                          {                                              // if the analyze part is "out'" then the NEXT arg string                                              // is the output path the analyze scope report should be written to.                                              if (ndx >= args.Length - 1)                                              {                                                  // must be followed by a path                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                              else                                              {                                                  ReportPath = args[++ndx];                                              }                                          }                                          else                                          {                                              // must be a report format. There can be only one' so clobber whatever                                              // is there from before -- last one listed wins.                                              ReportFormat = item;                                          }                                      }                                  }                                    // if analyze was specified but no warning level' jack up the warning level                                  // so everything is shown                                  if (!levelSpecified)                                  {                                      // we want to analyze' and we didn't specify a particular warning level.                                      // go ahead and report all errors                                      WarningLevel = int.MaxValue;                                  }                                    break;                                case "ASPNET":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // same setting for both CSS and JS                                      JSSettings.AllowEmbeddedAspNetBlocks =                                          CssSettings.AllowEmbeddedAspNetBlocks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "BRACES":                                  if (paramPartUpper == "NEW")                                  {                                      JSSettings.BlocksStartOnSameLine =                                           CssSettings.BlocksStartOnSameLine = MinifierBlockStart.NewLine;                                  }                                  else if (paramPartUpper == "SAME")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.SameLine;                                  }                                  else if (paramPartUpper == "SOURCE")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.UseSource;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "CC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // actually' the flag is the opposite of the member -- turn CC ON and we DON'T                                      // want to ignore them; turn CC OFF and we DO want to ignore them                                      JSSettings.IgnoreConditionalCompilation = !parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "COLORS":                                  // two options: hex or names                                  if (paramPartUpper == "HEX")                                  {                                      CssSettings.ColorNames = CssColor.Hex;                                  }                                  else if (paramPartUpper == "STRICT")                                  {                                      CssSettings.ColorNames = CssColor.Strict;                                  }                                  else if (paramPartUpper == "MAJOR")                                  {                                      CssSettings.ColorNames = CssColor.Major;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnCssOnlyParameter();                                  break;                                case "COMMENTS":                                  // four options for css: none' all' important' or hacks                                  // two options for js: none' important                                  // (default is important)                                  if (paramPartUpper == "NONE")                                  {                                      CssSettings.CommentMode = CssComment.None;                                      JSSettings.PreserveImportantComments = false;                                  }                                  else if (paramPartUpper == "ALL")                                  {                                      CssSettings.CommentMode = CssComment.All;                                      OnCssOnlyParameter();                                  }                                  else if (paramPartUpper == "IMPORTANT")                                  {                                      CssSettings.CommentMode = CssComment.Important;                                      JSSettings.PreserveImportantComments = true;                                  }                                  else if (paramPartUpper == "HACKS")                                  {                                      CssSettings.CommentMode = CssComment.Hacks;                                      OnCssOnlyParameter();                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    break;                                case "CONST":                                  // options: MOZ or ES6 (ES6 is the default)                                  if (paramPartUpper == "MOZ")                                  {                                      JSSettings.ConstStatementsMozilla = true;                                  }                                  else if (paramPartUpper == "ES6")                                  {                                      JSSettings.ConstStatementsMozilla = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "CSS":                                  OnCssOnlyParameter();                                  if (paramPartUpper != null)                                  {                                      switch (paramPartUpper)                                      {                                          case "FULL":                                              CssSettings.CssType = CssType.FullStyleSheet;                                              break;                                            case "DECLS":                                              CssSettings.CssType = CssType.DeclarationList;                                              break;                                            default:                                              // not an expected value                                              OnInvalidSwitch(switchPart' paramPart);                                              break;                                      }                                  }                                  break;                                case "DEBUG":                                  // see if the param part is a comma-delimited list                                  if (paramPartUpper != null && paramPartUpper.IndexOf(''') >= 0)                                  {                                      // we have a comma-separated list.                                      // the first item is the flag (if any)' and the rest (if any) are the "debug" lookup names                                      var items = paramPart.Split(listSeparators);                                        // use the first value as the debug boolean switch.                                      // since we are splitting the non-uppercase param part' we need to                                       // make sure the first item is capitalized for our boolean test.                                      if (BooleanSwitch(items[0].ToUpperInvariant()' true' out parameterFlag))                                      {                                          // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                          // strip debug statements' and a FALSE means we DO want to strip them                                          JSSettings.StripDebugStatements = !parameterFlag;                                            // make sure we align the DEBUG define to the new switch value                                          AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                        // clear out the existing debug list                                      JSSettings.DebugLookupList = null;                                        // start with index 1' since index 0 was the flag                                      for (var item = 1; item < items.Length; ++item)                                      {                                          // get the identifier that was specified                                          var identifier = items[item];                                          if (!identifier.IsNullOrWhiteSpace())                                          {                                              if (!JSSettings.AddDebugLookup(identifier))                                              {                                                  OnInvalidSwitch(switchPart' identifier);                                              }                                          }                                      }                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // no commas -- just use the entire param part as the boolean value.                                      // just putting the debug switch on the command line without any arguments                                      // is the same as putting -debug:true and perfectly valid.                                        // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                      // strip debug statements' and a FALSE means we DO want to strip them                                      JSSettings.StripDebugStatements = !parameterFlag;                                        // make sure we align the DEBUG define to the new switch value                                      AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "DEFINE":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string define in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          string trimmedName;                                          string value;                                          var ndxEquals = define.IndexOf('=');                                          if (ndxEquals < 0)                                          {                                              trimmedName = define.Trim();                                              value = string.Empty;                                          }                                          else                                          {                                              trimmedName = define.Substring(0' ndxEquals).Trim();                                              value = define.Substring(ndxEquals + 1);                                          }                                            // better be a valid JavaScript identifier                                          if (!JsScanner.IsValidIdentifier(trimmedName))                                          {                                              OnInvalidSwitch(switchPart' define);                                          }                                          else                                          {                                              // JS Settings                                              JSSettings.PreprocessorValues[trimmedName] = value;                                                // CSS settings                                              CssSettings.PreprocessorValues[trimmedName] = value;                                          }                                            // if we're defining the DEBUG name' set the strip-debug-statements flag to false                                          if (string.Compare(trimmedName' "DEBUG"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              JSSettings.StripDebugStatements = false;                                          }                                      }                                  }                                    break;                                case "ENC":                                  // the encoding is the next argument                                  if (ndx >= args.Length - 1)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      string encoding = args[++ndx];                                        // whether this is an in or an out encoding                                      if (paramPartUpper == "IN")                                      {                                          // save the name -- we'll create the encoding later because we may                                          // override it on a file-by-file basis in an XML file                                          EncodingInputName = encoding;                                      }                                      else if (paramPartUpper == "OUT")                                      {                                          // just save the name -- we'll create the encoding later because we need                                          // to know whether we are JS or CSS to pick the right encoding fallback                                          EncodingOutputName = encoding;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "ESC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.AlwaysEscapeNonAscii = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "EVALS":                                  // three options: ignore' make immediate scope safe' or make all scopes safe                                  if (paramPartUpper == "IGNORE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  }                                  else if (paramPartUpper == "IMMEDIATE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeImmediateSafe;                                  }                                  else if (paramPartUpper == "SAFEALL")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeAllSafe;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "EXPR":                                  // two options: minify (default) or raw                                  if (paramPartUpper == "MINIFY")                                  {                                      CssSettings.MinifyExpressions = true;                                  }                                  else if (paramPartUpper == "RAW")                                  {                                      CssSettings.MinifyExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    OnCssOnlyParameter();                                  break;                                case "FNAMES":                                  // three options:                                   // LOCK    -> keep all NFE names' don't allow renaming of function names                                  // KEEP    -> keep all NFE names' but allow function names to be renamed                                  // ONLYREF -> remove unref'd NFE names' allow function named to be renamed (DEFAULT)                                  if (paramPartUpper == "LOCK")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // and preserve the names (don't allow renaming)                                      JSSettings.PreserveFunctionNames = true;                                  }                                  else if (paramPartUpper == "KEEP")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // but it's okay to rename them                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      // remove function expression names if they aren't referenced                                      JSSettings.RemoveFunctionExpressionNames = true;                                        // and rename them if we so desire                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "GLOBAL":                              case "G": // <-- old style                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string global in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddKnownGlobal(global))                                          {                                              OnInvalidSwitch(switchPart' global);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "IGNORE":                                  // list of error codes to ignore (not report)                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string errorCode in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.Compare(errorCode' "ALL"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              // we want to ignore ALL errors. So set the appropriate flag                                              JSSettings.IgnoreAllErrors =                                                  CssSettings.IgnoreAllErrors = true;                                          }                                          else                                          {                                              // don't add duplicates                                              JSSettings.IgnoreErrorCollection.Add(errorCode);                                              CssSettings.IgnoreErrorCollection.Add(errorCode);                                          }                                      }                                  }                                  break;                                case "INLINE":                                  if (string.IsNullOrEmpty(paramPart))                                  {                                      // no param parts. This defaults to inline-safe                                      JSSettings.InlineSafeStrings = true;                                  }                                  else                                  {                                      // for each comma-separated part...                                      foreach (var inlinePart in paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.CompareOrdinal(inlinePart' "FORCE") == 0)                                          {                                              // this is the force flag -- throw an error if any string literal                                              // sources are not properly escaped AND make sure the output is                                               // safe                                              JSSettings.ErrorIfNotInlineSafe = true;                                              JSSettings.InlineSafeStrings = true;                                          }                                          else if (string.CompareOrdinal(inlinePart' "NOFORCE") == 0)                                          {                                              // this is the noforce flag; don't throw an error is the source isn't inline safe.                                              // don't change whatever the output-inline-safe flag may happen to be' though                                              JSSettings.ErrorIfNotInlineSafe = false;                                          }                                          else                                          {                                              // assume it must be the boolean flag.                                              // if no param part' will return true (indicating the default)                                              // if invalid param part' will throw error                                              if (BooleanSwitch(inlinePart' true' out parameterFlag))                                              {                                                  JSSettings.InlineSafeStrings = parameterFlag;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "JS":                                  if (paramPart == null)                                  {                                      // normal settings                                      JSSettings.SourceMode = JsSourceMode.Program;                                      JSSettings.Format = JsFormat.Normal;                                  }                                  else                                  {                                      // comma-delimited list of JS settings                                      var tokens = paramPartUpper.Split('''' ';');                                      foreach (var token in tokens)                                      {                                          switch (token)                                          {                                              case "JSON":                                                  // JSON is incompatible with any other tokens' so throw an error                                                  // if it's not the only token                                                  if (tokens.Length > 1)                                                  {                                                      OnInvalidSwitch(switchPart' paramPart);                                                  }                                                    // nothing to "minify" in the JSON format' so turn off the minify flag                                                  JSSettings.MinifyCode = false;                                                    // JSON affects both the input (it's an expression) and the output                                                  // (use the JSON-output visitor)                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  JSSettings.Format = JsFormat.JSON;                                                  break;                                                case "PROG":                                                  // this is the default setting                                                  JSSettings.SourceMode = JsSourceMode.Program;                                                  break;                                                case "EXPR":                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  break;                                                case "EVT":                                                  JSSettings.SourceMode = JsSourceMode.EventHandler;                                                  break;                                                default:                                                  // later: ES5 to convert any ES6 syntax to ES5-compatible                                                  // later: ES6 to create ES6 syntax when optimizing                                                  // etc.                                                  // those two examples will affect the format property.                                                  // but for now' not supported                                                  OnInvalidSwitch(switchPart' paramPart);                                                  break;                                          }                                      }                                  }                                    OnJSOnlyParameter();                                  break;                                case "KILL":                                  killSpecified = true;                                    // optional integer switch argument                                  if (paramPartUpper == null)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      // get the numeric portion                                      long killSwitch;                                      if (paramPartUpper.StartsWith("0X"' StringComparison.OrdinalIgnoreCase))                                      {                                          // it's hex -- convert the number after the "0x"                                          if (paramPartUpper.Substring(2).TryParseLongInvariant(NumberStyles.AllowHexSpecifier' out killSwitch))                                          {                                              // save the switch for both JS and Css                                              JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                                // for CSS' we only look at the first bit: preeserve important comments                                              if ((killSwitch & 1) != 0)                                              {                                                  // we set the kill' so make sure the comments are set to none                                                  CssSettings.CommentMode = CssComment.None;                                              }                                          }                                          else                                          {                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                      else if (paramPartUpper.TryParseLongInvariant(NumberStyles.AllowLeadingSign' out killSwitch))                                      {                                          // save the switch for both JS and CSS                                          JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                            // for CSS' we only look at the first bit: preeserve important comments                                          if ((killSwitch & 1) != 0)                                          {                                              // we set the kill' so make sure the comments are set to none                                              CssSettings.CommentMode = CssComment.None;                                          }                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LINE":                              case "LINES":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // if no number specified' use the max default threshold                                      JSSettings.LineBreakThreshold =                                          CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                                                            // single-line mode                                      JSSettings.OutputMode =                                           CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                        // and four spaces per indent level                                      JSSettings.IndentSize =                                          CssSettings.IndentSize = 4;                                  }                                  else                                  {                                      // split along commas (case-insensitive)                                      var lineParts = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                        // by default' the line-break index will be 1 (the second option).                                      // we will change this index to 0 if the first parameter is multi/single                                      // instead of the line-break character count.                                      var breakIndex = 1;                                      if (lineParts.Length <= 3)                                      {                                          // if the first optional part is numeric' then it's the line threshold.                                          // might also be "multi" or "single"' thereby skipping the line threshold.                                          // (don't need to check length greater than zero -- will always be at least one element returned from Split)                                          if (!string.IsNullOrEmpty(lineParts[0]))                                          {                                              // must be an unsigned decimal integer value                                              int lineThreshold;                                              if (lineParts[0].TryParseIntInvariant(NumberStyles.None' out lineThreshold))                                              {                                                  JSSettings.LineBreakThreshold =                                                      CssSettings.LineBreakThreshold = lineThreshold;                                              }                                              else if (lineParts[0][0] == 'S')                                              {                                                  // single-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else if (lineParts[0][0] == 'M')                                              {                                                  // multiple-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' lineParts[0]);                                              }                                          }                                          else                                          {                                              // use the default                                              JSSettings.LineBreakThreshold =                                                  CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                          }                                            if (lineParts.Length > breakIndex)                                          {                                              // if the line-break index was zero' then we already processed it                                              // and we can skip the logic                                              if (breakIndex > 0)                                              {                                                  // second optional part is single or multiple line output                                                  if (string.IsNullOrEmpty(lineParts[breakIndex]) || lineParts[breakIndex][0] == 'S')                                                  {                                                      // single-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                  }                                                  else if (lineParts[breakIndex][0] == 'M')                                                  {                                                      // multiple-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                  }                                                  else                                                  {                                                      // must either be missing' or start with S (single) or M (multiple)                                                      OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                  }                                              }                                                // move on to the next part                                              ++breakIndex;                                              if (lineParts.Length > breakIndex)                                              {                                                  // third optional part is the spaces-per-indent value                                                  if (!string.IsNullOrEmpty(lineParts[breakIndex]))                                                  {                                                      // get the numeric portion; must be a decimal integer                                                      int indentSize;                                                      if (lineParts[breakIndex].TryParseIntInvariant(NumberStyles.None' out indentSize))                                                      {                                                          // same value for JS and CSS.                                                          // don't need to check for negative' because the tryparse method above does NOT                                                          // allow for a sign -- no sign' no negative.                                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                                      }                                                      else                                                      {                                                          OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                      }                                                  }                                                  else                                                  {                                                      // default of 4                                                      JSSettings.IndentSize =                                                          CssSettings.IndentSize = 4;                                                  }                                              }                                          }                                      }                                      else                                      {                                          // only 1-3 parts allowed                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LITERALS":                                  // two areas with two options each: keep or combine and eval or noeval                                  if (paramPartUpper == "KEEP")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = false;                                  }                                  else if (paramPartUpper == "COMBINE")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = true;                                  }                                  else if (paramPartUpper == "EVAL")                                  {                                      JSSettings.EvalLiteralExpressions = true;                                  }                                  else if (paramPartUpper == "NOEVAL")                                  {                                      JSSettings.EvalLiteralExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MAC":                                  // optional boolean switch                                  // no arg is valid scenario (default is true)                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.MacSafariQuirks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MINIFY":                                  minifySpecified = true;                                  if (renamingSpecified && JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      // minify can only exist if rename is set to KeepAll                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // optional boolean switch                                      // no arg is a valid scenario (default is true)                                      JSSettings.MinifyCode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NEW":                                  // two options: keep and collapse                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.CollapseToLiteral = false;                                  }                                  else if (paramPartUpper == "COLLAPSE")                                  {                                      JSSettings.CollapseToLiteral = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NFE": // <-- deprecate; use FNAMES option instead                                  if (paramPartUpper == "KEEPALL")                                  {                                      JSSettings.RemoveFunctionExpressionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      JSSettings.RemoveFunctionExpressionNames = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NORENAME":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string ident in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddNoAutoRename(ident))                                          {                                              OnInvalidSwitch(switchPart' ident);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "OBJ":                                  // two options: MINify or QUOTE                                  if (paramPartUpper == "MIN")                                  {                                      JSSettings.QuoteObjectLiteralProperties = false;                                  }                                  else if (paramPartUpper == "QUOTE")                                  {                                      JSSettings.QuoteObjectLiteralProperties = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PPONLY":                                  // just putting the pponly switch on the command line without any arguments                                  // is the same as putting -pponly:true and perfectly valid.                                  if (paramPart == null)                                  {                                      JSSettings.PreprocessOnly = true;                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.PreprocessOnly = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PRETTY":                              case "P": // <-- old style                                  // doesn't take a flag -- just set to pretty                                  PrettyPrint = true;                                                // by default' pretty mode turns off minification' which sets a bunch of other flags as well                                  JSSettings.MinifyCode = false;                                    // and some other flags for pretty-mode                                  JSSettings.OutputMode = CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                  CssSettings.KillSwitch = ~((long)JsTreeModifications.PreserveImportantComments);                                    // optional integer switch argument                                  if (paramPartUpper != null)                                  {                                      // get the numeric portion; must be a decimal integer                                      int indentSize;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out indentSize))                                      {                                          // same value for JS and CSS.                                          // don't need to check for negative' because the tryparse method above does NOT                                          // allow for a sign -- no sign' no negative.                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                      }                                      else                                       {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "RENAME":                                  if (paramPartUpper == null)                                  {                                      // treat as if it's unknown                                      ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  }                                  else if (paramPartUpper.IndexOf('=') > 0)                                  {                                      // there is at least one equal sign -- treat this as a set of JS identifier                                      // pairs. split on commas -- multiple pairs can be specified                                      var paramPairs = paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var paramPair in paramPairs)                                      {                                          // split on the equal sign -- each pair needs to have an equal sige                                          var pairParts = paramPair.Split('=');                                          if (pairParts.Length == 2)                                          {                                              // there is an equal sign. The first part is the source name and the                                              // second part is the new name to which to rename those entities.                                              string fromIdentifier = pairParts[0];                                              string toIdentifier = pairParts[1];                                                // make sure both parts are valid JS identifiers                                              var fromIsValid = JsScanner.IsValidIdentifier(fromIdentifier);                                              var toIsValid = JsScanner.IsValidIdentifier(toIdentifier);                                              if (fromIsValid && toIsValid)                                              {                                                  // create the map if it hasn't been created yet.                                                  var toExisting = JSSettings.GetNewName(fromIdentifier);                                                  if (toExisting == null)                                                  {                                                      JSSettings.AddRenamePair(fromIdentifier' toIdentifier);                                                  }                                                  else if (string.CompareOrdinal(toIdentifier' toExisting) != 0)                                                  {                                                      // from-identifier already exists' and the to-identifier doesn't match.                                                      // can't rename the same name to two different names!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                              else                                              {                                                  if (fromIsValid)                                                  {                                                      // the toIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' toIdentifier);                                                  }                                                    if (toIsValid)                                                  {                                                      // the fromIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                          }                                          else                                          {                                              // either zero or more than one equal sign. Invalid.                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                  }                                  else                                  {                                      // no equal sign; just a plain option                                      // three options: all' localization' none                                      if (paramPartUpper == "ALL")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "LOCALIZATION")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NONE")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NOPROPS")                                      {                                          // manual-renaming does not change property names                                          JSSettings.ManualRenamesProperties = false;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  if (JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      ResetRenamingKill(killSpecified);                                        // if minify was specified as turned off' then this is invalid                                      if (minifySpecified && !JSSettings.MinifyCode)                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "REORDER":                                  // default is true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.ReorderScopeDeclarations = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "STRICT":                                  // default is false' but if we specify this switch without a parameter' then                                  // we assume we are turning it ON                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.StrictMode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "TERM":                                  // optional boolean argument' defaults to true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.TermSemicolons =                                          CssSettings.TermSemicolons = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "UNUSED":                                  // two options: keep and remove                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.RemoveUnneededCode = false;                                  }                                  else if (paramPartUpper == "REMOVE")                                  {                                      JSSettings.RemoveUnneededCode = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "VAR":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      var firstLetters = paramPart;                                      string partLetters = null;                                        var commaPosition = paramPart.IndexOf(''');                                      if (commaPosition == 0)                                      {                                          // no first letters; just part letters                                          firstLetters = null;                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                      else if (commaPosition > 0)                                      {                                          // first letters and part letters                                          firstLetters = paramPart.Substring(0' commaPosition);                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                        // if we specified first letters' set them now                                      if (!string.IsNullOrEmpty(firstLetters))                                      {                                          JsCrunchEnumerator.FirstLetters = firstLetters;                                      }                                        // if we specified part letters' use it -- otherwise use the first letters.                                      if (!string.IsNullOrEmpty(partLetters))                                      {                                          JsCrunchEnumerator.PartLetters = partLetters;                                      }                                      else if (!string.IsNullOrEmpty(firstLetters))                                      {                                          // we don't have any part letters' but we do have first letters. reuse.                                          JsCrunchEnumerator.PartLetters = firstLetters;                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "WARN":                              case "W": // <-- old style                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // just "-warn" without anything else means all errors and warnings                                      WarningLevel = int.MaxValue;                                  }                                  else                                  {                                      // must be an unsigned decimal integer value                                      int warningLevel;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out warningLevel))                                      {                                          WarningLevel = warningLevel;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  levelSpecified = true;                                  break;                                //                              // Backward-compatibility switches different from new switches                              //                                case "D":                                  // equivalent to -debug:false (default behavior)                                  JSSettings.StripDebugStatements = true;                                  OnJSOnlyParameter();                                  break;                                case "E":                              case "EO":                                  // equivalent to -enc:out <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // just save the name -- we'll create the encoding later because we need                                  // to know whether we are JS or CSS to pick the right encoding fallback                                  EncodingOutputName = paramPart;                                  break;                                case "EI":                                  // equivalent to -enc:in <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // save the name                                  EncodingInputName = paramPart;                                  break;                                case "H":                                  // equivalent to -rename:all -unused:remove (default behavior)                                  JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HL":                                  // equivalent to -rename:localization -unused:remove                                  JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HC":                                  // equivalent to -literals:combine -rename:all -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "H";                                case "HLC":                              case "HCL":                                  // equivalent to -literals:combine -rename:localization -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "HL";                                case "J":                                  // equivalent to -evals:ignore (default behavior)                                  JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  OnJSOnlyParameter();                                  break;                                case "K":                                  // equivalent to -inline:true (default behavior)                                  JSSettings.InlineSafeStrings = true;                                  OnJSOnlyParameter();                                  break;                                case "L":                                  // equivalent to -new:keep (default is collapse)                                  JSSettings.CollapseToLiteral = false;                                  OnJSOnlyParameter();                                  break;                                case "M":                                  // equivalent to -mac:true (default behavior)                                  JSSettings.MacSafariQuirks = true;                                  OnJSOnlyParameter();                                  break;                                case "Z":                                  // equivalent to -term:true (default is false)                                  JSSettings.TermSemicolons =                                      CssSettings.TermSemicolons = true;                                  break;                                // end backward-compatible section                                default:                                  ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  break;                          }
Magic Number,Spike.Build.Minifiers,MinifierParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\MinifierParser.cs,Parse,The following statement contains a magic number: switch (switchPart)                          {                              case "ANALYZE":                              case "A": // <-- old-style                                  // ignore any arguments                                  AnalyzeMode = true;                                    // by default' we have no report format                                  ReportFormat = null;                                  if (paramPartUpper != null)                                  {                                      var items = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var item in items)                                      {                                          if (string.CompareOrdinal(item' "OUT") == 0)                                          {                                              // if the analyze part is "out'" then the NEXT arg string                                              // is the output path the analyze scope report should be written to.                                              if (ndx >= args.Length - 1)                                              {                                                  // must be followed by a path                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                              else                                              {                                                  ReportPath = args[++ndx];                                              }                                          }                                          else                                          {                                              // must be a report format. There can be only one' so clobber whatever                                              // is there from before -- last one listed wins.                                              ReportFormat = item;                                          }                                      }                                  }                                    // if analyze was specified but no warning level' jack up the warning level                                  // so everything is shown                                  if (!levelSpecified)                                  {                                      // we want to analyze' and we didn't specify a particular warning level.                                      // go ahead and report all errors                                      WarningLevel = int.MaxValue;                                  }                                    break;                                case "ASPNET":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // same setting for both CSS and JS                                      JSSettings.AllowEmbeddedAspNetBlocks =                                          CssSettings.AllowEmbeddedAspNetBlocks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "BRACES":                                  if (paramPartUpper == "NEW")                                  {                                      JSSettings.BlocksStartOnSameLine =                                           CssSettings.BlocksStartOnSameLine = MinifierBlockStart.NewLine;                                  }                                  else if (paramPartUpper == "SAME")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.SameLine;                                  }                                  else if (paramPartUpper == "SOURCE")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.UseSource;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "CC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // actually' the flag is the opposite of the member -- turn CC ON and we DON'T                                      // want to ignore them; turn CC OFF and we DO want to ignore them                                      JSSettings.IgnoreConditionalCompilation = !parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "COLORS":                                  // two options: hex or names                                  if (paramPartUpper == "HEX")                                  {                                      CssSettings.ColorNames = CssColor.Hex;                                  }                                  else if (paramPartUpper == "STRICT")                                  {                                      CssSettings.ColorNames = CssColor.Strict;                                  }                                  else if (paramPartUpper == "MAJOR")                                  {                                      CssSettings.ColorNames = CssColor.Major;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnCssOnlyParameter();                                  break;                                case "COMMENTS":                                  // four options for css: none' all' important' or hacks                                  // two options for js: none' important                                  // (default is important)                                  if (paramPartUpper == "NONE")                                  {                                      CssSettings.CommentMode = CssComment.None;                                      JSSettings.PreserveImportantComments = false;                                  }                                  else if (paramPartUpper == "ALL")                                  {                                      CssSettings.CommentMode = CssComment.All;                                      OnCssOnlyParameter();                                  }                                  else if (paramPartUpper == "IMPORTANT")                                  {                                      CssSettings.CommentMode = CssComment.Important;                                      JSSettings.PreserveImportantComments = true;                                  }                                  else if (paramPartUpper == "HACKS")                                  {                                      CssSettings.CommentMode = CssComment.Hacks;                                      OnCssOnlyParameter();                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    break;                                case "CONST":                                  // options: MOZ or ES6 (ES6 is the default)                                  if (paramPartUpper == "MOZ")                                  {                                      JSSettings.ConstStatementsMozilla = true;                                  }                                  else if (paramPartUpper == "ES6")                                  {                                      JSSettings.ConstStatementsMozilla = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "CSS":                                  OnCssOnlyParameter();                                  if (paramPartUpper != null)                                  {                                      switch (paramPartUpper)                                      {                                          case "FULL":                                              CssSettings.CssType = CssType.FullStyleSheet;                                              break;                                            case "DECLS":                                              CssSettings.CssType = CssType.DeclarationList;                                              break;                                            default:                                              // not an expected value                                              OnInvalidSwitch(switchPart' paramPart);                                              break;                                      }                                  }                                  break;                                case "DEBUG":                                  // see if the param part is a comma-delimited list                                  if (paramPartUpper != null && paramPartUpper.IndexOf(''') >= 0)                                  {                                      // we have a comma-separated list.                                      // the first item is the flag (if any)' and the rest (if any) are the "debug" lookup names                                      var items = paramPart.Split(listSeparators);                                        // use the first value as the debug boolean switch.                                      // since we are splitting the non-uppercase param part' we need to                                       // make sure the first item is capitalized for our boolean test.                                      if (BooleanSwitch(items[0].ToUpperInvariant()' true' out parameterFlag))                                      {                                          // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                          // strip debug statements' and a FALSE means we DO want to strip them                                          JSSettings.StripDebugStatements = !parameterFlag;                                            // make sure we align the DEBUG define to the new switch value                                          AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                        // clear out the existing debug list                                      JSSettings.DebugLookupList = null;                                        // start with index 1' since index 0 was the flag                                      for (var item = 1; item < items.Length; ++item)                                      {                                          // get the identifier that was specified                                          var identifier = items[item];                                          if (!identifier.IsNullOrWhiteSpace())                                          {                                              if (!JSSettings.AddDebugLookup(identifier))                                              {                                                  OnInvalidSwitch(switchPart' identifier);                                              }                                          }                                      }                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // no commas -- just use the entire param part as the boolean value.                                      // just putting the debug switch on the command line without any arguments                                      // is the same as putting -debug:true and perfectly valid.                                        // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                      // strip debug statements' and a FALSE means we DO want to strip them                                      JSSettings.StripDebugStatements = !parameterFlag;                                        // make sure we align the DEBUG define to the new switch value                                      AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "DEFINE":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string define in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          string trimmedName;                                          string value;                                          var ndxEquals = define.IndexOf('=');                                          if (ndxEquals < 0)                                          {                                              trimmedName = define.Trim();                                              value = string.Empty;                                          }                                          else                                          {                                              trimmedName = define.Substring(0' ndxEquals).Trim();                                              value = define.Substring(ndxEquals + 1);                                          }                                            // better be a valid JavaScript identifier                                          if (!JsScanner.IsValidIdentifier(trimmedName))                                          {                                              OnInvalidSwitch(switchPart' define);                                          }                                          else                                          {                                              // JS Settings                                              JSSettings.PreprocessorValues[trimmedName] = value;                                                // CSS settings                                              CssSettings.PreprocessorValues[trimmedName] = value;                                          }                                            // if we're defining the DEBUG name' set the strip-debug-statements flag to false                                          if (string.Compare(trimmedName' "DEBUG"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              JSSettings.StripDebugStatements = false;                                          }                                      }                                  }                                    break;                                case "ENC":                                  // the encoding is the next argument                                  if (ndx >= args.Length - 1)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      string encoding = args[++ndx];                                        // whether this is an in or an out encoding                                      if (paramPartUpper == "IN")                                      {                                          // save the name -- we'll create the encoding later because we may                                          // override it on a file-by-file basis in an XML file                                          EncodingInputName = encoding;                                      }                                      else if (paramPartUpper == "OUT")                                      {                                          // just save the name -- we'll create the encoding later because we need                                          // to know whether we are JS or CSS to pick the right encoding fallback                                          EncodingOutputName = encoding;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "ESC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.AlwaysEscapeNonAscii = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "EVALS":                                  // three options: ignore' make immediate scope safe' or make all scopes safe                                  if (paramPartUpper == "IGNORE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  }                                  else if (paramPartUpper == "IMMEDIATE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeImmediateSafe;                                  }                                  else if (paramPartUpper == "SAFEALL")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeAllSafe;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "EXPR":                                  // two options: minify (default) or raw                                  if (paramPartUpper == "MINIFY")                                  {                                      CssSettings.MinifyExpressions = true;                                  }                                  else if (paramPartUpper == "RAW")                                  {                                      CssSettings.MinifyExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    OnCssOnlyParameter();                                  break;                                case "FNAMES":                                  // three options:                                   // LOCK    -> keep all NFE names' don't allow renaming of function names                                  // KEEP    -> keep all NFE names' but allow function names to be renamed                                  // ONLYREF -> remove unref'd NFE names' allow function named to be renamed (DEFAULT)                                  if (paramPartUpper == "LOCK")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // and preserve the names (don't allow renaming)                                      JSSettings.PreserveFunctionNames = true;                                  }                                  else if (paramPartUpper == "KEEP")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // but it's okay to rename them                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      // remove function expression names if they aren't referenced                                      JSSettings.RemoveFunctionExpressionNames = true;                                        // and rename them if we so desire                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "GLOBAL":                              case "G": // <-- old style                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string global in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddKnownGlobal(global))                                          {                                              OnInvalidSwitch(switchPart' global);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "IGNORE":                                  // list of error codes to ignore (not report)                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string errorCode in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.Compare(errorCode' "ALL"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              // we want to ignore ALL errors. So set the appropriate flag                                              JSSettings.IgnoreAllErrors =                                                  CssSettings.IgnoreAllErrors = true;                                          }                                          else                                          {                                              // don't add duplicates                                              JSSettings.IgnoreErrorCollection.Add(errorCode);                                              CssSettings.IgnoreErrorCollection.Add(errorCode);                                          }                                      }                                  }                                  break;                                case "INLINE":                                  if (string.IsNullOrEmpty(paramPart))                                  {                                      // no param parts. This defaults to inline-safe                                      JSSettings.InlineSafeStrings = true;                                  }                                  else                                  {                                      // for each comma-separated part...                                      foreach (var inlinePart in paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.CompareOrdinal(inlinePart' "FORCE") == 0)                                          {                                              // this is the force flag -- throw an error if any string literal                                              // sources are not properly escaped AND make sure the output is                                               // safe                                              JSSettings.ErrorIfNotInlineSafe = true;                                              JSSettings.InlineSafeStrings = true;                                          }                                          else if (string.CompareOrdinal(inlinePart' "NOFORCE") == 0)                                          {                                              // this is the noforce flag; don't throw an error is the source isn't inline safe.                                              // don't change whatever the output-inline-safe flag may happen to be' though                                              JSSettings.ErrorIfNotInlineSafe = false;                                          }                                          else                                          {                                              // assume it must be the boolean flag.                                              // if no param part' will return true (indicating the default)                                              // if invalid param part' will throw error                                              if (BooleanSwitch(inlinePart' true' out parameterFlag))                                              {                                                  JSSettings.InlineSafeStrings = parameterFlag;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "JS":                                  if (paramPart == null)                                  {                                      // normal settings                                      JSSettings.SourceMode = JsSourceMode.Program;                                      JSSettings.Format = JsFormat.Normal;                                  }                                  else                                  {                                      // comma-delimited list of JS settings                                      var tokens = paramPartUpper.Split('''' ';');                                      foreach (var token in tokens)                                      {                                          switch (token)                                          {                                              case "JSON":                                                  // JSON is incompatible with any other tokens' so throw an error                                                  // if it's not the only token                                                  if (tokens.Length > 1)                                                  {                                                      OnInvalidSwitch(switchPart' paramPart);                                                  }                                                    // nothing to "minify" in the JSON format' so turn off the minify flag                                                  JSSettings.MinifyCode = false;                                                    // JSON affects both the input (it's an expression) and the output                                                  // (use the JSON-output visitor)                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  JSSettings.Format = JsFormat.JSON;                                                  break;                                                case "PROG":                                                  // this is the default setting                                                  JSSettings.SourceMode = JsSourceMode.Program;                                                  break;                                                case "EXPR":                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  break;                                                case "EVT":                                                  JSSettings.SourceMode = JsSourceMode.EventHandler;                                                  break;                                                default:                                                  // later: ES5 to convert any ES6 syntax to ES5-compatible                                                  // later: ES6 to create ES6 syntax when optimizing                                                  // etc.                                                  // those two examples will affect the format property.                                                  // but for now' not supported                                                  OnInvalidSwitch(switchPart' paramPart);                                                  break;                                          }                                      }                                  }                                    OnJSOnlyParameter();                                  break;                                case "KILL":                                  killSpecified = true;                                    // optional integer switch argument                                  if (paramPartUpper == null)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      // get the numeric portion                                      long killSwitch;                                      if (paramPartUpper.StartsWith("0X"' StringComparison.OrdinalIgnoreCase))                                      {                                          // it's hex -- convert the number after the "0x"                                          if (paramPartUpper.Substring(2).TryParseLongInvariant(NumberStyles.AllowHexSpecifier' out killSwitch))                                          {                                              // save the switch for both JS and Css                                              JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                                // for CSS' we only look at the first bit: preeserve important comments                                              if ((killSwitch & 1) != 0)                                              {                                                  // we set the kill' so make sure the comments are set to none                                                  CssSettings.CommentMode = CssComment.None;                                              }                                          }                                          else                                          {                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                      else if (paramPartUpper.TryParseLongInvariant(NumberStyles.AllowLeadingSign' out killSwitch))                                      {                                          // save the switch for both JS and CSS                                          JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                            // for CSS' we only look at the first bit: preeserve important comments                                          if ((killSwitch & 1) != 0)                                          {                                              // we set the kill' so make sure the comments are set to none                                              CssSettings.CommentMode = CssComment.None;                                          }                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LINE":                              case "LINES":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // if no number specified' use the max default threshold                                      JSSettings.LineBreakThreshold =                                          CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                                                            // single-line mode                                      JSSettings.OutputMode =                                           CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                        // and four spaces per indent level                                      JSSettings.IndentSize =                                          CssSettings.IndentSize = 4;                                  }                                  else                                  {                                      // split along commas (case-insensitive)                                      var lineParts = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                        // by default' the line-break index will be 1 (the second option).                                      // we will change this index to 0 if the first parameter is multi/single                                      // instead of the line-break character count.                                      var breakIndex = 1;                                      if (lineParts.Length <= 3)                                      {                                          // if the first optional part is numeric' then it's the line threshold.                                          // might also be "multi" or "single"' thereby skipping the line threshold.                                          // (don't need to check length greater than zero -- will always be at least one element returned from Split)                                          if (!string.IsNullOrEmpty(lineParts[0]))                                          {                                              // must be an unsigned decimal integer value                                              int lineThreshold;                                              if (lineParts[0].TryParseIntInvariant(NumberStyles.None' out lineThreshold))                                              {                                                  JSSettings.LineBreakThreshold =                                                      CssSettings.LineBreakThreshold = lineThreshold;                                              }                                              else if (lineParts[0][0] == 'S')                                              {                                                  // single-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else if (lineParts[0][0] == 'M')                                              {                                                  // multiple-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' lineParts[0]);                                              }                                          }                                          else                                          {                                              // use the default                                              JSSettings.LineBreakThreshold =                                                  CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                          }                                            if (lineParts.Length > breakIndex)                                          {                                              // if the line-break index was zero' then we already processed it                                              // and we can skip the logic                                              if (breakIndex > 0)                                              {                                                  // second optional part is single or multiple line output                                                  if (string.IsNullOrEmpty(lineParts[breakIndex]) || lineParts[breakIndex][0] == 'S')                                                  {                                                      // single-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                  }                                                  else if (lineParts[breakIndex][0] == 'M')                                                  {                                                      // multiple-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                  }                                                  else                                                  {                                                      // must either be missing' or start with S (single) or M (multiple)                                                      OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                  }                                              }                                                // move on to the next part                                              ++breakIndex;                                              if (lineParts.Length > breakIndex)                                              {                                                  // third optional part is the spaces-per-indent value                                                  if (!string.IsNullOrEmpty(lineParts[breakIndex]))                                                  {                                                      // get the numeric portion; must be a decimal integer                                                      int indentSize;                                                      if (lineParts[breakIndex].TryParseIntInvariant(NumberStyles.None' out indentSize))                                                      {                                                          // same value for JS and CSS.                                                          // don't need to check for negative' because the tryparse method above does NOT                                                          // allow for a sign -- no sign' no negative.                                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                                      }                                                      else                                                      {                                                          OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                      }                                                  }                                                  else                                                  {                                                      // default of 4                                                      JSSettings.IndentSize =                                                          CssSettings.IndentSize = 4;                                                  }                                              }                                          }                                      }                                      else                                      {                                          // only 1-3 parts allowed                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LITERALS":                                  // two areas with two options each: keep or combine and eval or noeval                                  if (paramPartUpper == "KEEP")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = false;                                  }                                  else if (paramPartUpper == "COMBINE")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = true;                                  }                                  else if (paramPartUpper == "EVAL")                                  {                                      JSSettings.EvalLiteralExpressions = true;                                  }                                  else if (paramPartUpper == "NOEVAL")                                  {                                      JSSettings.EvalLiteralExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MAC":                                  // optional boolean switch                                  // no arg is valid scenario (default is true)                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.MacSafariQuirks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MINIFY":                                  minifySpecified = true;                                  if (renamingSpecified && JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      // minify can only exist if rename is set to KeepAll                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // optional boolean switch                                      // no arg is a valid scenario (default is true)                                      JSSettings.MinifyCode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NEW":                                  // two options: keep and collapse                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.CollapseToLiteral = false;                                  }                                  else if (paramPartUpper == "COLLAPSE")                                  {                                      JSSettings.CollapseToLiteral = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NFE": // <-- deprecate; use FNAMES option instead                                  if (paramPartUpper == "KEEPALL")                                  {                                      JSSettings.RemoveFunctionExpressionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      JSSettings.RemoveFunctionExpressionNames = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NORENAME":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string ident in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddNoAutoRename(ident))                                          {                                              OnInvalidSwitch(switchPart' ident);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "OBJ":                                  // two options: MINify or QUOTE                                  if (paramPartUpper == "MIN")                                  {                                      JSSettings.QuoteObjectLiteralProperties = false;                                  }                                  else if (paramPartUpper == "QUOTE")                                  {                                      JSSettings.QuoteObjectLiteralProperties = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PPONLY":                                  // just putting the pponly switch on the command line without any arguments                                  // is the same as putting -pponly:true and perfectly valid.                                  if (paramPart == null)                                  {                                      JSSettings.PreprocessOnly = true;                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.PreprocessOnly = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PRETTY":                              case "P": // <-- old style                                  // doesn't take a flag -- just set to pretty                                  PrettyPrint = true;                                                // by default' pretty mode turns off minification' which sets a bunch of other flags as well                                  JSSettings.MinifyCode = false;                                    // and some other flags for pretty-mode                                  JSSettings.OutputMode = CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                  CssSettings.KillSwitch = ~((long)JsTreeModifications.PreserveImportantComments);                                    // optional integer switch argument                                  if (paramPartUpper != null)                                  {                                      // get the numeric portion; must be a decimal integer                                      int indentSize;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out indentSize))                                      {                                          // same value for JS and CSS.                                          // don't need to check for negative' because the tryparse method above does NOT                                          // allow for a sign -- no sign' no negative.                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                      }                                      else                                       {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "RENAME":                                  if (paramPartUpper == null)                                  {                                      // treat as if it's unknown                                      ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  }                                  else if (paramPartUpper.IndexOf('=') > 0)                                  {                                      // there is at least one equal sign -- treat this as a set of JS identifier                                      // pairs. split on commas -- multiple pairs can be specified                                      var paramPairs = paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var paramPair in paramPairs)                                      {                                          // split on the equal sign -- each pair needs to have an equal sige                                          var pairParts = paramPair.Split('=');                                          if (pairParts.Length == 2)                                          {                                              // there is an equal sign. The first part is the source name and the                                              // second part is the new name to which to rename those entities.                                              string fromIdentifier = pairParts[0];                                              string toIdentifier = pairParts[1];                                                // make sure both parts are valid JS identifiers                                              var fromIsValid = JsScanner.IsValidIdentifier(fromIdentifier);                                              var toIsValid = JsScanner.IsValidIdentifier(toIdentifier);                                              if (fromIsValid && toIsValid)                                              {                                                  // create the map if it hasn't been created yet.                                                  var toExisting = JSSettings.GetNewName(fromIdentifier);                                                  if (toExisting == null)                                                  {                                                      JSSettings.AddRenamePair(fromIdentifier' toIdentifier);                                                  }                                                  else if (string.CompareOrdinal(toIdentifier' toExisting) != 0)                                                  {                                                      // from-identifier already exists' and the to-identifier doesn't match.                                                      // can't rename the same name to two different names!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                              else                                              {                                                  if (fromIsValid)                                                  {                                                      // the toIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' toIdentifier);                                                  }                                                    if (toIsValid)                                                  {                                                      // the fromIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                          }                                          else                                          {                                              // either zero or more than one equal sign. Invalid.                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                  }                                  else                                  {                                      // no equal sign; just a plain option                                      // three options: all' localization' none                                      if (paramPartUpper == "ALL")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "LOCALIZATION")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NONE")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NOPROPS")                                      {                                          // manual-renaming does not change property names                                          JSSettings.ManualRenamesProperties = false;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  if (JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      ResetRenamingKill(killSpecified);                                        // if minify was specified as turned off' then this is invalid                                      if (minifySpecified && !JSSettings.MinifyCode)                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "REORDER":                                  // default is true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.ReorderScopeDeclarations = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "STRICT":                                  // default is false' but if we specify this switch without a parameter' then                                  // we assume we are turning it ON                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.StrictMode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "TERM":                                  // optional boolean argument' defaults to true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.TermSemicolons =                                          CssSettings.TermSemicolons = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "UNUSED":                                  // two options: keep and remove                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.RemoveUnneededCode = false;                                  }                                  else if (paramPartUpper == "REMOVE")                                  {                                      JSSettings.RemoveUnneededCode = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "VAR":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      var firstLetters = paramPart;                                      string partLetters = null;                                        var commaPosition = paramPart.IndexOf(''');                                      if (commaPosition == 0)                                      {                                          // no first letters; just part letters                                          firstLetters = null;                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                      else if (commaPosition > 0)                                      {                                          // first letters and part letters                                          firstLetters = paramPart.Substring(0' commaPosition);                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                        // if we specified first letters' set them now                                      if (!string.IsNullOrEmpty(firstLetters))                                      {                                          JsCrunchEnumerator.FirstLetters = firstLetters;                                      }                                        // if we specified part letters' use it -- otherwise use the first letters.                                      if (!string.IsNullOrEmpty(partLetters))                                      {                                          JsCrunchEnumerator.PartLetters = partLetters;                                      }                                      else if (!string.IsNullOrEmpty(firstLetters))                                      {                                          // we don't have any part letters' but we do have first letters. reuse.                                          JsCrunchEnumerator.PartLetters = firstLetters;                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "WARN":                              case "W": // <-- old style                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // just "-warn" without anything else means all errors and warnings                                      WarningLevel = int.MaxValue;                                  }                                  else                                  {                                      // must be an unsigned decimal integer value                                      int warningLevel;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out warningLevel))                                      {                                          WarningLevel = warningLevel;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  levelSpecified = true;                                  break;                                //                              // Backward-compatibility switches different from new switches                              //                                case "D":                                  // equivalent to -debug:false (default behavior)                                  JSSettings.StripDebugStatements = true;                                  OnJSOnlyParameter();                                  break;                                case "E":                              case "EO":                                  // equivalent to -enc:out <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // just save the name -- we'll create the encoding later because we need                                  // to know whether we are JS or CSS to pick the right encoding fallback                                  EncodingOutputName = paramPart;                                  break;                                case "EI":                                  // equivalent to -enc:in <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // save the name                                  EncodingInputName = paramPart;                                  break;                                case "H":                                  // equivalent to -rename:all -unused:remove (default behavior)                                  JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HL":                                  // equivalent to -rename:localization -unused:remove                                  JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HC":                                  // equivalent to -literals:combine -rename:all -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "H";                                case "HLC":                              case "HCL":                                  // equivalent to -literals:combine -rename:localization -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "HL";                                case "J":                                  // equivalent to -evals:ignore (default behavior)                                  JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  OnJSOnlyParameter();                                  break;                                case "K":                                  // equivalent to -inline:true (default behavior)                                  JSSettings.InlineSafeStrings = true;                                  OnJSOnlyParameter();                                  break;                                case "L":                                  // equivalent to -new:keep (default is collapse)                                  JSSettings.CollapseToLiteral = false;                                  OnJSOnlyParameter();                                  break;                                case "M":                                  // equivalent to -mac:true (default behavior)                                  JSSettings.MacSafariQuirks = true;                                  OnJSOnlyParameter();                                  break;                                case "Z":                                  // equivalent to -term:true (default is false)                                  JSSettings.TermSemicolons =                                      CssSettings.TermSemicolons = true;                                  break;                                // end backward-compatible section                                default:                                  ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  break;                          }
Magic Number,Spike.Build.Minifiers,MinifierParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\MinifierParser.cs,Parse,The following statement contains a magic number: switch (switchPart)                          {                              case "ANALYZE":                              case "A": // <-- old-style                                  // ignore any arguments                                  AnalyzeMode = true;                                    // by default' we have no report format                                  ReportFormat = null;                                  if (paramPartUpper != null)                                  {                                      var items = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var item in items)                                      {                                          if (string.CompareOrdinal(item' "OUT") == 0)                                          {                                              // if the analyze part is "out'" then the NEXT arg string                                              // is the output path the analyze scope report should be written to.                                              if (ndx >= args.Length - 1)                                              {                                                  // must be followed by a path                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                              else                                              {                                                  ReportPath = args[++ndx];                                              }                                          }                                          else                                          {                                              // must be a report format. There can be only one' so clobber whatever                                              // is there from before -- last one listed wins.                                              ReportFormat = item;                                          }                                      }                                  }                                    // if analyze was specified but no warning level' jack up the warning level                                  // so everything is shown                                  if (!levelSpecified)                                  {                                      // we want to analyze' and we didn't specify a particular warning level.                                      // go ahead and report all errors                                      WarningLevel = int.MaxValue;                                  }                                    break;                                case "ASPNET":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // same setting for both CSS and JS                                      JSSettings.AllowEmbeddedAspNetBlocks =                                          CssSettings.AllowEmbeddedAspNetBlocks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "BRACES":                                  if (paramPartUpper == "NEW")                                  {                                      JSSettings.BlocksStartOnSameLine =                                           CssSettings.BlocksStartOnSameLine = MinifierBlockStart.NewLine;                                  }                                  else if (paramPartUpper == "SAME")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.SameLine;                                  }                                  else if (paramPartUpper == "SOURCE")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.UseSource;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "CC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // actually' the flag is the opposite of the member -- turn CC ON and we DON'T                                      // want to ignore them; turn CC OFF and we DO want to ignore them                                      JSSettings.IgnoreConditionalCompilation = !parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "COLORS":                                  // two options: hex or names                                  if (paramPartUpper == "HEX")                                  {                                      CssSettings.ColorNames = CssColor.Hex;                                  }                                  else if (paramPartUpper == "STRICT")                                  {                                      CssSettings.ColorNames = CssColor.Strict;                                  }                                  else if (paramPartUpper == "MAJOR")                                  {                                      CssSettings.ColorNames = CssColor.Major;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnCssOnlyParameter();                                  break;                                case "COMMENTS":                                  // four options for css: none' all' important' or hacks                                  // two options for js: none' important                                  // (default is important)                                  if (paramPartUpper == "NONE")                                  {                                      CssSettings.CommentMode = CssComment.None;                                      JSSettings.PreserveImportantComments = false;                                  }                                  else if (paramPartUpper == "ALL")                                  {                                      CssSettings.CommentMode = CssComment.All;                                      OnCssOnlyParameter();                                  }                                  else if (paramPartUpper == "IMPORTANT")                                  {                                      CssSettings.CommentMode = CssComment.Important;                                      JSSettings.PreserveImportantComments = true;                                  }                                  else if (paramPartUpper == "HACKS")                                  {                                      CssSettings.CommentMode = CssComment.Hacks;                                      OnCssOnlyParameter();                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    break;                                case "CONST":                                  // options: MOZ or ES6 (ES6 is the default)                                  if (paramPartUpper == "MOZ")                                  {                                      JSSettings.ConstStatementsMozilla = true;                                  }                                  else if (paramPartUpper == "ES6")                                  {                                      JSSettings.ConstStatementsMozilla = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "CSS":                                  OnCssOnlyParameter();                                  if (paramPartUpper != null)                                  {                                      switch (paramPartUpper)                                      {                                          case "FULL":                                              CssSettings.CssType = CssType.FullStyleSheet;                                              break;                                            case "DECLS":                                              CssSettings.CssType = CssType.DeclarationList;                                              break;                                            default:                                              // not an expected value                                              OnInvalidSwitch(switchPart' paramPart);                                              break;                                      }                                  }                                  break;                                case "DEBUG":                                  // see if the param part is a comma-delimited list                                  if (paramPartUpper != null && paramPartUpper.IndexOf(''') >= 0)                                  {                                      // we have a comma-separated list.                                      // the first item is the flag (if any)' and the rest (if any) are the "debug" lookup names                                      var items = paramPart.Split(listSeparators);                                        // use the first value as the debug boolean switch.                                      // since we are splitting the non-uppercase param part' we need to                                       // make sure the first item is capitalized for our boolean test.                                      if (BooleanSwitch(items[0].ToUpperInvariant()' true' out parameterFlag))                                      {                                          // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                          // strip debug statements' and a FALSE means we DO want to strip them                                          JSSettings.StripDebugStatements = !parameterFlag;                                            // make sure we align the DEBUG define to the new switch value                                          AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                        // clear out the existing debug list                                      JSSettings.DebugLookupList = null;                                        // start with index 1' since index 0 was the flag                                      for (var item = 1; item < items.Length; ++item)                                      {                                          // get the identifier that was specified                                          var identifier = items[item];                                          if (!identifier.IsNullOrWhiteSpace())                                          {                                              if (!JSSettings.AddDebugLookup(identifier))                                              {                                                  OnInvalidSwitch(switchPart' identifier);                                              }                                          }                                      }                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // no commas -- just use the entire param part as the boolean value.                                      // just putting the debug switch on the command line without any arguments                                      // is the same as putting -debug:true and perfectly valid.                                        // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                      // strip debug statements' and a FALSE means we DO want to strip them                                      JSSettings.StripDebugStatements = !parameterFlag;                                        // make sure we align the DEBUG define to the new switch value                                      AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "DEFINE":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string define in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          string trimmedName;                                          string value;                                          var ndxEquals = define.IndexOf('=');                                          if (ndxEquals < 0)                                          {                                              trimmedName = define.Trim();                                              value = string.Empty;                                          }                                          else                                          {                                              trimmedName = define.Substring(0' ndxEquals).Trim();                                              value = define.Substring(ndxEquals + 1);                                          }                                            // better be a valid JavaScript identifier                                          if (!JsScanner.IsValidIdentifier(trimmedName))                                          {                                              OnInvalidSwitch(switchPart' define);                                          }                                          else                                          {                                              // JS Settings                                              JSSettings.PreprocessorValues[trimmedName] = value;                                                // CSS settings                                              CssSettings.PreprocessorValues[trimmedName] = value;                                          }                                            // if we're defining the DEBUG name' set the strip-debug-statements flag to false                                          if (string.Compare(trimmedName' "DEBUG"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              JSSettings.StripDebugStatements = false;                                          }                                      }                                  }                                    break;                                case "ENC":                                  // the encoding is the next argument                                  if (ndx >= args.Length - 1)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      string encoding = args[++ndx];                                        // whether this is an in or an out encoding                                      if (paramPartUpper == "IN")                                      {                                          // save the name -- we'll create the encoding later because we may                                          // override it on a file-by-file basis in an XML file                                          EncodingInputName = encoding;                                      }                                      else if (paramPartUpper == "OUT")                                      {                                          // just save the name -- we'll create the encoding later because we need                                          // to know whether we are JS or CSS to pick the right encoding fallback                                          EncodingOutputName = encoding;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "ESC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.AlwaysEscapeNonAscii = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "EVALS":                                  // three options: ignore' make immediate scope safe' or make all scopes safe                                  if (paramPartUpper == "IGNORE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  }                                  else if (paramPartUpper == "IMMEDIATE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeImmediateSafe;                                  }                                  else if (paramPartUpper == "SAFEALL")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeAllSafe;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "EXPR":                                  // two options: minify (default) or raw                                  if (paramPartUpper == "MINIFY")                                  {                                      CssSettings.MinifyExpressions = true;                                  }                                  else if (paramPartUpper == "RAW")                                  {                                      CssSettings.MinifyExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    OnCssOnlyParameter();                                  break;                                case "FNAMES":                                  // three options:                                   // LOCK    -> keep all NFE names' don't allow renaming of function names                                  // KEEP    -> keep all NFE names' but allow function names to be renamed                                  // ONLYREF -> remove unref'd NFE names' allow function named to be renamed (DEFAULT)                                  if (paramPartUpper == "LOCK")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // and preserve the names (don't allow renaming)                                      JSSettings.PreserveFunctionNames = true;                                  }                                  else if (paramPartUpper == "KEEP")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // but it's okay to rename them                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      // remove function expression names if they aren't referenced                                      JSSettings.RemoveFunctionExpressionNames = true;                                        // and rename them if we so desire                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "GLOBAL":                              case "G": // <-- old style                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string global in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddKnownGlobal(global))                                          {                                              OnInvalidSwitch(switchPart' global);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "IGNORE":                                  // list of error codes to ignore (not report)                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string errorCode in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.Compare(errorCode' "ALL"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              // we want to ignore ALL errors. So set the appropriate flag                                              JSSettings.IgnoreAllErrors =                                                  CssSettings.IgnoreAllErrors = true;                                          }                                          else                                          {                                              // don't add duplicates                                              JSSettings.IgnoreErrorCollection.Add(errorCode);                                              CssSettings.IgnoreErrorCollection.Add(errorCode);                                          }                                      }                                  }                                  break;                                case "INLINE":                                  if (string.IsNullOrEmpty(paramPart))                                  {                                      // no param parts. This defaults to inline-safe                                      JSSettings.InlineSafeStrings = true;                                  }                                  else                                  {                                      // for each comma-separated part...                                      foreach (var inlinePart in paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.CompareOrdinal(inlinePart' "FORCE") == 0)                                          {                                              // this is the force flag -- throw an error if any string literal                                              // sources are not properly escaped AND make sure the output is                                               // safe                                              JSSettings.ErrorIfNotInlineSafe = true;                                              JSSettings.InlineSafeStrings = true;                                          }                                          else if (string.CompareOrdinal(inlinePart' "NOFORCE") == 0)                                          {                                              // this is the noforce flag; don't throw an error is the source isn't inline safe.                                              // don't change whatever the output-inline-safe flag may happen to be' though                                              JSSettings.ErrorIfNotInlineSafe = false;                                          }                                          else                                          {                                              // assume it must be the boolean flag.                                              // if no param part' will return true (indicating the default)                                              // if invalid param part' will throw error                                              if (BooleanSwitch(inlinePart' true' out parameterFlag))                                              {                                                  JSSettings.InlineSafeStrings = parameterFlag;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "JS":                                  if (paramPart == null)                                  {                                      // normal settings                                      JSSettings.SourceMode = JsSourceMode.Program;                                      JSSettings.Format = JsFormat.Normal;                                  }                                  else                                  {                                      // comma-delimited list of JS settings                                      var tokens = paramPartUpper.Split('''' ';');                                      foreach (var token in tokens)                                      {                                          switch (token)                                          {                                              case "JSON":                                                  // JSON is incompatible with any other tokens' so throw an error                                                  // if it's not the only token                                                  if (tokens.Length > 1)                                                  {                                                      OnInvalidSwitch(switchPart' paramPart);                                                  }                                                    // nothing to "minify" in the JSON format' so turn off the minify flag                                                  JSSettings.MinifyCode = false;                                                    // JSON affects both the input (it's an expression) and the output                                                  // (use the JSON-output visitor)                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  JSSettings.Format = JsFormat.JSON;                                                  break;                                                case "PROG":                                                  // this is the default setting                                                  JSSettings.SourceMode = JsSourceMode.Program;                                                  break;                                                case "EXPR":                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  break;                                                case "EVT":                                                  JSSettings.SourceMode = JsSourceMode.EventHandler;                                                  break;                                                default:                                                  // later: ES5 to convert any ES6 syntax to ES5-compatible                                                  // later: ES6 to create ES6 syntax when optimizing                                                  // etc.                                                  // those two examples will affect the format property.                                                  // but for now' not supported                                                  OnInvalidSwitch(switchPart' paramPart);                                                  break;                                          }                                      }                                  }                                    OnJSOnlyParameter();                                  break;                                case "KILL":                                  killSpecified = true;                                    // optional integer switch argument                                  if (paramPartUpper == null)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      // get the numeric portion                                      long killSwitch;                                      if (paramPartUpper.StartsWith("0X"' StringComparison.OrdinalIgnoreCase))                                      {                                          // it's hex -- convert the number after the "0x"                                          if (paramPartUpper.Substring(2).TryParseLongInvariant(NumberStyles.AllowHexSpecifier' out killSwitch))                                          {                                              // save the switch for both JS and Css                                              JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                                // for CSS' we only look at the first bit: preeserve important comments                                              if ((killSwitch & 1) != 0)                                              {                                                  // we set the kill' so make sure the comments are set to none                                                  CssSettings.CommentMode = CssComment.None;                                              }                                          }                                          else                                          {                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                      else if (paramPartUpper.TryParseLongInvariant(NumberStyles.AllowLeadingSign' out killSwitch))                                      {                                          // save the switch for both JS and CSS                                          JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                            // for CSS' we only look at the first bit: preeserve important comments                                          if ((killSwitch & 1) != 0)                                          {                                              // we set the kill' so make sure the comments are set to none                                              CssSettings.CommentMode = CssComment.None;                                          }                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LINE":                              case "LINES":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // if no number specified' use the max default threshold                                      JSSettings.LineBreakThreshold =                                          CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                                                            // single-line mode                                      JSSettings.OutputMode =                                           CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                        // and four spaces per indent level                                      JSSettings.IndentSize =                                          CssSettings.IndentSize = 4;                                  }                                  else                                  {                                      // split along commas (case-insensitive)                                      var lineParts = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                        // by default' the line-break index will be 1 (the second option).                                      // we will change this index to 0 if the first parameter is multi/single                                      // instead of the line-break character count.                                      var breakIndex = 1;                                      if (lineParts.Length <= 3)                                      {                                          // if the first optional part is numeric' then it's the line threshold.                                          // might also be "multi" or "single"' thereby skipping the line threshold.                                          // (don't need to check length greater than zero -- will always be at least one element returned from Split)                                          if (!string.IsNullOrEmpty(lineParts[0]))                                          {                                              // must be an unsigned decimal integer value                                              int lineThreshold;                                              if (lineParts[0].TryParseIntInvariant(NumberStyles.None' out lineThreshold))                                              {                                                  JSSettings.LineBreakThreshold =                                                      CssSettings.LineBreakThreshold = lineThreshold;                                              }                                              else if (lineParts[0][0] == 'S')                                              {                                                  // single-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else if (lineParts[0][0] == 'M')                                              {                                                  // multiple-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' lineParts[0]);                                              }                                          }                                          else                                          {                                              // use the default                                              JSSettings.LineBreakThreshold =                                                  CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                          }                                            if (lineParts.Length > breakIndex)                                          {                                              // if the line-break index was zero' then we already processed it                                              // and we can skip the logic                                              if (breakIndex > 0)                                              {                                                  // second optional part is single or multiple line output                                                  if (string.IsNullOrEmpty(lineParts[breakIndex]) || lineParts[breakIndex][0] == 'S')                                                  {                                                      // single-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                  }                                                  else if (lineParts[breakIndex][0] == 'M')                                                  {                                                      // multiple-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                  }                                                  else                                                  {                                                      // must either be missing' or start with S (single) or M (multiple)                                                      OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                  }                                              }                                                // move on to the next part                                              ++breakIndex;                                              if (lineParts.Length > breakIndex)                                              {                                                  // third optional part is the spaces-per-indent value                                                  if (!string.IsNullOrEmpty(lineParts[breakIndex]))                                                  {                                                      // get the numeric portion; must be a decimal integer                                                      int indentSize;                                                      if (lineParts[breakIndex].TryParseIntInvariant(NumberStyles.None' out indentSize))                                                      {                                                          // same value for JS and CSS.                                                          // don't need to check for negative' because the tryparse method above does NOT                                                          // allow for a sign -- no sign' no negative.                                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                                      }                                                      else                                                      {                                                          OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                      }                                                  }                                                  else                                                  {                                                      // default of 4                                                      JSSettings.IndentSize =                                                          CssSettings.IndentSize = 4;                                                  }                                              }                                          }                                      }                                      else                                      {                                          // only 1-3 parts allowed                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LITERALS":                                  // two areas with two options each: keep or combine and eval or noeval                                  if (paramPartUpper == "KEEP")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = false;                                  }                                  else if (paramPartUpper == "COMBINE")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = true;                                  }                                  else if (paramPartUpper == "EVAL")                                  {                                      JSSettings.EvalLiteralExpressions = true;                                  }                                  else if (paramPartUpper == "NOEVAL")                                  {                                      JSSettings.EvalLiteralExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MAC":                                  // optional boolean switch                                  // no arg is valid scenario (default is true)                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.MacSafariQuirks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MINIFY":                                  minifySpecified = true;                                  if (renamingSpecified && JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      // minify can only exist if rename is set to KeepAll                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // optional boolean switch                                      // no arg is a valid scenario (default is true)                                      JSSettings.MinifyCode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NEW":                                  // two options: keep and collapse                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.CollapseToLiteral = false;                                  }                                  else if (paramPartUpper == "COLLAPSE")                                  {                                      JSSettings.CollapseToLiteral = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NFE": // <-- deprecate; use FNAMES option instead                                  if (paramPartUpper == "KEEPALL")                                  {                                      JSSettings.RemoveFunctionExpressionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      JSSettings.RemoveFunctionExpressionNames = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NORENAME":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string ident in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddNoAutoRename(ident))                                          {                                              OnInvalidSwitch(switchPart' ident);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "OBJ":                                  // two options: MINify or QUOTE                                  if (paramPartUpper == "MIN")                                  {                                      JSSettings.QuoteObjectLiteralProperties = false;                                  }                                  else if (paramPartUpper == "QUOTE")                                  {                                      JSSettings.QuoteObjectLiteralProperties = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PPONLY":                                  // just putting the pponly switch on the command line without any arguments                                  // is the same as putting -pponly:true and perfectly valid.                                  if (paramPart == null)                                  {                                      JSSettings.PreprocessOnly = true;                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.PreprocessOnly = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PRETTY":                              case "P": // <-- old style                                  // doesn't take a flag -- just set to pretty                                  PrettyPrint = true;                                                // by default' pretty mode turns off minification' which sets a bunch of other flags as well                                  JSSettings.MinifyCode = false;                                    // and some other flags for pretty-mode                                  JSSettings.OutputMode = CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                  CssSettings.KillSwitch = ~((long)JsTreeModifications.PreserveImportantComments);                                    // optional integer switch argument                                  if (paramPartUpper != null)                                  {                                      // get the numeric portion; must be a decimal integer                                      int indentSize;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out indentSize))                                      {                                          // same value for JS and CSS.                                          // don't need to check for negative' because the tryparse method above does NOT                                          // allow for a sign -- no sign' no negative.                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                      }                                      else                                       {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "RENAME":                                  if (paramPartUpper == null)                                  {                                      // treat as if it's unknown                                      ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  }                                  else if (paramPartUpper.IndexOf('=') > 0)                                  {                                      // there is at least one equal sign -- treat this as a set of JS identifier                                      // pairs. split on commas -- multiple pairs can be specified                                      var paramPairs = paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var paramPair in paramPairs)                                      {                                          // split on the equal sign -- each pair needs to have an equal sige                                          var pairParts = paramPair.Split('=');                                          if (pairParts.Length == 2)                                          {                                              // there is an equal sign. The first part is the source name and the                                              // second part is the new name to which to rename those entities.                                              string fromIdentifier = pairParts[0];                                              string toIdentifier = pairParts[1];                                                // make sure both parts are valid JS identifiers                                              var fromIsValid = JsScanner.IsValidIdentifier(fromIdentifier);                                              var toIsValid = JsScanner.IsValidIdentifier(toIdentifier);                                              if (fromIsValid && toIsValid)                                              {                                                  // create the map if it hasn't been created yet.                                                  var toExisting = JSSettings.GetNewName(fromIdentifier);                                                  if (toExisting == null)                                                  {                                                      JSSettings.AddRenamePair(fromIdentifier' toIdentifier);                                                  }                                                  else if (string.CompareOrdinal(toIdentifier' toExisting) != 0)                                                  {                                                      // from-identifier already exists' and the to-identifier doesn't match.                                                      // can't rename the same name to two different names!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                              else                                              {                                                  if (fromIsValid)                                                  {                                                      // the toIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' toIdentifier);                                                  }                                                    if (toIsValid)                                                  {                                                      // the fromIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                          }                                          else                                          {                                              // either zero or more than one equal sign. Invalid.                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                  }                                  else                                  {                                      // no equal sign; just a plain option                                      // three options: all' localization' none                                      if (paramPartUpper == "ALL")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "LOCALIZATION")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NONE")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NOPROPS")                                      {                                          // manual-renaming does not change property names                                          JSSettings.ManualRenamesProperties = false;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  if (JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      ResetRenamingKill(killSpecified);                                        // if minify was specified as turned off' then this is invalid                                      if (minifySpecified && !JSSettings.MinifyCode)                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "REORDER":                                  // default is true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.ReorderScopeDeclarations = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "STRICT":                                  // default is false' but if we specify this switch without a parameter' then                                  // we assume we are turning it ON                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.StrictMode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "TERM":                                  // optional boolean argument' defaults to true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.TermSemicolons =                                          CssSettings.TermSemicolons = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "UNUSED":                                  // two options: keep and remove                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.RemoveUnneededCode = false;                                  }                                  else if (paramPartUpper == "REMOVE")                                  {                                      JSSettings.RemoveUnneededCode = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "VAR":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      var firstLetters = paramPart;                                      string partLetters = null;                                        var commaPosition = paramPart.IndexOf(''');                                      if (commaPosition == 0)                                      {                                          // no first letters; just part letters                                          firstLetters = null;                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                      else if (commaPosition > 0)                                      {                                          // first letters and part letters                                          firstLetters = paramPart.Substring(0' commaPosition);                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                        // if we specified first letters' set them now                                      if (!string.IsNullOrEmpty(firstLetters))                                      {                                          JsCrunchEnumerator.FirstLetters = firstLetters;                                      }                                        // if we specified part letters' use it -- otherwise use the first letters.                                      if (!string.IsNullOrEmpty(partLetters))                                      {                                          JsCrunchEnumerator.PartLetters = partLetters;                                      }                                      else if (!string.IsNullOrEmpty(firstLetters))                                      {                                          // we don't have any part letters' but we do have first letters. reuse.                                          JsCrunchEnumerator.PartLetters = firstLetters;                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "WARN":                              case "W": // <-- old style                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // just "-warn" without anything else means all errors and warnings                                      WarningLevel = int.MaxValue;                                  }                                  else                                  {                                      // must be an unsigned decimal integer value                                      int warningLevel;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out warningLevel))                                      {                                          WarningLevel = warningLevel;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  levelSpecified = true;                                  break;                                //                              // Backward-compatibility switches different from new switches                              //                                case "D":                                  // equivalent to -debug:false (default behavior)                                  JSSettings.StripDebugStatements = true;                                  OnJSOnlyParameter();                                  break;                                case "E":                              case "EO":                                  // equivalent to -enc:out <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // just save the name -- we'll create the encoding later because we need                                  // to know whether we are JS or CSS to pick the right encoding fallback                                  EncodingOutputName = paramPart;                                  break;                                case "EI":                                  // equivalent to -enc:in <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // save the name                                  EncodingInputName = paramPart;                                  break;                                case "H":                                  // equivalent to -rename:all -unused:remove (default behavior)                                  JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HL":                                  // equivalent to -rename:localization -unused:remove                                  JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HC":                                  // equivalent to -literals:combine -rename:all -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "H";                                case "HLC":                              case "HCL":                                  // equivalent to -literals:combine -rename:localization -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "HL";                                case "J":                                  // equivalent to -evals:ignore (default behavior)                                  JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  OnJSOnlyParameter();                                  break;                                case "K":                                  // equivalent to -inline:true (default behavior)                                  JSSettings.InlineSafeStrings = true;                                  OnJSOnlyParameter();                                  break;                                case "L":                                  // equivalent to -new:keep (default is collapse)                                  JSSettings.CollapseToLiteral = false;                                  OnJSOnlyParameter();                                  break;                                case "M":                                  // equivalent to -mac:true (default behavior)                                  JSSettings.MacSafariQuirks = true;                                  OnJSOnlyParameter();                                  break;                                case "Z":                                  // equivalent to -term:true (default is false)                                  JSSettings.TermSemicolons =                                      CssSettings.TermSemicolons = true;                                  break;                                // end backward-compatible section                                default:                                  ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  break;                          }
Magic Number,Spike.Build.Minifiers,MinifierParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\MinifierParser.cs,Parse,The following statement contains a magic number: switch (switchPart)                          {                              case "ANALYZE":                              case "A": // <-- old-style                                  // ignore any arguments                                  AnalyzeMode = true;                                    // by default' we have no report format                                  ReportFormat = null;                                  if (paramPartUpper != null)                                  {                                      var items = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var item in items)                                      {                                          if (string.CompareOrdinal(item' "OUT") == 0)                                          {                                              // if the analyze part is "out'" then the NEXT arg string                                              // is the output path the analyze scope report should be written to.                                              if (ndx >= args.Length - 1)                                              {                                                  // must be followed by a path                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                              else                                              {                                                  ReportPath = args[++ndx];                                              }                                          }                                          else                                          {                                              // must be a report format. There can be only one' so clobber whatever                                              // is there from before -- last one listed wins.                                              ReportFormat = item;                                          }                                      }                                  }                                    // if analyze was specified but no warning level' jack up the warning level                                  // so everything is shown                                  if (!levelSpecified)                                  {                                      // we want to analyze' and we didn't specify a particular warning level.                                      // go ahead and report all errors                                      WarningLevel = int.MaxValue;                                  }                                    break;                                case "ASPNET":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // same setting for both CSS and JS                                      JSSettings.AllowEmbeddedAspNetBlocks =                                          CssSettings.AllowEmbeddedAspNetBlocks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "BRACES":                                  if (paramPartUpper == "NEW")                                  {                                      JSSettings.BlocksStartOnSameLine =                                           CssSettings.BlocksStartOnSameLine = MinifierBlockStart.NewLine;                                  }                                  else if (paramPartUpper == "SAME")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.SameLine;                                  }                                  else if (paramPartUpper == "SOURCE")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.UseSource;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "CC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // actually' the flag is the opposite of the member -- turn CC ON and we DON'T                                      // want to ignore them; turn CC OFF and we DO want to ignore them                                      JSSettings.IgnoreConditionalCompilation = !parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "COLORS":                                  // two options: hex or names                                  if (paramPartUpper == "HEX")                                  {                                      CssSettings.ColorNames = CssColor.Hex;                                  }                                  else if (paramPartUpper == "STRICT")                                  {                                      CssSettings.ColorNames = CssColor.Strict;                                  }                                  else if (paramPartUpper == "MAJOR")                                  {                                      CssSettings.ColorNames = CssColor.Major;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnCssOnlyParameter();                                  break;                                case "COMMENTS":                                  // four options for css: none' all' important' or hacks                                  // two options for js: none' important                                  // (default is important)                                  if (paramPartUpper == "NONE")                                  {                                      CssSettings.CommentMode = CssComment.None;                                      JSSettings.PreserveImportantComments = false;                                  }                                  else if (paramPartUpper == "ALL")                                  {                                      CssSettings.CommentMode = CssComment.All;                                      OnCssOnlyParameter();                                  }                                  else if (paramPartUpper == "IMPORTANT")                                  {                                      CssSettings.CommentMode = CssComment.Important;                                      JSSettings.PreserveImportantComments = true;                                  }                                  else if (paramPartUpper == "HACKS")                                  {                                      CssSettings.CommentMode = CssComment.Hacks;                                      OnCssOnlyParameter();                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    break;                                case "CONST":                                  // options: MOZ or ES6 (ES6 is the default)                                  if (paramPartUpper == "MOZ")                                  {                                      JSSettings.ConstStatementsMozilla = true;                                  }                                  else if (paramPartUpper == "ES6")                                  {                                      JSSettings.ConstStatementsMozilla = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "CSS":                                  OnCssOnlyParameter();                                  if (paramPartUpper != null)                                  {                                      switch (paramPartUpper)                                      {                                          case "FULL":                                              CssSettings.CssType = CssType.FullStyleSheet;                                              break;                                            case "DECLS":                                              CssSettings.CssType = CssType.DeclarationList;                                              break;                                            default:                                              // not an expected value                                              OnInvalidSwitch(switchPart' paramPart);                                              break;                                      }                                  }                                  break;                                case "DEBUG":                                  // see if the param part is a comma-delimited list                                  if (paramPartUpper != null && paramPartUpper.IndexOf(''') >= 0)                                  {                                      // we have a comma-separated list.                                      // the first item is the flag (if any)' and the rest (if any) are the "debug" lookup names                                      var items = paramPart.Split(listSeparators);                                        // use the first value as the debug boolean switch.                                      // since we are splitting the non-uppercase param part' we need to                                       // make sure the first item is capitalized for our boolean test.                                      if (BooleanSwitch(items[0].ToUpperInvariant()' true' out parameterFlag))                                      {                                          // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                          // strip debug statements' and a FALSE means we DO want to strip them                                          JSSettings.StripDebugStatements = !parameterFlag;                                            // make sure we align the DEBUG define to the new switch value                                          AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                        // clear out the existing debug list                                      JSSettings.DebugLookupList = null;                                        // start with index 1' since index 0 was the flag                                      for (var item = 1; item < items.Length; ++item)                                      {                                          // get the identifier that was specified                                          var identifier = items[item];                                          if (!identifier.IsNullOrWhiteSpace())                                          {                                              if (!JSSettings.AddDebugLookup(identifier))                                              {                                                  OnInvalidSwitch(switchPart' identifier);                                              }                                          }                                      }                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // no commas -- just use the entire param part as the boolean value.                                      // just putting the debug switch on the command line without any arguments                                      // is the same as putting -debug:true and perfectly valid.                                        // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                      // strip debug statements' and a FALSE means we DO want to strip them                                      JSSettings.StripDebugStatements = !parameterFlag;                                        // make sure we align the DEBUG define to the new switch value                                      AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "DEFINE":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string define in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          string trimmedName;                                          string value;                                          var ndxEquals = define.IndexOf('=');                                          if (ndxEquals < 0)                                          {                                              trimmedName = define.Trim();                                              value = string.Empty;                                          }                                          else                                          {                                              trimmedName = define.Substring(0' ndxEquals).Trim();                                              value = define.Substring(ndxEquals + 1);                                          }                                            // better be a valid JavaScript identifier                                          if (!JsScanner.IsValidIdentifier(trimmedName))                                          {                                              OnInvalidSwitch(switchPart' define);                                          }                                          else                                          {                                              // JS Settings                                              JSSettings.PreprocessorValues[trimmedName] = value;                                                // CSS settings                                              CssSettings.PreprocessorValues[trimmedName] = value;                                          }                                            // if we're defining the DEBUG name' set the strip-debug-statements flag to false                                          if (string.Compare(trimmedName' "DEBUG"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              JSSettings.StripDebugStatements = false;                                          }                                      }                                  }                                    break;                                case "ENC":                                  // the encoding is the next argument                                  if (ndx >= args.Length - 1)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      string encoding = args[++ndx];                                        // whether this is an in or an out encoding                                      if (paramPartUpper == "IN")                                      {                                          // save the name -- we'll create the encoding later because we may                                          // override it on a file-by-file basis in an XML file                                          EncodingInputName = encoding;                                      }                                      else if (paramPartUpper == "OUT")                                      {                                          // just save the name -- we'll create the encoding later because we need                                          // to know whether we are JS or CSS to pick the right encoding fallback                                          EncodingOutputName = encoding;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "ESC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.AlwaysEscapeNonAscii = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "EVALS":                                  // three options: ignore' make immediate scope safe' or make all scopes safe                                  if (paramPartUpper == "IGNORE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  }                                  else if (paramPartUpper == "IMMEDIATE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeImmediateSafe;                                  }                                  else if (paramPartUpper == "SAFEALL")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeAllSafe;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "EXPR":                                  // two options: minify (default) or raw                                  if (paramPartUpper == "MINIFY")                                  {                                      CssSettings.MinifyExpressions = true;                                  }                                  else if (paramPartUpper == "RAW")                                  {                                      CssSettings.MinifyExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    OnCssOnlyParameter();                                  break;                                case "FNAMES":                                  // three options:                                   // LOCK    -> keep all NFE names' don't allow renaming of function names                                  // KEEP    -> keep all NFE names' but allow function names to be renamed                                  // ONLYREF -> remove unref'd NFE names' allow function named to be renamed (DEFAULT)                                  if (paramPartUpper == "LOCK")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // and preserve the names (don't allow renaming)                                      JSSettings.PreserveFunctionNames = true;                                  }                                  else if (paramPartUpper == "KEEP")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // but it's okay to rename them                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      // remove function expression names if they aren't referenced                                      JSSettings.RemoveFunctionExpressionNames = true;                                        // and rename them if we so desire                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "GLOBAL":                              case "G": // <-- old style                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string global in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddKnownGlobal(global))                                          {                                              OnInvalidSwitch(switchPart' global);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "IGNORE":                                  // list of error codes to ignore (not report)                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string errorCode in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.Compare(errorCode' "ALL"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              // we want to ignore ALL errors. So set the appropriate flag                                              JSSettings.IgnoreAllErrors =                                                  CssSettings.IgnoreAllErrors = true;                                          }                                          else                                          {                                              // don't add duplicates                                              JSSettings.IgnoreErrorCollection.Add(errorCode);                                              CssSettings.IgnoreErrorCollection.Add(errorCode);                                          }                                      }                                  }                                  break;                                case "INLINE":                                  if (string.IsNullOrEmpty(paramPart))                                  {                                      // no param parts. This defaults to inline-safe                                      JSSettings.InlineSafeStrings = true;                                  }                                  else                                  {                                      // for each comma-separated part...                                      foreach (var inlinePart in paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.CompareOrdinal(inlinePart' "FORCE") == 0)                                          {                                              // this is the force flag -- throw an error if any string literal                                              // sources are not properly escaped AND make sure the output is                                               // safe                                              JSSettings.ErrorIfNotInlineSafe = true;                                              JSSettings.InlineSafeStrings = true;                                          }                                          else if (string.CompareOrdinal(inlinePart' "NOFORCE") == 0)                                          {                                              // this is the noforce flag; don't throw an error is the source isn't inline safe.                                              // don't change whatever the output-inline-safe flag may happen to be' though                                              JSSettings.ErrorIfNotInlineSafe = false;                                          }                                          else                                          {                                              // assume it must be the boolean flag.                                              // if no param part' will return true (indicating the default)                                              // if invalid param part' will throw error                                              if (BooleanSwitch(inlinePart' true' out parameterFlag))                                              {                                                  JSSettings.InlineSafeStrings = parameterFlag;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "JS":                                  if (paramPart == null)                                  {                                      // normal settings                                      JSSettings.SourceMode = JsSourceMode.Program;                                      JSSettings.Format = JsFormat.Normal;                                  }                                  else                                  {                                      // comma-delimited list of JS settings                                      var tokens = paramPartUpper.Split('''' ';');                                      foreach (var token in tokens)                                      {                                          switch (token)                                          {                                              case "JSON":                                                  // JSON is incompatible with any other tokens' so throw an error                                                  // if it's not the only token                                                  if (tokens.Length > 1)                                                  {                                                      OnInvalidSwitch(switchPart' paramPart);                                                  }                                                    // nothing to "minify" in the JSON format' so turn off the minify flag                                                  JSSettings.MinifyCode = false;                                                    // JSON affects both the input (it's an expression) and the output                                                  // (use the JSON-output visitor)                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  JSSettings.Format = JsFormat.JSON;                                                  break;                                                case "PROG":                                                  // this is the default setting                                                  JSSettings.SourceMode = JsSourceMode.Program;                                                  break;                                                case "EXPR":                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  break;                                                case "EVT":                                                  JSSettings.SourceMode = JsSourceMode.EventHandler;                                                  break;                                                default:                                                  // later: ES5 to convert any ES6 syntax to ES5-compatible                                                  // later: ES6 to create ES6 syntax when optimizing                                                  // etc.                                                  // those two examples will affect the format property.                                                  // but for now' not supported                                                  OnInvalidSwitch(switchPart' paramPart);                                                  break;                                          }                                      }                                  }                                    OnJSOnlyParameter();                                  break;                                case "KILL":                                  killSpecified = true;                                    // optional integer switch argument                                  if (paramPartUpper == null)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      // get the numeric portion                                      long killSwitch;                                      if (paramPartUpper.StartsWith("0X"' StringComparison.OrdinalIgnoreCase))                                      {                                          // it's hex -- convert the number after the "0x"                                          if (paramPartUpper.Substring(2).TryParseLongInvariant(NumberStyles.AllowHexSpecifier' out killSwitch))                                          {                                              // save the switch for both JS and Css                                              JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                                // for CSS' we only look at the first bit: preeserve important comments                                              if ((killSwitch & 1) != 0)                                              {                                                  // we set the kill' so make sure the comments are set to none                                                  CssSettings.CommentMode = CssComment.None;                                              }                                          }                                          else                                          {                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                      else if (paramPartUpper.TryParseLongInvariant(NumberStyles.AllowLeadingSign' out killSwitch))                                      {                                          // save the switch for both JS and CSS                                          JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                            // for CSS' we only look at the first bit: preeserve important comments                                          if ((killSwitch & 1) != 0)                                          {                                              // we set the kill' so make sure the comments are set to none                                              CssSettings.CommentMode = CssComment.None;                                          }                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LINE":                              case "LINES":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // if no number specified' use the max default threshold                                      JSSettings.LineBreakThreshold =                                          CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                                                            // single-line mode                                      JSSettings.OutputMode =                                           CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                        // and four spaces per indent level                                      JSSettings.IndentSize =                                          CssSettings.IndentSize = 4;                                  }                                  else                                  {                                      // split along commas (case-insensitive)                                      var lineParts = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                        // by default' the line-break index will be 1 (the second option).                                      // we will change this index to 0 if the first parameter is multi/single                                      // instead of the line-break character count.                                      var breakIndex = 1;                                      if (lineParts.Length <= 3)                                      {                                          // if the first optional part is numeric' then it's the line threshold.                                          // might also be "multi" or "single"' thereby skipping the line threshold.                                          // (don't need to check length greater than zero -- will always be at least one element returned from Split)                                          if (!string.IsNullOrEmpty(lineParts[0]))                                          {                                              // must be an unsigned decimal integer value                                              int lineThreshold;                                              if (lineParts[0].TryParseIntInvariant(NumberStyles.None' out lineThreshold))                                              {                                                  JSSettings.LineBreakThreshold =                                                      CssSettings.LineBreakThreshold = lineThreshold;                                              }                                              else if (lineParts[0][0] == 'S')                                              {                                                  // single-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else if (lineParts[0][0] == 'M')                                              {                                                  // multiple-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' lineParts[0]);                                              }                                          }                                          else                                          {                                              // use the default                                              JSSettings.LineBreakThreshold =                                                  CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                          }                                            if (lineParts.Length > breakIndex)                                          {                                              // if the line-break index was zero' then we already processed it                                              // and we can skip the logic                                              if (breakIndex > 0)                                              {                                                  // second optional part is single or multiple line output                                                  if (string.IsNullOrEmpty(lineParts[breakIndex]) || lineParts[breakIndex][0] == 'S')                                                  {                                                      // single-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                  }                                                  else if (lineParts[breakIndex][0] == 'M')                                                  {                                                      // multiple-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                  }                                                  else                                                  {                                                      // must either be missing' or start with S (single) or M (multiple)                                                      OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                  }                                              }                                                // move on to the next part                                              ++breakIndex;                                              if (lineParts.Length > breakIndex)                                              {                                                  // third optional part is the spaces-per-indent value                                                  if (!string.IsNullOrEmpty(lineParts[breakIndex]))                                                  {                                                      // get the numeric portion; must be a decimal integer                                                      int indentSize;                                                      if (lineParts[breakIndex].TryParseIntInvariant(NumberStyles.None' out indentSize))                                                      {                                                          // same value for JS and CSS.                                                          // don't need to check for negative' because the tryparse method above does NOT                                                          // allow for a sign -- no sign' no negative.                                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                                      }                                                      else                                                      {                                                          OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                      }                                                  }                                                  else                                                  {                                                      // default of 4                                                      JSSettings.IndentSize =                                                          CssSettings.IndentSize = 4;                                                  }                                              }                                          }                                      }                                      else                                      {                                          // only 1-3 parts allowed                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LITERALS":                                  // two areas with two options each: keep or combine and eval or noeval                                  if (paramPartUpper == "KEEP")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = false;                                  }                                  else if (paramPartUpper == "COMBINE")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = true;                                  }                                  else if (paramPartUpper == "EVAL")                                  {                                      JSSettings.EvalLiteralExpressions = true;                                  }                                  else if (paramPartUpper == "NOEVAL")                                  {                                      JSSettings.EvalLiteralExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MAC":                                  // optional boolean switch                                  // no arg is valid scenario (default is true)                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.MacSafariQuirks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MINIFY":                                  minifySpecified = true;                                  if (renamingSpecified && JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      // minify can only exist if rename is set to KeepAll                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // optional boolean switch                                      // no arg is a valid scenario (default is true)                                      JSSettings.MinifyCode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NEW":                                  // two options: keep and collapse                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.CollapseToLiteral = false;                                  }                                  else if (paramPartUpper == "COLLAPSE")                                  {                                      JSSettings.CollapseToLiteral = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NFE": // <-- deprecate; use FNAMES option instead                                  if (paramPartUpper == "KEEPALL")                                  {                                      JSSettings.RemoveFunctionExpressionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      JSSettings.RemoveFunctionExpressionNames = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NORENAME":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string ident in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddNoAutoRename(ident))                                          {                                              OnInvalidSwitch(switchPart' ident);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "OBJ":                                  // two options: MINify or QUOTE                                  if (paramPartUpper == "MIN")                                  {                                      JSSettings.QuoteObjectLiteralProperties = false;                                  }                                  else if (paramPartUpper == "QUOTE")                                  {                                      JSSettings.QuoteObjectLiteralProperties = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PPONLY":                                  // just putting the pponly switch on the command line without any arguments                                  // is the same as putting -pponly:true and perfectly valid.                                  if (paramPart == null)                                  {                                      JSSettings.PreprocessOnly = true;                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.PreprocessOnly = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PRETTY":                              case "P": // <-- old style                                  // doesn't take a flag -- just set to pretty                                  PrettyPrint = true;                                                // by default' pretty mode turns off minification' which sets a bunch of other flags as well                                  JSSettings.MinifyCode = false;                                    // and some other flags for pretty-mode                                  JSSettings.OutputMode = CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                  CssSettings.KillSwitch = ~((long)JsTreeModifications.PreserveImportantComments);                                    // optional integer switch argument                                  if (paramPartUpper != null)                                  {                                      // get the numeric portion; must be a decimal integer                                      int indentSize;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out indentSize))                                      {                                          // same value for JS and CSS.                                          // don't need to check for negative' because the tryparse method above does NOT                                          // allow for a sign -- no sign' no negative.                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                      }                                      else                                       {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "RENAME":                                  if (paramPartUpper == null)                                  {                                      // treat as if it's unknown                                      ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  }                                  else if (paramPartUpper.IndexOf('=') > 0)                                  {                                      // there is at least one equal sign -- treat this as a set of JS identifier                                      // pairs. split on commas -- multiple pairs can be specified                                      var paramPairs = paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var paramPair in paramPairs)                                      {                                          // split on the equal sign -- each pair needs to have an equal sige                                          var pairParts = paramPair.Split('=');                                          if (pairParts.Length == 2)                                          {                                              // there is an equal sign. The first part is the source name and the                                              // second part is the new name to which to rename those entities.                                              string fromIdentifier = pairParts[0];                                              string toIdentifier = pairParts[1];                                                // make sure both parts are valid JS identifiers                                              var fromIsValid = JsScanner.IsValidIdentifier(fromIdentifier);                                              var toIsValid = JsScanner.IsValidIdentifier(toIdentifier);                                              if (fromIsValid && toIsValid)                                              {                                                  // create the map if it hasn't been created yet.                                                  var toExisting = JSSettings.GetNewName(fromIdentifier);                                                  if (toExisting == null)                                                  {                                                      JSSettings.AddRenamePair(fromIdentifier' toIdentifier);                                                  }                                                  else if (string.CompareOrdinal(toIdentifier' toExisting) != 0)                                                  {                                                      // from-identifier already exists' and the to-identifier doesn't match.                                                      // can't rename the same name to two different names!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                              else                                              {                                                  if (fromIsValid)                                                  {                                                      // the toIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' toIdentifier);                                                  }                                                    if (toIsValid)                                                  {                                                      // the fromIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                          }                                          else                                          {                                              // either zero or more than one equal sign. Invalid.                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                  }                                  else                                  {                                      // no equal sign; just a plain option                                      // three options: all' localization' none                                      if (paramPartUpper == "ALL")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "LOCALIZATION")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NONE")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NOPROPS")                                      {                                          // manual-renaming does not change property names                                          JSSettings.ManualRenamesProperties = false;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  if (JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      ResetRenamingKill(killSpecified);                                        // if minify was specified as turned off' then this is invalid                                      if (minifySpecified && !JSSettings.MinifyCode)                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "REORDER":                                  // default is true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.ReorderScopeDeclarations = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "STRICT":                                  // default is false' but if we specify this switch without a parameter' then                                  // we assume we are turning it ON                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.StrictMode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "TERM":                                  // optional boolean argument' defaults to true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.TermSemicolons =                                          CssSettings.TermSemicolons = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "UNUSED":                                  // two options: keep and remove                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.RemoveUnneededCode = false;                                  }                                  else if (paramPartUpper == "REMOVE")                                  {                                      JSSettings.RemoveUnneededCode = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "VAR":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      var firstLetters = paramPart;                                      string partLetters = null;                                        var commaPosition = paramPart.IndexOf(''');                                      if (commaPosition == 0)                                      {                                          // no first letters; just part letters                                          firstLetters = null;                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                      else if (commaPosition > 0)                                      {                                          // first letters and part letters                                          firstLetters = paramPart.Substring(0' commaPosition);                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                        // if we specified first letters' set them now                                      if (!string.IsNullOrEmpty(firstLetters))                                      {                                          JsCrunchEnumerator.FirstLetters = firstLetters;                                      }                                        // if we specified part letters' use it -- otherwise use the first letters.                                      if (!string.IsNullOrEmpty(partLetters))                                      {                                          JsCrunchEnumerator.PartLetters = partLetters;                                      }                                      else if (!string.IsNullOrEmpty(firstLetters))                                      {                                          // we don't have any part letters' but we do have first letters. reuse.                                          JsCrunchEnumerator.PartLetters = firstLetters;                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "WARN":                              case "W": // <-- old style                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // just "-warn" without anything else means all errors and warnings                                      WarningLevel = int.MaxValue;                                  }                                  else                                  {                                      // must be an unsigned decimal integer value                                      int warningLevel;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out warningLevel))                                      {                                          WarningLevel = warningLevel;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  levelSpecified = true;                                  break;                                //                              // Backward-compatibility switches different from new switches                              //                                case "D":                                  // equivalent to -debug:false (default behavior)                                  JSSettings.StripDebugStatements = true;                                  OnJSOnlyParameter();                                  break;                                case "E":                              case "EO":                                  // equivalent to -enc:out <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // just save the name -- we'll create the encoding later because we need                                  // to know whether we are JS or CSS to pick the right encoding fallback                                  EncodingOutputName = paramPart;                                  break;                                case "EI":                                  // equivalent to -enc:in <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // save the name                                  EncodingInputName = paramPart;                                  break;                                case "H":                                  // equivalent to -rename:all -unused:remove (default behavior)                                  JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HL":                                  // equivalent to -rename:localization -unused:remove                                  JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HC":                                  // equivalent to -literals:combine -rename:all -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "H";                                case "HLC":                              case "HCL":                                  // equivalent to -literals:combine -rename:localization -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "HL";                                case "J":                                  // equivalent to -evals:ignore (default behavior)                                  JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  OnJSOnlyParameter();                                  break;                                case "K":                                  // equivalent to -inline:true (default behavior)                                  JSSettings.InlineSafeStrings = true;                                  OnJSOnlyParameter();                                  break;                                case "L":                                  // equivalent to -new:keep (default is collapse)                                  JSSettings.CollapseToLiteral = false;                                  OnJSOnlyParameter();                                  break;                                case "M":                                  // equivalent to -mac:true (default behavior)                                  JSSettings.MacSafariQuirks = true;                                  OnJSOnlyParameter();                                  break;                                case "Z":                                  // equivalent to -term:true (default is false)                                  JSSettings.TermSemicolons =                                      CssSettings.TermSemicolons = true;                                  break;                                // end backward-compatible section                                default:                                  ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  break;                          }
Magic Number,Spike.Build.Minifiers,MinifierParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\MinifierParser.cs,Parse,The following statement contains a magic number: switch (switchPart)                          {                              case "ANALYZE":                              case "A": // <-- old-style                                  // ignore any arguments                                  AnalyzeMode = true;                                    // by default' we have no report format                                  ReportFormat = null;                                  if (paramPartUpper != null)                                  {                                      var items = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var item in items)                                      {                                          if (string.CompareOrdinal(item' "OUT") == 0)                                          {                                              // if the analyze part is "out'" then the NEXT arg string                                              // is the output path the analyze scope report should be written to.                                              if (ndx >= args.Length - 1)                                              {                                                  // must be followed by a path                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                              else                                              {                                                  ReportPath = args[++ndx];                                              }                                          }                                          else                                          {                                              // must be a report format. There can be only one' so clobber whatever                                              // is there from before -- last one listed wins.                                              ReportFormat = item;                                          }                                      }                                  }                                    // if analyze was specified but no warning level' jack up the warning level                                  // so everything is shown                                  if (!levelSpecified)                                  {                                      // we want to analyze' and we didn't specify a particular warning level.                                      // go ahead and report all errors                                      WarningLevel = int.MaxValue;                                  }                                    break;                                case "ASPNET":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // same setting for both CSS and JS                                      JSSettings.AllowEmbeddedAspNetBlocks =                                          CssSettings.AllowEmbeddedAspNetBlocks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "BRACES":                                  if (paramPartUpper == "NEW")                                  {                                      JSSettings.BlocksStartOnSameLine =                                           CssSettings.BlocksStartOnSameLine = MinifierBlockStart.NewLine;                                  }                                  else if (paramPartUpper == "SAME")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.SameLine;                                  }                                  else if (paramPartUpper == "SOURCE")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.UseSource;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "CC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // actually' the flag is the opposite of the member -- turn CC ON and we DON'T                                      // want to ignore them; turn CC OFF and we DO want to ignore them                                      JSSettings.IgnoreConditionalCompilation = !parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "COLORS":                                  // two options: hex or names                                  if (paramPartUpper == "HEX")                                  {                                      CssSettings.ColorNames = CssColor.Hex;                                  }                                  else if (paramPartUpper == "STRICT")                                  {                                      CssSettings.ColorNames = CssColor.Strict;                                  }                                  else if (paramPartUpper == "MAJOR")                                  {                                      CssSettings.ColorNames = CssColor.Major;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnCssOnlyParameter();                                  break;                                case "COMMENTS":                                  // four options for css: none' all' important' or hacks                                  // two options for js: none' important                                  // (default is important)                                  if (paramPartUpper == "NONE")                                  {                                      CssSettings.CommentMode = CssComment.None;                                      JSSettings.PreserveImportantComments = false;                                  }                                  else if (paramPartUpper == "ALL")                                  {                                      CssSettings.CommentMode = CssComment.All;                                      OnCssOnlyParameter();                                  }                                  else if (paramPartUpper == "IMPORTANT")                                  {                                      CssSettings.CommentMode = CssComment.Important;                                      JSSettings.PreserveImportantComments = true;                                  }                                  else if (paramPartUpper == "HACKS")                                  {                                      CssSettings.CommentMode = CssComment.Hacks;                                      OnCssOnlyParameter();                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    break;                                case "CONST":                                  // options: MOZ or ES6 (ES6 is the default)                                  if (paramPartUpper == "MOZ")                                  {                                      JSSettings.ConstStatementsMozilla = true;                                  }                                  else if (paramPartUpper == "ES6")                                  {                                      JSSettings.ConstStatementsMozilla = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "CSS":                                  OnCssOnlyParameter();                                  if (paramPartUpper != null)                                  {                                      switch (paramPartUpper)                                      {                                          case "FULL":                                              CssSettings.CssType = CssType.FullStyleSheet;                                              break;                                            case "DECLS":                                              CssSettings.CssType = CssType.DeclarationList;                                              break;                                            default:                                              // not an expected value                                              OnInvalidSwitch(switchPart' paramPart);                                              break;                                      }                                  }                                  break;                                case "DEBUG":                                  // see if the param part is a comma-delimited list                                  if (paramPartUpper != null && paramPartUpper.IndexOf(''') >= 0)                                  {                                      // we have a comma-separated list.                                      // the first item is the flag (if any)' and the rest (if any) are the "debug" lookup names                                      var items = paramPart.Split(listSeparators);                                        // use the first value as the debug boolean switch.                                      // since we are splitting the non-uppercase param part' we need to                                       // make sure the first item is capitalized for our boolean test.                                      if (BooleanSwitch(items[0].ToUpperInvariant()' true' out parameterFlag))                                      {                                          // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                          // strip debug statements' and a FALSE means we DO want to strip them                                          JSSettings.StripDebugStatements = !parameterFlag;                                            // make sure we align the DEBUG define to the new switch value                                          AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                        // clear out the existing debug list                                      JSSettings.DebugLookupList = null;                                        // start with index 1' since index 0 was the flag                                      for (var item = 1; item < items.Length; ++item)                                      {                                          // get the identifier that was specified                                          var identifier = items[item];                                          if (!identifier.IsNullOrWhiteSpace())                                          {                                              if (!JSSettings.AddDebugLookup(identifier))                                              {                                                  OnInvalidSwitch(switchPart' identifier);                                              }                                          }                                      }                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // no commas -- just use the entire param part as the boolean value.                                      // just putting the debug switch on the command line without any arguments                                      // is the same as putting -debug:true and perfectly valid.                                        // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                      // strip debug statements' and a FALSE means we DO want to strip them                                      JSSettings.StripDebugStatements = !parameterFlag;                                        // make sure we align the DEBUG define to the new switch value                                      AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "DEFINE":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string define in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          string trimmedName;                                          string value;                                          var ndxEquals = define.IndexOf('=');                                          if (ndxEquals < 0)                                          {                                              trimmedName = define.Trim();                                              value = string.Empty;                                          }                                          else                                          {                                              trimmedName = define.Substring(0' ndxEquals).Trim();                                              value = define.Substring(ndxEquals + 1);                                          }                                            // better be a valid JavaScript identifier                                          if (!JsScanner.IsValidIdentifier(trimmedName))                                          {                                              OnInvalidSwitch(switchPart' define);                                          }                                          else                                          {                                              // JS Settings                                              JSSettings.PreprocessorValues[trimmedName] = value;                                                // CSS settings                                              CssSettings.PreprocessorValues[trimmedName] = value;                                          }                                            // if we're defining the DEBUG name' set the strip-debug-statements flag to false                                          if (string.Compare(trimmedName' "DEBUG"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              JSSettings.StripDebugStatements = false;                                          }                                      }                                  }                                    break;                                case "ENC":                                  // the encoding is the next argument                                  if (ndx >= args.Length - 1)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      string encoding = args[++ndx];                                        // whether this is an in or an out encoding                                      if (paramPartUpper == "IN")                                      {                                          // save the name -- we'll create the encoding later because we may                                          // override it on a file-by-file basis in an XML file                                          EncodingInputName = encoding;                                      }                                      else if (paramPartUpper == "OUT")                                      {                                          // just save the name -- we'll create the encoding later because we need                                          // to know whether we are JS or CSS to pick the right encoding fallback                                          EncodingOutputName = encoding;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "ESC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.AlwaysEscapeNonAscii = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "EVALS":                                  // three options: ignore' make immediate scope safe' or make all scopes safe                                  if (paramPartUpper == "IGNORE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  }                                  else if (paramPartUpper == "IMMEDIATE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeImmediateSafe;                                  }                                  else if (paramPartUpper == "SAFEALL")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeAllSafe;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "EXPR":                                  // two options: minify (default) or raw                                  if (paramPartUpper == "MINIFY")                                  {                                      CssSettings.MinifyExpressions = true;                                  }                                  else if (paramPartUpper == "RAW")                                  {                                      CssSettings.MinifyExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    OnCssOnlyParameter();                                  break;                                case "FNAMES":                                  // three options:                                   // LOCK    -> keep all NFE names' don't allow renaming of function names                                  // KEEP    -> keep all NFE names' but allow function names to be renamed                                  // ONLYREF -> remove unref'd NFE names' allow function named to be renamed (DEFAULT)                                  if (paramPartUpper == "LOCK")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // and preserve the names (don't allow renaming)                                      JSSettings.PreserveFunctionNames = true;                                  }                                  else if (paramPartUpper == "KEEP")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // but it's okay to rename them                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      // remove function expression names if they aren't referenced                                      JSSettings.RemoveFunctionExpressionNames = true;                                        // and rename them if we so desire                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "GLOBAL":                              case "G": // <-- old style                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string global in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddKnownGlobal(global))                                          {                                              OnInvalidSwitch(switchPart' global);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "IGNORE":                                  // list of error codes to ignore (not report)                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string errorCode in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.Compare(errorCode' "ALL"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              // we want to ignore ALL errors. So set the appropriate flag                                              JSSettings.IgnoreAllErrors =                                                  CssSettings.IgnoreAllErrors = true;                                          }                                          else                                          {                                              // don't add duplicates                                              JSSettings.IgnoreErrorCollection.Add(errorCode);                                              CssSettings.IgnoreErrorCollection.Add(errorCode);                                          }                                      }                                  }                                  break;                                case "INLINE":                                  if (string.IsNullOrEmpty(paramPart))                                  {                                      // no param parts. This defaults to inline-safe                                      JSSettings.InlineSafeStrings = true;                                  }                                  else                                  {                                      // for each comma-separated part...                                      foreach (var inlinePart in paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.CompareOrdinal(inlinePart' "FORCE") == 0)                                          {                                              // this is the force flag -- throw an error if any string literal                                              // sources are not properly escaped AND make sure the output is                                               // safe                                              JSSettings.ErrorIfNotInlineSafe = true;                                              JSSettings.InlineSafeStrings = true;                                          }                                          else if (string.CompareOrdinal(inlinePart' "NOFORCE") == 0)                                          {                                              // this is the noforce flag; don't throw an error is the source isn't inline safe.                                              // don't change whatever the output-inline-safe flag may happen to be' though                                              JSSettings.ErrorIfNotInlineSafe = false;                                          }                                          else                                          {                                              // assume it must be the boolean flag.                                              // if no param part' will return true (indicating the default)                                              // if invalid param part' will throw error                                              if (BooleanSwitch(inlinePart' true' out parameterFlag))                                              {                                                  JSSettings.InlineSafeStrings = parameterFlag;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "JS":                                  if (paramPart == null)                                  {                                      // normal settings                                      JSSettings.SourceMode = JsSourceMode.Program;                                      JSSettings.Format = JsFormat.Normal;                                  }                                  else                                  {                                      // comma-delimited list of JS settings                                      var tokens = paramPartUpper.Split('''' ';');                                      foreach (var token in tokens)                                      {                                          switch (token)                                          {                                              case "JSON":                                                  // JSON is incompatible with any other tokens' so throw an error                                                  // if it's not the only token                                                  if (tokens.Length > 1)                                                  {                                                      OnInvalidSwitch(switchPart' paramPart);                                                  }                                                    // nothing to "minify" in the JSON format' so turn off the minify flag                                                  JSSettings.MinifyCode = false;                                                    // JSON affects both the input (it's an expression) and the output                                                  // (use the JSON-output visitor)                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  JSSettings.Format = JsFormat.JSON;                                                  break;                                                case "PROG":                                                  // this is the default setting                                                  JSSettings.SourceMode = JsSourceMode.Program;                                                  break;                                                case "EXPR":                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  break;                                                case "EVT":                                                  JSSettings.SourceMode = JsSourceMode.EventHandler;                                                  break;                                                default:                                                  // later: ES5 to convert any ES6 syntax to ES5-compatible                                                  // later: ES6 to create ES6 syntax when optimizing                                                  // etc.                                                  // those two examples will affect the format property.                                                  // but for now' not supported                                                  OnInvalidSwitch(switchPart' paramPart);                                                  break;                                          }                                      }                                  }                                    OnJSOnlyParameter();                                  break;                                case "KILL":                                  killSpecified = true;                                    // optional integer switch argument                                  if (paramPartUpper == null)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      // get the numeric portion                                      long killSwitch;                                      if (paramPartUpper.StartsWith("0X"' StringComparison.OrdinalIgnoreCase))                                      {                                          // it's hex -- convert the number after the "0x"                                          if (paramPartUpper.Substring(2).TryParseLongInvariant(NumberStyles.AllowHexSpecifier' out killSwitch))                                          {                                              // save the switch for both JS and Css                                              JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                                // for CSS' we only look at the first bit: preeserve important comments                                              if ((killSwitch & 1) != 0)                                              {                                                  // we set the kill' so make sure the comments are set to none                                                  CssSettings.CommentMode = CssComment.None;                                              }                                          }                                          else                                          {                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                      else if (paramPartUpper.TryParseLongInvariant(NumberStyles.AllowLeadingSign' out killSwitch))                                      {                                          // save the switch for both JS and CSS                                          JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                            // for CSS' we only look at the first bit: preeserve important comments                                          if ((killSwitch & 1) != 0)                                          {                                              // we set the kill' so make sure the comments are set to none                                              CssSettings.CommentMode = CssComment.None;                                          }                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LINE":                              case "LINES":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // if no number specified' use the max default threshold                                      JSSettings.LineBreakThreshold =                                          CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                                                            // single-line mode                                      JSSettings.OutputMode =                                           CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                        // and four spaces per indent level                                      JSSettings.IndentSize =                                          CssSettings.IndentSize = 4;                                  }                                  else                                  {                                      // split along commas (case-insensitive)                                      var lineParts = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                        // by default' the line-break index will be 1 (the second option).                                      // we will change this index to 0 if the first parameter is multi/single                                      // instead of the line-break character count.                                      var breakIndex = 1;                                      if (lineParts.Length <= 3)                                      {                                          // if the first optional part is numeric' then it's the line threshold.                                          // might also be "multi" or "single"' thereby skipping the line threshold.                                          // (don't need to check length greater than zero -- will always be at least one element returned from Split)                                          if (!string.IsNullOrEmpty(lineParts[0]))                                          {                                              // must be an unsigned decimal integer value                                              int lineThreshold;                                              if (lineParts[0].TryParseIntInvariant(NumberStyles.None' out lineThreshold))                                              {                                                  JSSettings.LineBreakThreshold =                                                      CssSettings.LineBreakThreshold = lineThreshold;                                              }                                              else if (lineParts[0][0] == 'S')                                              {                                                  // single-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else if (lineParts[0][0] == 'M')                                              {                                                  // multiple-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' lineParts[0]);                                              }                                          }                                          else                                          {                                              // use the default                                              JSSettings.LineBreakThreshold =                                                  CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                          }                                            if (lineParts.Length > breakIndex)                                          {                                              // if the line-break index was zero' then we already processed it                                              // and we can skip the logic                                              if (breakIndex > 0)                                              {                                                  // second optional part is single or multiple line output                                                  if (string.IsNullOrEmpty(lineParts[breakIndex]) || lineParts[breakIndex][0] == 'S')                                                  {                                                      // single-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                  }                                                  else if (lineParts[breakIndex][0] == 'M')                                                  {                                                      // multiple-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                  }                                                  else                                                  {                                                      // must either be missing' or start with S (single) or M (multiple)                                                      OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                  }                                              }                                                // move on to the next part                                              ++breakIndex;                                              if (lineParts.Length > breakIndex)                                              {                                                  // third optional part is the spaces-per-indent value                                                  if (!string.IsNullOrEmpty(lineParts[breakIndex]))                                                  {                                                      // get the numeric portion; must be a decimal integer                                                      int indentSize;                                                      if (lineParts[breakIndex].TryParseIntInvariant(NumberStyles.None' out indentSize))                                                      {                                                          // same value for JS and CSS.                                                          // don't need to check for negative' because the tryparse method above does NOT                                                          // allow for a sign -- no sign' no negative.                                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                                      }                                                      else                                                      {                                                          OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                      }                                                  }                                                  else                                                  {                                                      // default of 4                                                      JSSettings.IndentSize =                                                          CssSettings.IndentSize = 4;                                                  }                                              }                                          }                                      }                                      else                                      {                                          // only 1-3 parts allowed                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LITERALS":                                  // two areas with two options each: keep or combine and eval or noeval                                  if (paramPartUpper == "KEEP")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = false;                                  }                                  else if (paramPartUpper == "COMBINE")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = true;                                  }                                  else if (paramPartUpper == "EVAL")                                  {                                      JSSettings.EvalLiteralExpressions = true;                                  }                                  else if (paramPartUpper == "NOEVAL")                                  {                                      JSSettings.EvalLiteralExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MAC":                                  // optional boolean switch                                  // no arg is valid scenario (default is true)                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.MacSafariQuirks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MINIFY":                                  minifySpecified = true;                                  if (renamingSpecified && JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      // minify can only exist if rename is set to KeepAll                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // optional boolean switch                                      // no arg is a valid scenario (default is true)                                      JSSettings.MinifyCode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NEW":                                  // two options: keep and collapse                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.CollapseToLiteral = false;                                  }                                  else if (paramPartUpper == "COLLAPSE")                                  {                                      JSSettings.CollapseToLiteral = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NFE": // <-- deprecate; use FNAMES option instead                                  if (paramPartUpper == "KEEPALL")                                  {                                      JSSettings.RemoveFunctionExpressionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      JSSettings.RemoveFunctionExpressionNames = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NORENAME":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string ident in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddNoAutoRename(ident))                                          {                                              OnInvalidSwitch(switchPart' ident);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "OBJ":                                  // two options: MINify or QUOTE                                  if (paramPartUpper == "MIN")                                  {                                      JSSettings.QuoteObjectLiteralProperties = false;                                  }                                  else if (paramPartUpper == "QUOTE")                                  {                                      JSSettings.QuoteObjectLiteralProperties = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PPONLY":                                  // just putting the pponly switch on the command line without any arguments                                  // is the same as putting -pponly:true and perfectly valid.                                  if (paramPart == null)                                  {                                      JSSettings.PreprocessOnly = true;                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.PreprocessOnly = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PRETTY":                              case "P": // <-- old style                                  // doesn't take a flag -- just set to pretty                                  PrettyPrint = true;                                                // by default' pretty mode turns off minification' which sets a bunch of other flags as well                                  JSSettings.MinifyCode = false;                                    // and some other flags for pretty-mode                                  JSSettings.OutputMode = CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                  CssSettings.KillSwitch = ~((long)JsTreeModifications.PreserveImportantComments);                                    // optional integer switch argument                                  if (paramPartUpper != null)                                  {                                      // get the numeric portion; must be a decimal integer                                      int indentSize;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out indentSize))                                      {                                          // same value for JS and CSS.                                          // don't need to check for negative' because the tryparse method above does NOT                                          // allow for a sign -- no sign' no negative.                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                      }                                      else                                       {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "RENAME":                                  if (paramPartUpper == null)                                  {                                      // treat as if it's unknown                                      ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  }                                  else if (paramPartUpper.IndexOf('=') > 0)                                  {                                      // there is at least one equal sign -- treat this as a set of JS identifier                                      // pairs. split on commas -- multiple pairs can be specified                                      var paramPairs = paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var paramPair in paramPairs)                                      {                                          // split on the equal sign -- each pair needs to have an equal sige                                          var pairParts = paramPair.Split('=');                                          if (pairParts.Length == 2)                                          {                                              // there is an equal sign. The first part is the source name and the                                              // second part is the new name to which to rename those entities.                                              string fromIdentifier = pairParts[0];                                              string toIdentifier = pairParts[1];                                                // make sure both parts are valid JS identifiers                                              var fromIsValid = JsScanner.IsValidIdentifier(fromIdentifier);                                              var toIsValid = JsScanner.IsValidIdentifier(toIdentifier);                                              if (fromIsValid && toIsValid)                                              {                                                  // create the map if it hasn't been created yet.                                                  var toExisting = JSSettings.GetNewName(fromIdentifier);                                                  if (toExisting == null)                                                  {                                                      JSSettings.AddRenamePair(fromIdentifier' toIdentifier);                                                  }                                                  else if (string.CompareOrdinal(toIdentifier' toExisting) != 0)                                                  {                                                      // from-identifier already exists' and the to-identifier doesn't match.                                                      // can't rename the same name to two different names!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                              else                                              {                                                  if (fromIsValid)                                                  {                                                      // the toIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' toIdentifier);                                                  }                                                    if (toIsValid)                                                  {                                                      // the fromIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                          }                                          else                                          {                                              // either zero or more than one equal sign. Invalid.                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                  }                                  else                                  {                                      // no equal sign; just a plain option                                      // three options: all' localization' none                                      if (paramPartUpper == "ALL")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "LOCALIZATION")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NONE")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NOPROPS")                                      {                                          // manual-renaming does not change property names                                          JSSettings.ManualRenamesProperties = false;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  if (JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      ResetRenamingKill(killSpecified);                                        // if minify was specified as turned off' then this is invalid                                      if (minifySpecified && !JSSettings.MinifyCode)                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "REORDER":                                  // default is true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.ReorderScopeDeclarations = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "STRICT":                                  // default is false' but if we specify this switch without a parameter' then                                  // we assume we are turning it ON                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.StrictMode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "TERM":                                  // optional boolean argument' defaults to true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.TermSemicolons =                                          CssSettings.TermSemicolons = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "UNUSED":                                  // two options: keep and remove                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.RemoveUnneededCode = false;                                  }                                  else if (paramPartUpper == "REMOVE")                                  {                                      JSSettings.RemoveUnneededCode = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "VAR":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      var firstLetters = paramPart;                                      string partLetters = null;                                        var commaPosition = paramPart.IndexOf(''');                                      if (commaPosition == 0)                                      {                                          // no first letters; just part letters                                          firstLetters = null;                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                      else if (commaPosition > 0)                                      {                                          // first letters and part letters                                          firstLetters = paramPart.Substring(0' commaPosition);                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                        // if we specified first letters' set them now                                      if (!string.IsNullOrEmpty(firstLetters))                                      {                                          JsCrunchEnumerator.FirstLetters = firstLetters;                                      }                                        // if we specified part letters' use it -- otherwise use the first letters.                                      if (!string.IsNullOrEmpty(partLetters))                                      {                                          JsCrunchEnumerator.PartLetters = partLetters;                                      }                                      else if (!string.IsNullOrEmpty(firstLetters))                                      {                                          // we don't have any part letters' but we do have first letters. reuse.                                          JsCrunchEnumerator.PartLetters = firstLetters;                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "WARN":                              case "W": // <-- old style                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // just "-warn" without anything else means all errors and warnings                                      WarningLevel = int.MaxValue;                                  }                                  else                                  {                                      // must be an unsigned decimal integer value                                      int warningLevel;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out warningLevel))                                      {                                          WarningLevel = warningLevel;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  levelSpecified = true;                                  break;                                //                              // Backward-compatibility switches different from new switches                              //                                case "D":                                  // equivalent to -debug:false (default behavior)                                  JSSettings.StripDebugStatements = true;                                  OnJSOnlyParameter();                                  break;                                case "E":                              case "EO":                                  // equivalent to -enc:out <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // just save the name -- we'll create the encoding later because we need                                  // to know whether we are JS or CSS to pick the right encoding fallback                                  EncodingOutputName = paramPart;                                  break;                                case "EI":                                  // equivalent to -enc:in <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // save the name                                  EncodingInputName = paramPart;                                  break;                                case "H":                                  // equivalent to -rename:all -unused:remove (default behavior)                                  JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HL":                                  // equivalent to -rename:localization -unused:remove                                  JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HC":                                  // equivalent to -literals:combine -rename:all -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "H";                                case "HLC":                              case "HCL":                                  // equivalent to -literals:combine -rename:localization -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "HL";                                case "J":                                  // equivalent to -evals:ignore (default behavior)                                  JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  OnJSOnlyParameter();                                  break;                                case "K":                                  // equivalent to -inline:true (default behavior)                                  JSSettings.InlineSafeStrings = true;                                  OnJSOnlyParameter();                                  break;                                case "L":                                  // equivalent to -new:keep (default is collapse)                                  JSSettings.CollapseToLiteral = false;                                  OnJSOnlyParameter();                                  break;                                case "M":                                  // equivalent to -mac:true (default behavior)                                  JSSettings.MacSafariQuirks = true;                                  OnJSOnlyParameter();                                  break;                                case "Z":                                  // equivalent to -term:true (default is false)                                  JSSettings.TermSemicolons =                                      CssSettings.TermSemicolons = true;                                  break;                                // end backward-compatible section                                default:                                  ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  break;                          }
Magic Number,Spike.Build.Minifiers,MinifierParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\MinifierParser.cs,Parse,The following statement contains a magic number: switch (switchPart)                          {                              case "ANALYZE":                              case "A": // <-- old-style                                  // ignore any arguments                                  AnalyzeMode = true;                                    // by default' we have no report format                                  ReportFormat = null;                                  if (paramPartUpper != null)                                  {                                      var items = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var item in items)                                      {                                          if (string.CompareOrdinal(item' "OUT") == 0)                                          {                                              // if the analyze part is "out'" then the NEXT arg string                                              // is the output path the analyze scope report should be written to.                                              if (ndx >= args.Length - 1)                                              {                                                  // must be followed by a path                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                              else                                              {                                                  ReportPath = args[++ndx];                                              }                                          }                                          else                                          {                                              // must be a report format. There can be only one' so clobber whatever                                              // is there from before -- last one listed wins.                                              ReportFormat = item;                                          }                                      }                                  }                                    // if analyze was specified but no warning level' jack up the warning level                                  // so everything is shown                                  if (!levelSpecified)                                  {                                      // we want to analyze' and we didn't specify a particular warning level.                                      // go ahead and report all errors                                      WarningLevel = int.MaxValue;                                  }                                    break;                                case "ASPNET":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // same setting for both CSS and JS                                      JSSettings.AllowEmbeddedAspNetBlocks =                                          CssSettings.AllowEmbeddedAspNetBlocks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "BRACES":                                  if (paramPartUpper == "NEW")                                  {                                      JSSettings.BlocksStartOnSameLine =                                           CssSettings.BlocksStartOnSameLine = MinifierBlockStart.NewLine;                                  }                                  else if (paramPartUpper == "SAME")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.SameLine;                                  }                                  else if (paramPartUpper == "SOURCE")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.UseSource;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "CC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // actually' the flag is the opposite of the member -- turn CC ON and we DON'T                                      // want to ignore them; turn CC OFF and we DO want to ignore them                                      JSSettings.IgnoreConditionalCompilation = !parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "COLORS":                                  // two options: hex or names                                  if (paramPartUpper == "HEX")                                  {                                      CssSettings.ColorNames = CssColor.Hex;                                  }                                  else if (paramPartUpper == "STRICT")                                  {                                      CssSettings.ColorNames = CssColor.Strict;                                  }                                  else if (paramPartUpper == "MAJOR")                                  {                                      CssSettings.ColorNames = CssColor.Major;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnCssOnlyParameter();                                  break;                                case "COMMENTS":                                  // four options for css: none' all' important' or hacks                                  // two options for js: none' important                                  // (default is important)                                  if (paramPartUpper == "NONE")                                  {                                      CssSettings.CommentMode = CssComment.None;                                      JSSettings.PreserveImportantComments = false;                                  }                                  else if (paramPartUpper == "ALL")                                  {                                      CssSettings.CommentMode = CssComment.All;                                      OnCssOnlyParameter();                                  }                                  else if (paramPartUpper == "IMPORTANT")                                  {                                      CssSettings.CommentMode = CssComment.Important;                                      JSSettings.PreserveImportantComments = true;                                  }                                  else if (paramPartUpper == "HACKS")                                  {                                      CssSettings.CommentMode = CssComment.Hacks;                                      OnCssOnlyParameter();                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    break;                                case "CONST":                                  // options: MOZ or ES6 (ES6 is the default)                                  if (paramPartUpper == "MOZ")                                  {                                      JSSettings.ConstStatementsMozilla = true;                                  }                                  else if (paramPartUpper == "ES6")                                  {                                      JSSettings.ConstStatementsMozilla = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "CSS":                                  OnCssOnlyParameter();                                  if (paramPartUpper != null)                                  {                                      switch (paramPartUpper)                                      {                                          case "FULL":                                              CssSettings.CssType = CssType.FullStyleSheet;                                              break;                                            case "DECLS":                                              CssSettings.CssType = CssType.DeclarationList;                                              break;                                            default:                                              // not an expected value                                              OnInvalidSwitch(switchPart' paramPart);                                              break;                                      }                                  }                                  break;                                case "DEBUG":                                  // see if the param part is a comma-delimited list                                  if (paramPartUpper != null && paramPartUpper.IndexOf(''') >= 0)                                  {                                      // we have a comma-separated list.                                      // the first item is the flag (if any)' and the rest (if any) are the "debug" lookup names                                      var items = paramPart.Split(listSeparators);                                        // use the first value as the debug boolean switch.                                      // since we are splitting the non-uppercase param part' we need to                                       // make sure the first item is capitalized for our boolean test.                                      if (BooleanSwitch(items[0].ToUpperInvariant()' true' out parameterFlag))                                      {                                          // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                          // strip debug statements' and a FALSE means we DO want to strip them                                          JSSettings.StripDebugStatements = !parameterFlag;                                            // make sure we align the DEBUG define to the new switch value                                          AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                        // clear out the existing debug list                                      JSSettings.DebugLookupList = null;                                        // start with index 1' since index 0 was the flag                                      for (var item = 1; item < items.Length; ++item)                                      {                                          // get the identifier that was specified                                          var identifier = items[item];                                          if (!identifier.IsNullOrWhiteSpace())                                          {                                              if (!JSSettings.AddDebugLookup(identifier))                                              {                                                  OnInvalidSwitch(switchPart' identifier);                                              }                                          }                                      }                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // no commas -- just use the entire param part as the boolean value.                                      // just putting the debug switch on the command line without any arguments                                      // is the same as putting -debug:true and perfectly valid.                                        // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                      // strip debug statements' and a FALSE means we DO want to strip them                                      JSSettings.StripDebugStatements = !parameterFlag;                                        // make sure we align the DEBUG define to the new switch value                                      AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "DEFINE":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string define in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          string trimmedName;                                          string value;                                          var ndxEquals = define.IndexOf('=');                                          if (ndxEquals < 0)                                          {                                              trimmedName = define.Trim();                                              value = string.Empty;                                          }                                          else                                          {                                              trimmedName = define.Substring(0' ndxEquals).Trim();                                              value = define.Substring(ndxEquals + 1);                                          }                                            // better be a valid JavaScript identifier                                          if (!JsScanner.IsValidIdentifier(trimmedName))                                          {                                              OnInvalidSwitch(switchPart' define);                                          }                                          else                                          {                                              // JS Settings                                              JSSettings.PreprocessorValues[trimmedName] = value;                                                // CSS settings                                              CssSettings.PreprocessorValues[trimmedName] = value;                                          }                                            // if we're defining the DEBUG name' set the strip-debug-statements flag to false                                          if (string.Compare(trimmedName' "DEBUG"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              JSSettings.StripDebugStatements = false;                                          }                                      }                                  }                                    break;                                case "ENC":                                  // the encoding is the next argument                                  if (ndx >= args.Length - 1)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      string encoding = args[++ndx];                                        // whether this is an in or an out encoding                                      if (paramPartUpper == "IN")                                      {                                          // save the name -- we'll create the encoding later because we may                                          // override it on a file-by-file basis in an XML file                                          EncodingInputName = encoding;                                      }                                      else if (paramPartUpper == "OUT")                                      {                                          // just save the name -- we'll create the encoding later because we need                                          // to know whether we are JS or CSS to pick the right encoding fallback                                          EncodingOutputName = encoding;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "ESC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.AlwaysEscapeNonAscii = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "EVALS":                                  // three options: ignore' make immediate scope safe' or make all scopes safe                                  if (paramPartUpper == "IGNORE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  }                                  else if (paramPartUpper == "IMMEDIATE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeImmediateSafe;                                  }                                  else if (paramPartUpper == "SAFEALL")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeAllSafe;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "EXPR":                                  // two options: minify (default) or raw                                  if (paramPartUpper == "MINIFY")                                  {                                      CssSettings.MinifyExpressions = true;                                  }                                  else if (paramPartUpper == "RAW")                                  {                                      CssSettings.MinifyExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    OnCssOnlyParameter();                                  break;                                case "FNAMES":                                  // three options:                                   // LOCK    -> keep all NFE names' don't allow renaming of function names                                  // KEEP    -> keep all NFE names' but allow function names to be renamed                                  // ONLYREF -> remove unref'd NFE names' allow function named to be renamed (DEFAULT)                                  if (paramPartUpper == "LOCK")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // and preserve the names (don't allow renaming)                                      JSSettings.PreserveFunctionNames = true;                                  }                                  else if (paramPartUpper == "KEEP")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // but it's okay to rename them                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      // remove function expression names if they aren't referenced                                      JSSettings.RemoveFunctionExpressionNames = true;                                        // and rename them if we so desire                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "GLOBAL":                              case "G": // <-- old style                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string global in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddKnownGlobal(global))                                          {                                              OnInvalidSwitch(switchPart' global);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "IGNORE":                                  // list of error codes to ignore (not report)                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string errorCode in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.Compare(errorCode' "ALL"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              // we want to ignore ALL errors. So set the appropriate flag                                              JSSettings.IgnoreAllErrors =                                                  CssSettings.IgnoreAllErrors = true;                                          }                                          else                                          {                                              // don't add duplicates                                              JSSettings.IgnoreErrorCollection.Add(errorCode);                                              CssSettings.IgnoreErrorCollection.Add(errorCode);                                          }                                      }                                  }                                  break;                                case "INLINE":                                  if (string.IsNullOrEmpty(paramPart))                                  {                                      // no param parts. This defaults to inline-safe                                      JSSettings.InlineSafeStrings = true;                                  }                                  else                                  {                                      // for each comma-separated part...                                      foreach (var inlinePart in paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.CompareOrdinal(inlinePart' "FORCE") == 0)                                          {                                              // this is the force flag -- throw an error if any string literal                                              // sources are not properly escaped AND make sure the output is                                               // safe                                              JSSettings.ErrorIfNotInlineSafe = true;                                              JSSettings.InlineSafeStrings = true;                                          }                                          else if (string.CompareOrdinal(inlinePart' "NOFORCE") == 0)                                          {                                              // this is the noforce flag; don't throw an error is the source isn't inline safe.                                              // don't change whatever the output-inline-safe flag may happen to be' though                                              JSSettings.ErrorIfNotInlineSafe = false;                                          }                                          else                                          {                                              // assume it must be the boolean flag.                                              // if no param part' will return true (indicating the default)                                              // if invalid param part' will throw error                                              if (BooleanSwitch(inlinePart' true' out parameterFlag))                                              {                                                  JSSettings.InlineSafeStrings = parameterFlag;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "JS":                                  if (paramPart == null)                                  {                                      // normal settings                                      JSSettings.SourceMode = JsSourceMode.Program;                                      JSSettings.Format = JsFormat.Normal;                                  }                                  else                                  {                                      // comma-delimited list of JS settings                                      var tokens = paramPartUpper.Split('''' ';');                                      foreach (var token in tokens)                                      {                                          switch (token)                                          {                                              case "JSON":                                                  // JSON is incompatible with any other tokens' so throw an error                                                  // if it's not the only token                                                  if (tokens.Length > 1)                                                  {                                                      OnInvalidSwitch(switchPart' paramPart);                                                  }                                                    // nothing to "minify" in the JSON format' so turn off the minify flag                                                  JSSettings.MinifyCode = false;                                                    // JSON affects both the input (it's an expression) and the output                                                  // (use the JSON-output visitor)                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  JSSettings.Format = JsFormat.JSON;                                                  break;                                                case "PROG":                                                  // this is the default setting                                                  JSSettings.SourceMode = JsSourceMode.Program;                                                  break;                                                case "EXPR":                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  break;                                                case "EVT":                                                  JSSettings.SourceMode = JsSourceMode.EventHandler;                                                  break;                                                default:                                                  // later: ES5 to convert any ES6 syntax to ES5-compatible                                                  // later: ES6 to create ES6 syntax when optimizing                                                  // etc.                                                  // those two examples will affect the format property.                                                  // but for now' not supported                                                  OnInvalidSwitch(switchPart' paramPart);                                                  break;                                          }                                      }                                  }                                    OnJSOnlyParameter();                                  break;                                case "KILL":                                  killSpecified = true;                                    // optional integer switch argument                                  if (paramPartUpper == null)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      // get the numeric portion                                      long killSwitch;                                      if (paramPartUpper.StartsWith("0X"' StringComparison.OrdinalIgnoreCase))                                      {                                          // it's hex -- convert the number after the "0x"                                          if (paramPartUpper.Substring(2).TryParseLongInvariant(NumberStyles.AllowHexSpecifier' out killSwitch))                                          {                                              // save the switch for both JS and Css                                              JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                                // for CSS' we only look at the first bit: preeserve important comments                                              if ((killSwitch & 1) != 0)                                              {                                                  // we set the kill' so make sure the comments are set to none                                                  CssSettings.CommentMode = CssComment.None;                                              }                                          }                                          else                                          {                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                      else if (paramPartUpper.TryParseLongInvariant(NumberStyles.AllowLeadingSign' out killSwitch))                                      {                                          // save the switch for both JS and CSS                                          JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                            // for CSS' we only look at the first bit: preeserve important comments                                          if ((killSwitch & 1) != 0)                                          {                                              // we set the kill' so make sure the comments are set to none                                              CssSettings.CommentMode = CssComment.None;                                          }                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LINE":                              case "LINES":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // if no number specified' use the max default threshold                                      JSSettings.LineBreakThreshold =                                          CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                                                            // single-line mode                                      JSSettings.OutputMode =                                           CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                        // and four spaces per indent level                                      JSSettings.IndentSize =                                          CssSettings.IndentSize = 4;                                  }                                  else                                  {                                      // split along commas (case-insensitive)                                      var lineParts = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                        // by default' the line-break index will be 1 (the second option).                                      // we will change this index to 0 if the first parameter is multi/single                                      // instead of the line-break character count.                                      var breakIndex = 1;                                      if (lineParts.Length <= 3)                                      {                                          // if the first optional part is numeric' then it's the line threshold.                                          // might also be "multi" or "single"' thereby skipping the line threshold.                                          // (don't need to check length greater than zero -- will always be at least one element returned from Split)                                          if (!string.IsNullOrEmpty(lineParts[0]))                                          {                                              // must be an unsigned decimal integer value                                              int lineThreshold;                                              if (lineParts[0].TryParseIntInvariant(NumberStyles.None' out lineThreshold))                                              {                                                  JSSettings.LineBreakThreshold =                                                      CssSettings.LineBreakThreshold = lineThreshold;                                              }                                              else if (lineParts[0][0] == 'S')                                              {                                                  // single-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else if (lineParts[0][0] == 'M')                                              {                                                  // multiple-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' lineParts[0]);                                              }                                          }                                          else                                          {                                              // use the default                                              JSSettings.LineBreakThreshold =                                                  CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                          }                                            if (lineParts.Length > breakIndex)                                          {                                              // if the line-break index was zero' then we already processed it                                              // and we can skip the logic                                              if (breakIndex > 0)                                              {                                                  // second optional part is single or multiple line output                                                  if (string.IsNullOrEmpty(lineParts[breakIndex]) || lineParts[breakIndex][0] == 'S')                                                  {                                                      // single-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                  }                                                  else if (lineParts[breakIndex][0] == 'M')                                                  {                                                      // multiple-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                  }                                                  else                                                  {                                                      // must either be missing' or start with S (single) or M (multiple)                                                      OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                  }                                              }                                                // move on to the next part                                              ++breakIndex;                                              if (lineParts.Length > breakIndex)                                              {                                                  // third optional part is the spaces-per-indent value                                                  if (!string.IsNullOrEmpty(lineParts[breakIndex]))                                                  {                                                      // get the numeric portion; must be a decimal integer                                                      int indentSize;                                                      if (lineParts[breakIndex].TryParseIntInvariant(NumberStyles.None' out indentSize))                                                      {                                                          // same value for JS and CSS.                                                          // don't need to check for negative' because the tryparse method above does NOT                                                          // allow for a sign -- no sign' no negative.                                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                                      }                                                      else                                                      {                                                          OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                      }                                                  }                                                  else                                                  {                                                      // default of 4                                                      JSSettings.IndentSize =                                                          CssSettings.IndentSize = 4;                                                  }                                              }                                          }                                      }                                      else                                      {                                          // only 1-3 parts allowed                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LITERALS":                                  // two areas with two options each: keep or combine and eval or noeval                                  if (paramPartUpper == "KEEP")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = false;                                  }                                  else if (paramPartUpper == "COMBINE")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = true;                                  }                                  else if (paramPartUpper == "EVAL")                                  {                                      JSSettings.EvalLiteralExpressions = true;                                  }                                  else if (paramPartUpper == "NOEVAL")                                  {                                      JSSettings.EvalLiteralExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MAC":                                  // optional boolean switch                                  // no arg is valid scenario (default is true)                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.MacSafariQuirks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MINIFY":                                  minifySpecified = true;                                  if (renamingSpecified && JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      // minify can only exist if rename is set to KeepAll                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // optional boolean switch                                      // no arg is a valid scenario (default is true)                                      JSSettings.MinifyCode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NEW":                                  // two options: keep and collapse                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.CollapseToLiteral = false;                                  }                                  else if (paramPartUpper == "COLLAPSE")                                  {                                      JSSettings.CollapseToLiteral = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NFE": // <-- deprecate; use FNAMES option instead                                  if (paramPartUpper == "KEEPALL")                                  {                                      JSSettings.RemoveFunctionExpressionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      JSSettings.RemoveFunctionExpressionNames = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NORENAME":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string ident in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddNoAutoRename(ident))                                          {                                              OnInvalidSwitch(switchPart' ident);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "OBJ":                                  // two options: MINify or QUOTE                                  if (paramPartUpper == "MIN")                                  {                                      JSSettings.QuoteObjectLiteralProperties = false;                                  }                                  else if (paramPartUpper == "QUOTE")                                  {                                      JSSettings.QuoteObjectLiteralProperties = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PPONLY":                                  // just putting the pponly switch on the command line without any arguments                                  // is the same as putting -pponly:true and perfectly valid.                                  if (paramPart == null)                                  {                                      JSSettings.PreprocessOnly = true;                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.PreprocessOnly = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PRETTY":                              case "P": // <-- old style                                  // doesn't take a flag -- just set to pretty                                  PrettyPrint = true;                                                // by default' pretty mode turns off minification' which sets a bunch of other flags as well                                  JSSettings.MinifyCode = false;                                    // and some other flags for pretty-mode                                  JSSettings.OutputMode = CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                  CssSettings.KillSwitch = ~((long)JsTreeModifications.PreserveImportantComments);                                    // optional integer switch argument                                  if (paramPartUpper != null)                                  {                                      // get the numeric portion; must be a decimal integer                                      int indentSize;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out indentSize))                                      {                                          // same value for JS and CSS.                                          // don't need to check for negative' because the tryparse method above does NOT                                          // allow for a sign -- no sign' no negative.                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                      }                                      else                                       {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "RENAME":                                  if (paramPartUpper == null)                                  {                                      // treat as if it's unknown                                      ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  }                                  else if (paramPartUpper.IndexOf('=') > 0)                                  {                                      // there is at least one equal sign -- treat this as a set of JS identifier                                      // pairs. split on commas -- multiple pairs can be specified                                      var paramPairs = paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var paramPair in paramPairs)                                      {                                          // split on the equal sign -- each pair needs to have an equal sige                                          var pairParts = paramPair.Split('=');                                          if (pairParts.Length == 2)                                          {                                              // there is an equal sign. The first part is the source name and the                                              // second part is the new name to which to rename those entities.                                              string fromIdentifier = pairParts[0];                                              string toIdentifier = pairParts[1];                                                // make sure both parts are valid JS identifiers                                              var fromIsValid = JsScanner.IsValidIdentifier(fromIdentifier);                                              var toIsValid = JsScanner.IsValidIdentifier(toIdentifier);                                              if (fromIsValid && toIsValid)                                              {                                                  // create the map if it hasn't been created yet.                                                  var toExisting = JSSettings.GetNewName(fromIdentifier);                                                  if (toExisting == null)                                                  {                                                      JSSettings.AddRenamePair(fromIdentifier' toIdentifier);                                                  }                                                  else if (string.CompareOrdinal(toIdentifier' toExisting) != 0)                                                  {                                                      // from-identifier already exists' and the to-identifier doesn't match.                                                      // can't rename the same name to two different names!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                              else                                              {                                                  if (fromIsValid)                                                  {                                                      // the toIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' toIdentifier);                                                  }                                                    if (toIsValid)                                                  {                                                      // the fromIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                          }                                          else                                          {                                              // either zero or more than one equal sign. Invalid.                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                  }                                  else                                  {                                      // no equal sign; just a plain option                                      // three options: all' localization' none                                      if (paramPartUpper == "ALL")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "LOCALIZATION")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NONE")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NOPROPS")                                      {                                          // manual-renaming does not change property names                                          JSSettings.ManualRenamesProperties = false;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  if (JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      ResetRenamingKill(killSpecified);                                        // if minify was specified as turned off' then this is invalid                                      if (minifySpecified && !JSSettings.MinifyCode)                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "REORDER":                                  // default is true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.ReorderScopeDeclarations = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "STRICT":                                  // default is false' but if we specify this switch without a parameter' then                                  // we assume we are turning it ON                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.StrictMode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "TERM":                                  // optional boolean argument' defaults to true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.TermSemicolons =                                          CssSettings.TermSemicolons = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "UNUSED":                                  // two options: keep and remove                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.RemoveUnneededCode = false;                                  }                                  else if (paramPartUpper == "REMOVE")                                  {                                      JSSettings.RemoveUnneededCode = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "VAR":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      var firstLetters = paramPart;                                      string partLetters = null;                                        var commaPosition = paramPart.IndexOf(''');                                      if (commaPosition == 0)                                      {                                          // no first letters; just part letters                                          firstLetters = null;                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                      else if (commaPosition > 0)                                      {                                          // first letters and part letters                                          firstLetters = paramPart.Substring(0' commaPosition);                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                        // if we specified first letters' set them now                                      if (!string.IsNullOrEmpty(firstLetters))                                      {                                          JsCrunchEnumerator.FirstLetters = firstLetters;                                      }                                        // if we specified part letters' use it -- otherwise use the first letters.                                      if (!string.IsNullOrEmpty(partLetters))                                      {                                          JsCrunchEnumerator.PartLetters = partLetters;                                      }                                      else if (!string.IsNullOrEmpty(firstLetters))                                      {                                          // we don't have any part letters' but we do have first letters. reuse.                                          JsCrunchEnumerator.PartLetters = firstLetters;                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "WARN":                              case "W": // <-- old style                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // just "-warn" without anything else means all errors and warnings                                      WarningLevel = int.MaxValue;                                  }                                  else                                  {                                      // must be an unsigned decimal integer value                                      int warningLevel;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out warningLevel))                                      {                                          WarningLevel = warningLevel;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  levelSpecified = true;                                  break;                                //                              // Backward-compatibility switches different from new switches                              //                                case "D":                                  // equivalent to -debug:false (default behavior)                                  JSSettings.StripDebugStatements = true;                                  OnJSOnlyParameter();                                  break;                                case "E":                              case "EO":                                  // equivalent to -enc:out <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // just save the name -- we'll create the encoding later because we need                                  // to know whether we are JS or CSS to pick the right encoding fallback                                  EncodingOutputName = paramPart;                                  break;                                case "EI":                                  // equivalent to -enc:in <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // save the name                                  EncodingInputName = paramPart;                                  break;                                case "H":                                  // equivalent to -rename:all -unused:remove (default behavior)                                  JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HL":                                  // equivalent to -rename:localization -unused:remove                                  JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HC":                                  // equivalent to -literals:combine -rename:all -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "H";                                case "HLC":                              case "HCL":                                  // equivalent to -literals:combine -rename:localization -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "HL";                                case "J":                                  // equivalent to -evals:ignore (default behavior)                                  JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  OnJSOnlyParameter();                                  break;                                case "K":                                  // equivalent to -inline:true (default behavior)                                  JSSettings.InlineSafeStrings = true;                                  OnJSOnlyParameter();                                  break;                                case "L":                                  // equivalent to -new:keep (default is collapse)                                  JSSettings.CollapseToLiteral = false;                                  OnJSOnlyParameter();                                  break;                                case "M":                                  // equivalent to -mac:true (default behavior)                                  JSSettings.MacSafariQuirks = true;                                  OnJSOnlyParameter();                                  break;                                case "Z":                                  // equivalent to -term:true (default is false)                                  JSSettings.TermSemicolons =                                      CssSettings.TermSemicolons = true;                                  break;                                // end backward-compatible section                                default:                                  ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  break;                          }
Magic Number,Spike.Build.Minifiers,MinifierSettings,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\MinifierSettings.cs,MinifierSettings,The following statement contains a magic number: IndentSize = 4;
Magic Number,Spike.Build.Minifiers,MinifierSettings,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\MinifierSettings.cs,MinifierSettings,The following statement contains a magic number: LineBreakThreshold = int.MaxValue - 1000;
Duplicate Code,Spike.Build.CSharp5,CSharp5Template,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.CSharp5\CSharp5BuilderBase.cs,TransformText,The method contains a code clone-set at the following line numbers (starting from the method definition): ((1056' 1113)' (1122' 1179))
Duplicate Code,Spike.Build.CSharp5,CSharp5Template,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.CSharp5\CSharp5BuilderBase.cs,TransformText,The method contains a code clone-set at the following line numbers (starting from the method definition): ((1197' 1254)' (1263' 1320))
Duplicate Code,Spike.Build.Minifiers,JsParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsParser.cs,ParseForStatement,The method contains a code clone-set at the following line numbers (starting from the method definition): ((137' 156)' (273' 292))
Duplicate Code,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanString,The method contains a code clone-set at the following line numbers (starting from the method definition): ((150' 183)' (194' 251))
Duplicate Code,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanString,The method contains a code clone-set at the following line numbers (starting from the method definition): ((153' 172)' (197' 216)' (209' 228)' (221' 240))
Duplicate Code,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanString,The method contains a code clone-set at the following line numbers (starting from the method definition): ((197' 227)' (209' 239))
Duplicate Code,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,ScanString,The method contains a code clone-set at the following line numbers (starting from the method definition): ((197' 216)' (221' 240))
Duplicate Code,Spike.Build.WinRT,WinRTTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.WinRT\WinRTTemplate.cs,TransformText,The method contains a code clone-set at the following line numbers (starting from the method definition): ((1038' 1095)' (1104' 1161))
Duplicate Code,Spike.Build.WinRT,WinRTTemplate,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.WinRT\WinRTTemplate.cs,TransformText,The method contains a code clone-set at the following line numbers (starting from the method definition): ((1179' 1236)' (1245' 1302))
Missing Default,Spike.Build,KeyExtensions,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Extentions.cs,GetMurmurHash3,The following switch statement is missing a default case: switch (curLength)              {                  case 3:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8                        | data[currentIndex++] << 16);                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 2:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8);                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 1:                      k1 = data[currentIndex++];                      k1 *= c1;                      k1 = Rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;              }
Missing Default,Spike.Build,Model,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Model.cs,Load,The following switch statement is missing a default case: switch (compression)                          {                              case "Both":                                  compressSend = true;                                  compressReceive = true;                                  break;                              case "Incoming":                                  compressSend = true;                                  break;                              case "Outgoing":                                  compressReceive = true;                                  break;                          }
Missing Default,Spike.Build,Program,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Program.cs,Main,The following switch statement is missing a default case: switch (command)                      {                          case "-v":                          case "--verbose":                              if (index < args.Length && args[index][0] != '-') // no "-v blabla"                                   ShowUsageAndExit("--verbose shouldn't have any parameters");                                Verbose = true;                              break;                          case "-h":                          case "--help":                              ShowUsageAndExit();                              break;                          case "-p":                          case "--platform":                              if (index >= args.Length || args[index][0] == '-') //no -p -i                                  ShowUsageAndExit("You must define a platform after --platform");                                var builderName = args[index++];                              if (Builder != null ||  //no -p java -i file.spml -p xamarin                                  (index < args.Length && args[index][0] != '-')) //no -p java xamarin                                  ShowUsageAndExit("Only one builder");                                if (!Builders.TryGetValue(builderName' out Builder)) //no -p unknown                                  ShowUsageAndExit("Unknown platform");                              break;                          case "-i":                          case "--input":                              if (index >= args.Length || args[index][0] == '-')                                  ShowUsageAndExit("Input must be specified.");                                do                                  Sources.Add(args[index++]);                              while (index < args.Length && args[index][0] != '-');                                break;                          case "-o":                          case "--output":                              if (index >= args.Length || args[index][0] == '-')                                  ShowUsageAndExit("Output must be specified.");                                var destination = args[index++];                              if (Destination != null ||                                    (index < args.Length && args[index][0] != '-'))                                   ShowUsageAndExit("Only one output");                                Destination = destination;                              break;                          case "-f":                          case "--format":                              if (index >= args.Length || args[index][0] == '-')                                  ShowUsageAndExit("Format must be specified.");                                var format = args[index++];                              if (Format != null ||                                    (index < args.Length && args[index][0] != '-'))                                   ShowUsageAndExit("Only one format");                                Format = format;                              break;                          case "-n":                          case "--namespace":                              if (index >= args.Length || args[index][0] == '-')                                  ShowUsageAndExit("Namespace must be specified.");                                var ns = args[index++];                              if (Namespace != null ||  //already set by previex --platform                                  (index < args.Length && args[index][0] != '-')) //if the next argument is not a command                                  ShowUsageAndExit("Only one namespace");                                Namespace = ns;                              break;                      }
Missing Default,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseExpressionFunction,The following switch statement is missing a default case: switch (CurrentTokenText)                          {                              case "(":                                  // start a nested paren                                  ++parenLevel;                                  break;                                case ")":                                  // end a nested paren                                   // (we know it's nested because if it wasn't' we wouldn't                                  // have entered the loop)                                  --parenLevel;                                  break;                          }
Missing Default,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,ParseUnit,The following switch statement is missing a default case: switch (CurrentTokenType)              {                  case TokenType.Number:                  case TokenType.Percentage:                  case TokenType.Dimension:                  case TokenType.RelativeLength:                  case TokenType.AbsoluteLength:                  case TokenType.Angle:                  case TokenType.Time:                  case TokenType.Resolution:                  case TokenType.Frequency:                      // output it' skip any whitespace' and mark us as okay                      AppendCurrent();                      SkipSpace();                      parsed = Parsed.True;                      break;                    case TokenType.Function:                      // calc( or attr( are allowed here.                      parsed = ParseFunction();                        // if parsed is false' then we encountered an error with the function                      // and probably already output an error message. So only output an error                      // message if we didn't find ANYTHING                      if (parsed == Parsed.Empty)                      {                          ReportError(0' CssErrorCode.UnexpectedFunction' CurrentTokenText);                          parsed = Parsed.False;                      }                      break;                    case TokenType.Character:                      // only open parenthesis allowed                      if (CurrentTokenText == "(")                      {                          // TODO: make sure there is whitespace before the ( if it would cause                          // it to be the opening paren of a function token                            AppendCurrent();                          SkipSpace();                            // better be a sum inside the parens                          parsed = ParseSum();                          if (parsed != Parsed.True)                          {                              // report error and change the parsed flag to false so we know there was an error                              ReportError(0' CssErrorCode.ExpectedSum' CurrentTokenText);                              parsed = Parsed.False;                          }                          else if (CurrentTokenType != TokenType.Character || CurrentTokenText != ")")                          {                              // needs to be a closing paren here                              ReportError(0' CssErrorCode.ExpectedClosingParenthesis' CurrentTokenText);                              parsed = Parsed.False;                          }                          else                          {                              // we're at the closing paren' so output it now' advance past any                              // subsequent whitespace' and mark us as okay                              AppendCurrent();                              SkipSpace();                              parsed = Parsed.True;                          }                      }                      break;              }
Missing Default,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,Append,The following switch statement is missing a default case: switch (Settings.ColorNames)                      {                          case CssColor.Hex:                              // we don't want any color names in our code.                              // convert ALL known color names to hex' so see if there is a match on                              // the set containing all the name-to-hex values                              if (ColorSlice.AllColorNames.TryGetValue(lowerCaseText' out rgbString))                              {                                  text = rgbString;                                  nameConvertedToHex = true;                              }                              break;                            case CssColor.Strict:                              // we only want strict names in our css.                              // convert all non-strict name to hex' AND any strict names to hex if the hex is                              // shorter than the name. So check the set that contains all non-strict name-to-hex                              // values and all the strict name-to-hex values where hex is shorter than name.                              if (ColorSlice.StrictHexShorterThanNameAndAllNonStrict.TryGetValue(lowerCaseText' out rgbString))                              {                                  text = rgbString;                                  nameConvertedToHex = true;                              }                              break;                            case CssColor.Major:                              // we don't care if there are non-strict color name. So check the set that only                              // contains name-to-hex pairs where the hex is shorter than the name.                              if (ColorSlice.HexShorterThanName.TryGetValue(lowerCaseText' out rgbString))                              {                                  text = rgbString;                                  nameConvertedToHex = true;                              }                              break;                      }
Missing Default,Spike.Build.Minifiers,CssParser,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssParser.cs,MightContainColorNames,The following switch statement is missing a default case: switch (propertyName)                  {                      case "background":                      case "border-top":                      case "border-right":                      case "border-bottom":                      case "border-left":                      case "border":                      case "outline":                          hasColor = true;                          break;                  }
Missing Default,Spike.Build.Minifiers,CssScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\Css\CssScanner.cs,ScanNum,The following switch statement is missing a default case: switch (dimen.ToUpperInvariant())                          {                              case "EM":          // font-size of the element                              case "EX":          // x-height of the element's font                              case "CH":          // width of the zero glyph in the element's font                              case "REM":         // font-size of the root element                              case "VW":          // viewport's width                              case "VH":          // viewport's height                              case "VM":          // viewport width or height' whichever is smaller of the two (use VMIN)                              case "VMIN":        // minimum of the viewport's height and width                              case "VMAX":        // maximum of the viewport's height and width                              case "FR":          // fraction of available space                              case "GR":          // grid unit                              case "GD":          // text grid unit                                  tokenType = TokenType.RelativeLength;                                  break;                                case "CM":          // centimeters                              case "MM":          // millimeters                              case "IN":          // inches (1in == 2.54cm)                              case "PX":          // pixels (1px == 1/96in)                              case "PT":          // points (1pt == 1/72in)                              case "PC":          // picas (1pc == 12pt)                                  tokenType = TokenType.AbsoluteLength;                                  break;                                case "DEG":         // degrees (360deg == 1 full circle)                              case "GRAD":        // gradians (400grad == 1 full circle)                              case "RAD":         // radians (2*pi radians == 1 full circle)                              case "TURN":        // turns (1turn == 1 full circle)                                  tokenType = TokenType.Angle;                                  break;                                case "MS":          // milliseconds                              case "S":           // seconds                                  tokenType = TokenType.Time;                                  break;                                case "DPI":         // dots per inch                              case "DPCM":        // dots per centimeter                              case "DPPX":        // dots per pixel                                  tokenType = TokenType.Resolution;                                  break;                                case "HZ":          // hertz                              case "KHZ":         // kilohertz                                  tokenType = TokenType.Frequency;                                  break;                                case "DB":          // decibel                              case "ST":          // semitones                                  tokenType = TokenType.Speech;                                  break;                          }
Missing Default,Spike.Build.Minifiers,JsConstantWrapper,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsConstantWrapper.cs,IsEquivalentTo,The following switch statement is missing a default case: switch (PrimitiveType)                  {                      case JsPrimitiveType.Boolean:                          // bools must be the same                          return ToBoolean() == otherConstant.ToBoolean();                        case JsPrimitiveType.Null:                          // nulls are always equivalent                          return true;                        case JsPrimitiveType.Number:                          // numbers must be equal                          return ToNumber() == otherConstant.ToNumber();                        case JsPrimitiveType.String:                          // strings must be identical                          return string.CompareOrdinal(Value.ToString()' otherConstant.ToString()) == 0;                        case JsPrimitiveType.Other:                          // others are never the same                          return false;                  }
Missing Default,Spike.Build.Minifiers,JsConstantWrapper,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsConstantWrapper.cs,OkayToDoubleQuote,The following switch statement is missing a default case: switch (text[ndx])                  {                      case '"':                           ++numberOfQuotes;                           break;                      case '\'':                           ++numberOfApostrophes;                           break;                  }
Missing Default,Spike.Build.Minifiers,JsConstantWrapper,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsConstantWrapper.cs,ToString,The following switch statement is missing a default case: switch (PrimitiveType)              {                  case JsPrimitiveType.Null:                      // null is just "null"                      return "null";                    case JsPrimitiveType.Boolean:                      // boolean is "true" or "false"                      return (bool)Value ? "true" : "false";                    case JsPrimitiveType.Number:                      {                          // handle some special values' otherwise just fall through                          // to the default ToString implementation                          double doubleValue = (double)Value;                          if (doubleValue == 0)                          {                              // both -0 and 0 return "0". Go figure.                              return "0";                          }                          if (double.IsNaN(doubleValue))                          {                              return "NaN";                          }                          if (double.IsPositiveInfinity(doubleValue))                          {                              return "Infinity";                          }                          if (double.IsNegativeInfinity(doubleValue))                          {                              return "-Infinity";                          }                            // use the "R" format' which guarantees that the double value can                          // be round-tripped to the same value                          return doubleValue.ToStringInvariant("R");                      }              }
Missing Default,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalToTheLeft,The following switch statement is missing a default case: switch (node.OperatorToken)                  {                      case JsToken.BitwiseAnd:                          newLiteral = BitwiseAnd(otherConstant' thisConstant);                          break;                        case JsToken.BitwiseOr:                          newLiteral = BitwiseOr(otherConstant' thisConstant);                          break;                        case JsToken.BitwiseXor:                          newLiteral = BitwiseXor(otherConstant' thisConstant);                          break;                  }
Missing Default,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Equal,The following switch statement is missing a default case: switch (leftType)                      {                          case JsPrimitiveType.Null:                              // null == null is true                              newLiteral = new JsConstantWrapper(true' JsPrimitiveType.Boolean' null' m_parser);                              break;                            case JsPrimitiveType.Boolean:                              // compare boolean values                              newLiteral = new JsConstantWrapper(left.ToBoolean() == right.ToBoolean()' JsPrimitiveType.Boolean' null' m_parser);                              break;                            case JsPrimitiveType.String:                              // compare string ordinally                              if (left.IsOkayToCombine && right.IsOkayToCombine)                              {                                  newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) == 0' JsPrimitiveType.Boolean' null' m_parser);                              }                              break;                            case JsPrimitiveType.Number:                              try                              {                                  // compare the values                                  // +0 and -0 are treated as "equal" in C#' so we don't need to test them separately.                                  // and NaN is always unequal to everything else' including itself.                                  if (left.IsOkayToCombine && right.IsOkayToCombine)                                  {                                      newLiteral = new JsConstantWrapper(left.ToNumber() == right.ToNumber()' JsPrimitiveType.Boolean' null' m_parser);                                  }                              }                              catch (InvalidCastException)                              {                                  // some kind of casting in ToNumber caused a situation where we don't want                                  // to perform the combination on these operands                              }                              break;                      }
Missing Default,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,NotEqual,The following switch statement is missing a default case: switch (leftType)                      {                          case JsPrimitiveType.Null:                              // null != null is false                              newLiteral = new JsConstantWrapper(false' JsPrimitiveType.Boolean' null' m_parser);                              break;                            case JsPrimitiveType.Boolean:                              // compare boolean values                              newLiteral = new JsConstantWrapper(left.ToBoolean() != right.ToBoolean()' JsPrimitiveType.Boolean' null' m_parser);                              break;                            case JsPrimitiveType.String:                              // compare string ordinally                              if (left.IsOkayToCombine && right.IsOkayToCombine)                              {                                  newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) != 0' JsPrimitiveType.Boolean' null' m_parser);                              }                              break;                            case JsPrimitiveType.Number:                              try                              {                                  // compare the values                                  // +0 and -0 are treated as "equal" in C#' so we don't need to test them separately.                                  // and NaN is always unequal to everything else' including itself.                                  if (left.IsOkayToCombine && right.IsOkayToCombine)                                  {                                      newLiteral = new JsConstantWrapper(left.ToNumber() != right.ToNumber()' JsPrimitiveType.Boolean' null' m_parser);                                  }                              }                              catch (InvalidCastException)                              {                                  // some kind of casting in ToNumber caused a situation where we don't want                                  // to perform the combination on these operands                              }                              break;                      }
Missing Default,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,StrictEqual,The following switch statement is missing a default case: switch (leftType)                      {                          case JsPrimitiveType.Null:                              // null === null is true                              newLiteral = new JsConstantWrapper(true' JsPrimitiveType.Boolean' null' m_parser);                              break;                            case JsPrimitiveType.Boolean:                              // compare boolean values                              newLiteral = new JsConstantWrapper(left.ToBoolean() == right.ToBoolean()' JsPrimitiveType.Boolean' null' m_parser);                              break;                            case JsPrimitiveType.String:                              // compare string ordinally                              if (left.IsOkayToCombine && right.IsOkayToCombine)                              {                                  newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) == 0' JsPrimitiveType.Boolean' null' m_parser);                              }                              break;                            case JsPrimitiveType.Number:                              try                              {                                  // compare the values                                  // +0 and -0 are treated as "equal" in C#' so we don't need to test them separately.                                  // and NaN is always unequal to everything else' including itself.                                  if (left.IsOkayToCombine && right.IsOkayToCombine)                                  {                                      newLiteral = new JsConstantWrapper(left.ToNumber() == right.ToNumber()' JsPrimitiveType.Boolean' null' m_parser);                                  }                              }                              catch (InvalidCastException)                              {                                  // some kind of casting in ToNumber caused a situation where we don't want                                  // to perform the combination on these operands                              }                              break;                      }
Missing Default,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,StrictNotEqual,The following switch statement is missing a default case: switch (leftType)                      {                          case JsPrimitiveType.Null:                              // null !== null is false                              newLiteral = new JsConstantWrapper(false' JsPrimitiveType.Boolean' null' m_parser);                              break;                            case JsPrimitiveType.Boolean:                              // compare boolean values                              newLiteral = new JsConstantWrapper(left.ToBoolean() != right.ToBoolean()' JsPrimitiveType.Boolean' null' m_parser);                              break;                            case JsPrimitiveType.String:                              // compare string ordinally                              if (left.IsOkayToCombine && right.IsOkayToCombine)                              {                                  newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) != 0' JsPrimitiveType.Boolean' null' m_parser);                              }                              break;                            case JsPrimitiveType.Number:                              try                              {                                  // compare the values                                  // +0 and -0 are treated as "equal" in C#' so we don't need to test them separately.                                  // and NaN is always unequal to everything else' including itself.                                  if (left.IsOkayToCombine && right.IsOkayToCombine)                                  {                                      newLiteral = new JsConstantWrapper(left.ToNumber() != right.ToNumber()' JsPrimitiveType.Boolean' null' m_parser);                                  }                              }                              catch (InvalidCastException)                              {                                  // some kind of casting in ToNumber caused a situation where we don't want                                  // to perform the combination on these operands                              }                              break;                      }
Missing Default,Spike.Build.Minifiers,JsEvaluateLiteralVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The following switch statement is missing a default case: switch(node.OperatorToken)                  {                      case JsToken.Void:                          // see if our operand is a ConstantWrapper                          if (literalOperand != null)                          {                              // either number' string' boolean' or null.                              // the void operator evaluates its operand and returns undefined. Since evaluating a literal                              // does nothing' then it doesn't matter what the heck it is. Replace it with a zero -- a one-                              // character literal.                              node.Operand = new JsConstantWrapper(0' JsPrimitiveType.Number' node.Context' m_parser);                          }                          break;                        case JsToken.TypeOf:                          if (literalOperand != null)                          {                              // either number' string' boolean' or null.                              // the operand is a literal. Therefore we already know what the typeof                              // operator will return. Just short-circuit that behavior now and replace the operator                              // with a string literal of the proper value                              string typeName = null;                              if (literalOperand.IsStringLiteral)                              {                                  // "string"                                  typeName = "string";                              }                              else if (literalOperand.IsNumericLiteral)                              {                                  // "number"                                  typeName = "number";                              }                              else if (literalOperand.IsBooleanLiteral)                              {                                  // "boolean"                                  typeName = "boolean";                              }                              else if (literalOperand.Value == null)                              {                                  // "object"                                  typeName = "object";                              }                                if (!string.IsNullOrEmpty(typeName))                              {                                  ReplaceNodeWithLiteral(node' new JsConstantWrapper(typeName' JsPrimitiveType.String' node.Context' m_parser));                              }                          }                          else if (node.Operand is JsObjectLiteral)                          {                              ReplaceNodeWithLiteral(node' new JsConstantWrapper("object"' JsPrimitiveType.String' node.Context' m_parser));                          }                          break;                        case JsToken.Plus:                          if (literalOperand != null)                          {                              try                              {                                  // replace with a constant representing operand.ToNumber'                                  ReplaceNodeWithLiteral(node' new JsConstantWrapper(literalOperand.ToNumber()' JsPrimitiveType.Number' node.Context' m_parser));                              }                              catch (InvalidCastException)                              {                                  // some kind of casting in ToNumber caused a situation where we don't want                                  // to perform the combination on these operands                              }                          }                          break;                        case JsToken.Minus:                          if (literalOperand != null)                          {                              try                              {                                  // replace with a constant representing the negative of operand.ToNumber                                  ReplaceNodeWithLiteral(node' new JsConstantWrapper(-literalOperand.ToNumber()' JsPrimitiveType.Number' node.Context' m_parser));                              }                              catch (InvalidCastException)                              {                                  // some kind of casting in ToNumber caused a situation where we don't want                                  // to perform the combination on these operands                              }                          }                          break;                        case JsToken.BitwiseNot:                          if (literalOperand != null)                          {                              try                              {                                  // replace with a constant representing the bitwise-not of operant.ToInt32                                  ReplaceNodeWithLiteral(node' new JsConstantWrapper(Convert.ToDouble(~literalOperand.ToInt32())' JsPrimitiveType.Number' node.Context' m_parser));                              }                              catch (InvalidCastException)                              {                                  // some kind of casting in ToNumber caused a situation where we don't want                                  // to perform the combination on these operands                              }                          }                          break;                        case JsToken.LogicalNot:                          if (literalOperand != null)                          {                              // replace with a constant representing the opposite of operand.ToBoolean                              try                              {                                  ReplaceNodeWithLiteral(node' new JsConstantWrapper(!literalOperand.ToBoolean()' JsPrimitiveType.Boolean' node.Context' m_parser));                              }                              catch (InvalidCastException)                              {                                  // ignore any invalid cast exceptions                              }                          }                          break;                  }
Missing Default,Spike.Build.Minifiers,JsLogicalNot,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsLogicalNot.cs,MeasureBinaryOperator,The following switch statement is missing a default case: switch (node.OperatorToken)              {                  case JsToken.Equal:                  case JsToken.NotEqual:                  case JsToken.StrictEqual:                  case JsToken.StrictNotEqual:                      // these operators can be turned into a logical not without any                      // delta in code size. == becomes !=' etc.                      break;                    case JsToken.LessThan:                  case JsToken.GreaterThan:                  // these operators would add another character when turnbed into a not.                  // for example' < becomes >=' etc                  //++m_delta;                  //break;                    case JsToken.LessThanEqual:                  case JsToken.GreaterThanEqual:                  // these operators would subtract another character when turnbed into a not.                  // for example' <= becomes >' etc                  //--m_delta;                  //break;                    case JsToken.Assign:                  case JsToken.PlusAssign:                  case JsToken.MinusAssign:                  case JsToken.MultiplyAssign:                  case JsToken.DivideAssign:                  case JsToken.ModuloAssign:                  case JsToken.BitwiseAndAssign:                  case JsToken.BitwiseOrAssign:                  case JsToken.BitwiseXorAssign:                  case JsToken.LeftShiftAssign:                  case JsToken.RightShiftAssign:                  case JsToken.UnsignedRightShiftAssign:                  case JsToken.BitwiseAnd:                  case JsToken.BitwiseOr:                  case JsToken.BitwiseXor:                  case JsToken.Divide:                  case JsToken.Multiply:                  case JsToken.Modulo:                  case JsToken.Minus:                  case JsToken.Plus:                  case JsToken.LeftShift:                  case JsToken.RightShift:                  case JsToken.UnsignedRightShift:                  case JsToken.In:                  case JsToken.InstanceOf:                      // these operators have no logical not' which means we need to wrap them in                      // a unary logical-not operator. And since they have a lower precedence than                      // the unary logical-not' they'll have to be wrapped in parens. So that means                      // logical-not'ing these guys adds three characters                      m_delta += 3;                      break;                    case JsToken.Comma:                      // to logical-not a comma-operator' we just need to logical-not the                      // right-hand side                      node.Operand2.Accept(this);                      break;                    case JsToken.LogicalAnd:                  case JsToken.LogicalOr:                      if (node.Parent is JsBlock || (node.Parent is JsCommaOperator && node.Parent.Parent is JsBlock))                      {                          // if the parent is a block' then this is a simple expression statement:                          // expr1 || expr2; or expr1 && expr2; If so' then the result isn't                          // used anywhere and we're just using the || or && operator as a                          // shorter if-statement. So we don't need to negate the right-hand                          // side' just the left-hand side.                          if (node.Operand1 != null)                          {                              node.Operand1.Accept(this);                          }                      }                      else                      {                          // the logical-not of a logical-and or logical-or operation is the                           // other operation against the not of each operand. Since the opposite                          // operator is the same length as this operator' then we just need                          // to recurse both operands to find the true delta.                          if (node.Operand1 != null)                          {                              node.Operand1.Accept(this);                          }                            if (node.Operand2 != null)                          {                              node.Operand2.Accept(this);                          }                      }                      break;              }
Missing Default,Spike.Build.Minifiers,JsLogicalNot,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsLogicalNot.cs,ConvertBinaryOperator,The following switch statement is missing a default case: switch (node.OperatorToken)              {                  case JsToken.Equal:                      node.OperatorToken = JsToken.NotEqual;                      break;                    case JsToken.NotEqual:                      node.OperatorToken = JsToken.Equal;                      break;                    case JsToken.StrictEqual:                      node.OperatorToken = JsToken.StrictNotEqual;                      break;                    case JsToken.StrictNotEqual:                      node.OperatorToken = JsToken.StrictEqual;                      break;                    case JsToken.LessThan:                  //node.OperatorToken = JSToken.GreaterThanEqual;                  //break;                    case JsToken.GreaterThan:                  //node.OperatorToken = JSToken.LessThanEqual;                  //break;                    case JsToken.LessThanEqual:                  //node.OperatorToken = JSToken.GreaterThan;                  //break;                    case JsToken.GreaterThanEqual:                  //node.OperatorToken = JSToken.LessThan;                  //break;                    case JsToken.Assign:                  case JsToken.PlusAssign:                  case JsToken.MinusAssign:                  case JsToken.MultiplyAssign:                  case JsToken.DivideAssign:                  case JsToken.ModuloAssign:                  case JsToken.BitwiseAndAssign:                  case JsToken.BitwiseOrAssign:                  case JsToken.BitwiseXorAssign:                  case JsToken.LeftShiftAssign:                  case JsToken.RightShiftAssign:                  case JsToken.UnsignedRightShiftAssign:                  case JsToken.BitwiseAnd:                  case JsToken.BitwiseOr:                  case JsToken.BitwiseXor:                  case JsToken.Divide:                  case JsToken.Multiply:                  case JsToken.Modulo:                  case JsToken.Minus:                  case JsToken.Plus:                  case JsToken.LeftShift:                  case JsToken.RightShift:                  case JsToken.UnsignedRightShift:                  case JsToken.In:                  case JsToken.InstanceOf:                      WrapWithLogicalNot(node);                      break;                    case JsToken.Comma:                      // to logical-not a comma-operator' we just need to logical-not the                      // right-hand side                      node.Operand2.Accept(this);                      break;                    case JsToken.LogicalAnd:                  case JsToken.LogicalOr:                      if (node.Parent is JsBlock || (node.Parent is JsCommaOperator && node.Parent.Parent is JsBlock))                      {                          // if the parent is a block' then this is a simple expression statement:                          // expr1 || expr2; or expr1 && expr2; If so' then the result isn't                          // used anywhere and we're just using the || or && operator as a                          // shorter if-statement. So we don't need to negate the right-hand                          // side' just the left-hand side.                          if (node.Operand1 != null)                          {                              node.Operand1.Accept(this);                          }                      }                      else                      {                          // the logical-not of a logical-and or logical-or operation is the                           // other operation against the not of each operand. Since the opposite                          // operator is the same length as this operator' then we just need                          // to recurse both operands and swap the operator token                          if (node.Operand1 != null)                          {                              node.Operand1.Accept(this);                          }                            if (node.Operand2 != null)                          {                              node.Operand2.Accept(this);                          }                      }                      node.OperatorToken = node.OperatorToken == JsToken.LogicalAnd ? JsToken.LogicalOr : JsToken.LogicalAnd;                      break;              }
Missing Default,Spike.Build.Minifiers,JsonOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsonOutputVisitor.cs,Visit,The following switch statement is missing a default case: switch (node.PrimitiveType)                  {                      case JsPrimitiveType.Boolean:                          m_writer.Write((bool)node.Value ? "true" : "false");                          break;                        case JsPrimitiveType.Null:                          m_writer.Write("null");                          break;                        case JsPrimitiveType.Number:                          OutputNumber((double)node.Value' node.Context);                          break;                        case JsPrimitiveType.String:                      case JsPrimitiveType.Other:                          // string -- or treat it like a string                          OutputString(node.Value.ToString());                          break;                  }
Missing Default,Spike.Build.Minifiers,JsOutputVisitor,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The following switch statement is missing a default case: switch (node.PrimitiveType)                  {                      case JsPrimitiveType.Boolean:                          Output(node.ToBoolean() ? "true" : "false");                          break;                        case JsPrimitiveType.Null:                          Output("null");                          break;                        case JsPrimitiveType.Number:                          if (node.Context == null || !node.Context.HasCode                              || (!node.MayHaveIssues && m_settings.IsModificationAllowed(JsTreeModifications.MinifyNumericLiterals)))                          {                              // apply minification to the literal to get it as small as possible                              Output(NormalizeNumber(node.ToNumber()' node.Context));                          }                          else                          {                              // context is not null but we don't want to minify numeric literals.                              // just use the original literal from the context.                              Output(node.Context.Code);                          }                          break;                        case JsPrimitiveType.Other:                          Output(node.Value.ToString());                          break;                        case JsPrimitiveType.String:                          if (node.Context == null || !node.Context.HasCode)                          {                              // escape the string value because we don't have a raw context value                              // to show anyways                              Output(InlineSafeString(EscapeString(node.Value.ToString())));                          }                          else if (!m_settings.IsModificationAllowed(JsTreeModifications.MinifyStringLiterals))                          {                              // we don't want to modify the strings at all!                              Output(node.Context.Code);                          }                          else if (node.MayHaveIssues                              || (m_settings.AllowEmbeddedAspNetBlocks && node.StringContainsAspNetReplacement))                          {                              // we'd rather show the raw string' but make sure it's safe for inlining                              Output(InlineSafeString(node.Context.Code));                          }                          else                          {                              // we'd rather show the escaped string                              Output(InlineSafeString(EscapeString(node.Value.ToString())));                          }                            break;                  }
Missing Default,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,IsValidIdentifierStart,The following switch statement is missing a default case: switch (cat)                  {                      case UnicodeCategory.UppercaseLetter:                      case UnicodeCategory.LowercaseLetter:                      case UnicodeCategory.TitlecaseLetter:                      case UnicodeCategory.ModifierLetter:                      case UnicodeCategory.OtherLetter:                      case UnicodeCategory.LetterNumber:                          // okay                          return true;                  }
Missing Default,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,IsValidIdentifierPart,The following switch statement is missing a default case: switch (unicodeCategory)                  {                      case UnicodeCategory.UppercaseLetter:                      case UnicodeCategory.LowercaseLetter:                      case UnicodeCategory.TitlecaseLetter:                      case UnicodeCategory.ModifierLetter:                      case UnicodeCategory.OtherLetter:                      case UnicodeCategory.LetterNumber:                      case UnicodeCategory.NonSpacingMark:                      case UnicodeCategory.SpacingCombiningMark:                      case UnicodeCategory.DecimalDigitNumber:                      case UnicodeCategory.ConnectorPunctuation:                          return true;                  }
Missing Default,Spike.Build.Minifiers,JsScanner,D:\research\architectureSmells\repos\Kelindar_spike-build\Spike.Build.Runtime\Minifiers\JavaScript\JsScanner.cs,PPSkipToDirective,The following switch statement is missing a default case: switch (c)                  {                      // EOF                      case '\0':                          if (IsEndOfFile)                          {                              // adjust the scanner state                              m_currentPosition--;                              m_currentToken.EndPosition = m_currentPosition;                              m_currentToken.EndLineNumber = m_currentLine;                              m_currentToken.EndLinePosition = m_startLinePosition;                                // create a clone of the current token and set the ending to be the end of the                              // directive for which we're trying to find an end. Use THAT context for the                               // error context. Then throw an exception so we can bail.                              var contextError = m_currentToken.Clone();                              contextError.EndPosition = endPosition;                              contextError.EndLineNumber = endLineNum;                              contextError.EndLinePosition = endLinePos;                              contextError.HandleError(string.CompareOrdinal(endStrings[0]' "#ENDDEBUG") == 0                                   ? JsError.NoEndDebugDirective                                   : JsError.NoEndIfDirective);                              throw new EndOfStreamException();                          }                            break;                        // line terminator crap                      case '\r':                          if (GetChar(m_currentPosition) == '\n')                          {                              m_currentPosition++;                          }                            m_currentLine++;                          m_startLinePosition = m_currentPosition;                          break;                      case '\n':                          m_currentLine++;                          m_startLinePosition = m_currentPosition;                          break;                      case '\u2028':                          m_currentLine++;                          m_startLinePosition = m_currentPosition;                          break;                      case '\u2029':                          m_currentLine++;                          m_startLinePosition = m_currentPosition;                          break;                        // check for /// (and then followed by any one of the substrings passed to us)                      case '/':                          if (CheckSubstring(m_currentPosition' "//"))                          {                              // skip it                              m_currentPosition += 2;                                // check to see if this is the start of ANOTHER preprocessor construct. If it                              // is' then it's a NESTED statement and we'll need to recursively skip the                               // whole thing so everything stays on track                              if (CheckCaseInsensitiveSubstring("#IFDEF")                                  || CheckCaseInsensitiveSubstring("#IFNDEF")                                  || CheckCaseInsensitiveSubstring("#IF"))                              {                                  PPSkipToDirective("#ENDIF");                              }                              else                              {                                  // now check each of the ending strings that were passed to us to see if one of                                  // them is a match                                  for (var ndx = 0; ndx < endStrings.Length; ++ndx)                                  {                                      if (CheckCaseInsensitiveSubstring(endStrings[ndx]))                                      {                                          // found the ending string                                          return ndx;                                      }                                  }                                    // not something we're looking for -- but is it a simple ///#END?                                  if (CheckCaseInsensitiveSubstring("#END"))                                  {                                      // if the current character is not whitespace' then it's not a simple "#END"                                      c = GetChar(m_currentPosition);                                      if (IsBlankSpace(c) || IsAtEndOfLine)                                      {                                          // it is! Well' we were expecting either #ENDIF or #ENDDEBUG' but we found just an #END.                                          // that's not how the syntax is SUPPOSED to go. But let's let it fly.                                          // the ending token is always the first one.                                          return 0;                                      }                                  }                              }                          }                            break;                  }
