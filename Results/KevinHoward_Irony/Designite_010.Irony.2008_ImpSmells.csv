Implementation smell,Namespace,Class,File,Method,Description
Long Method,Irony.Interpreter,LanguageRuntime,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\LanguageRuntime_Init.cs,InitOperatorImplementations,The method has 167 lines of code.
Complex Method,Irony.Ast,StringTemplateNode,F:\newReposMay17\KevinHoward_Irony\Irony\Ast\PrimitiveNodes\StringTemplateNode.cs,ParseSegments,Cyclomatic complexity of the method is 8
Complex Method,Irony.Ast,StringTemplateNode,F:\newReposMay17\KevinHoward_Irony\Irony\Ast\PrimitiveNodes\StringTemplateNode.cs,BuildString,Cyclomatic complexity of the method is 8
Complex Method,Irony.Ast,UnaryOperationNode,F:\newReposMay17\KevinHoward_Irony\Irony\Ast\Expressions\UnaryOperationNode.cs,Init,Cyclomatic complexity of the method is 12
Complex Method,Irony.Ast,IdentifierNode,F:\newReposMay17\KevinHoward_Irony\Irony\Ast\PrimitiveNodes\IdentifierNode.cs,EvaluateNode,Cyclomatic complexity of the method is 8
Complex Method,Irony.Interpreter,CommandLine,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\CommandLine.cs,RunImpl,Cyclomatic complexity of the method is 21
Complex Method,Irony.Interpreter,OperatorImplementation,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\DynamicCallDispatcher.cs,SetupEvaluationMethod,Cyclomatic complexity of the method is 8
Complex Method,Irony.Interpreter,ScriptInterpreter,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\ScriptInterpreter.cs,CheckParseStatus,Cyclomatic complexity of the method is 9
Complex Method,Irony.Interpreter,LanguageRuntime,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\LanguageRuntime_Init.cs,InitTypeConverters,Cyclomatic complexity of the method is 9
Complex Method,Irony.Interpreter,LanguageRuntime,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\LanguageRuntime_Init.cs,GetUpType,Cyclomatic complexity of the method is 9
Complex Method,Irony.Parsing,CoreParser,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Parser\CoreParser_ErrorHandling.cs,ComputeGroupedExpectedSetForState,Cyclomatic complexity of the method is 9
Complex Method,Irony.Parsing,CoreParser,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Parser\CoreParser_ErrorHandling.cs,ExecuteAction,Cyclomatic complexity of the method is 19
Complex Method,Irony.Parsing,CoreParser,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Parser\CoreParser_ErrorHandling.cs,ExecuteConflictAction,Cyclomatic complexity of the method is 11
Complex Method,Irony.Parsing,DataLiteralBase,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\DataLiteralBase.cs,ConvertValue,Cyclomatic complexity of the method is 9
Complex Method,Irony.Parsing,ParserDataPrinter,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Diagnostics\ParserDataPrinter.cs,PrintStateList,Cyclomatic complexity of the method is 14
Complex Method,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,QuickParse,Cyclomatic complexity of the method is 19
Complex Method,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,ReadBody,Cyclomatic complexity of the method is 11
Complex Method,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,ConvertValue,Cyclomatic complexity of the method is 27
Complex Method,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,ConvertToFloat,Cyclomatic complexity of the method is 17
Complex Method,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,ConvertToBigInteger,Cyclomatic complexity of the method is 9
Complex Method,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,Init,Cyclomatic complexity of the method is 13
Complex Method,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,CompleteReadBody,Cyclomatic complexity of the method is 8
Complex Method,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,ConvertValue,Cyclomatic complexity of the method is 9
Complex Method,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,Cyclomatic complexity of the method is 26
Complex Method,Irony.Parsing,IdentifierTerminal,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\IdentifierTerminal.cs,Init,Cyclomatic complexity of the method is 11
Complex Method,Irony.Parsing,IdentifierTerminal,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\IdentifierTerminal.cs,AdjustCasing,Cyclomatic complexity of the method is 16
Complex Method,Irony.Parsing,IdentifierTerminal,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\IdentifierTerminal.cs,ReadUnicodeEscape,Cyclomatic complexity of the method is 9
Complex Method,Irony.Parsing,CodeOutlineFilter,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\TokenFilters\CodeOutlineFilter.cs,ProcessEofToken,Cyclomatic complexity of the method is 12
Complex Method,Irony.Parsing.Construction,GrammarDataBuilder,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Data\Construction\GrammarDataBuilder.cs,CollectTermsRecursive,Cyclomatic complexity of the method is 9
Complex Method,Irony.Parsing.Construction,GrammarDataBuilder,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Data\Construction\GrammarDataBuilder.cs,InitTermLists,Cyclomatic complexity of the method is 9
Complex Method,Irony.Parsing.Construction,GrammarDataBuilder,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Data\Construction\GrammarDataBuilder.cs,ValidateGrammar,Cyclomatic complexity of the method is 14
Complex Method,Irony.Parsing.Construction,ParserDataBuilder,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Data\Construction\ParserDataBuilder.cs,CreateLookbackTransitions,Cyclomatic complexity of the method is 11
Complex Method,Irony.Parsing.Construction,ParserDataBuilder,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Data\Construction\ParserDataBuilder.cs,ComputeLookaheads,Cyclomatic complexity of the method is 8
Complex Method,Irony.Parsing.Construction,ParserDataBuilder,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Data\Construction\ParserDataBuilder.cs,ComputeAndResolveConflicts,Cyclomatic complexity of the method is 15
Complex Method,Irony.Parsing.Construction,ParserDataBuilder,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Data\Construction\ParserDataBuilder.cs,ResolveConflictByHints,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,sub,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,ToString,Cyclomatic complexity of the method is 19
Long Parameter List,Irony.Interpreter,OperatorImplementation,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\DynamicCallDispatcher.cs,OperatorImplementation,The method has 6 parameters.
Long Parameter List,Irony.Parsing,ParserTraceEntry,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Diagnostics\ParserTrace.cs,ParserTraceEntry,The method has 5 parameters.
Long Parameter List,Irony.Parsing,WikiBlockTerminal,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\WikiTerminals\WikiBlockTerminal.cs,WikiBlockTerminal,The method has 5 parameters.
Long Parameter List,Irony.Parsing,WikiTagTerminal,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\WikiTerminals\WikiTagTerminal.cs,WikiTagTerminal,The method has 5 parameters.
Long Parameter List,Irony.Parsing,WikiTerminalBase,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\WikiTerminals\_WikiTerminalBase.cs,WikiTerminalBase,The method has 5 parameters.
Long Parameter List,Irony.Parsing,ParseTreeNode,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Parser\ParseTree.cs,ParseTreeNode,The method has 5 parameters.
Long Parameter List,Irony.Parsing,SourceStream,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Scanner\SourceStream.cs,CountCharsInText,The method has 6 parameters.
Long Parameter List,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,TestDivisionStep,The method has 5 parameters.
Long Parameter List,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,AppendRadix,The method has 5 parameters.
Long Statement,Irony.Ast,AssignmentNode,F:\newReposMay17\KevinHoward_Irony\Irony\Ast\Statements\AssignmentNode.cs,Init,The length of the statement  "	//There maybe an "=" sign in the middle' or not - if it is marked as punctuation; so we just take the last node in child list " is 125.
Long Statement,Irony.Ast,StringTemplateNode,F:\newReposMay17\KevinHoward_Irony\Irony\Ast\PrimitiveNodes\StringTemplateNode.cs,ParseSegments,The length of the statement  "	//As go along the "value text" (that has all escapes done)' we track the position in raw token text (that is original text from source code'  " is 140.
Long Statement,Irony.Ast,StringTemplateNode,F:\newReposMay17\KevinHoward_Irony\Irony\Ast\PrimitiveNodes\StringTemplateNode.cs,ParseSegments,The length of the statement  "	// It will be passed to segment constructor' and maybe used later to compute the exact position of runtime error when it occurs.  " is 128.
Long Statement,Irony.Ast,StringTemplateNode,F:\newReposMay17\KevinHoward_Irony\Irony\Ast\PrimitiveNodes\StringTemplateNode.cs,ParseSegments,The length of the statement  "				//we use original search in token text instead of currentPos in template to avoid distortions caused by opening quote and escaped sequences " is 139.
Long Statement,Irony.Ast,StringTemplateNode,F:\newReposMay17\KevinHoward_Irony\Irony\Ast\PrimitiveNodes\StringTemplateNode.cs,ParseSegments,The length of the statement  "			exprPosInTokenText = _tokenText.IndexOf (_templateSettings.StartTag' exprPosInTokenText) + _templateSettings.StartTag.Length; " is 125.
Long Statement,Irony.Interpreter,OperatorDispatchKey,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\DynamicCallDispatcher.cs,CreateFromArgs,The length of the statement  "	return new OperatorDispatchKey (opSymbol' (arg1 == null ? null : arg1.GetType ())' (arg2 == null ? null : arg2.GetType ())); " is 124.
Long Statement,Irony.Interpreter,OperatorDispatchKey,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\DynamicCallDispatcher.cs,Equals,The length of the statement  "	return HashCode == other.HashCode && OpSymbol == other.OpSymbol && Arg1Type == other.Arg1Type && Arg2Type == other.Arg2Type; " is 124.
Long Statement,Irony.Interpreter,LanguageRuntime,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\LanguageRuntime_Init.cs,InitOperatorImplementations,The length of the statement  "	// For each operator' we add a series of implementation methods for same-type operands. They are saved as DispatchRecords in  " is 124.
Long Statement,Irony.Interpreter,LanguageRuntime,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\LanguageRuntime_Init.cs,InitOperatorImplementations,The length of the statement  "	// operator dispatchers. This happens at initialization time. Dispatch records for mismatched argument types (ex: int + double) " is 127.
Long Statement,Irony.Interpreter,LanguageRuntime,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\LanguageRuntime_Init.cs,AddOperatorImplementation,The length of the statement  "		throw new Exception (string.Format (Resources.ErrOpNotDefinedForTypes' forKey.OpSymbol' forKey.Arg1Type' forKey.Arg2Type)); " is 123.
Long Statement,Irony.Interpreter,LanguageRuntime,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\LanguageRuntime_Init.cs,AddOperatorImplementation,The length of the statement  "	var impl = new OperatorImplementation (forKey' baseType' baseImpl.BaseMethod' arg1Converter' arg2Converter' baseImpl.ResultConverter); " is 134.
Long Statement,Irony.Parsing,CoreParser,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Parser\CoreParser_ErrorHandling.cs,FindErrorShiftActionInStack,The length of the statement  "		if (Context.CurrentParserState.Actions.TryGetValue (_grammar.SyntaxError' out errorShiftAction) && errorShiftAction.ActionType == ParserActionType.Shift) " is 153.
Long Statement,Irony.Parsing,CoreParser,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Parser\CoreParser_ErrorHandling.cs,GetShiftActionInCurrentState,The length of the statement  "	if (Context.CurrentParserState.Actions.TryGetValue (Context.CurrentParserInput.Term' out result) || Context.CurrentParserInput.Token != null && Context.CurrentParserInput.Token.KeyTerm != null && Context.CurrentParserState.Actions.TryGetValue (Context.CurrentParserInput.Token.KeyTerm' out result)) " is 298.
Long Statement,Irony.Parsing,CoreParser,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Parser\CoreParser_ErrorHandling.cs,ComputeGroupedExpectedSetForState,The length of the statement  "		if (group.GroupType == TermReportGroupType.Normal || group.GroupType == TermReportGroupType.Operator && terms.Overlaps (group.Terminals)) { " is 139.
Long Statement,Irony.Parsing,CoreParser,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Parser\CoreParser_ErrorHandling.cs,FindActionForStateAndInput,The length of the statement  "	if (Context.CurrentParserInput.Term == _grammar.Eof && _grammar.FlagIsSet (LanguageFlags.NewLineBeforeEOF) && Context.CurrentParserState.Actions.TryGetValue (_grammar.NewLine' out action)) { " is 190.
Long Statement,Irony.Parsing,CoreParser,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Parser\CoreParser_ErrorHandling.cs,CheckCreateAstNode,The length of the statement  "		Context.AddParserMessage (ParserErrorLevel.Error' parseNode.Span.Location' Resources.ErrFailedCreateNode' parseNode.Term.Name' ex.Message); " is 139.
Long Statement,Irony.Parsing,CoreParser,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Parser\CoreParser_ErrorHandling.cs,CreateBraceMismatchErrorToken,The length of the statement  "	return new Token (_grammar.SyntaxError' closingBrace.Location' closingBrace.Text' string.Format (Resources.ErrUnmatchedCloseBrace' closingBrace.Text)); " is 151.
Long Statement,Irony.Parsing,ParseTree,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Parser\ParseTree.cs,CopyMessages,The length of the statement  "		this.ParserMessages.Add (new ParserMessage (other.Level' baseLocation + other.Location' messagePrefix + other.Message' other.ParserState)); " is 139.
Long Statement,Irony.Parsing,ParsingContext,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Parser\ParsingContext.cs,GetExpectedTermSet,The length of the statement  "		CurrentParserState.ReportedExpectedSet = CoreParser.ComputeGroupedExpectedSetForState (Language.Grammar' CurrentParserState); " is 125.
Long Statement,Irony.Parsing,SourceStream,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Scanner\SourceStream.cs,MoveLocationToPreviewPosition,The length of the statement  "	CountCharsInText (Text' _scannerData.LineTerminatorsArray' lineStart + 1' PreviewPosition - 1' ref nlCount' ref lineStart); " is 123.
Long Statement,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,Init,The length of the statement  "			grammarData.Language.Errors.Add (GrammarErrorLevel.Error' null' Resources.ErrDupStartSymbolStr' subType.Start' this.Name); " is 122.
Long Statement,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,GetAstNodeType,The length of the statement  "	//check that IsTemplate flag is set and that the string actually contains embedded expression(s) by checking the start tag " is 122.
Long Statement,Irony.Parsing,KeyTerm,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\KeyTerm.cs,Init,The length of the statement  "	// Priority - determines the order in which multiple terminals try to match input for a given current char in the input. " is 120.
Long Statement,Irony.Parsing,KeyTerm,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\KeyTerm.cs,Init,The length of the statement  "	// For a given input char the scanner looks up the collection of terminals that may match this input symbol. It is the order " is 124.
Long Statement,Irony.Parsing,KeyTerm,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\KeyTerm.cs,Init,The length of the statement  "	// in this collection that is determined by Priority value - the higher the priority' the earlier the terminal gets a chance  " is 124.
Long Statement,Irony.Parsing,KeyTerm,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\KeyTerm.cs,Init,The length of the statement  "	// Keywords found in grammar by default have lowest priority to allow other terminals (like identifiers)to check the input first. " is 129.
Long Statement,Irony.Parsing,KeyTerm,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\KeyTerm.cs,Init,The length of the statement  "	// Additionally' longer symbols have higher priority' so symbols like "+=" should have higher priority value than "+" symbol.  " is 125.
Long Statement,Irony.Parsing,Terminal,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\_Terminal.cs,Init,The length of the statement  "	bool assignLiteralType = (AstNodeType == null && AstNodeCreator == null && FlagIsSet (TermFlags.IsLiteral) && Grammar.FlagIsSet (LanguageFlags.CreateAst)); " is 155.
Long Statement,Irony.Parsing,Scanner,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Scanner\Scanner.cs,ComputeCurrentTerminals,The length of the statement  "	if (Context.Status == ParserStatus.Recovering || Context.Status == ParserStatus.Previewing || Context.CurrentParserState == null || _grammar.FlagIsSet (LanguageFlags.DisableScannerParserLink) || Context.Mode == ParseMode.VsLineScan) { " is 234.
Long Statement,Irony.Parsing.Construction,GrammarDataBuilder,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Data\Construction\GrammarDataBuilder.cs,AssignWhitespaceAndDelimiters,The length of the statement  "	_grammarData.WhitespaceAndDelimiters = _grammar.WhitespaceChars + delims + "\n" //in case if it is removed from whitespace chars by NewLineTerminal  " is 147.
Long Statement,Irony.Parsing.Construction,GrammarDataBuilder,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Data\Construction\GrammarDataBuilder.cs,ValidateGrammar,The length of the statement  "		_language.Errors.Add (GrammarErrorLevel.Error' null' Resources.ErrTransientNtMustHaveOneTerm' invalidTransSet.ToString ()); " is 123.
Long Statement,Irony.Parsing.Construction,ParserDataBuilder,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Data\Construction\ParserDataBuilder.cs,ComputeLookaheads,The length of the statement  "			_language.Errors.Add (GrammarErrorLevel.InternalError' reduceItem.State' "Reduce item '{0}' in state {1} has no lookaheads."' reduceItem.Core' reduceItem.State); " is 161.
Long Statement,Irony.Parsing.Construction,ParserDataBuilder,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Data\Construction\ParserDataBuilder.cs,ReportAndCreateDefaultActionsForConflicts,The length of the statement  "		_language.Errors.Add (GrammarErrorLevel.Conflict' state' Resources.ErrSRConflict' state' shiftReduceConflicts.ToString ()); " is 123.
Long Statement,Irony.Parsing.Construction,ParserDataBuilder,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Data\Construction\ParserDataBuilder.cs,ReportAndCreateDefaultActionsForConflicts,The length of the statement  "		_language.Errors.Add (GrammarErrorLevel.Conflict' state' Resources.ErrRRConflict' state' reduceReduceConflicts.ToString ()); " is 124.
Long Statement,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,GetBits,The length of the statement  "	for (mostSignificantNonZeroWord = data.Length - 1; mostSignificantNonZeroWord >= 0 && data [mostSignificantNonZeroWord] == 0; mostSignificantNonZeroWord--) " is 155.
Long Statement,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,TryToFloat64,The length of the statement  "	return double.TryParse (ToString (10)' System.Globalization.NumberStyles.Number' System.Globalization.CultureInfo.InvariantCulture.NumberFormat' out result); " is 157.
Complex Conditional,Irony.Parsing,CoreParser,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Parser\CoreParser_ErrorHandling.cs,GetShiftActionInCurrentState,The conditional expression  "Context.CurrentParserState.Actions.TryGetValue (Context.CurrentParserInput.Term' out result) || Context.CurrentParserInput.Token != null && Context.CurrentParserInput.Token.KeyTerm != null && Context.CurrentParserState.Actions.TryGetValue (Context.CurrentParserInput.Token.KeyTerm' out result)"  is complex.
Complex Conditional,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,ReadBody,The conditional expression  "!allowFloat && foundDigits && (isDot || isExpSymbol)"  is complex.
Complex Conditional,Irony.Parsing,Scanner,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Scanner\Scanner.cs,ComputeCurrentTerminals,The conditional expression  "Context.Status == ParserStatus.Recovering || Context.Status == ParserStatus.Previewing || Context.CurrentParserState == null || _grammar.FlagIsSet (LanguageFlags.DisableScannerParserLink) || Context.Mode == ParseMode.VsLineScan"  is complex.
Complex Conditional,Irony.Parsing.Construction,GrammarDataBuilder,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Data\Construction\GrammarDataBuilder.cs,ValidateGrammar,The conditional expression  "createAst && nt.AstNodeCreator == null && nt.AstNodeType == null && !nt.FlagIsSet (TermFlags.NoAstNode)"  is complex.
Virtual Method Call from Constructor,Irony.Interpreter,ScriptInterpreter,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\ScriptInterpreter.cs,ScriptInterpreter,The constructor "ScriptInterpreter" calls a virtual method "CreateRuntime".
Virtual Method Call from Constructor,Irony.Parsing,Scanner,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Scanner\Scanner.cs,Scanner,The constructor "Scanner" calls a virtual method "CreateTokenFilters".
Virtual Method Call from Constructor,Irony.Parsing,Scanner,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Scanner\Scanner.cs,Scanner,The constructor "Scanner" calls a virtual method "BeginFiltering".
Empty Catch Block,Irony.Interpreter,ScriptInterpreter,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\ScriptInterpreter.cs,Abort,The method has an empty catch block.
Empty Catch Block,Irony.Parsing,StringList,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\StringUtils.cs,LongerFirst,The method has an empty catch block.
Magic Number,Irony.Ast,FunctionDefNode,F:\newReposMay17\KevinHoward_Irony\Irony\Ast\Functions\FunctionDefNode.cs,Init,The following statement contains a magic number: Parameters = AddChild ("Parameters"' treeNode.ChildNodes [2]);  
Magic Number,Irony.Ast,FunctionDefNode,F:\newReposMay17\KevinHoward_Irony\Irony\Ast\Functions\FunctionDefNode.cs,Init,The following statement contains a magic number: Body = AddChild ("Body"' treeNode.ChildNodes [3]);  
Magic Number,Irony.Ast,IfNode,F:\newReposMay17\KevinHoward_Irony\Irony\Ast\Statements\IfNode.cs,Init,The following statement contains a magic number: if (treeNode.ChildNodes.Count > 2)  	IfFalse = AddChild ("IfFalse"' treeNode.ChildNodes [2]);  
Magic Number,Irony.Ast,IfNode,F:\newReposMay17\KevinHoward_Irony\Irony\Ast\Statements\IfNode.cs,Init,The following statement contains a magic number: if (treeNode.ChildNodes.Count > 2)  	IfFalse = AddChild ("IfFalse"' treeNode.ChildNodes [2]);  
Magic Number,Irony.Ast,IfNode,F:\newReposMay17\KevinHoward_Irony\Irony\Ast\Statements\IfNode.cs,Init,The following statement contains a magic number: IfFalse = AddChild ("IfFalse"' treeNode.ChildNodes [2]);  
Magic Number,Irony.Ast,BinaryOperationNode,F:\newReposMay17\KevinHoward_Irony\Irony\Ast\Expressions\BinaryOperationNode.cs,Init,The following statement contains a magic number: Right = AddChild ("Arg"' treeNode.ChildNodes [2]);  
Magic Number,Irony.Interpreter,CommandLine,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\CommandLine.cs,RunImpl,The following statement contains a magic number: while (true) {  	Console.ForegroundColor = ConsoleColor.White;  	string prompt = (Interpreter.Status == InterpreterStatus.WaitingMoreInput ? PromptMoreInput : Prompt);  	Console.Write (prompt);  	var result = ReadInput (out input);  	//Check the result type - it may be the response to "Abort?" question' not a script to execute.   	switch (result) {  	case ReadResult.AbortYes:  		return;  	//exit  	case ReadResult.AbortNo:  		continue;  	//while loop  	case ReadResult.Script:  		break;  	//do nothing' continue to evaluate script  	}  	Interpreter.ClearOutputBuffer ();  	Interpreter.EvaluateAsync (input);  	while (Interpreter.IsBusy ())  		Thread.Sleep (50);  	switch (Interpreter.Status) {  	case InterpreterStatus.Ready:  		//success  		Console.WriteLine (Interpreter.GetOutput ());  		break;  	case InterpreterStatus.SyntaxError:  		Console.WriteLine (Interpreter.GetOutput ());  		//write all output we have  		Console.ForegroundColor = ConsoleColor.Red;  		foreach (var err in Interpreter.ParsedScript.ParserMessages) {  			Console.WriteLine (string.Empty.PadRight (prompt.Length + err.Location.Column) + "^");  			//show err location  			Console.WriteLine (err.Message);  			//print message  		}  		break;  	case InterpreterStatus.RuntimeError:  		ReportException ();  		break;  	default:  		break;  	}  	//switch  }  
Magic Number,Irony.Interpreter,CommandLine,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\CommandLine.cs,RunImpl,The following statement contains a magic number: while (Interpreter.IsBusy ())  	Thread.Sleep (50);  
Magic Number,Irony.Interpreter,CommandLine,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\CommandLine.cs,RunImpl,The following statement contains a magic number: Thread.Sleep (50);  
Magic Number,Irony.Interpreter,DynamicCallDispatcher,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\DynamicCallDispatcher.cs,ExecuteBinaryOperator,The following statement contains a magic number: if (opImpl != null) {  	try {  		var result = opImpl.Evaluate (arg1' arg2);  		_context.Data.Replace (2' result);  		return;  	} catch (OverflowException) {  		if (TryConvertArgsOnOverflow (opImpl.BaseType)) {  			ExecuteBinaryOperator (op);  			//call self recursively' now with new arg types  			return;  		}  		throw;  	}  	//catch  }  
Magic Number,Irony.Interpreter,DynamicCallDispatcher,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\DynamicCallDispatcher.cs,ExecuteBinaryOperator,The following statement contains a magic number: try {  	var result = opImpl.Evaluate (arg1' arg2);  	_context.Data.Replace (2' result);  	return;  } catch (OverflowException) {  	if (TryConvertArgsOnOverflow (opImpl.BaseType)) {  		ExecuteBinaryOperator (op);  		//call self recursively' now with new arg types  		return;  	}  	throw;  }  
Magic Number,Irony.Interpreter,DynamicCallDispatcher,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\DynamicCallDispatcher.cs,ExecuteBinaryOperator,The following statement contains a magic number: _context.Data.Replace (2' result);  
Magic Number,Irony.Interpreter,ScriptInterpreter,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\ScriptInterpreter.cs,Abort,The following statement contains a magic number: try {  	if (WorkerThread == null)  		return;  	WorkerThread.Abort ();  	WorkerThread.Join (50);  } catch {  }  
Magic Number,Irony.Interpreter,ScriptInterpreter,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\ScriptInterpreter.cs,Abort,The following statement contains a magic number: WorkerThread.Join (50);  
Magic Number,Irony.Interpreter,EvaluationContext,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\EvaluationContext.cs,EvaluationContext,The following statement contains a magic number: Globals = new ValuesTable (100);  
Magic Number,Irony.Interpreter,StackFrame,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\StackFrame.cs,StackFrame,The following statement contains a magic number: if (Values == null)  	Values = new ValuesTable (100);  
Magic Number,Irony.Interpreter,StackFrame,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\StackFrame.cs,StackFrame,The following statement contains a magic number: Values = new ValuesTable (100);  
Magic Number,Irony.Interpreter,StackFrame,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\StackFrame.cs,StackFrame,The following statement contains a magic number: Values = new ValuesTable (8);  
Magic Number,Irony.Parsing,DataLiteralBase,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\DataLiteralBase.cs,ConvertValue,The following statement contains a magic number: switch (DataType) {  case TypeCode.String:  	return textValue;  case TypeCode.DateTime:  	return DateTime.ParseExact (textValue' DateTimeFormat' context.Culture);  case TypeCode.Single:  case TypeCode.Double:  	var dValue = Convert.ToDouble (textValue' context.Culture);  	if (DataType == TypeCode.Double)  		return dValue;  	return Convert.ChangeType (dValue' DataType' context.Culture);  default:  	//integer types  	var iValue = (IntRadix == 10) ? Convert.ToInt64 (textValue' context.Culture) : Convert.ToInt64 (textValue' IntRadix);  	if (DataType == TypeCode.Int64)  		return iValue;  	return Convert.ChangeType (iValue' DataType' context.Culture);  }  
Magic Number,Irony.Parsing,DsvLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\DsvLiteral.cs,ReadQuotedBody,The following statement contains a magic number: while (true) {  	var until = source.Text.IndexOf (dQuoute' from);  	if (until < 0)  		throw new Exception (Resources.ErrDsvNoClosingQuote);  	// "Could not find a closing quote for quoted value."  	source.PreviewPosition = until;  	//now points at double-quote  	var piece = source.Text.Substring (from' until - from);  	source.PreviewPosition++;  	//move after double quote  	if (source.PreviewChar != dQuoute && sb == null)  		return piece;  	//quick path - if sb (string builder) was not created yet' we are looking at the very first segment;  	// and if we found a standalone dquote' then we are done - the "piece" is the result.   	if (sb == null)  		sb = new StringBuilder (100);  	sb.Append (piece);  	if (source.PreviewChar != dQuoute)  		return sb.ToString ();  	//we have doubled double-quote; add a single double-quoute char to the result and move over both symbols  	sb.Append (dQuoute);  	from = source.PreviewPosition + 1;  }  
Magic Number,Irony.Parsing,DsvLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\DsvLiteral.cs,ReadQuotedBody,The following statement contains a magic number: if (sb == null)  	sb = new StringBuilder (100);  
Magic Number,Irony.Parsing,DsvLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\DsvLiteral.cs,ReadQuotedBody,The following statement contains a magic number: sb = new StringBuilder (100);  
Magic Number,Irony.Parsing,WikiTextTerminal,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\WikiTerminals\WikiTextTerminal.cs,TryMatch,The following statement contains a magic number: if (isEscape) {  	//return a token containing only escaped char  	var value = source.NextPreviewChar.ToString ();  	source.PreviewPosition += 2;  	return source.CreateToken (this.OutputTerminal' value);  }  
Magic Number,Irony.Parsing,WikiTextTerminal,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\WikiTerminals\WikiTextTerminal.cs,TryMatch,The following statement contains a magic number: source.PreviewPosition += 2;  
Magic Number,Irony.Parsing,SourceStream,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Scanner\SourceStream.cs,ToString,The following statement contains a magic number: try {  	//show just 20 chars from current position  	if (Location.Position + 20 < Text.Length)  		result = Text.Substring (Location.Position' 20) + Resources.LabelSrcHaveMore;  	// " ..."  	else  		result = Text.Substring (Location.Position) + Resources.LabelEofMark;  	//"(EOF)"  } catch (Exception) {  	result = PreviewChar + Resources.LabelSrcHaveMore;  }  
Magic Number,Irony.Parsing,SourceStream,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Scanner\SourceStream.cs,ToString,The following statement contains a magic number: try {  	//show just 20 chars from current position  	if (Location.Position + 20 < Text.Length)  		result = Text.Substring (Location.Position' 20) + Resources.LabelSrcHaveMore;  	// " ..."  	else  		result = Text.Substring (Location.Position) + Resources.LabelEofMark;  	//"(EOF)"  } catch (Exception) {  	result = PreviewChar + Resources.LabelSrcHaveMore;  }  
Magic Number,Irony.Parsing,SourceStream,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Scanner\SourceStream.cs,ToString,The following statement contains a magic number: if (Location.Position + 20 < Text.Length)  	result = Text.Substring (Location.Position' 20) + Resources.LabelSrcHaveMore;  // " ..."  else  	result = Text.Substring (Location.Position) + Resources.LabelEofMark;  
Magic Number,Irony.Parsing,SourceStream,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Scanner\SourceStream.cs,ToString,The following statement contains a magic number: if (Location.Position + 20 < Text.Length)  	result = Text.Substring (Location.Position' 20) + Resources.LabelSrcHaveMore;  // " ..."  else  	result = Text.Substring (Location.Position) + Resources.LabelEofMark;  
Magic Number,Irony.Parsing,SourceStream,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Scanner\SourceStream.cs,ToString,The following statement contains a magic number: result = Text.Substring (Location.Position' 20) + Resources.LabelSrcHaveMore;  
Magic Number,Irony.Parsing,NonTerminal,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Grammar\NonTerminal.cs,ConvertNodeCaptionTemplate,The following statement contains a magic number: while (index < 100) {  	var strParam = "#{" + index + "}";  	if (_convertedTemplate.Contains (strParam)) {  		_convertedTemplate = _convertedTemplate.Replace (strParam' "{" + _captionParameters.Count + "}");  		_captionParameters.Add (index);  	}  	if (!_convertedTemplate.Contains ("#{"))  		return;  	index++;  }  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,QuickConvertToInt32,The following statement contains a magic number: if (radix == 10 && details.Body.Length > 10)  	return false;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,QuickConvertToInt32,The following statement contains a magic number: if (radix == 10 && details.Body.Length > 10)  	return false;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,QuickConvertToInt32,The following statement contains a magic number: try {  	//workaround for .Net FX bug: http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=278448  	int iValue = 0;  	if (radix == 10)  		iValue = Convert.ToInt32 (details.Body' CultureInfo.InvariantCulture);  	else  		iValue = Convert.ToInt32 (details.Body' radix);  	details.Value = iValue;  	return true;  } catch {  	return false;  }  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,QuickConvertToInt32,The following statement contains a magic number: if (radix == 10)  	iValue = Convert.ToInt32 (details.Body' CultureInfo.InvariantCulture);  else  	iValue = Convert.ToInt32 (details.Body' radix);  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,TryConvertToLong,The following statement contains a magic number: try {  	int radix = GetRadix (details);  	//workaround for .Net FX bug: http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=278448  	if (radix == 10)  		if (useULong)  			details.Value = Convert.ToUInt64 (details.Body' CultureInfo.InvariantCulture);  		else  			details.Value = Convert.ToInt64 (details.Body' CultureInfo.InvariantCulture);  	else if (useULong)  		details.Value = Convert.ToUInt64 (details.Body' radix);  	else  		details.Value = Convert.ToInt64 (details.Body' radix);  	return true;  } catch (OverflowException) {  	details.Error = string.Format (Resources.ErrCannotConvertValueToType' details.Value' TypeCode.Int64.ToString ());  	return false;  }  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,TryConvertToLong,The following statement contains a magic number: if (radix == 10)  	if (useULong)  		details.Value = Convert.ToUInt64 (details.Body' CultureInfo.InvariantCulture);  	else  		details.Value = Convert.ToInt64 (details.Body' CultureInfo.InvariantCulture);  else if (useULong)  	details.Value = Convert.ToUInt64 (details.Body' radix);  else  	details.Value = Convert.ToInt64 (details.Body' radix);  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,ConvertToBigInteger,The following statement contains a magic number: try {  	int startIndex = details.Body.Length - wordLength;  	for (int sectionIndex = sectionCount - 1; sectionIndex >= 0; sectionIndex--) {  		if (startIndex < 0) {  			wordLength += startIndex;  			startIndex = 0;  		}  		//workaround for .Net FX bug: http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=278448  		if (radix == 10)  			numberSections [sectionIndex] = Convert.ToUInt64 (details.Body.Substring (startIndex' wordLength));  		else  			numberSections [sectionIndex] = Convert.ToUInt64 (details.Body.Substring (startIndex' wordLength)' radix);  		startIndex -= wordLength;  	}  } catch {  	details.Error = Resources.ErrInvNumber;  	//  "Invalid number.";  	return false;  }  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,ConvertToBigInteger,The following statement contains a magic number: for (int sectionIndex = sectionCount - 1; sectionIndex >= 0; sectionIndex--) {  	if (startIndex < 0) {  		wordLength += startIndex;  		startIndex = 0;  	}  	//workaround for .Net FX bug: http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=278448  	if (radix == 10)  		numberSections [sectionIndex] = Convert.ToUInt64 (details.Body.Substring (startIndex' wordLength));  	else  		numberSections [sectionIndex] = Convert.ToUInt64 (details.Body.Substring (startIndex' wordLength)' radix);  	startIndex -= wordLength;  }  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,ConvertToBigInteger,The following statement contains a magic number: if (radix == 10)  	numberSections [sectionIndex] = Convert.ToUInt64 (details.Body.Substring (startIndex' wordLength));  else  	numberSections [sectionIndex] = Convert.ToUInt64 (details.Body.Substring (startIndex' wordLength)' radix);  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetRadix,The following statement contains a magic number: if (details.IsSet ((short)NumberOptions.Hex))  	return 16;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetRadix,The following statement contains a magic number: return 16;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetRadix,The following statement contains a magic number: if (details.IsSet ((short)NumberOptions.Octal))  	return 8;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetRadix,The following statement contains a magic number: return 8;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetRadix,The following statement contains a magic number: if (details.IsSet ((short)NumberOptions.Binary))  	return 2;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetRadix,The following statement contains a magic number: return 2;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetRadix,The following statement contains a magic number: return 10;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordLength,The following statement contains a magic number: if (details.IsSet ((short)NumberOptions.Hex))  	return 15;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordLength,The following statement contains a magic number: return 15;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordLength,The following statement contains a magic number: if (details.IsSet ((short)NumberOptions.Octal))  	return 21;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordLength,The following statement contains a magic number: return 21;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordLength,The following statement contains a magic number: if (details.IsSet ((short)NumberOptions.Binary))  	return 63;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordLength,The following statement contains a magic number: return 63;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordLength,The following statement contains a magic number: return 19;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordRadix,The following statement contains a magic number: if (details.IsSet ((short)NumberOptions.Hex))  	return 1152921504606846976;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordRadix,The following statement contains a magic number: return 1152921504606846976;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordRadix,The following statement contains a magic number: if (details.IsSet ((short)NumberOptions.Octal))  	return 9223372036854775808;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordRadix,The following statement contains a magic number: return 9223372036854775808;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordRadix,The following statement contains a magic number: if (details.IsSet ((short)NumberOptions.Binary))  	return 9223372036854775808;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordRadix,The following statement contains a magic number: return 9223372036854775808;  
Magic Number,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordRadix,The following statement contains a magic number: return 10000000000000000000;  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: switch (first) {  case 'u':  case 'U':  	if (details.IsSet ((short)StringOptions.AllowsUEscapes)) {  		len = (first == 'u' ? 4 : 8);  		if (segment.Length < len + 1) {  			details.Error = string.Format (Resources.ErrBadUnEscape' segment.Substring (len + 1)' len);  			// "Invalid unicode escape ({0})' expected {1} hex digits."  			return segment;  		}  		digits = segment.Substring (1' len);  		ch = (char)Convert.ToUInt32 (digits' 16);  		result = ch + segment.Substring (len + 1);  		return result;  	}  	//if  	break;  case 'x':  	if (details.IsSet ((short)StringOptions.AllowsXEscapes)) {  		//x-escape allows variable number of digits' from one to 4; let's count them  		p = 1;  		//current position  		while (p < 5 && p < segment.Length) {  			if (Strings.HexDigits.IndexOf (segment [p]) < 0)  				break;  			p++;  		}  		//p now point to char right after the last digit  		if (p <= 1) {  			details.Error = Resources.ErrBadXEscape;  			// @"Invalid \x escape' at least one digit expected.";  			return segment;  		}  		digits = segment.Substring (1' p - 1);  		ch = (char)Convert.ToUInt32 (digits' 16);  		result = ch + segment.Substring (p);  		return result;  	}  	//if  	break;  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  	if (details.IsSet ((short)StringOptions.AllowsOctalEscapes)) {  		//octal escape allows variable number of digits' from one to 3; let's count them  		p = 0;  		//current position  		while (p < 3 && p < segment.Length) {  			if (Strings.OctalDigits.IndexOf (segment [p]) < 0)  				break;  			p++;  		}  		//p now point to char right after the last digit  		digits = segment.Substring (0' p);  		ch = (char)Convert.ToUInt32 (digits' 8);  		result = ch + segment.Substring (p);  		return result;  	}  	//if  	break;  }  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: switch (first) {  case 'u':  case 'U':  	if (details.IsSet ((short)StringOptions.AllowsUEscapes)) {  		len = (first == 'u' ? 4 : 8);  		if (segment.Length < len + 1) {  			details.Error = string.Format (Resources.ErrBadUnEscape' segment.Substring (len + 1)' len);  			// "Invalid unicode escape ({0})' expected {1} hex digits."  			return segment;  		}  		digits = segment.Substring (1' len);  		ch = (char)Convert.ToUInt32 (digits' 16);  		result = ch + segment.Substring (len + 1);  		return result;  	}  	//if  	break;  case 'x':  	if (details.IsSet ((short)StringOptions.AllowsXEscapes)) {  		//x-escape allows variable number of digits' from one to 4; let's count them  		p = 1;  		//current position  		while (p < 5 && p < segment.Length) {  			if (Strings.HexDigits.IndexOf (segment [p]) < 0)  				break;  			p++;  		}  		//p now point to char right after the last digit  		if (p <= 1) {  			details.Error = Resources.ErrBadXEscape;  			// @"Invalid \x escape' at least one digit expected.";  			return segment;  		}  		digits = segment.Substring (1' p - 1);  		ch = (char)Convert.ToUInt32 (digits' 16);  		result = ch + segment.Substring (p);  		return result;  	}  	//if  	break;  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  	if (details.IsSet ((short)StringOptions.AllowsOctalEscapes)) {  		//octal escape allows variable number of digits' from one to 3; let's count them  		p = 0;  		//current position  		while (p < 3 && p < segment.Length) {  			if (Strings.OctalDigits.IndexOf (segment [p]) < 0)  				break;  			p++;  		}  		//p now point to char right after the last digit  		digits = segment.Substring (0' p);  		ch = (char)Convert.ToUInt32 (digits' 8);  		result = ch + segment.Substring (p);  		return result;  	}  	//if  	break;  }  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: switch (first) {  case 'u':  case 'U':  	if (details.IsSet ((short)StringOptions.AllowsUEscapes)) {  		len = (first == 'u' ? 4 : 8);  		if (segment.Length < len + 1) {  			details.Error = string.Format (Resources.ErrBadUnEscape' segment.Substring (len + 1)' len);  			// "Invalid unicode escape ({0})' expected {1} hex digits."  			return segment;  		}  		digits = segment.Substring (1' len);  		ch = (char)Convert.ToUInt32 (digits' 16);  		result = ch + segment.Substring (len + 1);  		return result;  	}  	//if  	break;  case 'x':  	if (details.IsSet ((short)StringOptions.AllowsXEscapes)) {  		//x-escape allows variable number of digits' from one to 4; let's count them  		p = 1;  		//current position  		while (p < 5 && p < segment.Length) {  			if (Strings.HexDigits.IndexOf (segment [p]) < 0)  				break;  			p++;  		}  		//p now point to char right after the last digit  		if (p <= 1) {  			details.Error = Resources.ErrBadXEscape;  			// @"Invalid \x escape' at least one digit expected.";  			return segment;  		}  		digits = segment.Substring (1' p - 1);  		ch = (char)Convert.ToUInt32 (digits' 16);  		result = ch + segment.Substring (p);  		return result;  	}  	//if  	break;  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  	if (details.IsSet ((short)StringOptions.AllowsOctalEscapes)) {  		//octal escape allows variable number of digits' from one to 3; let's count them  		p = 0;  		//current position  		while (p < 3 && p < segment.Length) {  			if (Strings.OctalDigits.IndexOf (segment [p]) < 0)  				break;  			p++;  		}  		//p now point to char right after the last digit  		digits = segment.Substring (0' p);  		ch = (char)Convert.ToUInt32 (digits' 8);  		result = ch + segment.Substring (p);  		return result;  	}  	//if  	break;  }  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: switch (first) {  case 'u':  case 'U':  	if (details.IsSet ((short)StringOptions.AllowsUEscapes)) {  		len = (first == 'u' ? 4 : 8);  		if (segment.Length < len + 1) {  			details.Error = string.Format (Resources.ErrBadUnEscape' segment.Substring (len + 1)' len);  			// "Invalid unicode escape ({0})' expected {1} hex digits."  			return segment;  		}  		digits = segment.Substring (1' len);  		ch = (char)Convert.ToUInt32 (digits' 16);  		result = ch + segment.Substring (len + 1);  		return result;  	}  	//if  	break;  case 'x':  	if (details.IsSet ((short)StringOptions.AllowsXEscapes)) {  		//x-escape allows variable number of digits' from one to 4; let's count them  		p = 1;  		//current position  		while (p < 5 && p < segment.Length) {  			if (Strings.HexDigits.IndexOf (segment [p]) < 0)  				break;  			p++;  		}  		//p now point to char right after the last digit  		if (p <= 1) {  			details.Error = Resources.ErrBadXEscape;  			// @"Invalid \x escape' at least one digit expected.";  			return segment;  		}  		digits = segment.Substring (1' p - 1);  		ch = (char)Convert.ToUInt32 (digits' 16);  		result = ch + segment.Substring (p);  		return result;  	}  	//if  	break;  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  	if (details.IsSet ((short)StringOptions.AllowsOctalEscapes)) {  		//octal escape allows variable number of digits' from one to 3; let's count them  		p = 0;  		//current position  		while (p < 3 && p < segment.Length) {  			if (Strings.OctalDigits.IndexOf (segment [p]) < 0)  				break;  			p++;  		}  		//p now point to char right after the last digit  		digits = segment.Substring (0' p);  		ch = (char)Convert.ToUInt32 (digits' 8);  		result = ch + segment.Substring (p);  		return result;  	}  	//if  	break;  }  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: switch (first) {  case 'u':  case 'U':  	if (details.IsSet ((short)StringOptions.AllowsUEscapes)) {  		len = (first == 'u' ? 4 : 8);  		if (segment.Length < len + 1) {  			details.Error = string.Format (Resources.ErrBadUnEscape' segment.Substring (len + 1)' len);  			// "Invalid unicode escape ({0})' expected {1} hex digits."  			return segment;  		}  		digits = segment.Substring (1' len);  		ch = (char)Convert.ToUInt32 (digits' 16);  		result = ch + segment.Substring (len + 1);  		return result;  	}  	//if  	break;  case 'x':  	if (details.IsSet ((short)StringOptions.AllowsXEscapes)) {  		//x-escape allows variable number of digits' from one to 4; let's count them  		p = 1;  		//current position  		while (p < 5 && p < segment.Length) {  			if (Strings.HexDigits.IndexOf (segment [p]) < 0)  				break;  			p++;  		}  		//p now point to char right after the last digit  		if (p <= 1) {  			details.Error = Resources.ErrBadXEscape;  			// @"Invalid \x escape' at least one digit expected.";  			return segment;  		}  		digits = segment.Substring (1' p - 1);  		ch = (char)Convert.ToUInt32 (digits' 16);  		result = ch + segment.Substring (p);  		return result;  	}  	//if  	break;  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  	if (details.IsSet ((short)StringOptions.AllowsOctalEscapes)) {  		//octal escape allows variable number of digits' from one to 3; let's count them  		p = 0;  		//current position  		while (p < 3 && p < segment.Length) {  			if (Strings.OctalDigits.IndexOf (segment [p]) < 0)  				break;  			p++;  		}  		//p now point to char right after the last digit  		digits = segment.Substring (0' p);  		ch = (char)Convert.ToUInt32 (digits' 8);  		result = ch + segment.Substring (p);  		return result;  	}  	//if  	break;  }  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: switch (first) {  case 'u':  case 'U':  	if (details.IsSet ((short)StringOptions.AllowsUEscapes)) {  		len = (first == 'u' ? 4 : 8);  		if (segment.Length < len + 1) {  			details.Error = string.Format (Resources.ErrBadUnEscape' segment.Substring (len + 1)' len);  			// "Invalid unicode escape ({0})' expected {1} hex digits."  			return segment;  		}  		digits = segment.Substring (1' len);  		ch = (char)Convert.ToUInt32 (digits' 16);  		result = ch + segment.Substring (len + 1);  		return result;  	}  	//if  	break;  case 'x':  	if (details.IsSet ((short)StringOptions.AllowsXEscapes)) {  		//x-escape allows variable number of digits' from one to 4; let's count them  		p = 1;  		//current position  		while (p < 5 && p < segment.Length) {  			if (Strings.HexDigits.IndexOf (segment [p]) < 0)  				break;  			p++;  		}  		//p now point to char right after the last digit  		if (p <= 1) {  			details.Error = Resources.ErrBadXEscape;  			// @"Invalid \x escape' at least one digit expected.";  			return segment;  		}  		digits = segment.Substring (1' p - 1);  		ch = (char)Convert.ToUInt32 (digits' 16);  		result = ch + segment.Substring (p);  		return result;  	}  	//if  	break;  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  	if (details.IsSet ((short)StringOptions.AllowsOctalEscapes)) {  		//octal escape allows variable number of digits' from one to 3; let's count them  		p = 0;  		//current position  		while (p < 3 && p < segment.Length) {  			if (Strings.OctalDigits.IndexOf (segment [p]) < 0)  				break;  			p++;  		}  		//p now point to char right after the last digit  		digits = segment.Substring (0' p);  		ch = (char)Convert.ToUInt32 (digits' 8);  		result = ch + segment.Substring (p);  		return result;  	}  	//if  	break;  }  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: switch (first) {  case 'u':  case 'U':  	if (details.IsSet ((short)StringOptions.AllowsUEscapes)) {  		len = (first == 'u' ? 4 : 8);  		if (segment.Length < len + 1) {  			details.Error = string.Format (Resources.ErrBadUnEscape' segment.Substring (len + 1)' len);  			// "Invalid unicode escape ({0})' expected {1} hex digits."  			return segment;  		}  		digits = segment.Substring (1' len);  		ch = (char)Convert.ToUInt32 (digits' 16);  		result = ch + segment.Substring (len + 1);  		return result;  	}  	//if  	break;  case 'x':  	if (details.IsSet ((short)StringOptions.AllowsXEscapes)) {  		//x-escape allows variable number of digits' from one to 4; let's count them  		p = 1;  		//current position  		while (p < 5 && p < segment.Length) {  			if (Strings.HexDigits.IndexOf (segment [p]) < 0)  				break;  			p++;  		}  		//p now point to char right after the last digit  		if (p <= 1) {  			details.Error = Resources.ErrBadXEscape;  			// @"Invalid \x escape' at least one digit expected.";  			return segment;  		}  		digits = segment.Substring (1' p - 1);  		ch = (char)Convert.ToUInt32 (digits' 16);  		result = ch + segment.Substring (p);  		return result;  	}  	//if  	break;  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  	if (details.IsSet ((short)StringOptions.AllowsOctalEscapes)) {  		//octal escape allows variable number of digits' from one to 3; let's count them  		p = 0;  		//current position  		while (p < 3 && p < segment.Length) {  			if (Strings.OctalDigits.IndexOf (segment [p]) < 0)  				break;  			p++;  		}  		//p now point to char right after the last digit  		digits = segment.Substring (0' p);  		ch = (char)Convert.ToUInt32 (digits' 8);  		result = ch + segment.Substring (p);  		return result;  	}  	//if  	break;  }  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: if (details.IsSet ((short)StringOptions.AllowsUEscapes)) {  	len = (first == 'u' ? 4 : 8);  	if (segment.Length < len + 1) {  		details.Error = string.Format (Resources.ErrBadUnEscape' segment.Substring (len + 1)' len);  		// "Invalid unicode escape ({0})' expected {1} hex digits."  		return segment;  	}  	digits = segment.Substring (1' len);  	ch = (char)Convert.ToUInt32 (digits' 16);  	result = ch + segment.Substring (len + 1);  	return result;  }  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: if (details.IsSet ((short)StringOptions.AllowsUEscapes)) {  	len = (first == 'u' ? 4 : 8);  	if (segment.Length < len + 1) {  		details.Error = string.Format (Resources.ErrBadUnEscape' segment.Substring (len + 1)' len);  		// "Invalid unicode escape ({0})' expected {1} hex digits."  		return segment;  	}  	digits = segment.Substring (1' len);  	ch = (char)Convert.ToUInt32 (digits' 16);  	result = ch + segment.Substring (len + 1);  	return result;  }  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: if (details.IsSet ((short)StringOptions.AllowsUEscapes)) {  	len = (first == 'u' ? 4 : 8);  	if (segment.Length < len + 1) {  		details.Error = string.Format (Resources.ErrBadUnEscape' segment.Substring (len + 1)' len);  		// "Invalid unicode escape ({0})' expected {1} hex digits."  		return segment;  	}  	digits = segment.Substring (1' len);  	ch = (char)Convert.ToUInt32 (digits' 16);  	result = ch + segment.Substring (len + 1);  	return result;  }  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: len = (first == 'u' ? 4 : 8);  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: len = (first == 'u' ? 4 : 8);  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: ch = (char)Convert.ToUInt32 (digits' 16);  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: if (details.IsSet ((short)StringOptions.AllowsXEscapes)) {  	//x-escape allows variable number of digits' from one to 4; let's count them  	p = 1;  	//current position  	while (p < 5 && p < segment.Length) {  		if (Strings.HexDigits.IndexOf (segment [p]) < 0)  			break;  		p++;  	}  	//p now point to char right after the last digit  	if (p <= 1) {  		details.Error = Resources.ErrBadXEscape;  		// @"Invalid \x escape' at least one digit expected.";  		return segment;  	}  	digits = segment.Substring (1' p - 1);  	ch = (char)Convert.ToUInt32 (digits' 16);  	result = ch + segment.Substring (p);  	return result;  }  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: if (details.IsSet ((short)StringOptions.AllowsXEscapes)) {  	//x-escape allows variable number of digits' from one to 4; let's count them  	p = 1;  	//current position  	while (p < 5 && p < segment.Length) {  		if (Strings.HexDigits.IndexOf (segment [p]) < 0)  			break;  		p++;  	}  	//p now point to char right after the last digit  	if (p <= 1) {  		details.Error = Resources.ErrBadXEscape;  		// @"Invalid \x escape' at least one digit expected.";  		return segment;  	}  	digits = segment.Substring (1' p - 1);  	ch = (char)Convert.ToUInt32 (digits' 16);  	result = ch + segment.Substring (p);  	return result;  }  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: while (p < 5 && p < segment.Length) {  	if (Strings.HexDigits.IndexOf (segment [p]) < 0)  		break;  	p++;  }  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: ch = (char)Convert.ToUInt32 (digits' 16);  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: if (details.IsSet ((short)StringOptions.AllowsOctalEscapes)) {  	//octal escape allows variable number of digits' from one to 3; let's count them  	p = 0;  	//current position  	while (p < 3 && p < segment.Length) {  		if (Strings.OctalDigits.IndexOf (segment [p]) < 0)  			break;  		p++;  	}  	//p now point to char right after the last digit  	digits = segment.Substring (0' p);  	ch = (char)Convert.ToUInt32 (digits' 8);  	result = ch + segment.Substring (p);  	return result;  }  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: if (details.IsSet ((short)StringOptions.AllowsOctalEscapes)) {  	//octal escape allows variable number of digits' from one to 3; let's count them  	p = 0;  	//current position  	while (p < 3 && p < segment.Length) {  		if (Strings.OctalDigits.IndexOf (segment [p]) < 0)  			break;  		p++;  	}  	//p now point to char right after the last digit  	digits = segment.Substring (0' p);  	ch = (char)Convert.ToUInt32 (digits' 8);  	result = ch + segment.Substring (p);  	return result;  }  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: while (p < 3 && p < segment.Length) {  	if (Strings.OctalDigits.IndexOf (segment [p]) < 0)  		break;  	p++;  }  
Magic Number,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: ch = (char)Convert.ToUInt32 (digits' 8);  
Magic Number,Irony.Parsing,IdentifierTerminal,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\IdentifierTerminal.cs,ReadUnicodeEscape,The following statement contains a magic number: switch (source.PreviewChar) {  case 'u':  	len = 4;  	break;  case 'U':  	len = 8;  	break;  default:  	details.Error = Resources.ErrInvEscSymbol;  	// "Invalid escape symbol' expected 'u' or 'U' only."  	return '\0';  }  
Magic Number,Irony.Parsing,IdentifierTerminal,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\IdentifierTerminal.cs,ReadUnicodeEscape,The following statement contains a magic number: switch (source.PreviewChar) {  case 'u':  	len = 4;  	break;  case 'U':  	len = 8;  	break;  default:  	details.Error = Resources.ErrInvEscSymbol;  	// "Invalid escape symbol' expected 'u' or 'U' only."  	return '\0';  }  
Magic Number,Irony.Parsing,IdentifierTerminal,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\IdentifierTerminal.cs,ReadUnicodeEscape,The following statement contains a magic number: len = 4;  
Magic Number,Irony.Parsing,IdentifierTerminal,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\IdentifierTerminal.cs,ReadUnicodeEscape,The following statement contains a magic number: len = 8;  
Magic Number,Microsoft.Scripting.Math,Complex64,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\Complex64.cs,Power,The following statement contains a magic number: if (power == c && power >= 0 && d == .0) {  	Complex64 result = new Complex64 (1.0);  	if (power == 0)  		return result;  	Complex64 factor = this;  	while (power != 0) {  		if ((power & 1) != 0) {  			result = result * factor;  		}  		factor = factor * factor;  		power >>= 1;  	}  	return result;  } else if (IsZero) {  	return y.IsZero ? Complex64.MakeReal (1.0) : Complex64.MakeReal (0.0);  } else {  	double a = real;  	double b = imag;  	double powers = a * a + b * b;  	double arg = System.Math.Atan2 (b' a);  	double mul = System.Math.Pow (powers' c / 2) * System.Math.Exp (-d * arg);  	double common = c * arg + .5 * d * System.Math.Log (powers);  	return new Complex64 (mul * System.Math.Cos (common)' mul * System.Math.Sin (common));  }  
Magic Number,Microsoft.Scripting.Math,Complex64,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\Complex64.cs,Power,The following statement contains a magic number: if (power == c && power >= 0 && d == .0) {  	Complex64 result = new Complex64 (1.0);  	if (power == 0)  		return result;  	Complex64 factor = this;  	while (power != 0) {  		if ((power & 1) != 0) {  			result = result * factor;  		}  		factor = factor * factor;  		power >>= 1;  	}  	return result;  } else if (IsZero) {  	return y.IsZero ? Complex64.MakeReal (1.0) : Complex64.MakeReal (0.0);  } else {  	double a = real;  	double b = imag;  	double powers = a * a + b * b;  	double arg = System.Math.Atan2 (b' a);  	double mul = System.Math.Pow (powers' c / 2) * System.Math.Exp (-d * arg);  	double common = c * arg + .5 * d * System.Math.Log (powers);  	return new Complex64 (mul * System.Math.Cos (common)' mul * System.Math.Sin (common));  }  
Magic Number,Microsoft.Scripting.Math,Complex64,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\Complex64.cs,Power,The following statement contains a magic number: if (IsZero) {  	return y.IsZero ? Complex64.MakeReal (1.0) : Complex64.MakeReal (0.0);  } else {  	double a = real;  	double b = imag;  	double powers = a * a + b * b;  	double arg = System.Math.Atan2 (b' a);  	double mul = System.Math.Pow (powers' c / 2) * System.Math.Exp (-d * arg);  	double common = c * arg + .5 * d * System.Math.Log (powers);  	return new Complex64 (mul * System.Math.Cos (common)' mul * System.Math.Sin (common));  }  
Magic Number,Microsoft.Scripting.Math,Complex64,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\Complex64.cs,Power,The following statement contains a magic number: if (IsZero) {  	return y.IsZero ? Complex64.MakeReal (1.0) : Complex64.MakeReal (0.0);  } else {  	double a = real;  	double b = imag;  	double powers = a * a + b * b;  	double arg = System.Math.Atan2 (b' a);  	double mul = System.Math.Pow (powers' c / 2) * System.Math.Exp (-d * arg);  	double common = c * arg + .5 * d * System.Math.Log (powers);  	return new Complex64 (mul * System.Math.Cos (common)' mul * System.Math.Sin (common));  }  
Magic Number,Microsoft.Scripting.Math,Complex64,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\Complex64.cs,GetHashCode,The following statement contains a magic number: return (int)real + (int)imag * 1000003;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: Debug.Assert (bits.Length == 4 && (bits [3] & DecimalScaleFactorMask) == 0);  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: Debug.Assert (bits.Length == 4 && (bits [3] & DecimalScaleFactorMask) == 0);  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: if (size > 2)  	array [2] = (UInt32)bits [2];  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: if (size > 2)  	array [2] = (UInt32)bits [2];  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: if (size > 2)  	array [2] = (UInt32)bits [2];  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: array [2] = (UInt32)bits [2];  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: array [2] = (UInt32)bits [2];  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: return new BigInteger (((bits [3] & DecimalSignMask) != 0) ? -1 : +1' array);  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: curByte = 3;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++) {  	byteInDword = 0;  	while (byteInDword < 4) {  		if (v [curByte] != 0x00)  			isZero = false;  		data [curDword] <<= 8;  		data [curDword] |= v [curByte];  		curByte--;  		byteInDword++;  	}  	curByte += 8;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++) {  	byteInDword = 0;  	while (byteInDword < 4) {  		if (v [curByte] != 0x00)  			isZero = false;  		data [curDword] <<= 8;  		data [curDword] |= v [curByte];  		curByte--;  		byteInDword++;  	}  	curByte += 8;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++) {  	byteInDword = 0;  	while (byteInDword < 4) {  		if (v [curByte] != 0x00)  			isZero = false;  		data [curDword] <<= 8;  		data [curDword] |= v [curByte];  		curByte--;  		byteInDword++;  	}  	curByte += 8;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: while (byteInDword < 4) {  	if (v [curByte] != 0x00)  		isZero = false;  	data [curDword] <<= 8;  	data [curDword] |= v [curByte];  	curByte--;  	byteInDword++;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: while (byteInDword < 4) {  	if (v [curByte] != 0x00)  		isZero = false;  	data [curDword] <<= 8;  	data [curDword] |= v [curByte];  	curByte--;  	byteInDword++;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: data [curDword] <<= 8;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: curByte += 8;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: if (unalignedBytes != 0) {  	if (isNegative)  		data [dwordCount - 1] = 0xffffffff;  	for (curByte = byteCount - 1; curByte >= byteCount - unalignedBytes; curByte--) {  		if (v [curByte] != 0x00)  			isZero = false;  		data [curDword] <<= 8;  		data [curDword] |= v [curByte];  	}  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: for (curByte = byteCount - 1; curByte >= byteCount - unalignedBytes; curByte--) {  	if (v [curByte] != 0x00)  		isZero = false;  	data [curDword] <<= 8;  	data [curDword] |= v [curByte];  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: data [curDword] <<= 8;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Negative,The following statement contains a magic number: return ((v [7] & 0x80) != 0);  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v [7] & 0x7F)) << (ushort)4) | (((ushort)(v [6] & 0xF0)) >> 4));  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v [7] & 0x7F)) << (ushort)4) | (((ushort)(v [6] & 0xF0)) >> 4));  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v [7] & 0x7F)) << (ushort)4) | (((ushort)(v [6] & 0xF0)) >> 4));  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v [7] & 0x7F)) << (ushort)4) | (((ushort)(v [6] & 0xF0)) >> 4));  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Mantissa,The following statement contains a magic number: return (ulong)((ulong)i1 | ((ulong)i2 << 32));  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,AsInt64,The following statement contains a magic number: if (Length > 2)  	return false;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,AsUInt64,The following statement contains a magic number: if (Length > 2)  	return false;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,AsUInt64,The following statement contains a magic number: if (data.Length > 1) {  	ret |= ((ulong)data [1]) << 32;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,AsUInt64,The following statement contains a magic number: ret |= ((ulong)data [1]) << 32;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,AsDecimal,The following statement contains a magic number: while (length > 3) {  	if (scale >= 28) {  		ret = default(decimal);  		return false;  	}  	bi = bi / 10;  	scale++;  	length = bi.Length;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,AsDecimal,The following statement contains a magic number: while (length > 3) {  	if (scale >= 28) {  		ret = default(decimal);  		return false;  	}  	bi = bi / 10;  	scale++;  	length = bi.Length;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,AsDecimal,The following statement contains a magic number: while (length > 3) {  	if (scale >= 28) {  		ret = default(decimal);  		return false;  	}  	bi = bi / 10;  	scale++;  	length = bi.Length;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,AsDecimal,The following statement contains a magic number: if (scale >= 28) {  	ret = default(decimal);  	return false;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,AsDecimal,The following statement contains a magic number: bi = bi / 10;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,AsDecimal,The following statement contains a magic number: if (length > 2)  	hi = (Int32)bi.data [2];  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,AsDecimal,The following statement contains a magic number: if (length > 2)  	hi = (Int32)bi.data [2];  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,AsDecimal,The following statement contains a magic number: hi = (Int32)bi.data [2];  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,TryToFloat64,The following statement contains a magic number: return double.TryParse (ToString (10)' System.Globalization.NumberStyles.Number' System.Globalization.CultureInfo.InvariantCulture.NumberFormat' out result);  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,ToFloat64,The following statement contains a magic number: return double.Parse (ToString (10)' System.Globalization.CultureInfo.InvariantCulture.NumberFormat);  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFFFF0000) == 0) {  	value <<= 16;  	shift += 16;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFFFF0000) == 0) {  	value <<= 16;  	shift += 16;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: value <<= 16;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: shift += 16;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFF000000) == 0) {  	value <<= 8;  	shift += 8;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFF000000) == 0) {  	value <<= 8;  	shift += 8;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: value <<= 8;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: shift += 8;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xF0000000) == 0) {  	value <<= 4;  	shift += 4;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xF0000000) == 0) {  	value <<= 4;  	shift += 4;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: value <<= 4;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: shift += 4;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xC0000000) == 0) {  	value <<= 2;  	shift += 2;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xC0000000) == 0) {  	value <<= 2;  	shift += 2;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: value <<= 2;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: shift += 2;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Normalize,The following statement contains a magic number: Debug.Assert (0 <= shift && shift < 32);  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Unnormalize,The following statement contains a magic number: Debug.Assert (0 <= shift && shift < 32);  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,Unnormalize,The following statement contains a magic number: if (shift > 0) {  	int lshift = 32 - shift;  	uint carry = 0;  	for (int i = length - 1; i >= 0; i--) {  		uint uni = un [i];  		r [i] = (uni >> shift) | carry;  		carry = (uni << lshift);  	}  } else {  	for (int i = 0; i < length; i++) {  		r [i] = un [i];  	}  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  	if (n == 0) {  		throw new DivideByZeroException ();  	}  	//  Divide by single digit  	//  	ulong rem = 0;  	uint v0 = v [0];  	q = new uint[m];  	r = new uint[1];  	for (int j = m - 1; j >= 0; j--) {  		rem *= Base;  		rem += u [j];  		ulong div = rem / v0;  		rem -= div * v0;  		q [j] = (uint)div;  	}  	r [0] = (uint)rem;  } else if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	TestDivisionStep (un' vn' q' u' v);  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			Debug.Assert (t == 0 || t == -1 || t == -2);  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  		TestDivisionStep (un' vn' q' u' v);  	}  	Unnormalize (un' out r' shift);  	//  Test normalized value ... Call TestNormalize  	//  only pass the values in different order.  	//  	TestNormalize (r' un' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  	if (n == 0) {  		throw new DivideByZeroException ();  	}  	//  Divide by single digit  	//  	ulong rem = 0;  	uint v0 = v [0];  	q = new uint[m];  	r = new uint[1];  	for (int j = m - 1; j >= 0; j--) {  		rem *= Base;  		rem += u [j];  		ulong div = rem / v0;  		rem -= div * v0;  		q [j] = (uint)div;  	}  	r [0] = (uint)rem;  } else if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	TestDivisionStep (un' vn' q' u' v);  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			Debug.Assert (t == 0 || t == -1 || t == -2);  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  		TestDivisionStep (un' vn' q' u' v);  	}  	Unnormalize (un' out r' shift);  	//  Test normalized value ... Call TestNormalize  	//  only pass the values in different order.  	//  	TestNormalize (r' un' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  	if (n == 0) {  		throw new DivideByZeroException ();  	}  	//  Divide by single digit  	//  	ulong rem = 0;  	uint v0 = v [0];  	q = new uint[m];  	r = new uint[1];  	for (int j = m - 1; j >= 0; j--) {  		rem *= Base;  		rem += u [j];  		ulong div = rem / v0;  		rem -= div * v0;  		q [j] = (uint)div;  	}  	r [0] = (uint)rem;  } else if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	TestDivisionStep (un' vn' q' u' v);  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			Debug.Assert (t == 0 || t == -1 || t == -2);  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  		TestDivisionStep (un' vn' q' u' v);  	}  	Unnormalize (un' out r' shift);  	//  Test normalized value ... Call TestNormalize  	//  only pass the values in different order.  	//  	TestNormalize (r' un' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  	if (n == 0) {  		throw new DivideByZeroException ();  	}  	//  Divide by single digit  	//  	ulong rem = 0;  	uint v0 = v [0];  	q = new uint[m];  	r = new uint[1];  	for (int j = m - 1; j >= 0; j--) {  		rem *= Base;  		rem += u [j];  		ulong div = rem / v0;  		rem -= div * v0;  		q [j] = (uint)div;  	}  	r [0] = (uint)rem;  } else if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	TestDivisionStep (un' vn' q' u' v);  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			Debug.Assert (t == 0 || t == -1 || t == -2);  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  		TestDivisionStep (un' vn' q' u' v);  	}  	Unnormalize (un' out r' shift);  	//  Test normalized value ... Call TestNormalize  	//  only pass the values in different order.  	//  	TestNormalize (r' un' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  	if (n == 0) {  		throw new DivideByZeroException ();  	}  	//  Divide by single digit  	//  	ulong rem = 0;  	uint v0 = v [0];  	q = new uint[m];  	r = new uint[1];  	for (int j = m - 1; j >= 0; j--) {  		rem *= Base;  		rem += u [j];  		ulong div = rem / v0;  		rem -= div * v0;  		q [j] = (uint)div;  	}  	r [0] = (uint)rem;  } else if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	TestDivisionStep (un' vn' q' u' v);  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			Debug.Assert (t == 0 || t == -1 || t == -2);  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  		TestDivisionStep (un' vn' q' u' v);  	}  	Unnormalize (un' out r' shift);  	//  Test normalized value ... Call TestNormalize  	//  only pass the values in different order.  	//  	TestNormalize (r' un' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  	if (n == 0) {  		throw new DivideByZeroException ();  	}  	//  Divide by single digit  	//  	ulong rem = 0;  	uint v0 = v [0];  	q = new uint[m];  	r = new uint[1];  	for (int j = m - 1; j >= 0; j--) {  		rem *= Base;  		rem += u [j];  		ulong div = rem / v0;  		rem -= div * v0;  		q [j] = (uint)div;  	}  	r [0] = (uint)rem;  } else if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	TestDivisionStep (un' vn' q' u' v);  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			Debug.Assert (t == 0 || t == -1 || t == -2);  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  		TestDivisionStep (un' vn' q' u' v);  	}  	Unnormalize (un' out r' shift);  	//  Test normalized value ... Call TestNormalize  	//  only pass the values in different order.  	//  	TestNormalize (r' un' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	TestDivisionStep (un' vn' q' u' v);  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			Debug.Assert (t == 0 || t == -1 || t == -2);  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  		TestDivisionStep (un' vn' q' u' v);  	}  	Unnormalize (un' out r' shift);  	//  Test normalized value ... Call TestNormalize  	//  only pass the values in different order.  	//  	TestNormalize (r' un' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	TestDivisionStep (un' vn' q' u' v);  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			Debug.Assert (t == 0 || t == -1 || t == -2);  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  		TestDivisionStep (un' vn' q' u' v);  	}  	Unnormalize (un' out r' shift);  	//  Test normalized value ... Call TestNormalize  	//  only pass the values in different order.  	//  	TestNormalize (r' un' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	TestDivisionStep (un' vn' q' u' v);  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			Debug.Assert (t == 0 || t == -1 || t == -2);  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  		TestDivisionStep (un' vn' q' u' v);  	}  	Unnormalize (un' out r' shift);  	//  Test normalized value ... Call TestNormalize  	//  only pass the values in different order.  	//  	TestNormalize (r' un' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	TestDivisionStep (un' vn' q' u' v);  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			Debug.Assert (t == 0 || t == -1 || t == -2);  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  		TestDivisionStep (un' vn' q' u' v);  	}  	Unnormalize (un' out r' shift);  	//  Test normalized value ... Call TestNormalize  	//  only pass the values in different order.  	//  	TestNormalize (r' un' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	TestDivisionStep (un' vn' q' u' v);  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			Debug.Assert (t == 0 || t == -1 || t == -2);  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  		TestDivisionStep (un' vn' q' u' v);  	}  	Unnormalize (un' out r' shift);  	//  Test normalized value ... Call TestNormalize  	//  only pass the values in different order.  	//  	TestNormalize (r' un' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (m >= n) {  	int shift = GetNormalizeShift (v [n - 1]);  	uint[] un = new uint[m + 1];  	uint[] vn = new uint[n];  	Normalize (u' m' un' shift);  	Normalize (v' n' vn' shift);  	q = new uint[m - n + 1];  	r = null;  	TestDivisionStep (un' vn' q' u' v);  	//  Main division loop  	//  	for (int j = m - n; j >= 0; j--) {  		ulong rr' qq;  		int i;  		rr = Base * un [j + n] + un [j + n - 1];  		qq = rr / vn [n - 1];  		rr -= qq * vn [n - 1];  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		for (; ;) {  			// Estimate too big ?  			//  			if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  				qq--;  				rr += (ulong)vn [n - 1];  				if (rr < Base)  					continue;  			}  			break;  		}  		Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  		//  Multiply and subtract  		//  		long b = 0;  		long t = 0;  		for (i = 0; i < n; i++) {  			ulong p = vn [i] * qq;  			t = (long)un [i + j] - (long)(uint)p - b;  			un [i + j] = (uint)t;  			p >>= 32;  			t >>= 32;  			Debug.Assert (t == 0 || t == -1 || t == -2);  			b = (long)p - t;  		}  		t = (long)un [j + n] - b;  		un [j + n] = (uint)t;  		//  Store the calculated value  		//  		q [j] = (uint)qq;  		//  Add back vn[0..n] to un[j..j+n]  		//  		if (t < 0) {  			q [j]--;  			ulong c = 0;  			for (i = 0; i < n; i++) {  				c = (ulong)vn [i] + un [j + i] + c;  				un [j + i] = (uint)c;  				c >>= 32;  			}  			c += (ulong)un [j + n];  			un [j + n] = (uint)c;  		}  		TestDivisionStep (un' vn' q' u' v);  	}  	Unnormalize (un' out r' shift);  	//  Test normalized value ... Call TestNormalize  	//  only pass the values in different order.  	//  	TestNormalize (r' un' shift);  } else {  	q = new uint[] {  		0  	};  	r = u;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (int j = m - n; j >= 0; j--) {  	ulong rr' qq;  	int i;  	rr = Base * un [j + n] + un [j + n - 1];  	qq = rr / vn [n - 1];  	rr -= qq * vn [n - 1];  	Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  	for (; ;) {  		// Estimate too big ?  		//  		if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  			qq--;  			rr += (ulong)vn [n - 1];  			if (rr < Base)  				continue;  		}  		break;  	}  	Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  	//  Multiply and subtract  	//  	long b = 0;  	long t = 0;  	for (i = 0; i < n; i++) {  		ulong p = vn [i] * qq;  		t = (long)un [i + j] - (long)(uint)p - b;  		un [i + j] = (uint)t;  		p >>= 32;  		t >>= 32;  		Debug.Assert (t == 0 || t == -1 || t == -2);  		b = (long)p - t;  	}  	t = (long)un [j + n] - b;  	un [j + n] = (uint)t;  	//  Store the calculated value  	//  	q [j] = (uint)qq;  	//  Add back vn[0..n] to un[j..j+n]  	//  	if (t < 0) {  		q [j]--;  		ulong c = 0;  		for (i = 0; i < n; i++) {  			c = (ulong)vn [i] + un [j + i] + c;  			un [j + i] = (uint)c;  			c >>= 32;  		}  		c += (ulong)un [j + n];  		un [j + n] = (uint)c;  	}  	TestDivisionStep (un' vn' q' u' v);  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (int j = m - n; j >= 0; j--) {  	ulong rr' qq;  	int i;  	rr = Base * un [j + n] + un [j + n - 1];  	qq = rr / vn [n - 1];  	rr -= qq * vn [n - 1];  	Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  	for (; ;) {  		// Estimate too big ?  		//  		if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  			qq--;  			rr += (ulong)vn [n - 1];  			if (rr < Base)  				continue;  		}  		break;  	}  	Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  	//  Multiply and subtract  	//  	long b = 0;  	long t = 0;  	for (i = 0; i < n; i++) {  		ulong p = vn [i] * qq;  		t = (long)un [i + j] - (long)(uint)p - b;  		un [i + j] = (uint)t;  		p >>= 32;  		t >>= 32;  		Debug.Assert (t == 0 || t == -1 || t == -2);  		b = (long)p - t;  	}  	t = (long)un [j + n] - b;  	un [j + n] = (uint)t;  	//  Store the calculated value  	//  	q [j] = (uint)qq;  	//  Add back vn[0..n] to un[j..j+n]  	//  	if (t < 0) {  		q [j]--;  		ulong c = 0;  		for (i = 0; i < n; i++) {  			c = (ulong)vn [i] + un [j + i] + c;  			un [j + i] = (uint)c;  			c >>= 32;  		}  		c += (ulong)un [j + n];  		un [j + n] = (uint)c;  	}  	TestDivisionStep (un' vn' q' u' v);  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (int j = m - n; j >= 0; j--) {  	ulong rr' qq;  	int i;  	rr = Base * un [j + n] + un [j + n - 1];  	qq = rr / vn [n - 1];  	rr -= qq * vn [n - 1];  	Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  	for (; ;) {  		// Estimate too big ?  		//  		if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  			qq--;  			rr += (ulong)vn [n - 1];  			if (rr < Base)  				continue;  		}  		break;  	}  	Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  	//  Multiply and subtract  	//  	long b = 0;  	long t = 0;  	for (i = 0; i < n; i++) {  		ulong p = vn [i] * qq;  		t = (long)un [i + j] - (long)(uint)p - b;  		un [i + j] = (uint)t;  		p >>= 32;  		t >>= 32;  		Debug.Assert (t == 0 || t == -1 || t == -2);  		b = (long)p - t;  	}  	t = (long)un [j + n] - b;  	un [j + n] = (uint)t;  	//  Store the calculated value  	//  	q [j] = (uint)qq;  	//  Add back vn[0..n] to un[j..j+n]  	//  	if (t < 0) {  		q [j]--;  		ulong c = 0;  		for (i = 0; i < n; i++) {  			c = (ulong)vn [i] + un [j + i] + c;  			un [j + i] = (uint)c;  			c >>= 32;  		}  		c += (ulong)un [j + n];  		un [j + n] = (uint)c;  	}  	TestDivisionStep (un' vn' q' u' v);  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (int j = m - n; j >= 0; j--) {  	ulong rr' qq;  	int i;  	rr = Base * un [j + n] + un [j + n - 1];  	qq = rr / vn [n - 1];  	rr -= qq * vn [n - 1];  	Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  	for (; ;) {  		// Estimate too big ?  		//  		if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  			qq--;  			rr += (ulong)vn [n - 1];  			if (rr < Base)  				continue;  		}  		break;  	}  	Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  	//  Multiply and subtract  	//  	long b = 0;  	long t = 0;  	for (i = 0; i < n; i++) {  		ulong p = vn [i] * qq;  		t = (long)un [i + j] - (long)(uint)p - b;  		un [i + j] = (uint)t;  		p >>= 32;  		t >>= 32;  		Debug.Assert (t == 0 || t == -1 || t == -2);  		b = (long)p - t;  	}  	t = (long)un [j + n] - b;  	un [j + n] = (uint)t;  	//  Store the calculated value  	//  	q [j] = (uint)qq;  	//  Add back vn[0..n] to un[j..j+n]  	//  	if (t < 0) {  		q [j]--;  		ulong c = 0;  		for (i = 0; i < n; i++) {  			c = (ulong)vn [i] + un [j + i] + c;  			un [j + i] = (uint)c;  			c >>= 32;  		}  		c += (ulong)un [j + n];  		un [j + n] = (uint)c;  	}  	TestDivisionStep (un' vn' q' u' v);  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (int j = m - n; j >= 0; j--) {  	ulong rr' qq;  	int i;  	rr = Base * un [j + n] + un [j + n - 1];  	qq = rr / vn [n - 1];  	rr -= qq * vn [n - 1];  	Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  	for (; ;) {  		// Estimate too big ?  		//  		if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  			qq--;  			rr += (ulong)vn [n - 1];  			if (rr < Base)  				continue;  		}  		break;  	}  	Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  	//  Multiply and subtract  	//  	long b = 0;  	long t = 0;  	for (i = 0; i < n; i++) {  		ulong p = vn [i] * qq;  		t = (long)un [i + j] - (long)(uint)p - b;  		un [i + j] = (uint)t;  		p >>= 32;  		t >>= 32;  		Debug.Assert (t == 0 || t == -1 || t == -2);  		b = (long)p - t;  	}  	t = (long)un [j + n] - b;  	un [j + n] = (uint)t;  	//  Store the calculated value  	//  	q [j] = (uint)qq;  	//  Add back vn[0..n] to un[j..j+n]  	//  	if (t < 0) {  		q [j]--;  		ulong c = 0;  		for (i = 0; i < n; i++) {  			c = (ulong)vn [i] + un [j + i] + c;  			un [j + i] = (uint)c;  			c >>= 32;  		}  		c += (ulong)un [j + n];  		un [j + n] = (uint)c;  	}  	TestDivisionStep (un' vn' q' u' v);  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (int j = m - n; j >= 0; j--) {  	ulong rr' qq;  	int i;  	rr = Base * un [j + n] + un [j + n - 1];  	qq = rr / vn [n - 1];  	rr -= qq * vn [n - 1];  	Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  	for (; ;) {  		// Estimate too big ?  		//  		if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  			qq--;  			rr += (ulong)vn [n - 1];  			if (rr < Base)  				continue;  		}  		break;  	}  	Debug.Assert ((Base * un [j + n] + un [j + n - 1]) == qq * vn [n - 1] + rr);  	//  Multiply and subtract  	//  	long b = 0;  	long t = 0;  	for (i = 0; i < n; i++) {  		ulong p = vn [i] * qq;  		t = (long)un [i + j] - (long)(uint)p - b;  		un [i + j] = (uint)t;  		p >>= 32;  		t >>= 32;  		Debug.Assert (t == 0 || t == -1 || t == -2);  		b = (long)p - t;  	}  	t = (long)un [j + n] - b;  	un [j + n] = (uint)t;  	//  Store the calculated value  	//  	q [j] = (uint)qq;  	//  Add back vn[0..n] to un[j..j+n]  	//  	if (t < 0) {  		q [j]--;  		ulong c = 0;  		for (i = 0; i < n; i++) {  			c = (ulong)vn [i] + un [j + i] + c;  			un [j + i] = (uint)c;  			c >>= 32;  		}  		c += (ulong)un [j + n];  		un [j + n] = (uint)c;  	}  	TestDivisionStep (un' vn' q' u' v);  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (; ;) {  	// Estimate too big ?  	//  	if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  		qq--;  		rr += (ulong)vn [n - 1];  		if (rr < Base)  			continue;  	}  	break;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (; ;) {  	// Estimate too big ?  	//  	if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  		qq--;  		rr += (ulong)vn [n - 1];  		if (rr < Base)  			continue;  	}  	break;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  	qq--;  	rr += (ulong)vn [n - 1];  	if (rr < Base)  		continue;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  	qq--;  	rr += (ulong)vn [n - 1];  	if (rr < Base)  		continue;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (i = 0; i < n; i++) {  	ulong p = vn [i] * qq;  	t = (long)un [i + j] - (long)(uint)p - b;  	un [i + j] = (uint)t;  	p >>= 32;  	t >>= 32;  	Debug.Assert (t == 0 || t == -1 || t == -2);  	b = (long)p - t;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (i = 0; i < n; i++) {  	ulong p = vn [i] * qq;  	t = (long)un [i + j] - (long)(uint)p - b;  	un [i + j] = (uint)t;  	p >>= 32;  	t >>= 32;  	Debug.Assert (t == 0 || t == -1 || t == -2);  	b = (long)p - t;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (i = 0; i < n; i++) {  	ulong p = vn [i] * qq;  	t = (long)un [i + j] - (long)(uint)p - b;  	un [i + j] = (uint)t;  	p >>= 32;  	t >>= 32;  	Debug.Assert (t == 0 || t == -1 || t == -2);  	b = (long)p - t;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: p >>= 32;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: t >>= 32;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: Debug.Assert (t == 0 || t == -1 || t == -2);  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (t < 0) {  	q [j]--;  	ulong c = 0;  	for (i = 0; i < n; i++) {  		c = (ulong)vn [i] + un [j + i] + c;  		un [j + i] = (uint)c;  		c >>= 32;  	}  	c += (ulong)un [j + n];  	un [j + n] = (uint)c;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: for (i = 0; i < n; i++) {  	c = (ulong)vn [i] + un [j + i] + c;  	un [j + i] = (uint)c;  	c >>= 32;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: c >>= 32;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,ToString,The following statement contains a magic number: return ToString (10);  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,ToString,The following statement contains a magic number: if (radix < 2) {  	throw new ArgumentOutOfRangeException ("radix");  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,ToString,The following statement contains a magic number: if (radix > 36) {  	throw new ArgumentOutOfRangeException ("radix");  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < dwords.Length; i++) {  	dword = dwords [i];  	for (int j = 0; j < 4; j++) {  		bytes [curByte++] = (byte)(dword & 0xff);  		dword >>= 8;  	}  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < dwords.Length; i++) {  	dword = dwords [i];  	for (int j = 0; j < 4; j++) {  		bytes [curByte++] = (byte)(dword & 0xff);  		dword >>= 8;  	}  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int j = 0; j < 4; j++) {  	bytes [curByte++] = (byte)(dword & 0xff);  	dword >>= 8;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int j = 0; j < 4; j++) {  	bytes [curByte++] = (byte)(dword & 0xff);  	dword >>= 8;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,ToByteArray,The following statement contains a magic number: dword >>= 8;  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,ToString,The following statement contains a magic number: switch (format [0]) {  case 'd':  case 'D':  	if (format.Length > 1) {  		int precision = Convert.ToInt32 (format.Substring (1)' CultureInfo.InvariantCulture.NumberFormat);  		string baseStr = ToString (10);  		if (baseStr.Length < precision) {  			string additional = new String ('0'' precision - baseStr.Length);  			if (baseStr [0] != '-') {  				return additional + baseStr;  			} else {  				return "-" + additional + baseStr.Substring (1);  			}  		}  		return baseStr;  	}  	return ToString (10);  case 'x':  case 'X':  	StringBuilder res = new StringBuilder (ToString (16));  	if (format [0] == 'x') {  		for (int i = 0; i < res.Length; i++) {  			if (res [i] >= 'A' && res [i] <= 'F') {  				res [i] = Char.ToLower (res [i]' CultureInfo.InvariantCulture);  			}  		}  	}  	if (format.Length > 1) {  		int precision = Convert.ToInt32 (format.Substring (1)' CultureInfo.InvariantCulture.NumberFormat);  		if (res.Length < precision) {  			string additional = new String ('0'' precision - res.Length);  			if (res [0] != '-') {  				res.Insert (0' additional);  			} else {  				res.Insert (1' additional);  			}  		}  	}  	return res.ToString ();  default:  	throw new NotImplementedException (MathResources.FormatNotImplemented);  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,ToString,The following statement contains a magic number: switch (format [0]) {  case 'd':  case 'D':  	if (format.Length > 1) {  		int precision = Convert.ToInt32 (format.Substring (1)' CultureInfo.InvariantCulture.NumberFormat);  		string baseStr = ToString (10);  		if (baseStr.Length < precision) {  			string additional = new String ('0'' precision - baseStr.Length);  			if (baseStr [0] != '-') {  				return additional + baseStr;  			} else {  				return "-" + additional + baseStr.Substring (1);  			}  		}  		return baseStr;  	}  	return ToString (10);  case 'x':  case 'X':  	StringBuilder res = new StringBuilder (ToString (16));  	if (format [0] == 'x') {  		for (int i = 0; i < res.Length; i++) {  			if (res [i] >= 'A' && res [i] <= 'F') {  				res [i] = Char.ToLower (res [i]' CultureInfo.InvariantCulture);  			}  		}  	}  	if (format.Length > 1) {  		int precision = Convert.ToInt32 (format.Substring (1)' CultureInfo.InvariantCulture.NumberFormat);  		if (res.Length < precision) {  			string additional = new String ('0'' precision - res.Length);  			if (res [0] != '-') {  				res.Insert (0' additional);  			} else {  				res.Insert (1' additional);  			}  		}  	}  	return res.ToString ();  default:  	throw new NotImplementedException (MathResources.FormatNotImplemented);  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,ToString,The following statement contains a magic number: switch (format [0]) {  case 'd':  case 'D':  	if (format.Length > 1) {  		int precision = Convert.ToInt32 (format.Substring (1)' CultureInfo.InvariantCulture.NumberFormat);  		string baseStr = ToString (10);  		if (baseStr.Length < precision) {  			string additional = new String ('0'' precision - baseStr.Length);  			if (baseStr [0] != '-') {  				return additional + baseStr;  			} else {  				return "-" + additional + baseStr.Substring (1);  			}  		}  		return baseStr;  	}  	return ToString (10);  case 'x':  case 'X':  	StringBuilder res = new StringBuilder (ToString (16));  	if (format [0] == 'x') {  		for (int i = 0; i < res.Length; i++) {  			if (res [i] >= 'A' && res [i] <= 'F') {  				res [i] = Char.ToLower (res [i]' CultureInfo.InvariantCulture);  			}  		}  	}  	if (format.Length > 1) {  		int precision = Convert.ToInt32 (format.Substring (1)' CultureInfo.InvariantCulture.NumberFormat);  		if (res.Length < precision) {  			string additional = new String ('0'' precision - res.Length);  			if (res [0] != '-') {  				res.Insert (0' additional);  			} else {  				res.Insert (1' additional);  			}  		}  	}  	return res.ToString ();  default:  	throw new NotImplementedException (MathResources.FormatNotImplemented);  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,ToString,The following statement contains a magic number: if (format.Length > 1) {  	int precision = Convert.ToInt32 (format.Substring (1)' CultureInfo.InvariantCulture.NumberFormat);  	string baseStr = ToString (10);  	if (baseStr.Length < precision) {  		string additional = new String ('0'' precision - baseStr.Length);  		if (baseStr [0] != '-') {  			return additional + baseStr;  		} else {  			return "-" + additional + baseStr.Substring (1);  		}  	}  	return baseStr;  }  
Magic Number,Microsoft.Scripting.Math,BigInteger,F:\newReposMay17\KevinHoward_Irony\Irony\Microsoft\BigInteger.cs,ToString,The following statement contains a magic number: return ToString (10);  
Missing Default,Irony.Ast,StringTemplateNode,F:\newReposMay17\KevinHoward_Irony\Irony\Ast\PrimitiveNodes\StringTemplateNode.cs,EvaluateNode,The following switch statement is missing a default case: switch (mode) {  case AstMode.Read:  	var value = BuildString (context);  	context.Data.Push (value);  	break;  case AstMode.Write:  	context.ThrowError (Resources.ErrAssignLiteralValue);  	break;  }  
Missing Default,Irony.Ast,StringTemplateNode,F:\newReposMay17\KevinHoward_Irony\Irony\Ast\PrimitiveNodes\StringTemplateNode.cs,BuildString,The following switch statement is missing a default case: switch (segment.Type) {  case SegmentType.Text:  	values [i] = segment.Text;  	break;  case SegmentType.Expression:  	values [i] = EvaluateExpression (context' segment);  	context.Data.PopUntil (initialStackCount);  	break;  }  
Missing Default,Irony.Ast,LiteralValueNode,F:\newReposMay17\KevinHoward_Irony\Irony\Ast\PrimitiveNodes\LiteralValueNode.cs,EvaluateNode,The following switch statement is missing a default case: switch (mode) {  case AstMode.Read:  	context.Data.Push (Value);  	break;  case AstMode.Write:  	context.ThrowError (Resources.ErrAssignLiteralValue);  	break;  }  
Missing Default,Irony.Ast,IdentifierNode,F:\newReposMay17\KevinHoward_Irony\Irony\Ast\PrimitiveNodes\IdentifierNode.cs,EvaluateNode,The following switch statement is missing a default case: switch (mode) {  case AstMode.Read:  	object value;  	if (context.TryGetValue (Symbol' out value))  		context.Data.Push (value);  	else  		context.ThrowError (Resources.ErrVarNotDefined' Symbol);  	break;  case AstMode.Write:  	context.SetValue (Symbol' context.Data.Pop ());  	break;  }  
Missing Default,Irony.Interpreter,CommandLine,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\CommandLine.cs,RunImpl,The following switch statement is missing a default case: switch (result) {  case ReadResult.AbortYes:  	return;  //exit  case ReadResult.AbortNo:  	continue;  //while loop  case ReadResult.Script:  	break;  //do nothing' continue to evaluate script  }  
Missing Default,Irony.Interpreter,LanguageRuntime,F:\newReposMay17\KevinHoward_Irony\Irony\Interpreter\LanguageRuntime_Init.cs,GetUpType,The following switch statement is missing a default case: switch (type.Name) {  case "Byte":  case "SByte":  case "Int16":  case "UInt16":  case "Int32":  case "UInt32":  	return typeof(Int64);  case "Int64":  case "UInt64":  	return typeof(BigInteger);  case "Single":  	return typeof(double);  }  
Missing Default,Irony.Parsing,CoreParser,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Parser\CoreParser_ErrorHandling.cs,ExecuteAction,The following switch statement is missing a default case: switch (action.ActionType) {  case ParserActionType.Shift:  	ExecuteShift (action);  	break;  case ParserActionType.Operator:  	ExecuteOperatorAction (action);  	break;  case ParserActionType.Reduce:  	ExecuteReduce (action);  	break;  case ParserActionType.Code:  	ExecuteConflictAction (action);  	break;  case ParserActionType.Accept:  	ExecuteAccept (action);  	break;  }  
Missing Default,Irony.Parsing,CoreParser,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Parser\CoreParser_ErrorHandling.cs,ExecuteOperatorAction,The following switch statement is missing a default case: switch (realActionType) {  case ParserActionType.Shift:  	ExecuteShift (action);  	break;  case ParserActionType.Reduce:  	ExecuteReduce (action);  	break;  }  
Missing Default,Irony.Parsing,ParserAction,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Data\ParserData.cs,ToString,The following switch statement is missing a default case: switch (this.ActionType) {  case ParserActionType.Shift:  	return string.Format (Resources.LabelActionShift' NewState.Name);  case ParserActionType.Reduce:  	return string.Format (Resources.LabelActionReduce' ReduceProduction.ToStringQuoted ());  case ParserActionType.Operator:  	return string.Format (Resources.LabelActionOp' NewState.Name' ReduceProduction.ToStringQuoted ());  case ParserActionType.Accept:  	return Resources.LabelActionAccept;  }  
Missing Default,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,ConvertValue,The following switch statement is missing a default case: switch (details.TypeCodes [0]) {  case TypeCode.Int32:  	if (QuickConvertToInt32 (details))  		return true;  	break;  case TypeCode.Double:  	if (QuickConvertToDouble (details))  		return true;  	break;  }  
Missing Default,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,ConvertValue,The following switch statement is missing a default case: switch (typeCode) {  case TypeCode.Single:  case TypeCode.Double:  case TypeCode.Decimal:  case TypeCodeImaginary:  	return ConvertToFloat (typeCode' details);  case TypeCode.SByte:  case TypeCode.Byte:  case TypeCode.Int16:  case TypeCode.UInt16:  case TypeCode.Int32:  case TypeCode.UInt32:  case TypeCode.Int64:  case TypeCode.UInt64:  	if (details.Value == null)  		//if it is not done yet  		TryConvertToLong (details' typeCode == TypeCode.UInt64);  	//try to convert to Long/Ulong and place the result into details.Value field;  	if (TryCastToIntegerType (typeCode' details))  		//now try to cast the ULong value to the target type   		return true;  	break;  case TypeCodeBigInt:  	if (ConvertToBigInteger (details))  		return true;  	break;  }  
Missing Default,Irony.Parsing,NumberLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\NumberLiteral.cs,ConvertToFloat,The following switch statement is missing a default case: switch (typeCode) {  case TypeCode.Double:  case TypeCodeImaginary:  	double dValue;  	if (!Double.TryParse (body' NumberStyles.Float' CultureInfo.InvariantCulture' out dValue))  		return false;  	if (typeCode == TypeCodeImaginary)  		details.Value = new Complex64 (0' dValue);  	else  		details.Value = dValue;  	return true;  case TypeCode.Single:  	float fValue;  	if (!Single.TryParse (body' NumberStyles.Float' CultureInfo.InvariantCulture' out fValue))  		return false;  	details.Value = fValue;  	return true;  case TypeCode.Decimal:  	decimal decValue;  	if (!Decimal.TryParse (body' NumberStyles.Float' CultureInfo.InvariantCulture' out decValue))  		return false;  	details.Value = decValue;  	return true;  }  
Missing Default,Irony.Parsing,StringLiteral,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following switch statement is missing a default case: switch (first) {  case 'u':  case 'U':  	if (details.IsSet ((short)StringOptions.AllowsUEscapes)) {  		len = (first == 'u' ? 4 : 8);  		if (segment.Length < len + 1) {  			details.Error = string.Format (Resources.ErrBadUnEscape' segment.Substring (len + 1)' len);  			// "Invalid unicode escape ({0})' expected {1} hex digits."  			return segment;  		}  		digits = segment.Substring (1' len);  		ch = (char)Convert.ToUInt32 (digits' 16);  		result = ch + segment.Substring (len + 1);  		return result;  	}  	//if  	break;  case 'x':  	if (details.IsSet ((short)StringOptions.AllowsXEscapes)) {  		//x-escape allows variable number of digits' from one to 4; let's count them  		p = 1;  		//current position  		while (p < 5 && p < segment.Length) {  			if (Strings.HexDigits.IndexOf (segment [p]) < 0)  				break;  			p++;  		}  		//p now point to char right after the last digit  		if (p <= 1) {  			details.Error = Resources.ErrBadXEscape;  			// @"Invalid \x escape' at least one digit expected.";  			return segment;  		}  		digits = segment.Substring (1' p - 1);  		ch = (char)Convert.ToUInt32 (digits' 16);  		result = ch + segment.Substring (p);  		return result;  	}  	//if  	break;  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  	if (details.IsSet ((short)StringOptions.AllowsOctalEscapes)) {  		//octal escape allows variable number of digits' from one to 3; let's count them  		p = 0;  		//current position  		while (p < 3 && p < segment.Length) {  			if (Strings.OctalDigits.IndexOf (segment [p]) < 0)  				break;  			p++;  		}  		//p now point to char right after the last digit  		digits = segment.Substring (0' p);  		ch = (char)Convert.ToUInt32 (digits' 8);  		result = ch + segment.Substring (p);  		return result;  	}  	//if  	break;  }  
Missing Default,Irony.Parsing,IdentifierTerminal,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\IdentifierTerminal.cs,Init,The following switch statement is missing a default case: switch (CaseRestriction) {  case CaseRestriction.AllLower:  case CaseRestriction.FirstLower:  	AllFirstChars = AllFirstChars.ToLower ();  	break;  case CaseRestriction.AllUpper:  case CaseRestriction.FirstUpper:  	AllFirstChars = AllFirstChars.ToUpper ();  	break;  }  
Missing Default,Irony.Parsing,IdentifierTerminal,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\Terminals\IdentifierTerminal.cs,AdjustCasing,The following switch statement is missing a default case: switch (CaseRestriction) {  case CaseRestriction.None:  	break;  case CaseRestriction.FirstLower:  	AllFirstChars = AllFirstChars.ToLower ();  	break;  case CaseRestriction.FirstUpper:  	AllFirstChars = AllFirstChars.ToUpper ();  	break;  case CaseRestriction.AllLower:  	AllFirstChars = AllFirstChars.ToLower ();  	AllChars = AllChars.ToLower ();  	break;  case CaseRestriction.AllUpper:  	AllFirstChars = AllFirstChars.ToUpper ();  	AllChars = AllChars.ToUpper ();  	break;  }  
Missing Default,Irony.Parsing,CodeOutlineFilter,F:\newReposMay17\KevinHoward_Irony\Irony\Parsing\TokenFilters\CodeOutlineFilter.cs,ProcessEofToken,The following switch statement is missing a default case: switch (_context.Mode) {  case ParseMode.File:  	pushDedents = _produceIndents;  	//Do dedents if token filter tracks indents  	break;  case ParseMode.CommandLine:  	//only if user entered empty line' we dedent all  	pushDedents = _produceIndents && _doubleEof;  	pushEos = !_prevIsContinuation && !_doubleEof;  	//if previous symbol is continuation symbol then don't push Eos  	break;  case ParseMode.VsLineScan:  	pushDedents = false;  	//Do not dedent at all on every line end  	break;  }  
