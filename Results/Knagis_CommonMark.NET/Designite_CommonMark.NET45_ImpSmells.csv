Implementation smell,Namespace,Class,File,Method,Description
Long Method,CommonMark.Formatters,HtmlFormatter,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\HtmlFormatter.cs,WriteBlock,The method has 128 lines of code.
Long Method,CommonMark.Formatters,HtmlFormatter,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\HtmlFormatter.cs,WriteInline,The method has 210 lines of code.
Long Method,CommonMark.Formatters,HtmlFormatterSlim,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\HtmlFormatterSlim.cs,BlocksToHtmlInner,The method has 152 lines of code.
Long Method,CommonMark.Formatters,HtmlFormatterSlim,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\HtmlFormatterSlim.cs,InlinesToHtml,The method has 151 lines of code.
Long Method,CommonMark.Formatters,Printer,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\Printer.cs,PrintBlocks,The method has 114 lines of code.
Long Method,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,IncorporateLine,The method has 363 lines of code.
Complex Method,CommonMark.Parser,PositionTracker,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\PositionTracker.cs,AddOffset,Cyclomatic complexity of the method is 11
Complex Method,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_html_block_start,Cyclomatic complexity of the method is 13
Complex Method,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagOpenTag,Cyclomatic complexity of the method is 13
Complex Method,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_autolink_uri,Cyclomatic complexity of the method is 11
Complex Method,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_autolink_email,Cyclomatic complexity of the method is 13
Complex Method,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_link_url,Cyclomatic complexity of the method is 16
Complex Method,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_atx_heading_start,Cyclomatic complexity of the method is 8
Complex Method,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_open_code_fence,Cyclomatic complexity of the method is 9
Complex Method,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,Cyclomatic complexity of the method is 9
Complex Method,CommonMark.Parser,TabTextReader,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\TabTextReader.cs,ReadLine,Cyclomatic complexity of the method is 8
Complex Method,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,IncorporateLine,Cyclomatic complexity of the method is 10
Complex Method,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,NormalizeWhitespace,Cyclomatic complexity of the method is 10
Complex Method,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,ParseReference,Cyclomatic complexity of the method is 8
Complex Method,CommonMark.Syntax,Enumerator,C:\repos\Knagis_CommonMark.NET\CommonMark\Syntax\Enumerable.cs,MoveNext,Cyclomatic complexity of the method is 13
Long Parameter List,CommonMark.Formatters,Printer,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\Printer.cs,PrintInlines,The method has 6 parameters. Parameters: writer' inline' indent' stack' buffer' trackPositions
Long Parameter List,CommonMark.Parser,InlineStack,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineStack.cs,FindMatchingOpener,The method has 6 parameters. Parameters: searchBackwardsFrom' priority' delimiter' closerDelimiterCount' closerCanOpen' canClose
Long Parameter List,CommonMark.Parser,PositionTracker,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\PositionTracker.cs,CalculateOrigin,The method has 5 parameters. Parameters: offsets' offsetCount' position' includeReduce' isStart
Long Parameter List,CommonMark.Parser,ScannerCharacterMatcher,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerCharacterMatcher.cs,MatchAsciiLetterOrDigit,The method has 8 parameters. Parameters: data' currentCharacter' currentPosition' lastPosition' valid1' valid2' valid3' valid4
Long Parameter List,CommonMark.Parser,ScannerCharacterMatcher,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerCharacterMatcher.cs,MatchAsciiLetterOrDigit,The method has 5 parameters. Parameters: data' currentCharacter' currentPosition' lastPosition' valid1
Long Parameter List,CommonMark.Parser,ScannerCharacterMatcher,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerCharacterMatcher.cs,MatchAsciiLetter,The method has 6 parameters. Parameters: data' currentCharacter' currentPosition' lastPosition' valid1' valid2
Long Parameter List,CommonMark.Parser,ScannerCharacterMatcher,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerCharacterMatcher.cs,MatchAnythingExcept,The method has 5 parameters. Parameters: data' currentCharacter' currentPosition' lastPosition' invalid1
Long Parameter List,CommonMark.Parser,ScannerCharacterMatcher,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerCharacterMatcher.cs,MatchAnythingExceptWhitespaces,The method has 10 parameters. Parameters: data' currentCharacter' currentPosition' lastPosition' invalid1' invalid2' invalid3' invalid4' invalid5' invalid6
Long Parameter List,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,The method has 5 parameters. Parameters: s' pos' length' namedEntity' numericEntity
Long Parameter List,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,AddLine,The method has 7 parameters. Parameters: block' lineInfo' ln' offset' remainingSpaces' length' isAddOffsetRequired
Long Parameter List,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,AdvanceOffset,The method has 6 parameters. Parameters: line' count' columns' offset' column' remainingSpaces
Long Parameter List,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,FindFirstNonspace,The method has 6 parameters. Parameters: ln' offset' column' first_nonspace' first_nonspace_column' curChar
Long Parameter List,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,MatchInlineStack,The method has 6 parameters. Parameters: opener' subj' closingDelimiterCount' closer' singleCharTag' doubleCharTag
Long Parameter List,CommonMark.Syntax,Inline,C:\repos\Knagis_CommonMark.NET\CommonMark\Syntax\Inline.cs,Inline,The method has 6 parameters. Parameters: content' startIndex' length' sourcePosition' sourceLastPosition' delimiterCharacter
Long Identifier,CommonMark,CommonMarkSettings,C:\repos\Knagis_CommonMark.NET\CommonMark\CommonMarkSettings.cs,,The length of the parameter _inlineParserSpecialCharacters is 30.
Long Statement,CommonMark,CommonMarkConverter,C:\repos\Knagis_CommonMark.NET\CommonMark\CommonMarkConverter.cs,ProcessStage2,The length of the statement  "                throw new ArgumentException("The block element passed to this method must represent a top level document."' nameof(document)); " is 126.
Long Statement,CommonMark,CommonMarkConverter,C:\repos\Knagis_CommonMark.NET\CommonMark\CommonMarkConverter.cs,ProcessStage3,The length of the statement  "                throw new ArgumentException("The block element passed to this method must represent a top level document."' nameof(document)); " is 126.
Long Statement,CommonMark,CommonMarkConverter,C:\repos\Knagis_CommonMark.NET\CommonMark\CommonMarkConverter.cs,ProcessStage3,The length of the statement  "                            throw new CommonMarkException("If `settings.OutputFormat` is set to `CustomDelegate`' the `settings.OutputDelegate` property must be populated."); " is 146.
Long Statement,CommonMark.Formatters,HtmlFormatterSlim,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\HtmlFormatterSlim.cs,BlocksToHtmlInner,The length of the statement  "                            writer.WriteLineConstant(x > 0 && x < 7 ? HeadingCloserTags[x - 1] : "</h" + x.ToString(CultureInfo.InvariantCulture) + ">"); " is 125.
Long Statement,CommonMark.Formatters,HtmlFormatterSlim,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\HtmlFormatterSlim.cs,BlocksToHtmlInner,The length of the statement  "                            writer.WriteConstant(x > 0 && x < 7 ? HeadingOpenerTags[x - 1] : "<h" + x.ToString(CultureInfo.InvariantCulture) + ">"); " is 120.
Long Statement,CommonMark.Formatters,HtmlFormatterSlim,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\HtmlFormatterSlim.cs,BlocksToHtmlInner,The length of the statement  "                            writer.WriteLineConstant(x > 0 && x < 7 ? HeadingCloserTags[x - 1] : "</h" + x.ToString(CultureInfo.InvariantCulture) + ">"); " is 125.
Long Statement,CommonMark.Parser,InlineStack,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineStack.cs,PostProcessInlineStack,The length of the statement  "                        var iopener = FindMatchingOpener(istack.Previous' istack.Priority' istack.Delimiter' istack.DelimiterCount' (istack.Flags & InlineStackFlags.Opener) > 0' out canClose); " is 168.
Long Statement,CommonMark.Parser,InlineStack,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineStack.cs,PostProcessInlineStack,The length of the statement  "                                var useDelims = InlineMethods.MatchInlineStack(iopener' subj' istack.DelimiterCount' istack' InlineTag.Emphasis' InlineTag.Strong); " is 131.
Long Statement,CommonMark.Parser,LineInfo,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\LineInfo.cs,CalculateOrigin,The length of the statement  "            return PositionTracker.CalculateOrigin(this.Offsets' this.OffsetCount' this.LineOffset + position' true' isStartPosition); " is 122.
Long Statement,CommonMark.Parser,PositionTracker,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\PositionTracker.cs,AddOffset,The length of the statement  "            Array.Copy(line.Offsets' indexAfterLastCopied' this.Offsets' this.OffsetCount' line.OffsetCount - indexAfterLastCopied); " is 120.
Long Statement,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagOpenTag,The length of the statement  "                        if (!ScannerCharacterMatcher.MatchAnythingExceptWhitespaces(s' ref currentChar' ref currentPosition' lastPosition' '\"'' '\''' '='' '<'' '>'' '`')) " is 147.
Long Statement,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagOpenTag,The length of the statement  "                ScannerCharacterMatcher.MatchAsciiLetterOrDigit(s' ref currentChar' ref currentPosition' lastPosition' '_'' ':'' '.'' '-'); " is 123.
Long Statement,CommonMark.Parser,TabTextReader,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\TabTextReader.cs,ReadLine,The length of the statement  "            if (c == '\r' && (this._bufferPosition < this._bufferLength || this.ReadBuffer()) && this._buffer[this._bufferPosition] == '\n') " is 128.
Long Statement,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,AddLine,The length of the statement  "                throw new CommonMarkException(string.Format(CultureInfo.InvariantCulture' "Attempted to add line '{0}' to closed container ({1})."' ln' block.Tag)); " is 148.
Long Statement,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,Finalize,The length of the statement  "                // Block types 6 and 7 calls Finalize once it finds the next empty row but that empty row is no longer considered to be part of the block. " is 138.
Long Statement,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,Finalize,The length of the statement  "                var includesThisLine = b.HtmlBlockType != HtmlBlockType.None && b.HtmlBlockType != HtmlBlockType.InterruptingBlock && b.HtmlBlockType != HtmlBlockType.NonInterruptingBlock; " is 172.
Long Statement,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,IncorporateLine,The length of the statement  "            // the adjustment to the virtual position `column` that points to the number of spaces from the TAB that have not been included in any indent. " is 142.
Long Statement,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,IncorporateLine,The length of the statement  "                                AdvanceOffset(ln' container.ListData.MarkerOffset + container.ListData.Padding' true' ref offset' ref column' ref remainingSpaces); " is 131.
Long Statement,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,IncorporateLine,The length of the statement  "                else if (!indented && curChar == '#' && 0 != (matched = Scanner.scan_atx_heading_start(ln' first_nonspace' ln.Length' out i))) " is 126.
Long Statement,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,IncorporateLine,The length of the statement  "                else if (!indented && (curChar == '`' || curChar == '~') && 0 != (matched = Scanner.scan_open_code_fence(ln' first_nonspace' ln.Length))) " is 137.
Long Statement,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,IncorporateLine,The length of the statement  "                    || (container.Tag != BlockTag.Paragraph && 0 != (matched = (int)Scanner.scan_html_block_start_7(ln' first_nonspace' ln.Length))) " is 128.
Long Statement,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,IncorporateLine,The length of the statement  "                        throw new CommonMarkException("Cannot finalize container block. Last matched container tag = " + last_matched_container.Tag); " is 125.
Long Statement,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,IncorporateLine,The length of the statement  "                    AddLine(container' line' ln' first_nonspace' remainingSpaces' isAddOffsetRequired: container.Parent == null || container.Parent.Tag == BlockTag.Document); " is 154.
Long Statement,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,IncorporateLine,The length of the statement  "                    Utilities.Warning("Line {0} with container type {1} did not match any condition:\n\"{2}\""' line.LineNumber' container.Tag' ln); " is 128.
Long Statement,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,NormalizeWhitespace,The length of the statement  "            // count will actually be the lastIndex. The method argument is count only because other similar methods have startIndex/count " is 126.
Long Statement,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,HandleOpenerCloser,The length of the statement  "                var istack = InlineStack.FindMatchingOpener(subj.LastPendingInline' InlineStack.InlineStackPriority.Emphasis' c' numdelims' canOpen' out canClose); " is 147.
Long Statement,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,HandleOpenerCloser,The length of the statement  "            var inlText = new Inline(subj.Buffer' subj.Position - numdelims' numdelims' subj.Position - numdelims' subj.Position' c); " is 121.
Long Statement,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,HandleLeftSquareBracket,The length of the statement  "            istack.Flags = InlineStack.InlineStackFlags.Opener | (isImage ? InlineStack.InlineStackFlags.ImageLink : InlineStack.InlineStackFlags.None); " is 140.
Long Statement,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,HandleRightSquareBracket,The length of the statement  "            var istack = InlineStack.FindMatchingOpener(subj.LastPendingInline' InlineStack.InlineStackPriority.Links' '['' 1' false' out canClose); " is 136.
Long Statement,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,ParseLinkDetails,The length of the statement  "                    Url = subj.Buffer.Substring(subj.LastPendingInline.StartPosition' subj.Position - subj.LastPendingInline.StartPosition - 1)' " is 124.
Long Statement,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,parse_inlines,The length of the statement  "            InlineStack.PostProcessInlineStack(subj' subj.FirstPendingInline' subj.LastPendingInline' InlineStack.InlineStackPriority.Maximum); " is 131.
Long Statement,CommonMark.Syntax,StringContent,C:\repos\Knagis_CommonMark.NET\CommonMark\Syntax\StringContent.cs,TakeFromStart,The length of the statement  "            throw new ArgumentOutOfRangeException(nameof(length)' "The length of the substring cannot be greater than the length of the string."); " is 134.
Complex Conditional,CommonMark.Parser,EntityDecoder,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\EntityDecoder.cs,DecodeEntity,The conditional expression  "utf32 < 0 || utf32 > 1114111 || (utf32 >= 55296 && utf32 <= 57343)"  is complex.
Complex Conditional,CommonMark.Parser,ScannerCharacterMatcher,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerCharacterMatcher.cs,MatchAsciiLetter,The conditional expression  "((currentCharacter >= 'a' && currentCharacter <= 'z')                      || (currentCharacter >= 'A' && currentCharacter <= 'Z'))                    && currentPosition < lastPosition"  is complex.
Complex Conditional,CommonMark.Parser,ScannerCharacterMatcher,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerCharacterMatcher.cs,MatchHtmlTagNameCharacter,The conditional expression  "(   (currentCharacter >= 'a' && currentCharacter <= 'z')                       || (currentCharacter >= 'A' && currentCharacter <= 'Z')                       || (currentCharacter >= '0' && currentCharacter <= '9')                      || (currentCharacter == '-'))                    && currentPosition < lastPosition"  is complex.
Complex Conditional,CommonMark.Parser,ScannerCharacterMatcher,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerCharacterMatcher.cs,MatchAsciiLetterOrDigit,The conditional expression  "(   currentCharacter == valid1                      || currentCharacter == valid2                      || currentCharacter == valid3                      || currentCharacter == valid4                      || (currentCharacter >= 'a' && currentCharacter <= 'z')                      || (currentCharacter >= 'A' && currentCharacter <= 'Z')                      || (currentCharacter >= '0' && currentCharacter <= '9'))                    && currentPosition < lastPosition"  is complex.
Complex Conditional,CommonMark.Parser,ScannerCharacterMatcher,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerCharacterMatcher.cs,MatchAsciiLetterOrDigit,The conditional expression  "(currentCharacter == valid1                      || (currentCharacter >= 'a' && currentCharacter <= 'z')                      || (currentCharacter >= 'A' && currentCharacter <= 'Z')                      || (currentCharacter >= '0' && currentCharacter <= '9'))                    && currentPosition < lastPosition"  is complex.
Complex Conditional,CommonMark.Parser,ScannerCharacterMatcher,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerCharacterMatcher.cs,MatchAsciiLetter,The conditional expression  "(   currentCharacter == valid1                       || currentCharacter == valid2                      || (currentCharacter >= 'a' && currentCharacter <= 'z')                      || (currentCharacter >= 'A' && currentCharacter <= 'Z')                      || (currentCharacter >= '0' && currentCharacter <= '9'))                    && currentPosition < lastPosition"  is complex.
Complex Conditional,CommonMark.Parser,ScannerCharacterMatcher,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerCharacterMatcher.cs,MatchAnythingExceptWhitespaces,The conditional expression  "currentCharacter != invalid1                  && currentCharacter != invalid2                  && currentCharacter != invalid3                  && currentCharacter != invalid4                  && currentCharacter != invalid5                  && currentCharacter != invalid6                  && (currentCharacter != ' ' && currentCharacter != '\n')                  && currentPosition < lastPosition"  is complex.
Complex Conditional,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_html_block_start,The conditional expression  "((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '1' && c <= '6')) && j < 10 && ++pos < sourceLength"  is complex.
Complex Conditional,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_html_block_start,The conditional expression  "c != '>' && (c != '/' || pos + 1 >= sourceLength || s[pos + 1] != '>') && !Utilities.IsWhitespace(c)"  is complex.
Complex Conditional,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scan_html_block_end_1,The conditional expression  "c != 's' && c != 'S' && c != 'p' && c != 'P'"  is complex.
Complex Conditional,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagCloseTag,The conditional expression  "(nextChar < 'A' || nextChar > 'Z') && (nextChar < 'a' || nextChar > 'z')"  is complex.
Complex Conditional,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagCloseTag,The conditional expression  "tagNameEnded || ((nextChar < 'A' || nextChar > 'Z')                                     && (nextChar < 'a' || nextChar > 'z')                                     && (nextChar < '0' || nextChar > '9'))"  is complex.
Complex Conditional,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_autolink_uri,The conditional expression  "!Utilities.IsAsciiLetter(c) && c != '+' && c != '.' && c != '-'"  is complex.
Complex Conditional,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_autolink_email,The conditional expression  "(c < 'a' || c > 'z')                      && (c < 'A' || c > 'Z')                      && (c < '0' || c > '9')                      && ".!#$%&'*+/=?^_`{|}~-".IndexOf(c) == -1"  is complex.
Complex Conditional,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,The conditional expression  "(c < 'A' || c > 'Z') && (c < 'a' && c > 'z')"  is complex.
Complex Conditional,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,The conditional expression  "(c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')"  is complex.
Complex Conditional,CommonMark.Parser,TabTextReader,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\TabTextReader.cs,ReadLine,The conditional expression  "c == '\r' && (this._bufferPosition < this._bufferLength || this.ReadBuffer()) && this._buffer[this._bufferPosition] == '\n'"  is complex.
Complex Conditional,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,ParseListMarker,The conditional expression  "c == '+' || c == '•' || ((c == '*' || c == '-') && 0 == Scanner.scan_thematic_break(ln' pos' len))"  is complex.
Complex Conditional,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,IncorporateLine,The conditional expression  "!indented && (curChar == '`' || curChar == '~') && 0 != (matched = Scanner.scan_open_code_fence(ln' first_nonspace' ln.Length))"  is complex.
Complex Conditional,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,IncorporateLine,The conditional expression  "!indented && curChar == '<' &&                       (0 != (matched = (int)Scanner.scan_html_block_start(ln' first_nonspace' ln.Length))                      || (container.Tag != BlockTag.Paragraph && 0 != (matched = (int)Scanner.scan_html_block_start_7(ln' first_nonspace' ln.Length)))                      )"  is complex.
Complex Conditional,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,IncorporateLine,The conditional expression  "!indented && container.Tag == BlockTag.Paragraph && (curChar == '=' || curChar == '-')                          && 0 != (matched = Scanner.scan_setext_heading_line(ln' first_nonspace' ln.Length))"  is complex.
Complex Conditional,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,IncorporateLine,The conditional expression  "!indented                       && !(container.Tag == BlockTag.Paragraph && !all_matched)                       && 0 != (Scanner.scan_thematic_break(ln' first_nonspace' ln.Length))"  is complex.
Complex Conditional,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,IncorporateLine,The conditional expression  "cur != last_matched_container &&                  container == last_matched_container &&                  !blank &&                  cur.Tag == BlockTag.Paragraph &&                  cur.StringContent.Length > 0"  is complex.
Complex Conditional,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,IncorporateLine,The conditional expression  "p >= 0 && (ln[p] == ' ' || ln[p] == '\t' || ln[p] == '\n')"  is complex.
Complex Conditional,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,CleanTitle,The conditional expression  "(a == '\'' && b == '\'') || (a == '(' && b == ')') || (a == '"' && b == '"')"  is complex.
Magic Number,CommonMark,CommonMarkConverter,C:\repos\Knagis_CommonMark.NET\CommonMark\CommonMarkConverter.cs,InitializeVersion,The following statement contains a magic number: using (var stream = Assembly.GetManifestResourceStream("CommonMark.Properties.CommonMark.NET.nuspec"))              using (var reader = new System.IO.StreamReader(stream' Encoding.UTF8))              {                  string line;                  while ((line = reader.ReadLine()) != null)                  {                      var i = line.IndexOf("<version>"' StringComparison.Ordinal);                      if (i == -1)                          continue;                        i += 9;                      return new Version(line.Substring(i' line.IndexOf("</version>"' StringComparison.Ordinal) - i));                  }              }
Magic Number,CommonMark,Utilities,C:\repos\Knagis_CommonMark.NET\CommonMark\Utilities.cs,IsEscapableSymbol,The following statement contains a magic number: return (c > ' ' && c < '0') || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || (c > 'z' && c < 127) || c == '•';
Magic Number,CommonMark,Utilities,C:\repos\Knagis_CommonMark.NET\CommonMark\Utilities.cs,CheckUnicodeCategory,The following statement contains a magic number: if (c <= 'ÿ')              {                  space = c == ' ' || (c >= '\t' && c <= '\r') || c == '\u00a0' || c == '\u0085';                  punctuation = (c >= 33 && c <= 47) || (c >= 58 && c <= 64) || (c >= 91 && c <= 96) || (c >= 123 && c <= 126);              }              else              {                  var category = System.Globalization.CharUnicodeInfo.GetUnicodeCategory(c);                  space = category == System.Globalization.UnicodeCategory.SpaceSeparator                      || category == System.Globalization.UnicodeCategory.LineSeparator                      || category == System.Globalization.UnicodeCategory.ParagraphSeparator;                  punctuation = !space &&                      (category == System.Globalization.UnicodeCategory.ConnectorPunctuation                      || category == System.Globalization.UnicodeCategory.DashPunctuation                      || category == System.Globalization.UnicodeCategory.OpenPunctuation                      || category == System.Globalization.UnicodeCategory.ClosePunctuation                      || category == System.Globalization.UnicodeCategory.InitialQuotePunctuation                      || category == System.Globalization.UnicodeCategory.FinalQuotePunctuation                      || category == System.Globalization.UnicodeCategory.OtherPunctuation);              }
Magic Number,CommonMark,Utilities,C:\repos\Knagis_CommonMark.NET\CommonMark\Utilities.cs,CheckUnicodeCategory,The following statement contains a magic number: if (c <= 'ÿ')              {                  space = c == ' ' || (c >= '\t' && c <= '\r') || c == '\u00a0' || c == '\u0085';                  punctuation = (c >= 33 && c <= 47) || (c >= 58 && c <= 64) || (c >= 91 && c <= 96) || (c >= 123 && c <= 126);              }              else              {                  var category = System.Globalization.CharUnicodeInfo.GetUnicodeCategory(c);                  space = category == System.Globalization.UnicodeCategory.SpaceSeparator                      || category == System.Globalization.UnicodeCategory.LineSeparator                      || category == System.Globalization.UnicodeCategory.ParagraphSeparator;                  punctuation = !space &&                      (category == System.Globalization.UnicodeCategory.ConnectorPunctuation                      || category == System.Globalization.UnicodeCategory.DashPunctuation                      || category == System.Globalization.UnicodeCategory.OpenPunctuation                      || category == System.Globalization.UnicodeCategory.ClosePunctuation                      || category == System.Globalization.UnicodeCategory.InitialQuotePunctuation                      || category == System.Globalization.UnicodeCategory.FinalQuotePunctuation                      || category == System.Globalization.UnicodeCategory.OtherPunctuation);              }
Magic Number,CommonMark,Utilities,C:\repos\Knagis_CommonMark.NET\CommonMark\Utilities.cs,CheckUnicodeCategory,The following statement contains a magic number: if (c <= 'ÿ')              {                  space = c == ' ' || (c >= '\t' && c <= '\r') || c == '\u00a0' || c == '\u0085';                  punctuation = (c >= 33 && c <= 47) || (c >= 58 && c <= 64) || (c >= 91 && c <= 96) || (c >= 123 && c <= 126);              }              else              {                  var category = System.Globalization.CharUnicodeInfo.GetUnicodeCategory(c);                  space = category == System.Globalization.UnicodeCategory.SpaceSeparator                      || category == System.Globalization.UnicodeCategory.LineSeparator                      || category == System.Globalization.UnicodeCategory.ParagraphSeparator;                  punctuation = !space &&                      (category == System.Globalization.UnicodeCategory.ConnectorPunctuation                      || category == System.Globalization.UnicodeCategory.DashPunctuation                      || category == System.Globalization.UnicodeCategory.OpenPunctuation                      || category == System.Globalization.UnicodeCategory.ClosePunctuation                      || category == System.Globalization.UnicodeCategory.InitialQuotePunctuation                      || category == System.Globalization.UnicodeCategory.FinalQuotePunctuation                      || category == System.Globalization.UnicodeCategory.OtherPunctuation);              }
Magic Number,CommonMark,Utilities,C:\repos\Knagis_CommonMark.NET\CommonMark\Utilities.cs,CheckUnicodeCategory,The following statement contains a magic number: if (c <= 'ÿ')              {                  space = c == ' ' || (c >= '\t' && c <= '\r') || c == '\u00a0' || c == '\u0085';                  punctuation = (c >= 33 && c <= 47) || (c >= 58 && c <= 64) || (c >= 91 && c <= 96) || (c >= 123 && c <= 126);              }              else              {                  var category = System.Globalization.CharUnicodeInfo.GetUnicodeCategory(c);                  space = category == System.Globalization.UnicodeCategory.SpaceSeparator                      || category == System.Globalization.UnicodeCategory.LineSeparator                      || category == System.Globalization.UnicodeCategory.ParagraphSeparator;                  punctuation = !space &&                      (category == System.Globalization.UnicodeCategory.ConnectorPunctuation                      || category == System.Globalization.UnicodeCategory.DashPunctuation                      || category == System.Globalization.UnicodeCategory.OpenPunctuation                      || category == System.Globalization.UnicodeCategory.ClosePunctuation                      || category == System.Globalization.UnicodeCategory.InitialQuotePunctuation                      || category == System.Globalization.UnicodeCategory.FinalQuotePunctuation                      || category == System.Globalization.UnicodeCategory.OtherPunctuation);              }
Magic Number,CommonMark,Utilities,C:\repos\Knagis_CommonMark.NET\CommonMark\Utilities.cs,CheckUnicodeCategory,The following statement contains a magic number: if (c <= 'ÿ')              {                  space = c == ' ' || (c >= '\t' && c <= '\r') || c == '\u00a0' || c == '\u0085';                  punctuation = (c >= 33 && c <= 47) || (c >= 58 && c <= 64) || (c >= 91 && c <= 96) || (c >= 123 && c <= 126);              }              else              {                  var category = System.Globalization.CharUnicodeInfo.GetUnicodeCategory(c);                  space = category == System.Globalization.UnicodeCategory.SpaceSeparator                      || category == System.Globalization.UnicodeCategory.LineSeparator                      || category == System.Globalization.UnicodeCategory.ParagraphSeparator;                  punctuation = !space &&                      (category == System.Globalization.UnicodeCategory.ConnectorPunctuation                      || category == System.Globalization.UnicodeCategory.DashPunctuation                      || category == System.Globalization.UnicodeCategory.OpenPunctuation                      || category == System.Globalization.UnicodeCategory.ClosePunctuation                      || category == System.Globalization.UnicodeCategory.InitialQuotePunctuation                      || category == System.Globalization.UnicodeCategory.FinalQuotePunctuation                      || category == System.Globalization.UnicodeCategory.OtherPunctuation);              }
Magic Number,CommonMark,Utilities,C:\repos\Knagis_CommonMark.NET\CommonMark\Utilities.cs,CheckUnicodeCategory,The following statement contains a magic number: if (c <= 'ÿ')              {                  space = c == ' ' || (c >= '\t' && c <= '\r') || c == '\u00a0' || c == '\u0085';                  punctuation = (c >= 33 && c <= 47) || (c >= 58 && c <= 64) || (c >= 91 && c <= 96) || (c >= 123 && c <= 126);              }              else              {                  var category = System.Globalization.CharUnicodeInfo.GetUnicodeCategory(c);                  space = category == System.Globalization.UnicodeCategory.SpaceSeparator                      || category == System.Globalization.UnicodeCategory.LineSeparator                      || category == System.Globalization.UnicodeCategory.ParagraphSeparator;                  punctuation = !space &&                      (category == System.Globalization.UnicodeCategory.ConnectorPunctuation                      || category == System.Globalization.UnicodeCategory.DashPunctuation                      || category == System.Globalization.UnicodeCategory.OpenPunctuation                      || category == System.Globalization.UnicodeCategory.ClosePunctuation                      || category == System.Globalization.UnicodeCategory.InitialQuotePunctuation                      || category == System.Globalization.UnicodeCategory.FinalQuotePunctuation                      || category == System.Globalization.UnicodeCategory.OtherPunctuation);              }
Magic Number,CommonMark,Utilities,C:\repos\Knagis_CommonMark.NET\CommonMark\Utilities.cs,CheckUnicodeCategory,The following statement contains a magic number: if (c <= 'ÿ')              {                  space = c == ' ' || (c >= '\t' && c <= '\r') || c == '\u00a0' || c == '\u0085';                  punctuation = (c >= 33 && c <= 47) || (c >= 58 && c <= 64) || (c >= 91 && c <= 96) || (c >= 123 && c <= 126);              }              else              {                  var category = System.Globalization.CharUnicodeInfo.GetUnicodeCategory(c);                  space = category == System.Globalization.UnicodeCategory.SpaceSeparator                      || category == System.Globalization.UnicodeCategory.LineSeparator                      || category == System.Globalization.UnicodeCategory.ParagraphSeparator;                  punctuation = !space &&                      (category == System.Globalization.UnicodeCategory.ConnectorPunctuation                      || category == System.Globalization.UnicodeCategory.DashPunctuation                      || category == System.Globalization.UnicodeCategory.OpenPunctuation                      || category == System.Globalization.UnicodeCategory.ClosePunctuation                      || category == System.Globalization.UnicodeCategory.InitialQuotePunctuation                      || category == System.Globalization.UnicodeCategory.FinalQuotePunctuation                      || category == System.Globalization.UnicodeCategory.OtherPunctuation);              }
Magic Number,CommonMark,Utilities,C:\repos\Knagis_CommonMark.NET\CommonMark\Utilities.cs,CheckUnicodeCategory,The following statement contains a magic number: if (c <= 'ÿ')              {                  space = c == ' ' || (c >= '\t' && c <= '\r') || c == '\u00a0' || c == '\u0085';                  punctuation = (c >= 33 && c <= 47) || (c >= 58 && c <= 64) || (c >= 91 && c <= 96) || (c >= 123 && c <= 126);              }              else              {                  var category = System.Globalization.CharUnicodeInfo.GetUnicodeCategory(c);                  space = category == System.Globalization.UnicodeCategory.SpaceSeparator                      || category == System.Globalization.UnicodeCategory.LineSeparator                      || category == System.Globalization.UnicodeCategory.ParagraphSeparator;                  punctuation = !space &&                      (category == System.Globalization.UnicodeCategory.ConnectorPunctuation                      || category == System.Globalization.UnicodeCategory.DashPunctuation                      || category == System.Globalization.UnicodeCategory.OpenPunctuation                      || category == System.Globalization.UnicodeCategory.ClosePunctuation                      || category == System.Globalization.UnicodeCategory.InitialQuotePunctuation                      || category == System.Globalization.UnicodeCategory.FinalQuotePunctuation                      || category == System.Globalization.UnicodeCategory.OtherPunctuation);              }
Magic Number,CommonMark.Formatters,HtmlFormatterSlim,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\HtmlFormatterSlim.cs,EscapeUrl,The following statement contains a magic number: for (var pos = 0; pos < len; pos++)              {                  c = buffer[pos];                    if (c == '&')                  {                      target.WriteConstant(buffer' lastPos' pos - lastPos);                      lastPos = pos + 1;                      target.WriteConstant(EscapeHtmlAmpersand);                  }                  else if (c < 128 && !UrlSafeCharacters[c])                  {                      target.WriteConstant(buffer' lastPos' pos - lastPos);                      lastPos = pos + 1;                        target.WriteConstant(new[] { '%'' HexCharacters[c / 16]' HexCharacters[c % 16] });                  }                  else if (c > 127)                  {                      target.WriteConstant(buffer' lastPos' pos - lastPos);                      lastPos = pos + 1;                        byte[] bytes;                      if (c >= '\ud800' && c <= '\udfff' && len != lastPos)                      {                          // this char is the first of UTF-32 character pair                          bytes = Encoding.UTF8.GetBytes(new[] { c' buffer[lastPos] });                          lastPos = ++pos + 1;                      }                      else                      {                          bytes = Encoding.UTF8.GetBytes(new[] { c });                      }                        for (var i = 0; i < bytes.Length; i++)                          target.WriteConstant(new[] { '%'' HexCharacters[bytes[i] / 16]' HexCharacters[bytes[i] % 16] });                  }              }
Magic Number,CommonMark.Formatters,HtmlFormatterSlim,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\HtmlFormatterSlim.cs,EscapeUrl,The following statement contains a magic number: for (var pos = 0; pos < len; pos++)              {                  c = buffer[pos];                    if (c == '&')                  {                      target.WriteConstant(buffer' lastPos' pos - lastPos);                      lastPos = pos + 1;                      target.WriteConstant(EscapeHtmlAmpersand);                  }                  else if (c < 128 && !UrlSafeCharacters[c])                  {                      target.WriteConstant(buffer' lastPos' pos - lastPos);                      lastPos = pos + 1;                        target.WriteConstant(new[] { '%'' HexCharacters[c / 16]' HexCharacters[c % 16] });                  }                  else if (c > 127)                  {                      target.WriteConstant(buffer' lastPos' pos - lastPos);                      lastPos = pos + 1;                        byte[] bytes;                      if (c >= '\ud800' && c <= '\udfff' && len != lastPos)                      {                          // this char is the first of UTF-32 character pair                          bytes = Encoding.UTF8.GetBytes(new[] { c' buffer[lastPos] });                          lastPos = ++pos + 1;                      }                      else                      {                          bytes = Encoding.UTF8.GetBytes(new[] { c });                      }                        for (var i = 0; i < bytes.Length; i++)                          target.WriteConstant(new[] { '%'' HexCharacters[bytes[i] / 16]' HexCharacters[bytes[i] % 16] });                  }              }
Magic Number,CommonMark.Formatters,HtmlFormatterSlim,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\HtmlFormatterSlim.cs,EscapeUrl,The following statement contains a magic number: for (var pos = 0; pos < len; pos++)              {                  c = buffer[pos];                    if (c == '&')                  {                      target.WriteConstant(buffer' lastPos' pos - lastPos);                      lastPos = pos + 1;                      target.WriteConstant(EscapeHtmlAmpersand);                  }                  else if (c < 128 && !UrlSafeCharacters[c])                  {                      target.WriteConstant(buffer' lastPos' pos - lastPos);                      lastPos = pos + 1;                        target.WriteConstant(new[] { '%'' HexCharacters[c / 16]' HexCharacters[c % 16] });                  }                  else if (c > 127)                  {                      target.WriteConstant(buffer' lastPos' pos - lastPos);                      lastPos = pos + 1;                        byte[] bytes;                      if (c >= '\ud800' && c <= '\udfff' && len != lastPos)                      {                          // this char is the first of UTF-32 character pair                          bytes = Encoding.UTF8.GetBytes(new[] { c' buffer[lastPos] });                          lastPos = ++pos + 1;                      }                      else                      {                          bytes = Encoding.UTF8.GetBytes(new[] { c });                      }                        for (var i = 0; i < bytes.Length; i++)                          target.WriteConstant(new[] { '%'' HexCharacters[bytes[i] / 16]' HexCharacters[bytes[i] % 16] });                  }              }
Magic Number,CommonMark.Formatters,HtmlFormatterSlim,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\HtmlFormatterSlim.cs,EscapeUrl,The following statement contains a magic number: for (var pos = 0; pos < len; pos++)              {                  c = buffer[pos];                    if (c == '&')                  {                      target.WriteConstant(buffer' lastPos' pos - lastPos);                      lastPos = pos + 1;                      target.WriteConstant(EscapeHtmlAmpersand);                  }                  else if (c < 128 && !UrlSafeCharacters[c])                  {                      target.WriteConstant(buffer' lastPos' pos - lastPos);                      lastPos = pos + 1;                        target.WriteConstant(new[] { '%'' HexCharacters[c / 16]' HexCharacters[c % 16] });                  }                  else if (c > 127)                  {                      target.WriteConstant(buffer' lastPos' pos - lastPos);                      lastPos = pos + 1;                        byte[] bytes;                      if (c >= '\ud800' && c <= '\udfff' && len != lastPos)                      {                          // this char is the first of UTF-32 character pair                          bytes = Encoding.UTF8.GetBytes(new[] { c' buffer[lastPos] });                          lastPos = ++pos + 1;                      }                      else                      {                          bytes = Encoding.UTF8.GetBytes(new[] { c });                      }                        for (var i = 0; i < bytes.Length; i++)                          target.WriteConstant(new[] { '%'' HexCharacters[bytes[i] / 16]' HexCharacters[bytes[i] % 16] });                  }              }
Magic Number,CommonMark.Formatters,HtmlFormatterSlim,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\HtmlFormatterSlim.cs,EscapeUrl,The following statement contains a magic number: for (var pos = 0; pos < len; pos++)              {                  c = buffer[pos];                    if (c == '&')                  {                      target.WriteConstant(buffer' lastPos' pos - lastPos);                      lastPos = pos + 1;                      target.WriteConstant(EscapeHtmlAmpersand);                  }                  else if (c < 128 && !UrlSafeCharacters[c])                  {                      target.WriteConstant(buffer' lastPos' pos - lastPos);                      lastPos = pos + 1;                        target.WriteConstant(new[] { '%'' HexCharacters[c / 16]' HexCharacters[c % 16] });                  }                  else if (c > 127)                  {                      target.WriteConstant(buffer' lastPos' pos - lastPos);                      lastPos = pos + 1;                        byte[] bytes;                      if (c >= '\ud800' && c <= '\udfff' && len != lastPos)                      {                          // this char is the first of UTF-32 character pair                          bytes = Encoding.UTF8.GetBytes(new[] { c' buffer[lastPos] });                          lastPos = ++pos + 1;                      }                      else                      {                          bytes = Encoding.UTF8.GetBytes(new[] { c });                      }                        for (var i = 0; i < bytes.Length; i++)                          target.WriteConstant(new[] { '%'' HexCharacters[bytes[i] / 16]' HexCharacters[bytes[i] % 16] });                  }              }
Magic Number,CommonMark.Formatters,HtmlFormatterSlim,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\HtmlFormatterSlim.cs,EscapeUrl,The following statement contains a magic number: for (var pos = 0; pos < len; pos++)              {                  c = buffer[pos];                    if (c == '&')                  {                      target.WriteConstant(buffer' lastPos' pos - lastPos);                      lastPos = pos + 1;                      target.WriteConstant(EscapeHtmlAmpersand);                  }                  else if (c < 128 && !UrlSafeCharacters[c])                  {                      target.WriteConstant(buffer' lastPos' pos - lastPos);                      lastPos = pos + 1;                        target.WriteConstant(new[] { '%'' HexCharacters[c / 16]' HexCharacters[c % 16] });                  }                  else if (c > 127)                  {                      target.WriteConstant(buffer' lastPos' pos - lastPos);                      lastPos = pos + 1;                        byte[] bytes;                      if (c >= '\ud800' && c <= '\udfff' && len != lastPos)                      {                          // this char is the first of UTF-32 character pair                          bytes = Encoding.UTF8.GetBytes(new[] { c' buffer[lastPos] });                          lastPos = ++pos + 1;                      }                      else                      {                          bytes = Encoding.UTF8.GetBytes(new[] { c });                      }                        for (var i = 0; i < bytes.Length; i++)                          target.WriteConstant(new[] { '%'' HexCharacters[bytes[i] / 16]' HexCharacters[bytes[i] % 16] });                  }              }
Magic Number,CommonMark.Formatters,HtmlFormatterSlim,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\HtmlFormatterSlim.cs,BlocksToHtmlInner,The following statement contains a magic number: while (block != null)              {                  visitChildren = false;                    switch (block.Tag)                  {                      case BlockTag.Document:                          stackLiteral = null;                          stackTight = false;                          visitChildren = true;                          break;                        case BlockTag.Paragraph:                          if (tight)                          {                              InlinesToHtml(writer' block.InlineContent' settings' inlineStack);                          }                          else                          {                              writer.EnsureLine();                              writer.WriteConstant("<p");                              if (trackPositions) PrintPosition(writer' block);                              writer.Write('>');                              InlinesToHtml(writer' block.InlineContent' settings' inlineStack);                              writer.WriteLineConstant("</p>");                          }                          break;                        case BlockTag.BlockQuote:                          writer.EnsureLine();                          writer.WriteConstant("<blockquote");                          if (trackPositions) PrintPosition(writer' block);                          writer.WriteLine('>');                            stackLiteral = "</blockquote>";                          stackTight = false;                          visitChildren = true;                          break;                        case BlockTag.ListItem:                          writer.EnsureLine();                          writer.WriteConstant("<li");                          if (trackPositions) PrintPosition(writer' block);                          writer.Write('>');                            stackLiteral = "</li>";                          stackTight = tight;                          visitChildren = true;                          break;                        case BlockTag.List:                          // make sure a list starts at the beginning of the line:                          writer.EnsureLine();                          var data = block.ListData;                          writer.WriteConstant(data.ListType == ListType.Bullet ? "<ul" : "<ol");                          if (data.Start != 1)                          {                              writer.WriteConstant(" start=\"");                              writer.WriteConstant(data.Start.ToString(CultureInfo.InvariantCulture));                              writer.Write('\"');                          }                          if (trackPositions) PrintPosition(writer' block);                          writer.WriteLine('>');                            stackLiteral = data.ListType == ListType.Bullet ? "</ul>" : "</ol>";                          stackTight = data.IsTight;                          visitChildren = true;                          break;                        case BlockTag.AtxHeading:                      case BlockTag.SetextHeading:                          writer.EnsureLine();                            x = block.Heading.Level;                            if (trackPositions)                          {                              writer.WriteConstant("<h" + x.ToString(CultureInfo.InvariantCulture));                              PrintPosition(writer' block);                              writer.Write('>');                              InlinesToHtml(writer' block.InlineContent' settings' inlineStack);                              writer.WriteLineConstant(x > 0 && x < 7 ? HeadingCloserTags[x - 1] : "</h" + x.ToString(CultureInfo.InvariantCulture) + ">");                          }                          else                          {                              writer.WriteConstant(x > 0 && x < 7 ? HeadingOpenerTags[x - 1] : "<h" + x.ToString(CultureInfo.InvariantCulture) + ">");                              InlinesToHtml(writer' block.InlineContent' settings' inlineStack);                              writer.WriteLineConstant(x > 0 && x < 7 ? HeadingCloserTags[x - 1] : "</h" + x.ToString(CultureInfo.InvariantCulture) + ">");                          }                            break;                        case BlockTag.IndentedCode:                      case BlockTag.FencedCode:                          writer.EnsureLine();                          writer.WriteConstant("<pre><code");                          if (trackPositions) PrintPosition(writer' block);                            var info = block.FencedCodeData == null ? null : block.FencedCodeData.Info;                          if (info != null && info.Length > 0)                          {                              x = info.IndexOf(' ');                              if (x == -1)                                  x = info.Length;                                writer.WriteConstant(" class=\"language-");                              EscapeHtml(new StringPart(info' 0' x)' writer);                              writer.Write('\"');                          }                          writer.Write('>');                          EscapeHtml(block.StringContent' writer);                          writer.WriteLineConstant("</code></pre>");                          break;                        case BlockTag.HtmlBlock:                          // cannot output source position for HTML blocks                          block.StringContent.WriteTo(writer);                            break;                        case BlockTag.ThematicBreak:                          if (trackPositions)                          {                              writer.WriteConstant("<hr");                              PrintPosition(writer' block);                              writer.WriteLine();                          }                          else                          {                              writer.WriteLineConstant("<hr />");                          }                            break;                        case BlockTag.ReferenceDefinition:                          break;                        default:                          throw new CommonMarkException("Block type " + block.Tag + " is not supported."' block);                  }                    if (visitChildren)                  {                      stack.Push(new BlockStackEntry(stackLiteral' block.NextSibling' tight));                        tight = stackTight;                      block = block.FirstChild;                  }                  else if (block.NextSibling != null)                  {                      block = block.NextSibling;                  }                  else                  {                      block = null;                  }                    while (block == null && stack.Count > 0)                  {                      var entry = stack.Pop();                        if (entry.Literal != null)                          writer.WriteLineConstant(entry.Literal);                        tight = entry.IsTight;                      block = entry.Target;                  }              }
Magic Number,CommonMark.Formatters,HtmlFormatterSlim,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\HtmlFormatterSlim.cs,BlocksToHtmlInner,The following statement contains a magic number: while (block != null)              {                  visitChildren = false;                    switch (block.Tag)                  {                      case BlockTag.Document:                          stackLiteral = null;                          stackTight = false;                          visitChildren = true;                          break;                        case BlockTag.Paragraph:                          if (tight)                          {                              InlinesToHtml(writer' block.InlineContent' settings' inlineStack);                          }                          else                          {                              writer.EnsureLine();                              writer.WriteConstant("<p");                              if (trackPositions) PrintPosition(writer' block);                              writer.Write('>');                              InlinesToHtml(writer' block.InlineContent' settings' inlineStack);                              writer.WriteLineConstant("</p>");                          }                          break;                        case BlockTag.BlockQuote:                          writer.EnsureLine();                          writer.WriteConstant("<blockquote");                          if (trackPositions) PrintPosition(writer' block);                          writer.WriteLine('>');                            stackLiteral = "</blockquote>";                          stackTight = false;                          visitChildren = true;                          break;                        case BlockTag.ListItem:                          writer.EnsureLine();                          writer.WriteConstant("<li");                          if (trackPositions) PrintPosition(writer' block);                          writer.Write('>');                            stackLiteral = "</li>";                          stackTight = tight;                          visitChildren = true;                          break;                        case BlockTag.List:                          // make sure a list starts at the beginning of the line:                          writer.EnsureLine();                          var data = block.ListData;                          writer.WriteConstant(data.ListType == ListType.Bullet ? "<ul" : "<ol");                          if (data.Start != 1)                          {                              writer.WriteConstant(" start=\"");                              writer.WriteConstant(data.Start.ToString(CultureInfo.InvariantCulture));                              writer.Write('\"');                          }                          if (trackPositions) PrintPosition(writer' block);                          writer.WriteLine('>');                            stackLiteral = data.ListType == ListType.Bullet ? "</ul>" : "</ol>";                          stackTight = data.IsTight;                          visitChildren = true;                          break;                        case BlockTag.AtxHeading:                      case BlockTag.SetextHeading:                          writer.EnsureLine();                            x = block.Heading.Level;                            if (trackPositions)                          {                              writer.WriteConstant("<h" + x.ToString(CultureInfo.InvariantCulture));                              PrintPosition(writer' block);                              writer.Write('>');                              InlinesToHtml(writer' block.InlineContent' settings' inlineStack);                              writer.WriteLineConstant(x > 0 && x < 7 ? HeadingCloserTags[x - 1] : "</h" + x.ToString(CultureInfo.InvariantCulture) + ">");                          }                          else                          {                              writer.WriteConstant(x > 0 && x < 7 ? HeadingOpenerTags[x - 1] : "<h" + x.ToString(CultureInfo.InvariantCulture) + ">");                              InlinesToHtml(writer' block.InlineContent' settings' inlineStack);                              writer.WriteLineConstant(x > 0 && x < 7 ? HeadingCloserTags[x - 1] : "</h" + x.ToString(CultureInfo.InvariantCulture) + ">");                          }                            break;                        case BlockTag.IndentedCode:                      case BlockTag.FencedCode:                          writer.EnsureLine();                          writer.WriteConstant("<pre><code");                          if (trackPositions) PrintPosition(writer' block);                            var info = block.FencedCodeData == null ? null : block.FencedCodeData.Info;                          if (info != null && info.Length > 0)                          {                              x = info.IndexOf(' ');                              if (x == -1)                                  x = info.Length;                                writer.WriteConstant(" class=\"language-");                              EscapeHtml(new StringPart(info' 0' x)' writer);                              writer.Write('\"');                          }                          writer.Write('>');                          EscapeHtml(block.StringContent' writer);                          writer.WriteLineConstant("</code></pre>");                          break;                        case BlockTag.HtmlBlock:                          // cannot output source position for HTML blocks                          block.StringContent.WriteTo(writer);                            break;                        case BlockTag.ThematicBreak:                          if (trackPositions)                          {                              writer.WriteConstant("<hr");                              PrintPosition(writer' block);                              writer.WriteLine();                          }                          else                          {                              writer.WriteLineConstant("<hr />");                          }                            break;                        case BlockTag.ReferenceDefinition:                          break;                        default:                          throw new CommonMarkException("Block type " + block.Tag + " is not supported."' block);                  }                    if (visitChildren)                  {                      stack.Push(new BlockStackEntry(stackLiteral' block.NextSibling' tight));                        tight = stackTight;                      block = block.FirstChild;                  }                  else if (block.NextSibling != null)                  {                      block = block.NextSibling;                  }                  else                  {                      block = null;                  }                    while (block == null && stack.Count > 0)                  {                      var entry = stack.Pop();                        if (entry.Literal != null)                          writer.WriteLineConstant(entry.Literal);                        tight = entry.IsTight;                      block = entry.Target;                  }              }
Magic Number,CommonMark.Formatters,HtmlFormatterSlim,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\HtmlFormatterSlim.cs,BlocksToHtmlInner,The following statement contains a magic number: while (block != null)              {                  visitChildren = false;                    switch (block.Tag)                  {                      case BlockTag.Document:                          stackLiteral = null;                          stackTight = false;                          visitChildren = true;                          break;                        case BlockTag.Paragraph:                          if (tight)                          {                              InlinesToHtml(writer' block.InlineContent' settings' inlineStack);                          }                          else                          {                              writer.EnsureLine();                              writer.WriteConstant("<p");                              if (trackPositions) PrintPosition(writer' block);                              writer.Write('>');                              InlinesToHtml(writer' block.InlineContent' settings' inlineStack);                              writer.WriteLineConstant("</p>");                          }                          break;                        case BlockTag.BlockQuote:                          writer.EnsureLine();                          writer.WriteConstant("<blockquote");                          if (trackPositions) PrintPosition(writer' block);                          writer.WriteLine('>');                            stackLiteral = "</blockquote>";                          stackTight = false;                          visitChildren = true;                          break;                        case BlockTag.ListItem:                          writer.EnsureLine();                          writer.WriteConstant("<li");                          if (trackPositions) PrintPosition(writer' block);                          writer.Write('>');                            stackLiteral = "</li>";                          stackTight = tight;                          visitChildren = true;                          break;                        case BlockTag.List:                          // make sure a list starts at the beginning of the line:                          writer.EnsureLine();                          var data = block.ListData;                          writer.WriteConstant(data.ListType == ListType.Bullet ? "<ul" : "<ol");                          if (data.Start != 1)                          {                              writer.WriteConstant(" start=\"");                              writer.WriteConstant(data.Start.ToString(CultureInfo.InvariantCulture));                              writer.Write('\"');                          }                          if (trackPositions) PrintPosition(writer' block);                          writer.WriteLine('>');                            stackLiteral = data.ListType == ListType.Bullet ? "</ul>" : "</ol>";                          stackTight = data.IsTight;                          visitChildren = true;                          break;                        case BlockTag.AtxHeading:                      case BlockTag.SetextHeading:                          writer.EnsureLine();                            x = block.Heading.Level;                            if (trackPositions)                          {                              writer.WriteConstant("<h" + x.ToString(CultureInfo.InvariantCulture));                              PrintPosition(writer' block);                              writer.Write('>');                              InlinesToHtml(writer' block.InlineContent' settings' inlineStack);                              writer.WriteLineConstant(x > 0 && x < 7 ? HeadingCloserTags[x - 1] : "</h" + x.ToString(CultureInfo.InvariantCulture) + ">");                          }                          else                          {                              writer.WriteConstant(x > 0 && x < 7 ? HeadingOpenerTags[x - 1] : "<h" + x.ToString(CultureInfo.InvariantCulture) + ">");                              InlinesToHtml(writer' block.InlineContent' settings' inlineStack);                              writer.WriteLineConstant(x > 0 && x < 7 ? HeadingCloserTags[x - 1] : "</h" + x.ToString(CultureInfo.InvariantCulture) + ">");                          }                            break;                        case BlockTag.IndentedCode:                      case BlockTag.FencedCode:                          writer.EnsureLine();                          writer.WriteConstant("<pre><code");                          if (trackPositions) PrintPosition(writer' block);                            var info = block.FencedCodeData == null ? null : block.FencedCodeData.Info;                          if (info != null && info.Length > 0)                          {                              x = info.IndexOf(' ');                              if (x == -1)                                  x = info.Length;                                writer.WriteConstant(" class=\"language-");                              EscapeHtml(new StringPart(info' 0' x)' writer);                              writer.Write('\"');                          }                          writer.Write('>');                          EscapeHtml(block.StringContent' writer);                          writer.WriteLineConstant("</code></pre>");                          break;                        case BlockTag.HtmlBlock:                          // cannot output source position for HTML blocks                          block.StringContent.WriteTo(writer);                            break;                        case BlockTag.ThematicBreak:                          if (trackPositions)                          {                              writer.WriteConstant("<hr");                              PrintPosition(writer' block);                              writer.WriteLine();                          }                          else                          {                              writer.WriteLineConstant("<hr />");                          }                            break;                        case BlockTag.ReferenceDefinition:                          break;                        default:                          throw new CommonMarkException("Block type " + block.Tag + " is not supported."' block);                  }                    if (visitChildren)                  {                      stack.Push(new BlockStackEntry(stackLiteral' block.NextSibling' tight));                        tight = stackTight;                      block = block.FirstChild;                  }                  else if (block.NextSibling != null)                  {                      block = block.NextSibling;                  }                  else                  {                      block = null;                  }                    while (block == null && stack.Count > 0)                  {                      var entry = stack.Pop();                        if (entry.Literal != null)                          writer.WriteLineConstant(entry.Literal);                        tight = entry.IsTight;                      block = entry.Target;                  }              }
Magic Number,CommonMark.Formatters,Printer,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\Printer.cs,PrintBlocks,The following statement contains a magic number: while (block != null)              {                  writer.Write(new string(' '' indent));                    switch (block.Tag)                  {                      case BlockTag.Document:                          writer.Write("document");                          PrintPosition(trackPositions' writer' block);                          break;                        case BlockTag.BlockQuote:                          writer.Write("block_quote");                          PrintPosition(trackPositions' writer' block);                          break;                        case BlockTag.ListItem:                          writer.Write("list_item");                          PrintPosition(trackPositions' writer' block);                          break;                        case BlockTag.List:                          writer.Write("list");                          PrintPosition(trackPositions' writer' block);                            var data = block.ListData;                          if (data.ListType == ListType.Ordered)                          {                              writer.Write(" (type=ordered tight={0} start={1} delim={2})"'                                   data.IsTight'                                   data.Start'                                   data.Delimiter);                          }                          else                          {                              writer.Write("(type=bullet tight={0} bullet_char={1})"'                                   data.IsTight'                                   data.BulletChar);                          }                          break;                        case BlockTag.AtxHeading:                          writer.Write("atx_heading");                          PrintPosition(trackPositions' writer' block);                          writer.Write(" (level={0})"' block.Heading.Level);                          break;                        case BlockTag.SetextHeading:                          writer.Write("setext_heading");                          PrintPosition(trackPositions' writer' block);                          writer.Write(" (level={0})"' block.Heading.Level);                          break;                        case BlockTag.Paragraph:                          writer.Write("paragraph");                          PrintPosition(trackPositions' writer' block);                          break;                        case BlockTag.ThematicBreak:                          writer.Write("thematic_break");                          PrintPosition(trackPositions' writer' block);                          break;                        case BlockTag.IndentedCode:                          writer.Write("indented_code {0}"' format_str(block.StringContent.ToString(buffer)' buffer));                          PrintPosition(trackPositions' writer' block);                          writer.Write(' ');                          writer.Write(format_str(block.StringContent.ToString(buffer)' buffer));                          break;                        case BlockTag.FencedCode:                          writer.Write("fenced_code");                          PrintPosition(trackPositions' writer' block);                          writer.Write(" length={0} info={1} {2}"'                                 block.FencedCodeData.FenceLength'                                 format_str(block.FencedCodeData.Info' buffer)'                                 format_str(block.StringContent.ToString(buffer)' buffer));                          break;                        case BlockTag.HtmlBlock:                          writer.Write("html_block");                          PrintPosition(trackPositions' writer' block);                          writer.Write(' ');                          writer.Write(format_str(block.StringContent.ToString(buffer)' buffer));                          break;                        case BlockTag.ReferenceDefinition:                          writer.Write("reference_def");                          PrintPosition(trackPositions' writer' block);                          break;                        default:                          throw new CommonMarkException("Block type " + block.Tag + " is not supported."' block);                  }                    writer.WriteLine();                    if (block.InlineContent != null)                  {                      PrintInlines(writer' block.InlineContent' indent + 2' inlineStack' buffer' trackPositions);                  }                    if (block.FirstChild != null)                  {                      if (block.NextSibling != null)                          stack.Push(new BlockStackEntry(indent' block.NextSibling));                        indent += 2;                      block = block.FirstChild;                  }                  else if (block.NextSibling != null)                  {                      block = block.NextSibling;                  }                  else if (stack.Count > 0)                  {                      var entry = stack.Pop();                      indent = entry.Indent;                      block = entry.Target;                  }                  else                  {                      block = null;                  }              }
Magic Number,CommonMark.Formatters,Printer,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\Printer.cs,PrintBlocks,The following statement contains a magic number: while (block != null)              {                  writer.Write(new string(' '' indent));                    switch (block.Tag)                  {                      case BlockTag.Document:                          writer.Write("document");                          PrintPosition(trackPositions' writer' block);                          break;                        case BlockTag.BlockQuote:                          writer.Write("block_quote");                          PrintPosition(trackPositions' writer' block);                          break;                        case BlockTag.ListItem:                          writer.Write("list_item");                          PrintPosition(trackPositions' writer' block);                          break;                        case BlockTag.List:                          writer.Write("list");                          PrintPosition(trackPositions' writer' block);                            var data = block.ListData;                          if (data.ListType == ListType.Ordered)                          {                              writer.Write(" (type=ordered tight={0} start={1} delim={2})"'                                   data.IsTight'                                   data.Start'                                   data.Delimiter);                          }                          else                          {                              writer.Write("(type=bullet tight={0} bullet_char={1})"'                                   data.IsTight'                                   data.BulletChar);                          }                          break;                        case BlockTag.AtxHeading:                          writer.Write("atx_heading");                          PrintPosition(trackPositions' writer' block);                          writer.Write(" (level={0})"' block.Heading.Level);                          break;                        case BlockTag.SetextHeading:                          writer.Write("setext_heading");                          PrintPosition(trackPositions' writer' block);                          writer.Write(" (level={0})"' block.Heading.Level);                          break;                        case BlockTag.Paragraph:                          writer.Write("paragraph");                          PrintPosition(trackPositions' writer' block);                          break;                        case BlockTag.ThematicBreak:                          writer.Write("thematic_break");                          PrintPosition(trackPositions' writer' block);                          break;                        case BlockTag.IndentedCode:                          writer.Write("indented_code {0}"' format_str(block.StringContent.ToString(buffer)' buffer));                          PrintPosition(trackPositions' writer' block);                          writer.Write(' ');                          writer.Write(format_str(block.StringContent.ToString(buffer)' buffer));                          break;                        case BlockTag.FencedCode:                          writer.Write("fenced_code");                          PrintPosition(trackPositions' writer' block);                          writer.Write(" length={0} info={1} {2}"'                                 block.FencedCodeData.FenceLength'                                 format_str(block.FencedCodeData.Info' buffer)'                                 format_str(block.StringContent.ToString(buffer)' buffer));                          break;                        case BlockTag.HtmlBlock:                          writer.Write("html_block");                          PrintPosition(trackPositions' writer' block);                          writer.Write(' ');                          writer.Write(format_str(block.StringContent.ToString(buffer)' buffer));                          break;                        case BlockTag.ReferenceDefinition:                          writer.Write("reference_def");                          PrintPosition(trackPositions' writer' block);                          break;                        default:                          throw new CommonMarkException("Block type " + block.Tag + " is not supported."' block);                  }                    writer.WriteLine();                    if (block.InlineContent != null)                  {                      PrintInlines(writer' block.InlineContent' indent + 2' inlineStack' buffer' trackPositions);                  }                    if (block.FirstChild != null)                  {                      if (block.NextSibling != null)                          stack.Push(new BlockStackEntry(indent' block.NextSibling));                        indent += 2;                      block = block.FirstChild;                  }                  else if (block.NextSibling != null)                  {                      block = block.NextSibling;                  }                  else if (stack.Count > 0)                  {                      var entry = stack.Pop();                      indent = entry.Indent;                      block = entry.Target;                  }                  else                  {                      block = null;                  }              }
Magic Number,CommonMark.Formatters,Printer,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\Printer.cs,PrintInlines,The following statement contains a magic number: while (inline != null)              {                  writer.Write(new string(' '' indent));                    switch (inline.Tag)                  {                      case InlineTag.String:                          writer.Write("str");                          PrintPosition(trackPositions' writer' inline);                          writer.Write(' ');                          writer.Write(format_str(inline.LiteralContent' buffer));                          break;                        case InlineTag.LineBreak:                          writer.Write("linebreak");                          PrintPosition(trackPositions' writer' inline);                          break;                        case InlineTag.SoftBreak:                          writer.Write("softbreak");                          PrintPosition(trackPositions' writer' inline);                          break;                        case InlineTag.Code:                          writer.Write("code {0}"' format_str(inline.LiteralContent' buffer));                          PrintPosition(trackPositions' writer' inline);                          writer.Write(' ');                          writer.Write(format_str(inline.LiteralContent' buffer));                          break;                        case InlineTag.RawHtml:                          writer.Write("html_inline {0}"' format_str(inline.LiteralContent' buffer));                          writer.Write(' ');                          writer.Write(format_str(inline.LiteralContent' buffer));                          break;                        case InlineTag.Link:                          writer.Write("link");                          PrintPosition(trackPositions' writer' inline);                          writer.Write(" url={0} title={1}"'                                 format_str(inline.TargetUrl' buffer)'                                 format_str(inline.LiteralContent' buffer));                          break;                        case InlineTag.Placeholder:                          writer.Write("placeholder");                          PrintPosition(trackPositions' writer' inline);                          writer.Write(" url={0}"'                                 format_str(inline.TargetUrl' buffer));                          break;                        case InlineTag.Image:                          writer.Write("image");                          PrintPosition(trackPositions' writer' inline);                          writer.Write(" url={0} title={1}"'                                 format_str(inline.TargetUrl' buffer)'                                 format_str(inline.LiteralContent' buffer));                          break;                        case InlineTag.Strong:                          writer.Write("strong");                          PrintPosition(trackPositions' writer' inline);                          break;                        case InlineTag.Emphasis:                          writer.Write("emph");                          PrintPosition(trackPositions' writer' inline);                          break;                        case InlineTag.Strikethrough:                          writer.Write("del");                          PrintPosition(trackPositions' writer' inline);                          break;                        default:                          writer.Write("unknown: " + inline.Tag.ToString());                          PrintPosition(trackPositions' writer' inline);                          break;                  }                    writer.WriteLine();                    if (inline.FirstChild != null)                  {                      if (inline.NextSibling != null)                          stack.Push(new InlineStackEntry(indent' inline.NextSibling));                        indent += 2;                      inline = inline.FirstChild;                  }                  else if (inline.NextSibling != null)                  {                      inline = inline.NextSibling;                  }                  else if (stack.Count > 0)                  {                      var entry = stack.Pop();                      indent = entry.Indent;                      inline = entry.Target;                  }                  else                  {                      inline = null;                  }              }
Magic Number,CommonMark.Parser,EntityDecoder,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\EntityDecoder.cs,DecodeEntity,The following statement contains a magic number: if (utf32 < 0 || utf32 > 1114111 || (utf32 >= 55296 && utf32 <= 57343))                  return null;
Magic Number,CommonMark.Parser,EntityDecoder,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\EntityDecoder.cs,DecodeEntity,The following statement contains a magic number: if (utf32 < 0 || utf32 > 1114111 || (utf32 >= 55296 && utf32 <= 57343))                  return null;
Magic Number,CommonMark.Parser,EntityDecoder,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\EntityDecoder.cs,DecodeEntity,The following statement contains a magic number: if (utf32 < 0 || utf32 > 1114111 || (utf32 >= 55296 && utf32 <= 57343))                  return null;
Magic Number,CommonMark.Parser,EntityDecoder,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\EntityDecoder.cs,DecodeEntity,The following statement contains a magic number: if (utf32 < 65536)                  return char.ToString((char)utf32);
Magic Number,CommonMark.Parser,EntityDecoder,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\EntityDecoder.cs,DecodeEntity,The following statement contains a magic number: utf32 -= 65536;
Magic Number,CommonMark.Parser,EntityDecoder,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\EntityDecoder.cs,DecodeEntity,The following statement contains a magic number: return new string(new char[]              {                  (char)(utf32 / 1024 + 55296)'                  (char)(utf32 % 1024 + 56320)              });
Magic Number,CommonMark.Parser,EntityDecoder,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\EntityDecoder.cs,DecodeEntity,The following statement contains a magic number: return new string(new char[]              {                  (char)(utf32 / 1024 + 55296)'                  (char)(utf32 % 1024 + 56320)              });
Magic Number,CommonMark.Parser,EntityDecoder,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\EntityDecoder.cs,DecodeEntity,The following statement contains a magic number: return new string(new char[]              {                  (char)(utf32 / 1024 + 55296)'                  (char)(utf32 % 1024 + 56320)              });
Magic Number,CommonMark.Parser,EntityDecoder,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\EntityDecoder.cs,DecodeEntity,The following statement contains a magic number: return new string(new char[]              {                  (char)(utf32 / 1024 + 55296)'                  (char)(utf32 % 1024 + 56320)              });
Magic Number,CommonMark.Parser,InlineStack,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineStack.cs,FindMatchingOpener,The following statement contains a magic number: while (true)              {                  if (istack == null)                  {                      // this cannot be a closer since there is no opener available.                      canClose = false;                      return null;                  }                    if (istack.Priority > priority ||                      (istack.Delimiter == delimiter && 0 != (istack.Flags & InlineStackFlags.Closer)))                  {                      // there might be a closer further back but we cannot go there yet because a higher priority element is blocking                      // the other option is that the stack entry could be a closer for the same char - this means                      // that any opener we might find would first have to be matched against this closer.                      return null;                  }                    if (istack.Delimiter == delimiter) {                        // interior closer of size 2 does not match opener of size 1 and vice versa.                      // for more details' see https://github.com/jgm/cmark/commit/c50197bab81d7105c9c790548821b61bcb97a62a                      var oddMatch = (closerCanOpen || (istack.Flags & InlineStackFlags.CloserOriginally) > 0)                          && istack.DelimiterCount != closerDelimiterCount                          && ((istack.DelimiterCount + closerDelimiterCount) % 3 == 0);                        if (!oddMatch)                          return istack;                  }                    istack = istack.Previous;              }
Magic Number,CommonMark.Parser,LineInfo,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\LineInfo.cs,AddOffset,The following statement contains a magic number: if (this.OffsetCount == this.Offsets.Length)                  Array.Resize(ref this.Offsets' this.OffsetCount + 20);
Magic Number,CommonMark.Parser,LineInfo,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\LineInfo.cs,ToString,The following statement contains a magic number: if (this.Line == null)                  ln = string.Empty;              else if (this.Line.Length < 50)                  ln = this.Line;              else                  ln = this.Line.Substring(0' 49) + "…";
Magic Number,CommonMark.Parser,LineInfo,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\LineInfo.cs,ToString,The following statement contains a magic number: if (this.Line == null)                  ln = string.Empty;              else if (this.Line.Length < 50)                  ln = this.Line;              else                  ln = this.Line.Substring(0' 49) + "…";
Magic Number,CommonMark.Parser,PositionTracker,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\PositionTracker.cs,AddOffset,The following statement contains a magic number: if (this.OffsetCount + line.OffsetCount + 2 >= this.Offsets.Length)                  Array.Resize(ref this.Offsets' this.Offsets.Length + line.OffsetCount + 20);
Magic Number,CommonMark.Parser,PositionTracker,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\PositionTracker.cs,AddOffset,The following statement contains a magic number: if (this.OffsetCount + line.OffsetCount + 2 >= this.Offsets.Length)                  Array.Resize(ref this.Offsets' this.Offsets.Length + line.OffsetCount + 20);
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_html_block_start,The following statement contains a magic number: if (pos + 2 >= sourceLength)                  return Syntax.HtmlBlockType.None;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_html_block_start,The following statement contains a magic number: if (c == '!')              {                  c = pos + 2 >= sourceLength ? '\0' : s[++pos];                  if (c >= 'A' && c <= 'Z')                      return Syntax.HtmlBlockType.DocumentType;                    if (c == '[' && pos + 7 < sourceLength                      && string.Equals("CDATA["' s.Substring(pos + 1' 6)' StringComparison.Ordinal))                      return Syntax.HtmlBlockType.CData;                    if (c == '-' && pos + 1 < sourceLength && s[pos + 1] == '-')                      return Syntax.HtmlBlockType.Comment;                    return Syntax.HtmlBlockType.None;              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_html_block_start,The following statement contains a magic number: if (c == '!')              {                  c = pos + 2 >= sourceLength ? '\0' : s[++pos];                  if (c >= 'A' && c <= 'Z')                      return Syntax.HtmlBlockType.DocumentType;                    if (c == '[' && pos + 7 < sourceLength                      && string.Equals("CDATA["' s.Substring(pos + 1' 6)' StringComparison.Ordinal))                      return Syntax.HtmlBlockType.CData;                    if (c == '-' && pos + 1 < sourceLength && s[pos + 1] == '-')                      return Syntax.HtmlBlockType.Comment;                    return Syntax.HtmlBlockType.None;              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_html_block_start,The following statement contains a magic number: if (c == '!')              {                  c = pos + 2 >= sourceLength ? '\0' : s[++pos];                  if (c >= 'A' && c <= 'Z')                      return Syntax.HtmlBlockType.DocumentType;                    if (c == '[' && pos + 7 < sourceLength                      && string.Equals("CDATA["' s.Substring(pos + 1' 6)' StringComparison.Ordinal))                      return Syntax.HtmlBlockType.CData;                    if (c == '-' && pos + 1 < sourceLength && s[pos + 1] == '-')                      return Syntax.HtmlBlockType.Comment;                    return Syntax.HtmlBlockType.None;              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_html_block_start,The following statement contains a magic number: var tagname = new char[10];
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_html_block_start,The following statement contains a magic number: while (((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '1' && c <= '6')) && j < 10 && ++pos < sourceLength)              {                  tagname[j++] = c;                  c = s[pos];              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_html_block_start,The following statement contains a magic number: if (tagIndex == 44 || tagIndex == 45 || tagIndex == 48)                  return c == '/' ? Syntax.HtmlBlockType.None : Syntax.HtmlBlockType.InterruptingBlockWithEmptyLines;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_html_block_start,The following statement contains a magic number: if (tagIndex == 44 || tagIndex == 45 || tagIndex == 48)                  return c == '/' ? Syntax.HtmlBlockType.None : Syntax.HtmlBlockType.InterruptingBlockWithEmptyLines;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_html_block_start,The following statement contains a magic number: if (tagIndex == 44 || tagIndex == 45 || tagIndex == 48)                  return c == '/' ? Syntax.HtmlBlockType.None : Syntax.HtmlBlockType.InterruptingBlockWithEmptyLines;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_html_block_start_7,The following statement contains a magic number: if (pos + 2 >= sourceLength)                  return Syntax.HtmlBlockType.None;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scan_html_block_end_1,The following statement contains a magic number: while (i + 5 < sourceLength)              {                  i = s.IndexOf('<'' i' sourceLength - i - 3);                  if (i == -1)                      break;                    if (s[++i] != '/')                      continue;                    var c = s[++i];                  if (c != 's' && c != 'S' && c != 'p' && c != 'P')                      continue;                    var j = s.IndexOf('>'' i' Math.Min(sourceLength - i' 7));                  if (j == -1)                      continue;                    var t = s.Substring(i' j - i).ToUpperInvariant();                  if (string.Equals("PRE"' t' StringComparison.Ordinal)                      || string.Equals("STYLE"' t' StringComparison.Ordinal)                      || string.Equals("SCRIPT"' t' StringComparison.Ordinal))                      return true;              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scan_html_block_end_1,The following statement contains a magic number: while (i + 5 < sourceLength)              {                  i = s.IndexOf('<'' i' sourceLength - i - 3);                  if (i == -1)                      break;                    if (s[++i] != '/')                      continue;                    var c = s[++i];                  if (c != 's' && c != 'S' && c != 'p' && c != 'P')                      continue;                    var j = s.IndexOf('>'' i' Math.Min(sourceLength - i' 7));                  if (j == -1)                      continue;                    var t = s.Substring(i' j - i).ToUpperInvariant();                  if (string.Equals("PRE"' t' StringComparison.Ordinal)                      || string.Equals("STYLE"' t' StringComparison.Ordinal)                      || string.Equals("SCRIPT"' t' StringComparison.Ordinal))                      return true;              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scan_html_block_end_1,The following statement contains a magic number: while (i + 5 < sourceLength)              {                  i = s.IndexOf('<'' i' sourceLength - i - 3);                  if (i == -1)                      break;                    if (s[++i] != '/')                      continue;                    var c = s[++i];                  if (c != 's' && c != 'S' && c != 'p' && c != 'P')                      continue;                    var j = s.IndexOf('>'' i' Math.Min(sourceLength - i' 7));                  if (j == -1)                      continue;                    var t = s.Substring(i' j - i).ToUpperInvariant();                  if (string.Equals("PRE"' t' StringComparison.Ordinal)                      || string.Equals("STYLE"' t' StringComparison.Ordinal)                      || string.Equals("SCRIPT"' t' StringComparison.Ordinal))                      return true;              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagCloseTag,The following statement contains a magic number: if (pos + 2 >= sourceLength)                  return 0;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagCloseTag,The following statement contains a magic number: for (var i = pos + 2; i < sourceLength; i++)              {                  nextChar = s[i];                  if (nextChar == '>')                      return i - pos + 1;                    if (nextChar == ' ' || nextChar == '\n')                  {                      tagNameEnded = true;                      continue;                  }                    if (tagNameEnded || ((nextChar < 'A' || nextChar > 'Z')                                     && (nextChar < 'a' || nextChar > 'z')                                     && (nextChar < '0' || nextChar > '9')))                      return 0;              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagHtmlComment,The following statement contains a magic number: if (pos + 5 >= sourceLength)                  return 0;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagHtmlComment,The following statement contains a magic number: if (s[pos + 2] != '-')                  return 0;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagHtmlComment,The following statement contains a magic number: char nextChar = s[pos + 3];
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagHtmlComment,The following statement contains a magic number: if (nextChar == '>' || (nextChar == '-' && s[pos + 4] == '>'))                  return 0;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagHtmlComment,The following statement contains a magic number: for (var i = pos + 3; i < sourceLength ; i++)              {                  nextChar = s[i];                    if (hyphenCount == 2)                      return nextChar == '>' ? i - pos + 1 : 0;                    if (nextChar == '-')                      hyphenCount++;                  else                      hyphenCount = 0;              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagHtmlComment,The following statement contains a magic number: for (var i = pos + 3; i < sourceLength ; i++)              {                  nextChar = s[i];                    if (hyphenCount == 2)                      return nextChar == '>' ? i - pos + 1 : 0;                    if (nextChar == '-')                      hyphenCount++;                  else                      hyphenCount = 0;              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagCData,The following statement contains a magic number: if (pos + 10 >= sourceLength)                  return 0;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagCData,The following statement contains a magic number: if (!string.Equals(s.Substring(pos' 8)' "![CDATA["' StringComparison.Ordinal))                  return 0;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagCData,The following statement contains a magic number: for (var i = pos + 8; i < sourceLength; i++ )              {                  nextChar = s[i];                    if (nextChar == '>' && bracketCount >= 2)                      return i - pos + 1;                    if (nextChar == ']')                      bracketCount++;                  else                      bracketCount = 0;              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagCData,The following statement contains a magic number: for (var i = pos + 8; i < sourceLength; i++ )              {                  nextChar = s[i];                    if (nextChar == '>' && bracketCount >= 2)                      return i - pos + 1;                    if (nextChar == ']')                      bracketCount++;                  else                      bracketCount = 0;              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagDeclaration,The following statement contains a magic number: if (pos + 4 >= sourceLength)                  return 0;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagDeclaration,The following statement contains a magic number: char nextChar = s[pos + 2];
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,_scanHtmlTagDeclaration,The following statement contains a magic number: for (var i = pos + 3; i < sourceLength; i++)              {                  nextChar = s[i];                    if (nextChar == '>')                      return spaceFound ? i - pos + 1 : 0;                    if (nextChar == ' ' || nextChar == '\n')                      spaceFound = true;              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_html_tag,The following statement contains a magic number: if (pos + 2 >= sourceLength)                  return 0;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_autolink_uri,The following statement contains a magic number: while (++i < sourceLength)              {                  if (++schemeLength > 32)                      return 0;                    c = s[i];                  if (c == ':')                      break;                  if (!Utilities.IsAsciiLetter(c) && c != '+' && c != '.' && c != '-')                      return 0;              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_autolink_uri,The following statement contains a magic number: if (schemeLength < 2)                  return 0;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_autolink_email,The following statement contains a magic number: if (pos + 6 >= sourceLength)                  return 0;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_autolink_email,The following statement contains a magic number: while (true)              {                  var domainStart = i;                  if (!ScannerCharacterMatcher.MatchAsciiLetterOrDigit(s' ref c' ref i' ln' '-'))                      return 0;                    if (s[i - 1] == '-' || i - domainStart > 63)                      return 0;                    if (c == '>')                      return hadDot ? i - pos + 1 : 0;                    if (c != '.' || i == ln)                      return 0;                    hadDot = true;                  c = s[++i];              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_link_title,The following statement contains a magic number: if (pos + 2 >= sourceLength)                  return 0;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_atx_heading_start,The following statement contains a magic number: for (var i = pos + 1; i < sourceLength; i++)              {                  var c = s[i];                    if (c == '#')                  {                      if (headingLevel == 6)                          return 0;                        if (spaceExists)                          return i - pos;                      else                          headingLevel++;                  }                  else if (c == ' ' || c == '\t')                  {                      spaceExists = true;                  }                  else if (c == '\n')                  {                      return i - pos + 1;                  }                  else                  {                      return spaceExists ? i - pos : 0;                  }              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_setext_heading_line,The following statement contains a magic number: return c1 == '=' ? 1 : 2;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_thematic_break,The following statement contains a magic number: if (count < 3)                  return 0;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_open_code_fence,The following statement contains a magic number: if (pos + 3 >= sourceLength)                  return 0;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_open_code_fence,The following statement contains a magic number: for (var i = pos + 1; i < sourceLength; i++)              {                  var c = s[i];                    if (c == fchar)                  {                      if (fenceDone)                          return 0;                        cnt++;                      continue;                  }                    fenceDone = true;                  if (cnt < 3)                      return 0;                    if (c == '\n')                      return cnt;              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_open_code_fence,The following statement contains a magic number: if (cnt < 3)                  return 0;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,The following statement contains a magic number: if (pos + 3 >= lastPos)                  return 0;
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,The following statement contains a magic number: if (s[pos + 1] == '#')              {                  c = s[pos + 2];                  if (c == 'x' || c == 'X')                  {                      // expect 1-8 hex digits starting from pos+3                      for (i = pos + 3; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - '0');                              continue;                          }                          else if (c >= 'A' && c <= 'F')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'A' + 10);                              continue;                          }                          else if (c >= 'a' && c <= 'f')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'a' + 10);                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }                  else                  {                      // expect 1-8 digits starting from pos+2                      for (i = pos + 2; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 10 + (c - '0');                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }              }              else              {                  // expect a letter and 1-31 letters or digits                  c = s[pos + 1];                  if ((c < 'A' || c > 'Z') && (c < 'a' && c > 'z'))                      return 0;                    for (i = pos + 2; i < lastPos; i++)                  {                      c = s[i];                      if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))                      {                          if (++counter == 32)                              return 0;                            continue;                      }                        if (c == ';')                      {                          namedEntity = s.Substring(pos + 1' counter + 1);                          return counter == 0 ? 0 : i - pos + 1;                      }                        return 0;                  }              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,The following statement contains a magic number: if (s[pos + 1] == '#')              {                  c = s[pos + 2];                  if (c == 'x' || c == 'X')                  {                      // expect 1-8 hex digits starting from pos+3                      for (i = pos + 3; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - '0');                              continue;                          }                          else if (c >= 'A' && c <= 'F')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'A' + 10);                              continue;                          }                          else if (c >= 'a' && c <= 'f')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'a' + 10);                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }                  else                  {                      // expect 1-8 digits starting from pos+2                      for (i = pos + 2; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 10 + (c - '0');                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }              }              else              {                  // expect a letter and 1-31 letters or digits                  c = s[pos + 1];                  if ((c < 'A' || c > 'Z') && (c < 'a' && c > 'z'))                      return 0;                    for (i = pos + 2; i < lastPos; i++)                  {                      c = s[i];                      if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))                      {                          if (++counter == 32)                              return 0;                            continue;                      }                        if (c == ';')                      {                          namedEntity = s.Substring(pos + 1' counter + 1);                          return counter == 0 ? 0 : i - pos + 1;                      }                        return 0;                  }              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,The following statement contains a magic number: if (s[pos + 1] == '#')              {                  c = s[pos + 2];                  if (c == 'x' || c == 'X')                  {                      // expect 1-8 hex digits starting from pos+3                      for (i = pos + 3; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - '0');                              continue;                          }                          else if (c >= 'A' && c <= 'F')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'A' + 10);                              continue;                          }                          else if (c >= 'a' && c <= 'f')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'a' + 10);                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }                  else                  {                      // expect 1-8 digits starting from pos+2                      for (i = pos + 2; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 10 + (c - '0');                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }              }              else              {                  // expect a letter and 1-31 letters or digits                  c = s[pos + 1];                  if ((c < 'A' || c > 'Z') && (c < 'a' && c > 'z'))                      return 0;                    for (i = pos + 2; i < lastPos; i++)                  {                      c = s[i];                      if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))                      {                          if (++counter == 32)                              return 0;                            continue;                      }                        if (c == ';')                      {                          namedEntity = s.Substring(pos + 1' counter + 1);                          return counter == 0 ? 0 : i - pos + 1;                      }                        return 0;                  }              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,The following statement contains a magic number: if (s[pos + 1] == '#')              {                  c = s[pos + 2];                  if (c == 'x' || c == 'X')                  {                      // expect 1-8 hex digits starting from pos+3                      for (i = pos + 3; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - '0');                              continue;                          }                          else if (c >= 'A' && c <= 'F')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'A' + 10);                              continue;                          }                          else if (c >= 'a' && c <= 'f')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'a' + 10);                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }                  else                  {                      // expect 1-8 digits starting from pos+2                      for (i = pos + 2; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 10 + (c - '0');                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }              }              else              {                  // expect a letter and 1-31 letters or digits                  c = s[pos + 1];                  if ((c < 'A' || c > 'Z') && (c < 'a' && c > 'z'))                      return 0;                    for (i = pos + 2; i < lastPos; i++)                  {                      c = s[i];                      if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))                      {                          if (++counter == 32)                              return 0;                            continue;                      }                        if (c == ';')                      {                          namedEntity = s.Substring(pos + 1' counter + 1);                          return counter == 0 ? 0 : i - pos + 1;                      }                        return 0;                  }              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,The following statement contains a magic number: if (s[pos + 1] == '#')              {                  c = s[pos + 2];                  if (c == 'x' || c == 'X')                  {                      // expect 1-8 hex digits starting from pos+3                      for (i = pos + 3; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - '0');                              continue;                          }                          else if (c >= 'A' && c <= 'F')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'A' + 10);                              continue;                          }                          else if (c >= 'a' && c <= 'f')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'a' + 10);                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }                  else                  {                      // expect 1-8 digits starting from pos+2                      for (i = pos + 2; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 10 + (c - '0');                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }              }              else              {                  // expect a letter and 1-31 letters or digits                  c = s[pos + 1];                  if ((c < 'A' || c > 'Z') && (c < 'a' && c > 'z'))                      return 0;                    for (i = pos + 2; i < lastPos; i++)                  {                      c = s[i];                      if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))                      {                          if (++counter == 32)                              return 0;                            continue;                      }                        if (c == ';')                      {                          namedEntity = s.Substring(pos + 1' counter + 1);                          return counter == 0 ? 0 : i - pos + 1;                      }                        return 0;                  }              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,The following statement contains a magic number: if (s[pos + 1] == '#')              {                  c = s[pos + 2];                  if (c == 'x' || c == 'X')                  {                      // expect 1-8 hex digits starting from pos+3                      for (i = pos + 3; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - '0');                              continue;                          }                          else if (c >= 'A' && c <= 'F')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'A' + 10);                              continue;                          }                          else if (c >= 'a' && c <= 'f')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'a' + 10);                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }                  else                  {                      // expect 1-8 digits starting from pos+2                      for (i = pos + 2; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 10 + (c - '0');                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }              }              else              {                  // expect a letter and 1-31 letters or digits                  c = s[pos + 1];                  if ((c < 'A' || c > 'Z') && (c < 'a' && c > 'z'))                      return 0;                    for (i = pos + 2; i < lastPos; i++)                  {                      c = s[i];                      if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))                      {                          if (++counter == 32)                              return 0;                            continue;                      }                        if (c == ';')                      {                          namedEntity = s.Substring(pos + 1' counter + 1);                          return counter == 0 ? 0 : i - pos + 1;                      }                        return 0;                  }              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,The following statement contains a magic number: if (s[pos + 1] == '#')              {                  c = s[pos + 2];                  if (c == 'x' || c == 'X')                  {                      // expect 1-8 hex digits starting from pos+3                      for (i = pos + 3; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - '0');                              continue;                          }                          else if (c >= 'A' && c <= 'F')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'A' + 10);                              continue;                          }                          else if (c >= 'a' && c <= 'f')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'a' + 10);                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }                  else                  {                      // expect 1-8 digits starting from pos+2                      for (i = pos + 2; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 10 + (c - '0');                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }              }              else              {                  // expect a letter and 1-31 letters or digits                  c = s[pos + 1];                  if ((c < 'A' || c > 'Z') && (c < 'a' && c > 'z'))                      return 0;                    for (i = pos + 2; i < lastPos; i++)                  {                      c = s[i];                      if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))                      {                          if (++counter == 32)                              return 0;                            continue;                      }                        if (c == ';')                      {                          namedEntity = s.Substring(pos + 1' counter + 1);                          return counter == 0 ? 0 : i - pos + 1;                      }                        return 0;                  }              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,The following statement contains a magic number: if (s[pos + 1] == '#')              {                  c = s[pos + 2];                  if (c == 'x' || c == 'X')                  {                      // expect 1-8 hex digits starting from pos+3                      for (i = pos + 3; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - '0');                              continue;                          }                          else if (c >= 'A' && c <= 'F')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'A' + 10);                              continue;                          }                          else if (c >= 'a' && c <= 'f')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'a' + 10);                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }                  else                  {                      // expect 1-8 digits starting from pos+2                      for (i = pos + 2; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 10 + (c - '0');                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }              }              else              {                  // expect a letter and 1-31 letters or digits                  c = s[pos + 1];                  if ((c < 'A' || c > 'Z') && (c < 'a' && c > 'z'))                      return 0;                    for (i = pos + 2; i < lastPos; i++)                  {                      c = s[i];                      if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))                      {                          if (++counter == 32)                              return 0;                            continue;                      }                        if (c == ';')                      {                          namedEntity = s.Substring(pos + 1' counter + 1);                          return counter == 0 ? 0 : i - pos + 1;                      }                        return 0;                  }              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,The following statement contains a magic number: if (s[pos + 1] == '#')              {                  c = s[pos + 2];                  if (c == 'x' || c == 'X')                  {                      // expect 1-8 hex digits starting from pos+3                      for (i = pos + 3; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - '0');                              continue;                          }                          else if (c >= 'A' && c <= 'F')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'A' + 10);                              continue;                          }                          else if (c >= 'a' && c <= 'f')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'a' + 10);                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }                  else                  {                      // expect 1-8 digits starting from pos+2                      for (i = pos + 2; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 10 + (c - '0');                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }              }              else              {                  // expect a letter and 1-31 letters or digits                  c = s[pos + 1];                  if ((c < 'A' || c > 'Z') && (c < 'a' && c > 'z'))                      return 0;                    for (i = pos + 2; i < lastPos; i++)                  {                      c = s[i];                      if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))                      {                          if (++counter == 32)                              return 0;                            continue;                      }                        if (c == ';')                      {                          namedEntity = s.Substring(pos + 1' counter + 1);                          return counter == 0 ? 0 : i - pos + 1;                      }                        return 0;                  }              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,The following statement contains a magic number: if (s[pos + 1] == '#')              {                  c = s[pos + 2];                  if (c == 'x' || c == 'X')                  {                      // expect 1-8 hex digits starting from pos+3                      for (i = pos + 3; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - '0');                              continue;                          }                          else if (c >= 'A' && c <= 'F')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'A' + 10);                              continue;                          }                          else if (c >= 'a' && c <= 'f')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'a' + 10);                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }                  else                  {                      // expect 1-8 digits starting from pos+2                      for (i = pos + 2; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 10 + (c - '0');                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }              }              else              {                  // expect a letter and 1-31 letters or digits                  c = s[pos + 1];                  if ((c < 'A' || c > 'Z') && (c < 'a' && c > 'z'))                      return 0;                    for (i = pos + 2; i < lastPos; i++)                  {                      c = s[i];                      if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))                      {                          if (++counter == 32)                              return 0;                            continue;                      }                        if (c == ';')                      {                          namedEntity = s.Substring(pos + 1' counter + 1);                          return counter == 0 ? 0 : i - pos + 1;                      }                        return 0;                  }              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,The following statement contains a magic number: if (s[pos + 1] == '#')              {                  c = s[pos + 2];                  if (c == 'x' || c == 'X')                  {                      // expect 1-8 hex digits starting from pos+3                      for (i = pos + 3; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - '0');                              continue;                          }                          else if (c >= 'A' && c <= 'F')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'A' + 10);                              continue;                          }                          else if (c >= 'a' && c <= 'f')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'a' + 10);                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }                  else                  {                      // expect 1-8 digits starting from pos+2                      for (i = pos + 2; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 10 + (c - '0');                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }              }              else              {                  // expect a letter and 1-31 letters or digits                  c = s[pos + 1];                  if ((c < 'A' || c > 'Z') && (c < 'a' && c > 'z'))                      return 0;                    for (i = pos + 2; i < lastPos; i++)                  {                      c = s[i];                      if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))                      {                          if (++counter == 32)                              return 0;                            continue;                      }                        if (c == ';')                      {                          namedEntity = s.Substring(pos + 1' counter + 1);                          return counter == 0 ? 0 : i - pos + 1;                      }                        return 0;                  }              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,The following statement contains a magic number: if (s[pos + 1] == '#')              {                  c = s[pos + 2];                  if (c == 'x' || c == 'X')                  {                      // expect 1-8 hex digits starting from pos+3                      for (i = pos + 3; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - '0');                              continue;                          }                          else if (c >= 'A' && c <= 'F')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'A' + 10);                              continue;                          }                          else if (c >= 'a' && c <= 'f')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'a' + 10);                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }                  else                  {                      // expect 1-8 digits starting from pos+2                      for (i = pos + 2; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 10 + (c - '0');                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }              }              else              {                  // expect a letter and 1-31 letters or digits                  c = s[pos + 1];                  if ((c < 'A' || c > 'Z') && (c < 'a' && c > 'z'))                      return 0;                    for (i = pos + 2; i < lastPos; i++)                  {                      c = s[i];                      if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))                      {                          if (++counter == 32)                              return 0;                            continue;                      }                        if (c == ';')                      {                          namedEntity = s.Substring(pos + 1' counter + 1);                          return counter == 0 ? 0 : i - pos + 1;                      }                        return 0;                  }              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,The following statement contains a magic number: if (s[pos + 1] == '#')              {                  c = s[pos + 2];                  if (c == 'x' || c == 'X')                  {                      // expect 1-8 hex digits starting from pos+3                      for (i = pos + 3; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - '0');                              continue;                          }                          else if (c >= 'A' && c <= 'F')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'A' + 10);                              continue;                          }                          else if (c >= 'a' && c <= 'f')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'a' + 10);                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }                  else                  {                      // expect 1-8 digits starting from pos+2                      for (i = pos + 2; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 10 + (c - '0');                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }              }              else              {                  // expect a letter and 1-31 letters or digits                  c = s[pos + 1];                  if ((c < 'A' || c > 'Z') && (c < 'a' && c > 'z'))                      return 0;                    for (i = pos + 2; i < lastPos; i++)                  {                      c = s[i];                      if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))                      {                          if (++counter == 32)                              return 0;                            continue;                      }                        if (c == ';')                      {                          namedEntity = s.Substring(pos + 1' counter + 1);                          return counter == 0 ? 0 : i - pos + 1;                      }                        return 0;                  }              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,The following statement contains a magic number: if (s[pos + 1] == '#')              {                  c = s[pos + 2];                  if (c == 'x' || c == 'X')                  {                      // expect 1-8 hex digits starting from pos+3                      for (i = pos + 3; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - '0');                              continue;                          }                          else if (c >= 'A' && c <= 'F')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'A' + 10);                              continue;                          }                          else if (c >= 'a' && c <= 'f')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'a' + 10);                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }                  else                  {                      // expect 1-8 digits starting from pos+2                      for (i = pos + 2; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 10 + (c - '0');                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }              }              else              {                  // expect a letter and 1-31 letters or digits                  c = s[pos + 1];                  if ((c < 'A' || c > 'Z') && (c < 'a' && c > 'z'))                      return 0;                    for (i = pos + 2; i < lastPos; i++)                  {                      c = s[i];                      if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))                      {                          if (++counter == 32)                              return 0;                            continue;                      }                        if (c == ';')                      {                          namedEntity = s.Substring(pos + 1' counter + 1);                          return counter == 0 ? 0 : i - pos + 1;                      }                        return 0;                  }              }
Magic Number,CommonMark.Parser,Scanner,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\ScannerHtmlTag.cs,scan_entity,The following statement contains a magic number: if (s[pos + 1] == '#')              {                  c = s[pos + 2];                  if (c == 'x' || c == 'X')                  {                      // expect 1-8 hex digits starting from pos+3                      for (i = pos + 3; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - '0');                              continue;                          }                          else if (c >= 'A' && c <= 'F')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'A' + 10);                              continue;                          }                          else if (c >= 'a' && c <= 'f')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 16 + (c - 'a' + 10);                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }                  else                  {                      // expect 1-8 digits starting from pos+2                      for (i = pos + 2; i < lastPos; i++)                      {                          c = s[i];                          if (c >= '0' && c <= '9')                          {                              if (++counter == 9) return 0;                              numericEntity = numericEntity * 10 + (c - '0');                              continue;                          }                            if (c == ';')                              return counter == 0 ? 0 : i - pos + 1;                            return 0;                      }                  }              }              else              {                  // expect a letter and 1-31 letters or digits                  c = s[pos + 1];                  if ((c < 'A' || c > 'Z') && (c < 'a' && c > 'z'))                      return 0;                    for (i = pos + 2; i < lastPos; i++)                  {                      c = s[i];                      if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))                      {                          if (++counter == 32)                              return 0;                            continue;                      }                        if (c == ';')                      {                          namedEntity = s.Substring(pos + 1' counter + 1);                          return counter == 0 ? 0 : i - pos + 1;                      }                        return 0;                  }              }
Magic Number,CommonMark.Parser,TabTextReader,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\TabTextReader.cs,TabTextReader,The following statement contains a magic number: this._builder = new StringBuilder(256);
Magic Number,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,ParseListMarker,The following statement contains a magic number: if (c == '+' || c == '•' || ((c == '*' || c == '-') && 0 == Scanner.scan_thematic_break(ln' pos' len)))              {                  pos++;                    if (pos == len || !Utilities.IsWhitespace(ln[pos]))                      return 0;                    if (interruptsParagraph && Scanner.scan_spacechars(ln' pos + 1' ln.Length) == ln.Length - pos - 1)                      return 0;                    data = new ListData();                  data.BulletChar = c;                  data.Start = 1;              }              else if (c >= '0' && c <= '9')              {                    int start = c - '0';                    while (pos < len - 1)                  {                      c = ln[++pos];                      // We limit to 9 digits to avoid overflow' This also seems to be the limit for 'start' in some browsers.                       if (c >= '0' && c <= '9' && start < 100000000)                          start = start * 10 + (c - '0');                      else                          break;                  }                    if (pos >= len - 1 || (c != '.' && c != ')'))                      return 0;                    pos++;                  if (pos == len || !Utilities.IsWhitespace(ln[pos]))                      return 0;                    if (interruptsParagraph &&                      (start != 1 || Scanner.scan_spacechars(ln' pos + 1' ln.Length) == ln.Length - pos - 1))                      return 0;                    data = new ListData();                  data.ListType = ListType.Ordered;                  data.BulletChar = '\0';                  data.Start = start;                  data.Delimiter = (c == '.' ? ListDelimiter.Period : ListDelimiter.Parenthesis);                }              else              {                  return 0;              }
Magic Number,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,ParseListMarker,The following statement contains a magic number: if (c == '+' || c == '•' || ((c == '*' || c == '-') && 0 == Scanner.scan_thematic_break(ln' pos' len)))              {                  pos++;                    if (pos == len || !Utilities.IsWhitespace(ln[pos]))                      return 0;                    if (interruptsParagraph && Scanner.scan_spacechars(ln' pos + 1' ln.Length) == ln.Length - pos - 1)                      return 0;                    data = new ListData();                  data.BulletChar = c;                  data.Start = 1;              }              else if (c >= '0' && c <= '9')              {                    int start = c - '0';                    while (pos < len - 1)                  {                      c = ln[++pos];                      // We limit to 9 digits to avoid overflow' This also seems to be the limit for 'start' in some browsers.                       if (c >= '0' && c <= '9' && start < 100000000)                          start = start * 10 + (c - '0');                      else                          break;                  }                    if (pos >= len - 1 || (c != '.' && c != ')'))                      return 0;                    pos++;                  if (pos == len || !Utilities.IsWhitespace(ln[pos]))                      return 0;                    if (interruptsParagraph &&                      (start != 1 || Scanner.scan_spacechars(ln' pos + 1' ln.Length) == ln.Length - pos - 1))                      return 0;                    data = new ListData();                  data.ListType = ListType.Ordered;                  data.BulletChar = '\0';                  data.Start = start;                  data.Delimiter = (c == '.' ? ListDelimiter.Period : ListDelimiter.Parenthesis);                }              else              {                  return 0;              }
Magic Number,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,AdvanceOptionalSpace,The following statement contains a magic number: if (c == ' ')              {                  offset++;                  column++;                  return true;              }              else if (c == '\t')              {                  offset++;                  var chars_to_tab = 4 - (column % TabSize);                  column += chars_to_tab;                  remainingSpaces = chars_to_tab - 1;                  return true;              }
Magic Number,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,AdvanceOffset,The following statement contains a magic number: while (count > 0 && (c = line[offset]) != '\n')              {                  if (c == '\t')                  {                      var chars_to_tab = 4 - (column % TabSize);                      column += chars_to_tab;                      offset += 1;                      count -= columns ? chars_to_tab : 1;                        if (count < 0)                      {                          remainingSpaces = 0 - count;                      }                  }                  else                  {                      offset += 1;                      column += 1; // assume ascii; block starts are ascii                        count -= 1;                  }              }
Magic Number,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,IncorporateLine,The following statement contains a magic number: while (container.LastChild != null && container.LastChild.IsOpen)              {                  container = container.LastChild;                    FindFirstNonspace(ln' offset' column' out first_nonspace' out first_nonspace_column' out curChar);                    indent = first_nonspace_column - column + remainingSpaces;                  blank = curChar == '\n';                    switch (container.Tag)                  {                      case BlockTag.BlockQuote:                          {                              if (indent <= 3 && curChar == '>')                              {                                  AdvanceOffset(ln' indent + 1' true' ref offset' ref column' ref remainingSpaces);                                  AdvanceOptionalSpace(ln' ref offset' ref column' ref remainingSpaces);                              }                              else                              {                                  all_matched = false;                              }                                break;                          }                        case BlockTag.ListItem:                          {                              if (indent >= container.ListData.MarkerOffset + container.ListData.Padding)                              {                                  AdvanceOffset(ln' container.ListData.MarkerOffset + container.ListData.Padding' true' ref offset' ref column' ref remainingSpaces);                              }                              else if (blank && container.FirstChild != null)                              {                                  // if container->first_child is NULL' then the opening line                                  // of the list item was blank after the list marker; in this                                  // case' we are done with the list item.                                  AdvanceOffset(ln' first_nonspace - offset' false' ref offset' ref column' ref remainingSpaces);                              }                              else                              {                                  all_matched = false;                              }                                break;                          }                        case BlockTag.IndentedCode:                          {                              if (indent >= CODE_INDENT)                                  AdvanceOffset(ln' CODE_INDENT' true' ref offset' ref column' ref remainingSpaces);                              else if (blank)                                  AdvanceOffset(ln' first_nonspace - offset' false' ref offset' ref column' ref remainingSpaces);                              else                                  all_matched = false;                                break;                          }                        case BlockTag.AtxHeading:                      case BlockTag.SetextHeading:                          {                              // a heading can never contain more than one line                              all_matched = false;                              if (blank)                                  container.IsLastLineBlank = true;                                break;                          }                        case BlockTag.FencedCode:                          {                              // -1 means we've seen closer                               if (container.FencedCodeData.FenceLength == -1)                              {                                  all_matched = false;                                  if (blank)                                      container.IsLastLineBlank = true;                              }                              else                              {                                  // skip optional spaces of fence offset                                  i = container.FencedCodeData.FenceOffset;                                  while (i > 0 && ln[offset] == ' ')                                  {                                      offset++;                                      column++;                                      i--;                                  }                              }                                break;                          }                        case BlockTag.HtmlBlock:                          {                              // all other block types can accept blanks                              if (blank && container.HtmlBlockType >= HtmlBlockType.InterruptingBlock)                              {                                  container.IsLastLineBlank = true;                                  all_matched = false;                              }                                break;                          }                        case BlockTag.Paragraph:                          {                              if (blank)                              {                                  container.IsLastLineBlank = true;                                  all_matched = false;                              }                                break;                          }                  }                    if (!all_matched)                  {                      container = container.Parent;  // back up to last matching block                      break;                  }              }
Magic Number,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,IncorporateLine,The following statement contains a magic number: if (cur != last_matched_container &&                  container == last_matched_container &&                  !blank &&                  cur.Tag == BlockTag.Paragraph &&                  cur.StringContent.Length > 0)              {                    AddLine(cur' line' ln' offset' remainingSpaces);                }              else              { // not a lazy continuation                    // finalize any blocks that were not matched and set cur to container:                  while (cur != last_matched_container)                  {                        Finalize(cur' line);                      cur = cur.Parent;                        if (cur == null)                          throw new CommonMarkException("Cannot finalize container block. Last matched container tag = " + last_matched_container.Tag);                    }                    if (container.Tag == BlockTag.IndentedCode)                  {                      AddLine(container' line' ln' offset' remainingSpaces);                    }                  else if (container.Tag == BlockTag.FencedCode)                  {                        if ((indent <= 3                        && curChar == container.FencedCodeData.FenceChar)                        && (0 != Scanner.scan_close_code_fence(ln' first_nonspace' container.FencedCodeData.FenceLength' ln.Length)))                      {                          // if closing fence' set fence length to -1. it will be closed when the next line is processed.                           container.FencedCodeData.FenceLength = -1;                      }                      else                      {                          AddLine(container' line' ln' offset' remainingSpaces);                      }                    }                  else if (container.Tag == BlockTag.HtmlBlock)                  {                        AddLine(container' line' ln' offset' remainingSpaces);                        if (Scanner.scan_html_block_end(container.HtmlBlockType' ln' first_nonspace' ln.Length))                      {                          Finalize(container' line);                          container = container.Parent;                      }                    }                  else if (blank)                  {                        // ??? do nothing                    }                  else if (container.Tag == BlockTag.AtxHeading)                  {                        int p = ln.Length - 1;                        // trim trailing spaces                      while (p >= 0 && (ln[p] == ' ' || ln[p] == '\t' || ln[p] == '\n'))                          p--;                        int px = p;                        // if string ends in #s' remove these:                      while (p >= 0 && ln[p] == '#')                          p--;                        // there must be a space before the last hashtag                      if (p < 0 || (ln[p] != ' ' && ln[p] != '\t'))                          p = px;                        // trim trailing spaces that are before the closing #s                      while (p >= first_nonspace && (ln[p] == ' ' || ln[p] == '\t'))                          p--;                        AddLine(container' line' ln' first_nonspace' remainingSpaces' p - first_nonspace + 1);                      Finalize(container' line);                      container = container.Parent;                    }                  else if (AcceptsLines(container.Tag))                  {                        AddLine(container' line' ln' first_nonspace' remainingSpaces' isAddOffsetRequired: container.Parent == null || container.Parent.Tag == BlockTag.Document);                    }                  else if (container.Tag != BlockTag.ThematicBreak && container.Tag != BlockTag.SetextHeading)                  {                        // create paragraph container for line                      container = CreateChildBlock(container' line' BlockTag.Paragraph'  first_nonspace);                      AddLine(container' line' ln' first_nonspace' remainingSpaces);                    }                  else                  {                        Utilities.Warning("Line {0} with container type {1} did not match any condition:\n\"{2}\""' line.LineNumber' container.Tag' ln);                    }                    curptr = container;              }
Magic Number,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,InitializeParsers,The following statement contains a magic number: var p = new Func<Subject' Inline>[strikethroughTilde ? 127 : 97];
Magic Number,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,InitializeParsers,The following statement contains a magic number: var p = new Func<Subject' Inline>[strikethroughTilde ? 127 : 97];
Magic Number,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,ScanToClosingBackticks,The following statement contains a magic number: for (var i = subj.Position; i < len; i++)              {                  if (buf[i] == '`')                  {                      cc++;                  }                  else                  {                      if (cc == openticklength)                          return subj.Position = i;                        i = buf.IndexOf('`'' i' len - i) - 1;                      if (i == -2)                          return 0;                        cc = 0;                  }              }
Magic Number,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,MatchInlineStack,The following statement contains a magic number: if (closingDelimiterCount < 3 || openerDelims < 3)              {                  useDelims = closingDelimiterCount <= openerDelims ? closingDelimiterCount : openerDelims;                  if (useDelims == 1 && singleCharTag == 0)                      return 0;              }              else if (singleCharTag == 0)                  useDelims = 2;              else if (doubleCharTag == 0)                  useDelims = 1;              else                  useDelims = closingDelimiterCount % 2 == 0 ? 2 : 1;
Magic Number,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,MatchInlineStack,The following statement contains a magic number: if (closingDelimiterCount < 3 || openerDelims < 3)              {                  useDelims = closingDelimiterCount <= openerDelims ? closingDelimiterCount : openerDelims;                  if (useDelims == 1 && singleCharTag == 0)                      return 0;              }              else if (singleCharTag == 0)                  useDelims = 2;              else if (doubleCharTag == 0)                  useDelims = 1;              else                  useDelims = closingDelimiterCount % 2 == 0 ? 2 : 1;
Magic Number,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,MatchInlineStack,The following statement contains a magic number: if (closingDelimiterCount < 3 || openerDelims < 3)              {                  useDelims = closingDelimiterCount <= openerDelims ? closingDelimiterCount : openerDelims;                  if (useDelims == 1 && singleCharTag == 0)                      return 0;              }              else if (singleCharTag == 0)                  useDelims = 2;              else if (doubleCharTag == 0)                  useDelims = 1;              else                  useDelims = closingDelimiterCount % 2 == 0 ? 2 : 1;
Magic Number,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,MatchInlineStack,The following statement contains a magic number: if (closingDelimiterCount < 3 || openerDelims < 3)              {                  useDelims = closingDelimiterCount <= openerDelims ? closingDelimiterCount : openerDelims;                  if (useDelims == 1 && singleCharTag == 0)                      return 0;              }              else if (singleCharTag == 0)                  useDelims = 2;              else if (doubleCharTag == 0)                  useDelims = 1;              else                  useDelims = closingDelimiterCount % 2 == 0 ? 2 : 1;
Magic Number,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,MatchInlineStack,The following statement contains a magic number: if (closingDelimiterCount < 3 || openerDelims < 3)              {                  useDelims = closingDelimiterCount <= openerDelims ? closingDelimiterCount : openerDelims;                  if (useDelims == 1 && singleCharTag == 0)                      return 0;              }              else if (singleCharTag == 0)                  useDelims = 2;              else if (doubleCharTag == 0)                  useDelims = 1;              else                  useDelims = closingDelimiterCount % 2 == 0 ? 2 : 1;
Magic Number,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,HandleOpenerCloser,The following statement contains a magic number: if (canClose)              {                  // walk the stack and find a matching opener' if there is one                  var istack = InlineStack.FindMatchingOpener(subj.LastPendingInline' InlineStack.InlineStackPriority.Emphasis' c' numdelims' canOpen' out canClose);                  if (istack != null)                  {                      var useDelims = MatchInlineStack(istack' subj' numdelims' null' singleCharTag' doubleCharTag);                        if (useDelims > 0)                      {                          // if the closer was not fully used' move back a char or two and try again.                          if (useDelims < numdelims)                          {                              subj.Position = subj.Position - numdelims + useDelims;                                // use recursion only if it will not be very deep.                              // however it cannot be used if the single char will not be parsed.                              if (numdelims < 10)                                  return HandleOpenerCloser(subj' singleCharTag' doubleCharTag);                          }                            return null;                      }                  }              }
Magic Number,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,handle_backslash,The following statement contains a magic number: if (Utilities.IsEscapableSymbol(nextChar))              {                  // only ascii symbols and newline can be escaped                  // the exception is the unicode bullet char since it can be used for defining list items                  subj.Position++;                  return new Inline(nextChar.ToString()' subj.Position - 2' subj.Position);              }              else if (nextChar == '\n')              {                  subj.Position++;                  return new Inline(InlineTag.LineBreak)                   {                      SourcePosition = subj.Position - 2'                      SourceLastPosition = subj.Position                  };              }              else              {                  return new Inline("\\"' subj.Position - 1' subj.Position);              }
Magic Number,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,handle_backslash,The following statement contains a magic number: if (Utilities.IsEscapableSymbol(nextChar))              {                  // only ascii symbols and newline can be escaped                  // the exception is the unicode bullet char since it can be used for defining list items                  subj.Position++;                  return new Inline(nextChar.ToString()' subj.Position - 2' subj.Position);              }              else if (nextChar == '\n')              {                  subj.Position++;                  return new Inline(InlineTag.LineBreak)                   {                      SourcePosition = subj.Position - 2'                      SourceLastPosition = subj.Position                  };              }              else              {                  return new Inline("\\"' subj.Position - 1' subj.Position);              }
Magic Number,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,CleanUrl,The following statement contains a magic number: if (url[0] == '<' && url[url.Length - 1] == '>')                  url = url.Substring(1' url.Length - 2);
Magic Number,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,CleanTitle,The following statement contains a magic number: if ((a == '\'' && b == '\'') || (a == '(' && b == ')') || (a == '"' && b == '"'))                  title = title.Substring(1' titlelength - 2);
Magic Number,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,handle_newline,The following statement contains a magic number: if (nlpos > 1 && subj.Buffer[nlpos - 1] == ' ' && subj.Buffer[nlpos - 2] == ' ')                  return new Inline(InlineTag.LineBreak) { SourcePosition = nlpos - 2' SourceLastPosition = nlpos + 1 };              else                  return new Inline(InlineTag.SoftBreak) { SourcePosition = nlpos' SourceLastPosition = nlpos + 1 };
Magic Number,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,handle_newline,The following statement contains a magic number: if (nlpos > 1 && subj.Buffer[nlpos - 1] == ' ' && subj.Buffer[nlpos - 2] == ' ')                  return new Inline(InlineTag.LineBreak) { SourcePosition = nlpos - 2' SourceLastPosition = nlpos + 1 };              else                  return new Inline(InlineTag.SoftBreak) { SourcePosition = nlpos' SourceLastPosition = nlpos + 1 };
Magic Number,CommonMark.Parser,InlineMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\InlineMethods.cs,ParseReferenceLabel,The following statement contains a magic number: while (subj.Position > -1)              {                  var c = source[subj.Position];                  if (c == '\\')                  {                      subj.Position += 2;                      if (subj.Position >= len)                          break;                        subj.Position = source.IndexOfAny(BracketSpecialCharacters' subj.Position' len - subj.Position);                  }                  else if (c == '[')                  {                      break;                  }                  else                  {                      var label = new StringPart(source' labelStartPos' subj.Position - labelStartPos);                      subj.Position++;                      return label;                  }              }
Magic Number,CommonMark.Syntax,EnumeratorEntry,C:\repos\Knagis_CommonMark.NET\CommonMark\Syntax\EnumeratorEntry.cs,ToString,The following statement contains a magic number: if (this.Block != null)                  r += "block " + this.Block.Tag.ToString();              else if (this.Inline != null)              {                  r += "inline " + this.Inline.Tag.ToString();                    if (this.Inline.Tag == InlineTag.String)                  {                      if (this.Inline.LiteralContent == null)                          r += ": <null>";                      else if (this.Inline.LiteralContent.Length < 20)                          r += ": " + this.Inline.LiteralContent;                      else                          r += ": " + this.Inline.LiteralContent.Substring(0' 19) + "…";                  }              }              else                  r += "empty";
Magic Number,CommonMark.Syntax,EnumeratorEntry,C:\repos\Knagis_CommonMark.NET\CommonMark\Syntax\EnumeratorEntry.cs,ToString,The following statement contains a magic number: if (this.Block != null)                  r += "block " + this.Block.Tag.ToString();              else if (this.Inline != null)              {                  r += "inline " + this.Inline.Tag.ToString();                    if (this.Inline.Tag == InlineTag.String)                  {                      if (this.Inline.LiteralContent == null)                          r += ": <null>";                      else if (this.Inline.LiteralContent.Length < 20)                          r += ": " + this.Inline.LiteralContent;                      else                          r += ": " + this.Inline.LiteralContent.Substring(0' 19) + "…";                  }              }              else                  r += "empty";
Magic Number,CommonMark.Syntax,StringContent,C:\repos\Knagis_CommonMark.NET\CommonMark\Syntax\StringContent.cs,Append,The following statement contains a magic number: if (this._partCounter == this._partsLength)              {                  this._partsLength += 10;                  Array.Resize(ref this._parts' this._partsLength);              }
Magic Number,CommonMark.Syntax,StringContent,C:\repos\Knagis_CommonMark.NET\CommonMark\Syntax\StringContent.cs,ToString,The following statement contains a magic number: if (this._partCounter == 2)              {                  return this._parts[0].Source.Substring(this._parts[0].StartIndex' this._parts[0].Length)                       + this._parts[1].Source.Substring(this._parts[1].StartIndex' this._parts[1].Length);              }
Missing Default,CommonMark.Formatters,HtmlFormatterSlim,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\HtmlFormatterSlim.cs,EscapeHtml,The following switch statement is missing a default case: switch (input.Source[pos])                  {                      case '<':                          target.WriteConstant(EscapeHtmlLessThan);                          break;                      case '>':                          target.WriteConstant(EscapeHtmlGreaterThan);                          break;                      case '&':                          target.WriteConstant(EscapeHtmlAmpersand);                          break;                      case '"':                          target.WriteConstant(EscapeHtmlQuote);                          break;                  }
Missing Default,CommonMark.Formatters,HtmlFormatterSlim,C:\repos\Knagis_CommonMark.NET\CommonMark\Formatters\HtmlFormatterSlim.cs,EscapeHtml,The following switch statement is missing a default case: switch (part.Source[pos])                      {                          case '<':                              target.WriteConstant(EscapeHtmlLessThan);                              break;                          case '>':                              target.WriteConstant(EscapeHtmlGreaterThan);                              break;                          case '&':                              target.WriteConstant(EscapeHtmlAmpersand);                              break;                          case '"':                              target.WriteConstant(EscapeHtmlQuote);                              break;                      }
Missing Default,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,Finalize,The following switch statement is missing a default case: switch (b.Tag)              {                  case BlockTag.Paragraph:                      var sc = b.StringContent;                      if (!sc.StartsWith('['))                          break;                        var subj = new Subject(b.Top.Document);                      sc.FillSubject(subj);                      var origPos = subj.Position;                      while (subj.Position < subj.Buffer.Length                           && subj.Buffer[subj.Position] == '['                           && 0 != InlineMethods.ParseReference(subj))                      {                      }                        if (subj.Position != origPos)                      {                          sc.Replace(subj.Buffer' subj.Position' subj.Buffer.Length - subj.Position);                            if (sc.PositionTracker != null)                              sc.PositionTracker.AddBlockOffset(subj.Position - origPos);                            if (Utilities.IsFirstLineBlank(subj.Buffer' subj.Position))                              b.Tag = BlockTag.ReferenceDefinition;                      }                        break;                    case BlockTag.IndentedCode:                      b.StringContent.RemoveTrailingBlankLines();                      break;                    case BlockTag.FencedCode:                      // first line of contents becomes info                      var firstlinelen = b.StringContent.IndexOf('\n') + 1;                      b.FencedCodeData.Info = InlineMethods.Unescape(b.StringContent.TakeFromStart(firstlinelen' true).Trim());                      break;                    case BlockTag.List: // determine tight/loose status                      b.ListData.IsTight = true; // tight by default                      var item = b.FirstChild;                      Block subitem;                        while (item != null)                      {                          // check for non-final non-empty list item ending with blank line:                          if (item.IsLastLineBlank && item.NextSibling != null)                          {                              b.ListData.IsTight = false;                              break;                          }                            // recurse into children of list item' to see if there are spaces between them:                          subitem = item.FirstChild;                          while (subitem != null)                          {                              if (EndsWithBlankLine(subitem) && (item.NextSibling != null || subitem.NextSibling != null))                              {                                  b.ListData.IsTight = false;                                  break;                              }                                subitem = subitem.NextSibling;                          }                            if (!b.ListData.IsTight)                              break;                            item = item.NextSibling;                      }                        break;              }
Missing Default,CommonMark.Parser,BlockMethods,C:\repos\Knagis_CommonMark.NET\CommonMark\Parser\BlockMethods.cs,IncorporateLine,The following switch statement is missing a default case: switch (container.Tag)                  {                      case BlockTag.BlockQuote:                          {                              if (indent <= 3 && curChar == '>')                              {                                  AdvanceOffset(ln' indent + 1' true' ref offset' ref column' ref remainingSpaces);                                  AdvanceOptionalSpace(ln' ref offset' ref column' ref remainingSpaces);                              }                              else                              {                                  all_matched = false;                              }                                break;                          }                        case BlockTag.ListItem:                          {                              if (indent >= container.ListData.MarkerOffset + container.ListData.Padding)                              {                                  AdvanceOffset(ln' container.ListData.MarkerOffset + container.ListData.Padding' true' ref offset' ref column' ref remainingSpaces);                              }                              else if (blank && container.FirstChild != null)                              {                                  // if container->first_child is NULL' then the opening line                                  // of the list item was blank after the list marker; in this                                  // case' we are done with the list item.                                  AdvanceOffset(ln' first_nonspace - offset' false' ref offset' ref column' ref remainingSpaces);                              }                              else                              {                                  all_matched = false;                              }                                break;                          }                        case BlockTag.IndentedCode:                          {                              if (indent >= CODE_INDENT)                                  AdvanceOffset(ln' CODE_INDENT' true' ref offset' ref column' ref remainingSpaces);                              else if (blank)                                  AdvanceOffset(ln' first_nonspace - offset' false' ref offset' ref column' ref remainingSpaces);                              else                                  all_matched = false;                                break;                          }                        case BlockTag.AtxHeading:                      case BlockTag.SetextHeading:                          {                              // a heading can never contain more than one line                              all_matched = false;                              if (blank)                                  container.IsLastLineBlank = true;                                break;                          }                        case BlockTag.FencedCode:                          {                              // -1 means we've seen closer                               if (container.FencedCodeData.FenceLength == -1)                              {                                  all_matched = false;                                  if (blank)                                      container.IsLastLineBlank = true;                              }                              else                              {                                  // skip optional spaces of fence offset                                  i = container.FencedCodeData.FenceOffset;                                  while (i > 0 && ln[offset] == ' ')                                  {                                      offset++;                                      column++;                                      i--;                                  }                              }                                break;                          }                        case BlockTag.HtmlBlock:                          {                              // all other block types can accept blanks                              if (blank && container.HtmlBlockType >= HtmlBlockType.InterruptingBlock)                              {                                  container.IsLastLineBlank = true;                                  all_matched = false;                              }                                break;                          }                        case BlockTag.Paragraph:                          {                              if (blank)                              {                                  container.IsLastLineBlank = true;                                  all_matched = false;                              }                                break;                          }                  }
