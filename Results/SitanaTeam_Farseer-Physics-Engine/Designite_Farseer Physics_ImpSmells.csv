Implementation smell,Namespace,Class,File,Method,Description
Long Method,FarseerPhysics.Collision,Collision,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,CollideEdgeAndCircle,The method has 108 lines of code.
Long Method,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The method has 113 lines of code.
Long Method,FarseerPhysics.Collision,Distance,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,ComputeDistance,The method has 120 lines of code.
Long Method,FarseerPhysics.Collision,DynamicTree,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\DynamicTree.cs,InsertLeaf,The method has 103 lines of code.
Long Method,FarseerPhysics.Collision,DynamicTree,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\DynamicTree.cs,Balance,The method has 107 lines of code.
Long Method,FarseerPhysics.Collision,TimeOfImpact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\TimeOfImpact.cs,CalculateTimeOfImpact,The method has 157 lines of code.
Long Method,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\EarclipDecomposer.cs,TriangulatePolygon,The method has 102 lines of code.
Long Method,FarseerPhysics.Common,WorldXmlSerializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,SerializeJoint,The method has 131 lines of code.
Long Method,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Deserialize,The method has 573 lines of code.
Long Method,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The method has 221 lines of code.
Long Method,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,DetectSquares,The method has 175 lines of code.
Long Method,FarseerPhysics.Dynamics,Island,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Island.cs,Solve,The method has 154 lines of code.
Long Method,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,Solve,The method has 188 lines of code.
Long Method,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,SolveTOI,The method has 281 lines of code.
Long Method,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\Contact.cs,Update,The method has 103 lines of code.
Long Method,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The method has 248 lines of code.
Long Method,FarseerPhysics.Dynamics.Joints,PrismaticJoint,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Joints\PrismaticJoint.cs,InitVelocityConstraints,The method has 104 lines of code.
Long Method,FarseerPhysics.Dynamics.Joints,WheelJoint,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Joints\WheelJoint.cs,InitVelocityConstraints,The method has 102 lines of code.
Complex Method,FarseerPhysics.Collision,AABB,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,RayCast,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Collision,Collision,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,CollidePolygonAndCircle,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Collision,Collision,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,CollideEdgeAndCircle,Cyclomatic complexity of the method is 11
Complex Method,FarseerPhysics.Collision,Collision,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,FindMaxSeparation,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Collision,DistanceProxy,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Set,Cyclomatic complexity of the method is 16
Complex Method,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,GetWitnessPoints,Cyclomatic complexity of the method is 19
Complex Method,FarseerPhysics.Collision,Distance,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,ComputeDistance,Cyclomatic complexity of the method is 23
Complex Method,FarseerPhysics.Collision,DynamicTree,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\DynamicTree.cs,RayCast,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Collision,DynamicTree,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\DynamicTree.cs,InsertLeaf,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Collision,DynamicTree,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\DynamicTree.cs,Balance,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Collision,DynamicTree,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\DynamicTree.cs,RebuildBottomUp,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Collision,SeparationFunction,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\TimeOfImpact.cs,FindMinSeparation,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Collision,SeparationFunction,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\TimeOfImpact.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Collision,TimeOfImpact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\TimeOfImpact.cs,CalculateTimeOfImpact,Cyclomatic complexity of the method is 22
Complex Method,FarseerPhysics.Collision.Shapes,PolygonShape,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\PolygonShape.cs,RayCast,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Collision.Shapes,PolygonShape,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\PolygonShape.cs,ComputeSubmergedArea,Cyclomatic complexity of the method is 15
Complex Method,FarseerPhysics.Common.ConvexHull,ChainHull,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\ChainHull.cs,GetConvexHull,Cyclomatic complexity of the method is 19
Complex Method,FarseerPhysics.Common.ConvexHull,GiftWrap,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\GiftWrap.cs,GetConvexHull,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Xna.Framework,Curve,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Curve.cs,Evaluate,Cyclomatic complexity of the method is 26
Complex Method,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,Cyclomatic complexity of the method is 19
Complex Method,FarseerPhysics.Common.Decomposition,CDTDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDTDecomposer.cs,ConvexPartition,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\EarclipDecomposer.cs,TriangulatePolygon,Cyclomatic complexity of the method is 15
Complex Method,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\EarclipDecomposer.cs,ResolvePinchPoint,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Common.Decomposition,Triangulate,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Triangulate.cs,ConvexPartition,Cyclomatic complexity of the method is 29
Complex Method,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep,AdvancingFront,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\Sweep\AdvancingFront.cs,LocateNode,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep,AdvancingFront,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\Sweep\AdvancingFront.cs,LocatePoint,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep,DTSweep,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,EdgeEvent,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep,DTSweep,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,FlipEdgeEvent,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep,DTSweep,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,FillAdvancingFront,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep,DTSweep,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,FillBasinReq,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep,DTSweep,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,Legalize,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common.Decomposition.Seidel,TrapezoidalMap,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\TrapezoidalMap.cs,BoundingBox,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Common.Decomposition.Seidel,Triangulator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\Triangulator.cs,Process,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Common,Path,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Path.cs,GetPosition,Cyclomatic complexity of the method is 19
Complex Method,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateCapsule,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Common,WorldXmlSerializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,SerializeShape,Cyclomatic complexity of the method is 18
Complex Method,FarseerPhysics.Common,WorldXmlSerializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,SerializeJoint,Cyclomatic complexity of the method is 35
Complex Method,FarseerPhysics.Common,WorldXmlSerializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Join,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common,WorldXmlSerializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Serialize,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Deserialize,Cyclomatic complexity of the method is 375
Complex Method,FarseerPhysics.Common,XMLFragmentParser,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,NextToken,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common,XMLFragmentParser,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,TryParseNode,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,Cyclomatic complexity of the method is 30
Complex Method,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\CuttingTools.cs,SplitShape,Cyclomatic complexity of the method is 18
Complex Method,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\YuPengClipper.cs,CalculateIntersections,Cyclomatic complexity of the method is 12
Complex Method,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\YuPengClipper.cs,CalculateResultChain,Cyclomatic complexity of the method is 17
Complex Method,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\YuPengClipper.cs,BuildPolygonsFromChain,Cyclomatic complexity of the method is 11
Complex Method,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,DetectSquares,Cyclomatic complexity of the method is 36
Complex Method,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,Cyclomatic complexity of the method is 16
Complex Method,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,combLeft,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,Initialize,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,Cyclomatic complexity of the method is 30
Complex Method,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,Cyclomatic complexity of the method is 14
Complex Method,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchCrossingEdges,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SplitPolygonEdge,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,CreateSimplePolygon,Cyclomatic complexity of the method is 14
Complex Method,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Controllers,AbstractForceController,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Controllers\AbstractForceController.cs,AbstractForceController,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Controllers,AbstractForceController,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Controllers\AbstractForceController.cs,GetDecayMultiplier,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Controllers,AbstractForceController,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Controllers\AbstractForceController.cs,Update,Cyclomatic complexity of the method is 11
Complex Method,FarseerPhysics.Controllers,GravityController,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Controllers\GravityController.cs,Update,Cyclomatic complexity of the method is 18
Complex Method,FarseerPhysics.Dynamics,ContactManager,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\ContactManager.cs,AddPair,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Dynamics,ContactManager,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\ContactManager.cs,Destroy,Cyclomatic complexity of the method is 11
Complex Method,FarseerPhysics.Dynamics,ContactManager,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\ContactManager.cs,Collide,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Dynamics,Island,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Island.cs,Solve,Cyclomatic complexity of the method is 31
Complex Method,FarseerPhysics.Dynamics,Island,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Island.cs,SolveTOI,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,ProcessRemovedJoints,Cyclomatic complexity of the method is 16
Complex Method,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,ProcessAddedJoints,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,Solve,Cyclomatic complexity of the method is 26
Complex Method,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,SolveTOI,Cyclomatic complexity of the method is 35
Complex Method,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,Step,Cyclomatic complexity of the method is 14
Complex Method,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\Contact.cs,Update,Cyclomatic complexity of the method is 29
Complex Method,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\Contact.cs,Evaluate,Cyclomatic complexity of the method is 25
Complex Method,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Dynamics.Joints,PrismaticJoint,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Joints\PrismaticJoint.cs,InitVelocityConstraints,Cyclomatic complexity of the method is 13
Complex Method,FarseerPhysics.Dynamics.Joints,PrismaticJoint,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Joints\PrismaticJoint.cs,SolvePositionConstraints,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Dynamics.Joints,RevoluteJoint,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Joints\RevoluteJoint.cs,InitVelocityConstraints,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Dynamics.Joints,RevoluteJoint,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Joints\RevoluteJoint.cs,SolveVelocityConstraints,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Dynamics.Joints,WheelJoint,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Joints\WheelJoint.cs,InitVelocityConstraints,Cyclomatic complexity of the method is 10
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,TestOverlap,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,CollideCircles,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,CollidePolygonAndCircle,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,CollidePolygons,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,CollideEdgeAndCircle,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,CollideEdgeAndPolygon,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,ClipSegmentToLine,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,EdgeSeparation,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,FindMaxSeparation,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,FindIncidentEdge,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,ReadCache,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Collision,SeparationFunction,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\TimeOfImpact.cs,Set,The method has 6 parameters.
Long Parameter List,Microsoft.Xna.Framework,CurveKey,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\CurveKey.cs,CurveKey,The method has 5 parameters.
Long Parameter List,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,Barycentric,The method has 5 parameters.
Long Parameter List,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,CatmullRom,The method has 5 parameters.
Long Parameter List,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,Hermite,The method has 5 parameters.
Long Parameter List,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,Matrix,The method has 16 parameters.
Long Parameter List,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,CreateBillboard,The method has 5 parameters.
Long Parameter List,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,CreateConstrainedBillboard,The method has 5 parameters.
Long Parameter List,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,CreateConstrainedBillboard,The method has 6 parameters.
Long Parameter List,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,CreateOrthographic,The method has 5 parameters.
Long Parameter List,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,CreateOrthographicOffCenter,The method has 6 parameters.
Long Parameter List,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,CreateOrthographicOffCenter,The method has 7 parameters.
Long Parameter List,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,CreatePerspective,The method has 5 parameters.
Long Parameter List,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,CreatePerspectiveFieldOfView,The method has 5 parameters.
Long Parameter List,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,CreatePerspectiveOffCenter,The method has 6 parameters.
Long Parameter List,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,CreatePerspectiveOffCenter,The method has 7 parameters.
Long Parameter List,Microsoft.Xna.Framework,Vector2,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector2.cs,Barycentric,The method has 5 parameters.
Long Parameter List,Microsoft.Xna.Framework,Vector2,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector2.cs,Barycentric,The method has 6 parameters.
Long Parameter List,Microsoft.Xna.Framework,Vector2,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector2.cs,CatmullRom,The method has 5 parameters.
Long Parameter List,Microsoft.Xna.Framework,Vector2,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector2.cs,CatmullRom,The method has 6 parameters.
Long Parameter List,Microsoft.Xna.Framework,Vector2,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector2.cs,Hermite,The method has 5 parameters.
Long Parameter List,Microsoft.Xna.Framework,Vector2,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector2.cs,Hermite,The method has 6 parameters.
Long Parameter List,Microsoft.Xna.Framework,Vector2,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector2.cs,Transform,The method has 6 parameters.
Long Parameter List,Microsoft.Xna.Framework,Vector2,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector2.cs,TransformNormal,The method has 6 parameters.
Long Parameter List,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,Barycentric,The method has 5 parameters.
Long Parameter List,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,Barycentric,The method has 6 parameters.
Long Parameter List,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,CatmullRom,The method has 5 parameters.
Long Parameter List,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,CatmullRom,The method has 6 parameters.
Long Parameter List,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,Hermite,The method has 5 parameters.
Long Parameter List,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,Hermite,The method has 6 parameters.
Long Parameter List,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,Transform,The method has 6 parameters.
Long Parameter List,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,TransformNormal,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\FlipcodeDecomposer.cs,Snip,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep,DTSweep,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,EdgeEvent,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep,DTSweep,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,FlipEdgeEvent,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep,DTSweep,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,NextFlipTriangle,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep,DTSweep,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,FlipScanEdgeEvent,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Common,LineTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\LineTools.cs,LineIntersect2,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Common,LineTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\LineTools.cs,LineIntersect,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Common,LineTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\LineTools.cs,LineIntersect,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Common,LineTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\LineTools.cs,LineIntersect,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Common,LineTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\LineTools.cs,LineIntersect,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Common,PathManager,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PathManager.cs,EvenlyDistributeShapesAlongPath,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Common,PathManager,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PathManager.cs,EvenlyDistributeShapesAlongPath,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Common,PathManager,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PathManager.cs,EvenlyDistributeShapesAlongPath,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Common,PathManager,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PathManager.cs,MoveBodyOnPath,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Common,PathManager,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PathManager.cs,AttachBodiesWithRevoluteJoint,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateRoundedRectangle,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateCapsule,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreatePolygon,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The method has 8 parameters.
Long Parameter List,FarseerPhysics.Common.PhysicsLogic,SimpleExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\SimpleExplosion.cs,Activate,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Common.PhysicsLogic,SimpleExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\SimpleExplosion.cs,ApplyImpulse,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\CuttingTools.cs,Cut,The method has 11 parameters.
Long Parameter List,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\SimplifyTools.cs,SimplifySection,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\YuPengClipper.cs,CalculateResultChain,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,DetectSquares,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,Xlerp,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,Ylerp,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The method has 10 parameters.
Long Parameter List,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,TextureConverter,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,TextureConverter,The method has 8 parameters.
Long Parameter List,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,Initialize,The method has 8 parameters.
Long Parameter List,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Controllers,BuoyancyController,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Controllers\BuoyancyController.cs,BuoyancyController,The method has 5 parameters.
Long Parameter List,FarseerPhysics,DebugViewBase,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\DebugViewBase.cs,DrawPolygon,The method has 6 parameters.
Long Parameter List,FarseerPhysics,DebugViewBase,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\DebugViewBase.cs,DrawSolidPolygon,The method has 5 parameters.
Long Parameter List,FarseerPhysics,DebugViewBase,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\DebugViewBase.cs,DrawCircle,The method has 5 parameters.
Long Parameter List,FarseerPhysics,DebugViewBase,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\DebugViewBase.cs,DrawSolidCircle,The method has 6 parameters.
Long Parameter List,FarseerPhysics,DebugViewBase,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\DebugViewBase.cs,DrawSegment,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,RayCast,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\ContactSolver.cs,Reset,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Dynamics.Joints,DistanceJoint,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Joints\DistanceJoint.cs,DistanceJoint,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Dynamics.Joints,GearJoint,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Joints\GearJoint.cs,GearJoint,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Dynamics.Joints,PrismaticJoint,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Joints\PrismaticJoint.cs,PrismaticJoint,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Dynamics.Joints,PrismaticJoint,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Joints\PrismaticJoint.cs,PrismaticJoint,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Dynamics.Joints,PulleyJoint,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Joints\PulleyJoint.cs,PulleyJoint,The method has 8 parameters.
Long Parameter List,FarseerPhysics.Dynamics.Joints,RevoluteJoint,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Joints\RevoluteJoint.cs,RevoluteJoint,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Dynamics.Joints,RopeJoint,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Joints\RopeJoint.cs,RopeJoint,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Dynamics.Joints,WeldJoint,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Joints\WeldJoint.cs,WeldJoint,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Dynamics.Joints,WheelJoint,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Joints\WheelJoint.cs,WheelJoint,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\BodyFactory.cs,CreateRectangle,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\BodyFactory.cs,CreateRectangle,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\BodyFactory.cs,CreateCircle,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\BodyFactory.cs,CreateEllipse,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\BodyFactory.cs,CreateEllipse,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\BodyFactory.cs,CreatePolygon,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\BodyFactory.cs,CreateCompoundPolygon,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\BodyFactory.cs,CreateGear,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\BodyFactory.cs,CreateCapsule,The method has 9 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\BodyFactory.cs,CreateCapsule,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\BodyFactory.cs,CreateRoundedRectangle,The method has 9 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\BodyFactory.cs,CreateRoundedRectangle,The method has 8 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\BodyFactory.cs,CreateLineArc,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\BodyFactory.cs,CreateSolidArc,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Factories,FixtureFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\FixtureFactory.cs,AttachRectangle,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,FixtureFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\FixtureFactory.cs,AttachCircle,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,FixtureFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\FixtureFactory.cs,AttachEllipse,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,FixtureFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\FixtureFactory.cs,AttachLineArc,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Factories,FixtureFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\FixtureFactory.cs,AttachSolidArc,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\JointFactory.cs,CreateRevoluteJoint,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\JointFactory.cs,CreateRopeJoint,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\JointFactory.cs,CreateWeldJoint,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\JointFactory.cs,CreatePrismaticJoint,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\JointFactory.cs,CreateWheelJoint,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\JointFactory.cs,CreateDistanceJoint,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\JointFactory.cs,CreateFrictionJoint,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\JointFactory.cs,CreateGearJoint,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\JointFactory.cs,CreatePulleyJoint,The method has 9 parameters.
Long Parameter List,FarseerPhysics.Factories,LinkFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\LinkFactory.cs,CreateChain,The method has 8 parameters.
Long Identifier,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep,DTSweep,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,AngleExceedsPlus90DegreesOrIsNegative,The length of the parameter exceedsPlus90DegreesOrIsNegative is 32.
Long Statement,FarseerPhysics.Collision,AABB,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,Contains,The length of the statement  "	return (point.X > (LowerBound.X + Settings.Epsilon) && point.X < (UpperBound.X - Settings.Epsilon) && (point.Y > (LowerBound.Y + Settings.Epsilon) && point.Y < (UpperBound.Y - Settings.Epsilon))); " is 196.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,CollidePolygonAndCircle,The length of the statement  "		float factor = 1f / (float)Math.Sqrt (manifold.LocalNormal.X * manifold.LocalNormal.X + manifold.LocalNormal.Y * manifold.LocalNormal.Y); " is 137.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,CollidePolygonAndCircle,The length of the statement  "		float factor = 1f / (float)Math.Sqrt (manifold.LocalNormal.X * manifold.LocalNormal.X + manifold.LocalNormal.Y * manifold.LocalNormal.Y); " is 137.
Long Statement,FarseerPhysics.Collision.Shapes,EdgeShape,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\EdgeShape.cs,CompareTo,The length of the statement  "	return (HasVertex0 == shape.HasVertex0 && HasVertex3 == shape.HasVertex3 && Vertex0 == shape.Vertex0 && Vertex1 == shape.Vertex1 && Vertex2 == shape.Vertex2 && Vertex3 == shape.Vertex3); " is 186.
Long Statement,FarseerPhysics.Collision.Shapes,PolygonShape,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\PolygonShape.cs,ComputeProperties,The length of the statement  "	MassData.Inertia += MassData.Mass * (Vector2.Dot (MassData.Centroid' MassData.Centroid) - Vector2.Dot (center' center)); " is 120.
Long Statement,FarseerPhysics.Collision.Shapes,PolygonShape,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\PolygonShape.cs,ComputeSubmergedArea,The length of the statement  "	Vector2 intoVec = new Vector2 (Vertices [intoIndex].X * (1 - intoLambda) + Vertices [intoIndex2].X * intoLambda' Vertices [intoIndex].Y * (1 - intoLambda) + Vertices [intoIndex2].Y * intoLambda); " is 195.
Long Statement,FarseerPhysics.Collision.Shapes,PolygonShape,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\PolygonShape.cs,ComputeSubmergedArea,The length of the statement  "	Vector2 outoVec = new Vector2 (Vertices [outoIndex].X * (1 - outoLambda) + Vertices [outoIndex2].X * outoLambda' Vertices [outoIndex].Y * (1 - outoLambda) + Vertices [outoIndex2].Y * outoLambda); " is 195.
Long Statement,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The length of the statement  "		if (MathUtils.Area (ref deque [qfm1]' ref deque [qf]' ref nextPt) > 0 && MathUtils.Area (ref deque [qb]' ref deque [qbm1]' ref nextPt) > 0) " is 139.
Long Statement,Microsoft.Xna.Framework,Curve,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Curve.cs,GetCurvePosition,The length of the statement  "			return (2 * tss - 3 * ts + 1f) * prev.Value + (tss - 2 * ts + t) * prev.TangentOut + (3 * ts - 2 * tss) * next.Value + (tss - ts) * next.TangentIn; " is 147.
Long Statement,Microsoft.Xna.Framework,CurveKey,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\CurveKey.cs,GetHashCode,The length of the statement  "	return position.GetHashCode () ^ value.GetHashCode () ^ tangentIn.GetHashCode () ^ tangentOut.GetHashCode () ^ continuity.GetHashCode (); " is 137.
Long Statement,Microsoft.Xna.Framework,CurveKeyCollection,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\CurveKeyCollection.cs,RemoveAt,The length of the statement  "		throw new ArgumentOutOfRangeException ("Index was out of range. Must be non-negative and less than the size of the collection.\r\nParameter name: index"' (Exception)null); " is 171.
Long Statement,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,CatmullRom,The length of the statement  "	return (float)(0.5 * (2.0 * value2 + (value3 - value1) * amount + (2.0 * value1 - 5.0 * value2 + 4.0 * value3 - value4) * amountSquared + (3.0 * value2 - value1 - 3.0 * value3 + value4) * amountCubed)); " is 202.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,CreatePerspectiveFieldOfView,The length of the statement  "		throw new ArgumentOutOfRangeException ("fieldOfView"' "fieldOfView takes a value between 0 and Pi (180 degrees) in radians."); " is 126.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,CreatePerspectiveFieldOfView,The length of the statement  "		throw new ArgumentOutOfRangeException ("nearPlaneDistance"' "You should specify positive value for nearPlaneDistance."); " is 120.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,CreatePerspectiveFieldOfView,The length of the statement  "		throw new ArgumentOutOfRangeException ("nearPlaneDistance"' "Near plane distance is larger than Far plane distance. Near plane distance must be smaller than Far plane distance."); " is 179.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,Multiply,The length of the statement  "	result.M11 = matrix1.M11 * matrix2.M11 + matrix1.M12 * matrix2.M21 + matrix1.M13 * matrix2.M31 + matrix1.M14 * matrix2.M41; " is 123.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,Multiply,The length of the statement  "	result.M12 = matrix1.M11 * matrix2.M12 + matrix1.M12 * matrix2.M22 + matrix1.M13 * matrix2.M32 + matrix1.M14 * matrix2.M42; " is 123.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,Multiply,The length of the statement  "	result.M13 = matrix1.M11 * matrix2.M13 + matrix1.M12 * matrix2.M23 + matrix1.M13 * matrix2.M33 + matrix1.M14 * matrix2.M43; " is 123.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,Multiply,The length of the statement  "	result.M14 = matrix1.M11 * matrix2.M14 + matrix1.M12 * matrix2.M24 + matrix1.M13 * matrix2.M34 + matrix1.M14 * matrix2.M44; " is 123.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,Multiply,The length of the statement  "	result.M21 = matrix1.M21 * matrix2.M11 + matrix1.M22 * matrix2.M21 + matrix1.M23 * matrix2.M31 + matrix1.M24 * matrix2.M41; " is 123.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,Multiply,The length of the statement  "	result.M22 = matrix1.M21 * matrix2.M12 + matrix1.M22 * matrix2.M22 + matrix1.M23 * matrix2.M32 + matrix1.M24 * matrix2.M42; " is 123.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,Multiply,The length of the statement  "	result.M23 = matrix1.M21 * matrix2.M13 + matrix1.M22 * matrix2.M23 + matrix1.M23 * matrix2.M33 + matrix1.M24 * matrix2.M43; " is 123.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,Multiply,The length of the statement  "	result.M24 = matrix1.M21 * matrix2.M14 + matrix1.M22 * matrix2.M24 + matrix1.M23 * matrix2.M34 + matrix1.M24 * matrix2.M44; " is 123.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,Multiply,The length of the statement  "	result.M31 = matrix1.M31 * matrix2.M11 + matrix1.M32 * matrix2.M21 + matrix1.M33 * matrix2.M31 + matrix1.M34 * matrix2.M41; " is 123.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,Multiply,The length of the statement  "	result.M32 = matrix1.M31 * matrix2.M12 + matrix1.M32 * matrix2.M22 + matrix1.M33 * matrix2.M32 + matrix1.M34 * matrix2.M42; " is 123.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,Multiply,The length of the statement  "	result.M33 = matrix1.M31 * matrix2.M13 + matrix1.M32 * matrix2.M23 + matrix1.M33 * matrix2.M33 + matrix1.M34 * matrix2.M43; " is 123.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,Multiply,The length of the statement  "	result.M34 = matrix1.M31 * matrix2.M14 + matrix1.M32 * matrix2.M24 + matrix1.M33 * matrix2.M34 + matrix1.M34 * matrix2.M44; " is 123.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,Multiply,The length of the statement  "	result.M41 = matrix1.M41 * matrix2.M11 + matrix1.M42 * matrix2.M21 + matrix1.M43 * matrix2.M31 + matrix1.M44 * matrix2.M41; " is 123.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,Multiply,The length of the statement  "	result.M42 = matrix1.M41 * matrix2.M12 + matrix1.M42 * matrix2.M22 + matrix1.M43 * matrix2.M32 + matrix1.M44 * matrix2.M42; " is 123.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,Multiply,The length of the statement  "	result.M43 = matrix1.M41 * matrix2.M13 + matrix1.M42 * matrix2.M23 + matrix1.M43 * matrix2.M33 + matrix1.M44 * matrix2.M43; " is 123.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,Multiply,The length of the statement  "	result.M44 = matrix1.M41 * matrix2.M14 + matrix1.M42 * matrix2.M24 + matrix1.M43 * matrix2.M34 + matrix1.M44 * matrix2.M44; " is 123.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,Determinant,The length of the statement  "	return M11 * (M22 * minor6 - M23 * minor5 + M24 * minor4) - M12 * (M21 * minor6 - M23 * minor3 + M24 * minor2) + M13 * (M21 * minor5 - M22 * minor3 + M24 * minor1) - M14 * (M21 * minor4 - M22 * minor2 + M23 * minor1); " is 217.
Long Statement,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,ToString,The length of the statement  "	return "{ {M11:" + M11 + " M12:" + M12 + " M13:" + M13 + " M14:" + M14 + "}" + " {M21:" + M21 + " M22:" + M22 + " M23:" + M23 + " M24:" + M24 + "}" + " {M31:" + M31 + " M32:" + M32 + " M33:" + M33 + " M34:" + M34 + "}" + " {M41:" + M41 + " M42:" + M42 + " M43:" + M43 + " M44:" + M44 + "} }"; " is 292.
Long Statement,Microsoft.Xna.Framework,Vector2,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector2.cs,Barycentric,The length of the statement  "	return new Vector2 (MathHelper.Barycentric (value1.X' value2.X' value3.X' amount1' amount2)' MathHelper.Barycentric (value1.Y' value2.Y' value3.Y' amount1' amount2)); " is 166.
Long Statement,Microsoft.Xna.Framework,Vector2,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector2.cs,Barycentric,The length of the statement  "	result = new Vector2 (MathHelper.Barycentric (value1.X' value2.X' value3.X' amount1' amount2)' MathHelper.Barycentric (value1.Y' value2.Y' value3.Y' amount1' amount2)); " is 168.
Long Statement,Microsoft.Xna.Framework,Vector2,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector2.cs,CatmullRom,The length of the statement  "	return new Vector2 (MathHelper.CatmullRom (value1.X' value2.X' value3.X' value4.X' amount)' MathHelper.CatmullRom (value1.Y' value2.Y' value3.Y' value4.Y' amount)); " is 164.
Long Statement,Microsoft.Xna.Framework,Vector2,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector2.cs,CatmullRom,The length of the statement  "	result = new Vector2 (MathHelper.CatmullRom (value1.X' value2.X' value3.X' value4.X' amount)' MathHelper.CatmullRom (value1.Y' value2.Y' value3.Y' value4.Y' amount)); " is 166.
Long Statement,Microsoft.Xna.Framework,Vector2,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector2.cs,SmoothStep,The length of the statement  "	return new Vector2 (MathHelper.SmoothStep (value1.X' value2.X' amount)' MathHelper.SmoothStep (value1.Y' value2.Y' amount)); " is 124.
Long Statement,Microsoft.Xna.Framework,Vector2,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector2.cs,SmoothStep,The length of the statement  "	result = new Vector2 (MathHelper.SmoothStep (value1.X' value2.X' amount)' MathHelper.SmoothStep (value1.Y' value2.Y' amount)); " is 126.
Long Statement,Microsoft.Xna.Framework,Vector2,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector2.cs,Transform,The length of the statement  "	result = new Vector2 ((position.X * matrix.M11) + (position.Y * matrix.M21) + matrix.M41' (position.X * matrix.M12) + (position.Y * matrix.M22) + matrix.M42); " is 158.
Long Statement,Microsoft.Xna.Framework,Vector2,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector2.cs,TransformNormal,The length of the statement  "	result = new Vector2 ((normal.X * matrix.M11) + (normal.Y * matrix.M21)' (normal.X * matrix.M12) + (normal.Y * matrix.M22)); " is 124.
Long Statement,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,Barycentric,The length of the statement  "	return new Vector3 (MathHelper.Barycentric (value1.X' value2.X' value3.X' amount1' amount2)' MathHelper.Barycentric (value1.Y' value2.Y' value3.Y' amount1' amount2)' MathHelper.Barycentric (value1.Z' value2.Z' value3.Z' amount1' amount2)); " is 239.
Long Statement,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,Barycentric,The length of the statement  "	result = new Vector3 (MathHelper.Barycentric (value1.X' value2.X' value3.X' amount1' amount2)' MathHelper.Barycentric (value1.Y' value2.Y' value3.Y' amount1' amount2)' MathHelper.Barycentric (value1.Z' value2.Z' value3.Z' amount1' amount2)); " is 241.
Long Statement,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,CatmullRom,The length of the statement  "	return new Vector3 (MathHelper.CatmullRom (value1.X' value2.X' value3.X' value4.X' amount)' MathHelper.CatmullRom (value1.Y' value2.Y' value3.Y' value4.Y' amount)' MathHelper.CatmullRom (value1.Z' value2.Z' value3.Z' value4.Z' amount)); " is 236.
Long Statement,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,CatmullRom,The length of the statement  "	result = new Vector3 (MathHelper.CatmullRom (value1.X' value2.X' value3.X' value4.X' amount)' MathHelper.CatmullRom (value1.Y' value2.Y' value3.Y' value4.Y' amount)' MathHelper.CatmullRom (value1.Z' value2.Z' value3.Z' value4.Z' amount)); " is 238.
Long Statement,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,Clamp,The length of the statement  "	return new Vector3 (MathHelper.Clamp (value1.X' min.X' max.X)' MathHelper.Clamp (value1.Y' min.Y' max.Y)' MathHelper.Clamp (value1.Z' min.Z' max.Z)); " is 149.
Long Statement,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,Clamp,The length of the statement  "	result = new Vector3 (MathHelper.Clamp (value1.X' min.X' max.X)' MathHelper.Clamp (value1.Y' min.Y' max.Y)' MathHelper.Clamp (value1.Z' min.Z' max.Z)); " is 151.
Long Statement,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,Cross,The length of the statement  "	result = new Vector3 (vector1.Y * vector2.Z - vector2.Y * vector1.Z' -(vector1.X * vector2.Z - vector2.X * vector1.Z)' vector1.X * vector2.Y - vector2.X * vector1.Y); " is 166.
Long Statement,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,DistanceSquared,The length of the statement  "	result = (value1.X - value2.X) * (value1.X - value2.X) + (value1.Y - value2.Y) * (value1.Y - value2.Y) + (value1.Z - value2.Z) * (value1.Z - value2.Z); " is 151.
Long Statement,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,Lerp,The length of the statement  "	return new Vector3 (MathHelper.Lerp (value1.X' value2.X' amount)' MathHelper.Lerp (value1.Y' value2.Y' amount)' MathHelper.Lerp (value1.Z' value2.Z' amount)); " is 158.
Long Statement,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,Lerp,The length of the statement  "	result = new Vector3 (MathHelper.Lerp (value1.X' value2.X' amount)' MathHelper.Lerp (value1.Y' value2.Y' amount)' MathHelper.Lerp (value1.Z' value2.Z' amount)); " is 160.
Long Statement,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,Max,The length of the statement  "	return new Vector3 (MathHelper.Max (value1.X' value2.X)' MathHelper.Max (value1.Y' value2.Y)' MathHelper.Max (value1.Z' value2.Z)); " is 131.
Long Statement,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,Max,The length of the statement  "	result = new Vector3 (MathHelper.Max (value1.X' value2.X)' MathHelper.Max (value1.Y' value2.Y)' MathHelper.Max (value1.Z' value2.Z)); " is 133.
Long Statement,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,Min,The length of the statement  "	return new Vector3 (MathHelper.Min (value1.X' value2.X)' MathHelper.Min (value1.Y' value2.Y)' MathHelper.Min (value1.Z' value2.Z)); " is 131.
Long Statement,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,Min,The length of the statement  "	result = new Vector3 (MathHelper.Min (value1.X' value2.X)' MathHelper.Min (value1.Y' value2.Y)' MathHelper.Min (value1.Z' value2.Z)); " is 133.
Long Statement,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,SmoothStep,The length of the statement  "	return new Vector3 (MathHelper.SmoothStep (value1.X' value2.X' amount)' MathHelper.SmoothStep (value1.Y' value2.Y' amount)' MathHelper.SmoothStep (value1.Z' value2.Z' amount)); " is 176.
Long Statement,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,SmoothStep,The length of the statement  "	result = new Vector3 (MathHelper.SmoothStep (value1.X' value2.X' amount)' MathHelper.SmoothStep (value1.Y' value2.Y' amount)' MathHelper.SmoothStep (value1.Z' value2.Z' amount)); " is 178.
Long Statement,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,Transform,The length of the statement  "	result = new Vector3 ((position.X * matrix.M11) + (position.Y * matrix.M21) + (position.Z * matrix.M31) + matrix.M41' (position.X * matrix.M12) + (position.Y * matrix.M22) + (position.Z * matrix.M32) + matrix.M42' (position.X * matrix.M13) + (position.Y * matrix.M23) + (position.Z * matrix.M33) + matrix.M43); " is 310.
Long Statement,Microsoft.Xna.Framework,Vector3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vector3.cs,TransformNormal,The length of the statement  "	result = new Vector3 ((normal.X * matrix.M11) + (normal.Y * matrix.M21) + (normal.Z * matrix.M31)' (normal.X * matrix.M12) + (normal.Y * matrix.M22) + (normal.Z * matrix.M32)' (normal.X * matrix.M13) + (normal.Y * matrix.M23) + (normal.Z * matrix.M33)); " is 253.
Long Statement,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The length of the statement  "				if (Left (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)) && RightOn (At (i - 1' vertices)' At (i' vertices)' At (j - 1' vertices))) { " is 144.
Long Statement,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The length of the statement  "				if (Left (At (i + 1' vertices)' At (i' vertices)' At (j + 1' vertices)) && RightOn (At (i + 1' vertices)' At (i' vertices)' At (j' vertices))) { " is 144.
Long Statement,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The length of the statement  "							if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices))) " is 140.
Long Statement,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,CanSee,The length of the statement  "		if (LeftOn (At (i' vertices)' At (i - 1' vertices)' At (j' vertices)) && RightOn (At (i' vertices)' At (i + 1' vertices)' At (j' vertices))) " is 140.
Long Statement,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,CanSee,The length of the statement  "		if (RightOn (At (i' vertices)' At (i + 1' vertices)' At (j' vertices)) || LeftOn (At (i' vertices)' At (i - 1' vertices)' At (j' vertices))) " is 140.
Long Statement,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,CanSee,The length of the statement  "		if (LeftOn (At (j' vertices)' At (j - 1' vertices)' At (i' vertices)) && RightOn (At (j' vertices)' At (j + 1' vertices)' At (i' vertices))) " is 140.
Long Statement,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,CanSee,The length of the statement  "		if (RightOn (At (j' vertices)' At (j + 1' vertices)' At (i' vertices)) || LeftOn (At (j' vertices)' At (j - 1' vertices)' At (i' vertices))) " is 140.
Long Statement,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,CanSee,The length of the statement  "		if (LineTools.LineIntersect (At (i' vertices)' At (j' vertices)' At (k' vertices)' At (k + 1' vertices)' out intersectionPoint)) " is 128.
Long Statement,FarseerPhysics.Common.Decomposition,Triangulate,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Triangulate.cs,ConvexPartition,The length of the statement  "			Debug.Assert (vertices.IsCounterClockWise ()' "The polygon is not counter clockwise. This is needed for Bayazit to work correctly."); " is 133.
Long Statement,FarseerPhysics.Common.Decomposition,Triangulate,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Triangulate.cs,ConvexPartition,The length of the statement  "			Debug.Assert (vertices.IsCounterClockWise ()' "The polygon is not counter clockwise. This is needed for Bayazit to work correctly."); " is 133.
Long Statement,FarseerPhysics.Common.Decomposition,Triangulate,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Triangulate.cs,ValidatePolygon,The length of the statement  "	if (errorCode == PolygonError.InvalidAmountOfVertices || errorCode == PolygonError.AreaTooSmall || errorCode == PolygonError.SideTooSmall || errorCode == PolygonError.NotSimple) " is 177.
Long Statement,FarseerPhysics.Common.Decomposition.CDT.Polygon,Polygon,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Polygon\Polygon.cs,InsertPointAfter,The length of the statement  "		throw new ArgumentException ("Tried to insert a point into a Polygon after a point not belonging to the Polygon"' "point"); " is 123.
Long Statement,FarseerPhysics.Common,LineTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\LineTools.cs,LineIntersect,The length of the statement  "	return LineIntersect (ref point1' ref point2' ref point3' ref point4' firstIsSegment' secondIsSegment' out intersectionPoint); " is 126.
Long Statement,FarseerPhysics.Common,Mat33,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Math.cs,Solve33,The length of the statement  "	return new Vector3 (det * Vector3.Dot (b' Vector3.Cross (ey' ez))' det * Vector3.Dot (ex' Vector3.Cross (b' ez))' det * Vector3.Dot (ex' Vector3.Cross (ey' b))); " is 161.
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateRoundedRectangle,The length of the statement  "			vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase)))); " is 147.
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateCapsule,The length of the statement  "		throw new ArgumentException ("The radius must be lower than height / 2. Higher values of radius would create a circle' and not a half circle."' "endRadius"); " is 157.
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateCapsule,The length of the statement  "		throw new ArgumentException ("The top radius must be lower than height / 2. Higher values of top radius would create a circle' and not a half circle."' "topRadius"); " is 165.
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateCapsule,The length of the statement  "		throw new ArgumentException ("The bottom radius must be lower than height / 2. Higher values of bottom radius would create a circle' and not a half circle."' "bottomRadius"); " is 174.
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateCapsule,The length of the statement  "		vertices.Add (new Vector2 (topRadius * (float)Math.Cos (stepSize * i)' topRadius * (float)Math.Sin (stepSize * i) + newHeight)); " is 128.
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateCapsule,The length of the statement  "		vertices.Add (new Vector2 (-bottomRadius * (float)Math.Cos (stepSize * i)' -bottomRadius * (float)Math.Sin (stepSize * i) - newHeight)); " is 136.
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateGear,The length of the statement  "			vertices.Add (new Vector2 (radius * (float)Math.Cos (stepSize * i + toothAngleStepSize * 2f + toothTipStepSize)' -radius * (float)Math.Sin (stepSize * i + toothAngleStepSize * 2f + toothTipStepSize))); " is 201.
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateGear,The length of the statement  "			vertices.Add (new Vector2 ((radius + toothHeight) * (float)Math.Cos (stepSize * i + toothAngleStepSize + toothTipStepSize)' -(radius + toothHeight) * (float)Math.Sin (stepSize * i + toothAngleStepSize + toothTipStepSize))); " is 223.
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateGear,The length of the statement  "		vertices.Add (new Vector2 ((radius + toothHeight) * (float)Math.Cos (stepSize * i + toothAngleStepSize)' -(radius + toothHeight) * (float)Math.Sin (stepSize * i + toothAngleStepSize))); " is 185.
Long Statement,FarseerPhysics.Common,Vertices,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vertices.cs,Translate,The length of the statement  "	Debug.Assert (!AttachedToBody' "Translating vertices that are used by a Body can result in unstable behavior. Use Body.Position instead."); " is 139.
Long Statement,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The length of the statement  "			if ((_data.Count > 1) && (i == valIndex - 1) && (_data.Last ().Body == _data.First ().Body) && (_data.Last ().Max == _data.First ().Min)) { " is 139.
Long Statement,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The length of the statement  "		for (float j = _data [i].Min + first; j < _data [i].Max || MathUtils.FloatEquals (j' _data [i].Max' 0.0001f); j += offset) { " is 124.
Long Statement,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The length of the statement  "				float impulse = (arclen / (MinRays + insertedRays)) * maxForce * 180.0f / MathHelper.Pi * (1.0f - Math.Min (1.0f' minlambda)); " is 126.
Long Statement,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The length of the statement  "				Vector2 vectImp = Vector2.Dot (impulse * new Vector2 ((float)Math.Cos (j)' (float)Math.Sin (j))' -ro.Normal) * new Vector2 ((float)Math.Cos (j)' (float)Math.Sin (j)); " is 166.
Long Statement,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The length of the statement  "		if (Vector2.Dot (MathUtils.Cross (localExitPoint - localEntryPoint' 1)' vertices [i] - localEntryPoint) > Settings.Epsilon) " is 123.
Long Statement,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\YuPengClipper.cs,Execute,The length of the statement  "	Debug.Assert (subject.IsSimple () && clip.IsSimple ()' "Non simple input!"' "Input polygons must be simple (cannot intersect themselves)."); " is 140.
Long Statement,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\YuPengClipper.cs,PointOnLineSegment,The length of the statement  "	return MathUtils.Area (ref start' ref end' ref point) == 0f && Vector2.Dot (point - start' segment) >= 0f && Vector2.Dot (point - end' segment) <= 0f; " is 150.
Long Statement,FarseerPhysics.Common.TextureTools,Terrain,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\Terrain.cs,GenerateTerrain,The length of the statement  "	List<Vertices> polys = MarchingSquares.DetectSquares (new AABB (new Vector2 (ax' ay)' new Vector2 (ax + CellSize' ay + CellSize))' SubCellSize' SubCellSize' _terrainMap' Iterations' true); " is 188.
Long Statement,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SetTextureData,The length of the statement  "		throw new ArgumentOutOfRangeException ("data"' "'data' length can't be less then 4. Your texture must be at least 2 x 2 pixels in size."); " is 138.
Long Statement,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SetTextureData,The length of the statement  "		throw new ArgumentOutOfRangeException ("width"' "'width' can't be less then 2. Your texture must be at least 2 x 2 pixels in size."); " is 133.
Long Statement,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The length of the statement  "		throw new Exception ("'_data' can't be null. You have to use SetTextureData(uint[] data' int width) before calling this method."); " is 130.
Long Statement,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The length of the statement  "		throw new Exception ("'_data' length can't be less then 4. Your texture must be at least 2 x 2 pixels in size. " + "You have to use SetTextureData(uint[] data' int width) before calling this method."); " is 201.
Long Statement,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The length of the statement  "		throw new Exception ("'_width' can't be less then 2. Your texture must be at least 2 x 2 pixels in size. " + "You have to use SetTextureData(uint[] data' int width) before calling this method."); " is 195.
Long Statement,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The length of the statement  "		throw new Exception ("'_width' has an invalid value. You have to use SetTextureData(uint[] data' int width) before calling this method."); " is 138.
Long Statement,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The length of the statement  "			polygon = new Vertices (CreateSimplePolygon (polygonEntrance.Value' new Vector2 (polygonEntrance.Value.X - 1f' polygonEntrance.Value.Y))); " is 138.
Long Statement,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The length of the statement  "							Vertices holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y)); " is 126.
Long Statement,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DistanceToHullAcceptable,The length of the statement  "			if (LineTools.DistanceBetweenPointAndLineSegment (ref point' ref edgeVertex1' ref edgeVertex2) <= _hullTolerance || Vector2.Distance (point' edgeVertex1) <= _hullTolerance) " is 172.
Long Statement,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchForOutstandingVertex,The length of the statement  "			if (LineTools.DistanceBetweenPointAndLineSegment (ref tempVector1' ref tempVector2' ref tempVector3) >= _hullTolerance) { " is 121.
Long Statement,FarseerPhysics.Controllers,SimpleWindForce,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Controllers\SimpleWindForce.cs,ApplyForce,The length of the statement  "			//forceVector = Vector2.Transform(forceVector' Matrix.CreateRotationZ((MathHelper.Pi - MathHelper.Pi/2) * (float)Randomize.NextDouble())); " is 138.
Long Statement,FarseerPhysics.Dynamics,Body,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Body.cs,GetLinearVelocityFromWorldPoint,The length of the statement  "	return _linearVelocity + new Vector2 (-_angularVelocity * (worldPoint.Y - _sweep.C.Y)' _angularVelocity * (worldPoint.X - _sweep.C.X)); " is 135.
Long Statement,FarseerPhysics.Dynamics,ContactManager,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\ContactManager.cs,ShouldCollide,The length of the statement  "		if ((fixtureA.CollisionGroup == fixtureB.CollisionGroup) && fixtureA.CollisionGroup != 0 && fixtureB.CollisionGroup != 0) " is 121.
Long Statement,FarseerPhysics.Dynamics,ContactManager,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\ContactManager.cs,ShouldCollide,The length of the statement  "		if (((fixtureA.CollisionCategories & fixtureB.CollidesWith) == Category.None) & ((fixtureB.CollisionCategories & fixtureA.CollidesWith) == Category.None)) " is 154.
Long Statement,FarseerPhysics.Dynamics,ContactManager,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\ContactManager.cs,ShouldCollide,The length of the statement  "	bool collide = (fixtureA.CollidesWith & fixtureB.CollisionCategories) != 0 && (fixtureA.CollisionCategories & fixtureB.CollidesWith) != 0; " is 138.
Long Statement,FarseerPhysics.Dynamics,Fixture,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Fixture.cs,CompareTo,The length of the statement  "	return (_collidesWith == fixture._collidesWith && _collisionCategories == fixture._collisionCategories && _collisionGroup == fixture._collisionGroup && Friction == fixture.Friction && IsSensor == fixture.IsSensor && Restitution == fixture.Restitution && UserData == fixture.UserData && IgnoreCCDWith == fixture.IgnoreCCDWith && SequenceEqual (_collisionIgnores' fixture._collisionIgnores)); " is 390.
Long Statement,FarseerPhysics.Dynamics,Island,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Island.cs,Solve,The length of the statement  "			if (!b.SleepingAllowed || b._angularVelocity * b._angularVelocity > AngTolSqr || Vector2.Dot (b._linearVelocity' b._linearVelocity) > LinTolSqr) { " is 146.
Long Statement,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,SolveTOI,The length of the statement  "				bool collideA = (bA.IsBullet || typeA != BodyType.Dynamic) && ((fA.IgnoreCCDWith & fB.CollisionCategories) == 0) && !bA.IgnoreCCD; " is 130.
Long Statement,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,SolveTOI,The length of the statement  "				bool collideB = (bB.IsBullet || typeB != BodyType.Dynamic) && ((fB.IgnoreCCDWith & fA.CollisionCategories) == 0) && !bB.IgnoreCCD; " is 130.
Long Statement,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,RemoveBody,The length of the statement  "	Debug.Assert (!_bodyRemoveList.Contains (body)' "The body is already marked for removal. You are removing the body more than once."); " is 133.
Long Statement,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,RemoveJoint,The length of the statement  "		Debug.Assert (!_jointRemoveList.Contains (joint)' "The joint is already marked for removal. You are removing the joint more than once."); " is 137.
Long Statement,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,Step,The length of the statement  "		ContinuousPhysicsTime = _watch.ElapsedTicks - (AddRemoveTime + NewContactsTime + ControllersUpdateTime + ContactsUpdateTime + SolveUpdateTime); " is 143.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\Contact.cs,GetWorldManifold,The length of the statement  "	ContactSolver.WorldManifold.Initialize (ref Manifold' ref bodyA._xf' shapeA.Radius' ref bodyB._xf' shapeB.Radius' out normal' out points); " is 138.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\Contact.cs,Evaluate,The length of the statement  "		Collision.Collision.CollidePolygons (ref manifold' (PolygonShape)FixtureA.Shape' ref transformA' (PolygonShape)FixtureB.Shape' ref transformB); " is 143.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\Contact.cs,Evaluate,The length of the statement  "		Collision.Collision.CollidePolygonAndCircle (ref manifold' (PolygonShape)FixtureA.Shape' ref transformA' (CircleShape)FixtureB.Shape' ref transformB); " is 150.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\Contact.cs,Evaluate,The length of the statement  "		Collision.Collision.CollideEdgeAndCircle (ref manifold' (EdgeShape)FixtureA.Shape' ref transformA' (CircleShape)FixtureB.Shape' ref transformB); " is 144.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\Contact.cs,Evaluate,The length of the statement  "		Collision.Collision.CollideEdgeAndPolygon (ref manifold' (EdgeShape)FixtureA.Shape' ref transformA' (PolygonShape)FixtureB.Shape' ref transformB); " is 146.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\Contact.cs,Evaluate,The length of the statement  "		Collision.Collision.CollideEdgeAndCircle (ref manifold' _edge' ref transformA' (CircleShape)FixtureB.Shape' ref transformB); " is 124.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\Contact.cs,Evaluate,The length of the statement  "		Collision.Collision.CollideEdgeAndPolygon (ref manifold' _edge' ref transformA' (PolygonShape)FixtureB.Shape' ref transformB); " is 126.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\Contact.cs,Evaluate,The length of the statement  "		Collision.Collision.CollideCircles (ref manifold' (CircleShape)FixtureA.Shape' ref transformA' (CircleShape)FixtureB.Shape' ref transformB); " is 140.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\Contact.cs,Create,The length of the statement  "		if ((type1 >= type2 || (type1 == ShapeType.Edge && type2 == ShapeType.Polygon)) && !(type2 == ShapeType.Edge && type1 == ShapeType.Polygon)) { " is 142.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\Contact.cs,Create,The length of the statement  "		if ((type1 >= type2 || (type1 == ShapeType.Edge && type2 == ShapeType.Polygon)) && !(type2 == ShapeType.Edge && type1 == ShapeType.Polygon)) { " is 142.
Long Statement,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The length of the statement  "			// In order to account of the accumulated impulse 'a' (because of the iterative nature of the solver which only requires " is 120.
Long Statement,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\ContactSolver.cs,SolvePositionConstraints,The length of the statement  "			float C = MathUtils.Clamp (Settings.Baumgarte * (separation + Settings.LinearSlop)' -Settings.MaxLinearCorrection' 0.0f); " is 121.
Long Statement,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\ContactSolver.cs,SolveTOIPositionConstraints,The length of the statement  "			float C = MathUtils.Clamp (Settings.Baumgarte * (separation + Settings.LinearSlop)' -Settings.MaxLinearCorrection' 0.0f); " is 121.
Long Statement,FarseerPhysics.Dynamics.Joints,Joint,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Joints\Joint.cs,IsFixedType,The length of the statement  "	return JointType == JointType.FixedRevolute || JointType == JointType.FixedDistance || JointType == JointType.FixedPrismatic || JointType == JointType.FixedLine || JointType == JointType.FixedMouse || JointType == JointType.FixedAngle || JointType == JointType.FixedFriction; " is 275.
Long Statement,FarseerPhysics.Dynamics.Joints,MotorJoint,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Joints\MotorJoint.cs,SolveVelocityConstraints,The length of the statement  "		Vector2 Cdot = vB + MathUtils.Cross (wB' _rB) - vA - MathUtils.Cross (wA' _rA) + inv_h * CorrectionFactor * _linearError; " is 121.
Long Statement,FarseerPhysics.Factories,JointFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\JointFactory.cs,CreatePulleyJoint,The length of the statement  "	PulleyJoint pulleyJoint = new PulleyJoint (bodyA' bodyB' anchorA' anchorB' worldAnchorA' worldAnchorB' ratio' useWorldCoordinates); " is 131.
Long Statement,FarseerPhysics.Factories,LinkFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\LinkFactory.cs,CreateChain,The length of the statement  "	List<Body> chainLinks = PathManager.EvenlyDistributeShapesAlongPath (world' path' shape' BodyType.Dynamic' numberOfLinks); " is 122.
Long Statement,FarseerPhysics.Factories,LinkFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\LinkFactory.cs,CreateChain,The length of the statement  "	PathManager.AttachBodiesWithRevoluteJoint (world' chainLinks' new Vector2 (0' -linkHeight)' new Vector2 (0' linkHeight)' false' false); " is 135.
Complex Conditional,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,CanSee,The conditional expression  "(k + 1) % vertices.Count == i || k == i || (k + 1) % vertices.Count == j || k == j"  is complex.
Complex Conditional,FarseerPhysics.Common.Decomposition,Triangulate,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Triangulate.cs,ValidatePolygon,The conditional expression  "errorCode == PolygonError.InvalidAmountOfVertices || errorCode == PolygonError.AreaTooSmall || errorCode == PolygonError.SideTooSmall || errorCode == PolygonError.NotSimple"  is complex.
Complex Conditional,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The conditional expression  "(p1 == Points [2] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [2])"  is complex.
Complex Conditional,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The conditional expression  "(p1 == Points [0] && p2 == Points [2]) || (p1 == Points [2] && p2 == Points [0])"  is complex.
Complex Conditional,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The conditional expression  "(p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])"  is complex.
Complex Conditional,FarseerPhysics.Common,LineTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\LineTools.cs,LineIntersect2,The conditional expression  "a0 == b0 || a0 == b1 || a1 == b0 || a1 == b1"  is complex.
Complex Conditional,FarseerPhysics.Common,LineTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\LineTools.cs,LineIntersect2,The conditional expression  "(0 < ua) && (ua < 1) && (0 < ub) && (ub < 1)"  is complex.
Complex Conditional,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The conditional expression  "(_data.Count > 1) && (i == valIndex - 1) && (_data.Last ().Body == _data.First ().Body) && (_data.Last ().Max == _data.First ().Min)"  is complex.
Complex Conditional,FarseerPhysics.Common.TextureTools,Terrain,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\Terrain.cs,ApplyData,The conditional expression  "x + offset.X >= 0 && x + offset.X < _localWidth && y + offset.Y >= 0 && y + offset.Y < _localHeight"  is complex.
Complex Conditional,FarseerPhysics.Common.TextureTools,Terrain,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\Terrain.cs,ModifyTerrain,The conditional expression  "p.X >= 0 && p.X < _localWidth && p.Y >= 0 && p.Y < _localHeight"  is complex.
Complex Conditional,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,IsSolid,The conditional expression  "_tempIsSolidX >= 0 && _tempIsSolidX < _width && _tempIsSolidY >= 0 && _tempIsSolidY < _height"  is complex.
Complex Conditional,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,IsSolid,The conditional expression  "x >= 0 && x < _width && y >= 0 && y < _height"  is complex.
Complex Conditional,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The conditional expression  "startY > 0 && startY < _height && endY > 0 && endY < _height"  is complex.
Complex Conditional,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchCrossingEdges,The conditional expression  "(vertex1.Y >= y && vertex2.Y <= y) || (vertex1.Y <= y && vertex2.Y >= y)"  is complex.
Complex Conditional,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,IsNearPixel,The conditional expression  "x >= 0 && x <= _width && y >= 0 && y <= _height"  is complex.
Complex Conditional,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetNextHullPoint,The conditional expression  "x >= 0 && x < _width && y >= 0 && y <= _height"  is complex.
Complex Conditional,FarseerPhysics.Controllers,GravityController,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Controllers\GravityController.cs,Update,The conditional expression  "worldBody == controllerBody || (worldBody.IsStatic && controllerBody.IsStatic) || !controllerBody.Enabled"  is complex.
Complex Conditional,FarseerPhysics.Dynamics,ContactManager,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\ContactManager.cs,AddPair,The conditional expression  "fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB"  is complex.
Complex Conditional,FarseerPhysics.Dynamics,ContactManager,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\ContactManager.cs,AddPair,The conditional expression  "fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA"  is complex.
Complex Conditional,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\Contact.cs,Create,The conditional expression  "(type1 >= type2 || (type1 == ShapeType.Edge && type2 == ShapeType.Polygon)) && !(type2 == ShapeType.Edge && type1 == ShapeType.Polygon)"  is complex.
Complex Conditional,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\Contact.cs,Create,The conditional expression  "(type1 >= type2 || (type1 == ShapeType.Edge && type2 == ShapeType.Polygon)) && !(type2 == ShapeType.Edge && type1 == ShapeType.Polygon)"  is complex.
Virtual Method Call from Constructor,FarseerPhysics.Dynamics,Fixture,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Fixture.cs,Fixture,The constructor "Fixture" calls a virtual method "Clone".
Magic Number,FarseerPhysics.Collision,AABB,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,AABB,The following statement contains a magic number: LowerBound = center - new Vector2 (width / 2' height / 2);  
Magic Number,FarseerPhysics.Collision,AABB,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,AABB,The following statement contains a magic number: LowerBound = center - new Vector2 (width / 2' height / 2);  
Magic Number,FarseerPhysics.Collision,AABB,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,AABB,The following statement contains a magic number: UpperBound = center + new Vector2 (width / 2' height / 2);  
Magic Number,FarseerPhysics.Collision,AABB,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,AABB,The following statement contains a magic number: UpperBound = center + new Vector2 (width / 2' height / 2);  
Magic Number,FarseerPhysics.Collision,AABB,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,RayCast,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {  	float absD_i = i == 0 ? absD.X : absD.Y;  	float lowerBound_i = i == 0 ? LowerBound.X : LowerBound.Y;  	float upperBound_i = i == 0 ? UpperBound.X : UpperBound.Y;  	float p_i = i == 0 ? p.X : p.Y;  	if (absD_i < Settings.Epsilon) {  		// Parallel.  		if (p_i < lowerBound_i || upperBound_i < p_i) {  			return false;  		}  	}  	else {  		float d_i = i == 0 ? d.X : d.Y;  		float inv_d = 1.0f / d_i;  		float t1 = (lowerBound_i - p_i) * inv_d;  		float t2 = (upperBound_i - p_i) * inv_d;  		// Sign of the normal vector.  		float s = -1.0f;  		if (t1 > t2) {  			MathUtils.Swap (ref t1' ref t2);  			s = 1.0f;  		}  		// Push the min up  		if (t1 > tmin) {  			if (i == 0) {  				normal.X = s;  			}  			else {  				normal.Y = s;  			}  			tmin = t1;  		}  		// Pull the max down  		tmax = Math.Min (tmax' t2);  		if (tmin > tmax) {  			return false;  		}  	}  }  
Magic Number,FarseerPhysics.Collision,Collision,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,CollidePolygons,The following statement contains a magic number: if (np < 2)  	return;  
Magic Number,FarseerPhysics.Collision,Collision,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Collision.cs,CollidePolygons,The following statement contains a magic number: if (np < 2) {  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,ReadCache,The following statement contains a magic number: Debug.Assert (cache.Count <= 3);  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,GetSearchDirection,The following statement contains a magic number: switch (Count) {  case 1:  	return -V [0].W;  case 2: {  	Vector2 e12 = V [1].W - V [0].W;  	float sgn = MathUtils.Cross (e12' -V [0].W);  	if (sgn > 0.0f) {  		// Origin is left of e12.  		return new Vector2 (-e12.Y' e12.X);  	}  	else {  		// Origin is right of e12.  		return new Vector2 (e12.Y' -e12.X);  	}  }  default:  	Debug.Assert (false);  	return Vector2.Zero;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,GetClosestPoint,The following statement contains a magic number: switch (Count) {  case 0:  	Debug.Assert (false);  	return Vector2.Zero;  case 1:  	return V [0].W;  case 2:  	return V [0].A * V [0].W + V [1].A * V [1].W;  case 3:  	return Vector2.Zero;  default:  	Debug.Assert (false);  	return Vector2.Zero;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,GetClosestPoint,The following statement contains a magic number: switch (Count) {  case 0:  	Debug.Assert (false);  	return Vector2.Zero;  case 1:  	return V [0].W;  case 2:  	return V [0].A * V [0].W + V [1].A * V [1].W;  case 3:  	return Vector2.Zero;  default:  	Debug.Assert (false);  	return Vector2.Zero;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,GetWitnessPoints,The following statement contains a magic number: switch (Count) {  case 0:  	pA = Vector2.Zero;  	pB = Vector2.Zero;  	Debug.Assert (false);  	break;  case 1:  	pA = V [0].WA;  	pB = V [0].WB;  	break;  case 2:  	pA = V [0].A * V [0].WA + V [1].A * V [1].WA;  	pB = V [0].A * V [0].WB + V [1].A * V [1].WB;  	break;  case 3:  	pA = V [0].A * V [0].WA + V [1].A * V [1].WA + V [2].A * V [2].WA;  	pB = pA;  	break;  default:  	throw new Exception ();  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,GetWitnessPoints,The following statement contains a magic number: switch (Count) {  case 0:  	pA = Vector2.Zero;  	pB = Vector2.Zero;  	Debug.Assert (false);  	break;  case 1:  	pA = V [0].WA;  	pB = V [0].WB;  	break;  case 2:  	pA = V [0].A * V [0].WA + V [1].A * V [1].WA;  	pB = V [0].A * V [0].WB + V [1].A * V [1].WB;  	break;  case 3:  	pA = V [0].A * V [0].WA + V [1].A * V [1].WA + V [2].A * V [2].WA;  	pB = pA;  	break;  default:  	throw new Exception ();  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,GetWitnessPoints,The following statement contains a magic number: switch (Count) {  case 0:  	pA = Vector2.Zero;  	pB = Vector2.Zero;  	Debug.Assert (false);  	break;  case 1:  	pA = V [0].WA;  	pB = V [0].WB;  	break;  case 2:  	pA = V [0].A * V [0].WA + V [1].A * V [1].WA;  	pB = V [0].A * V [0].WB + V [1].A * V [1].WB;  	break;  case 3:  	pA = V [0].A * V [0].WA + V [1].A * V [1].WA + V [2].A * V [2].WA;  	pB = pA;  	break;  default:  	throw new Exception ();  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,GetWitnessPoints,The following statement contains a magic number: switch (Count) {  case 0:  	pA = Vector2.Zero;  	pB = Vector2.Zero;  	Debug.Assert (false);  	break;  case 1:  	pA = V [0].WA;  	pB = V [0].WB;  	break;  case 2:  	pA = V [0].A * V [0].WA + V [1].A * V [1].WA;  	pB = V [0].A * V [0].WB + V [1].A * V [1].WB;  	break;  case 3:  	pA = V [0].A * V [0].WA + V [1].A * V [1].WA + V [2].A * V [2].WA;  	pB = pA;  	break;  default:  	throw new Exception ();  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,GetWitnessPoints,The following statement contains a magic number: pA = V [0].A * V [0].WA + V [1].A * V [1].WA + V [2].A * V [2].WA;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,GetWitnessPoints,The following statement contains a magic number: pA = V [0].A * V [0].WA + V [1].A * V [1].WA + V [2].A * V [2].WA;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,GetMetric,The following statement contains a magic number: switch (Count) {  case 0:  	Debug.Assert (false);  	return 0.0f;  case 1:  	return 0.0f;  case 2:  	return (V [0].W - V [1].W).Length ();  case 3:  	return MathUtils.Cross (V [1].W - V [0].W' V [2].W - V [0].W);  default:  	Debug.Assert (false);  	return 0.0f;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,GetMetric,The following statement contains a magic number: switch (Count) {  case 0:  	Debug.Assert (false);  	return 0.0f;  case 1:  	return 0.0f;  case 2:  	return (V [0].W - V [1].W).Length ();  case 3:  	return MathUtils.Cross (V [1].W - V [0].W' V [2].W - V [0].W);  default:  	Debug.Assert (false);  	return 0.0f;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,GetMetric,The following statement contains a magic number: switch (Count) {  case 0:  	Debug.Assert (false);  	return 0.0f;  case 1:  	return 0.0f;  case 2:  	return (V [0].W - V [1].W).Length ();  case 3:  	return MathUtils.Cross (V [1].W - V [0].W' V [2].W - V [0].W);  default:  	Debug.Assert (false);  	return 0.0f;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,GetMetric,The following statement contains a magic number: return MathUtils.Cross (V [1].W - V [0].W' V [2].W - V [0].W);  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve2,The following statement contains a magic number: Count = 2;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d12_1 > 0.0f && d12_2 > 0.0f && d123_3 <= 0.0f) {  	float inv_d12 = 1.0f / (d12_1 + d12_2);  	SimplexVertex v0_2 = V [0];  	SimplexVertex v1_2 = V [1];  	v0_2.A = d12_1 * inv_d12;  	v1_2.A = d12_2 * inv_d12;  	V [0] = v0_2;  	V [1] = v1_2;  	Count = 2;  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: Count = 2;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 > 0.0f && d13_2 > 0.0f && d123_2 <= 0.0f) {  	float inv_d13 = 1.0f / (d13_1 + d13_2);  	SimplexVertex v0_3 = V [0];  	SimplexVertex v2_3 = V [2];  	v0_3.A = d13_1 * inv_d13;  	v2_3.A = d13_2 * inv_d13;  	V [0] = v0_3;  	V [2] = v2_3;  	Count = 2;  	V [1] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 > 0.0f && d13_2 > 0.0f && d123_2 <= 0.0f) {  	float inv_d13 = 1.0f / (d13_1 + d13_2);  	SimplexVertex v0_3 = V [0];  	SimplexVertex v2_3 = V [2];  	v0_3.A = d13_1 * inv_d13;  	v2_3.A = d13_2 * inv_d13;  	V [0] = v0_3;  	V [2] = v2_3;  	Count = 2;  	V [1] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 > 0.0f && d13_2 > 0.0f && d123_2 <= 0.0f) {  	float inv_d13 = 1.0f / (d13_1 + d13_2);  	SimplexVertex v0_3 = V [0];  	SimplexVertex v2_3 = V [2];  	v0_3.A = d13_1 * inv_d13;  	v2_3.A = d13_2 * inv_d13;  	V [0] = v0_3;  	V [2] = v2_3;  	Count = 2;  	V [1] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 > 0.0f && d13_2 > 0.0f && d123_2 <= 0.0f) {  	float inv_d13 = 1.0f / (d13_1 + d13_2);  	SimplexVertex v0_3 = V [0];  	SimplexVertex v2_3 = V [2];  	v0_3.A = d13_1 * inv_d13;  	v2_3.A = d13_2 * inv_d13;  	V [0] = v0_3;  	V [2] = v2_3;  	Count = 2;  	V [1] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: V [2] = v2_3;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: Count = 2;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: V [1] = V [2];  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 <= 0.0f && d23_1 <= 0.0f) {  	SimplexVertex v2_5 = V [2];  	v2_5.A = 1.0f;  	V [2] = v2_5;  	Count = 1;  	V [0] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 <= 0.0f && d23_1 <= 0.0f) {  	SimplexVertex v2_5 = V [2];  	v2_5.A = 1.0f;  	V [2] = v2_5;  	Count = 1;  	V [0] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 <= 0.0f && d23_1 <= 0.0f) {  	SimplexVertex v2_5 = V [2];  	v2_5.A = 1.0f;  	V [2] = v2_5;  	Count = 1;  	V [0] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: V [2] = v2_5;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: V [0] = V [2];  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d23_1 > 0.0f && d23_2 > 0.0f && d123_1 <= 0.0f) {  	float inv_d23 = 1.0f / (d23_1 + d23_2);  	SimplexVertex v1_6 = V [1];  	SimplexVertex v2_6 = V [2];  	v1_6.A = d23_1 * inv_d23;  	v2_6.A = d23_2 * inv_d23;  	V [1] = v1_6;  	V [2] = v2_6;  	Count = 2;  	V [0] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d23_1 > 0.0f && d23_2 > 0.0f && d123_1 <= 0.0f) {  	float inv_d23 = 1.0f / (d23_1 + d23_2);  	SimplexVertex v1_6 = V [1];  	SimplexVertex v2_6 = V [2];  	v1_6.A = d23_1 * inv_d23;  	v2_6.A = d23_2 * inv_d23;  	V [1] = v1_6;  	V [2] = v2_6;  	Count = 2;  	V [0] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d23_1 > 0.0f && d23_2 > 0.0f && d123_1 <= 0.0f) {  	float inv_d23 = 1.0f / (d23_1 + d23_2);  	SimplexVertex v1_6 = V [1];  	SimplexVertex v2_6 = V [2];  	v1_6.A = d23_1 * inv_d23;  	v2_6.A = d23_2 * inv_d23;  	V [1] = v1_6;  	V [2] = v2_6;  	Count = 2;  	V [0] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d23_1 > 0.0f && d23_2 > 0.0f && d123_1 <= 0.0f) {  	float inv_d23 = 1.0f / (d23_1 + d23_2);  	SimplexVertex v1_6 = V [1];  	SimplexVertex v2_6 = V [2];  	v1_6.A = d23_1 * inv_d23;  	v2_6.A = d23_2 * inv_d23;  	V [1] = v1_6;  	V [2] = v2_6;  	Count = 2;  	V [0] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: V [2] = v2_6;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: Count = 2;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: V [0] = V [2];  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: V [2] = v2_7;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,Solve3,The following statement contains a magic number: Count = 3;  
Magic Number,FarseerPhysics.Collision,Distance,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,ComputeDistance,The following statement contains a magic number: while (iter < Settings.MaxGJKIterations) {  	// Copy simplex so we can identify duplicates.  	int saveCount = simplex.Count;  	for (int i = 0; i < saveCount; ++i) {  		saveA [i] = simplex.V [i].IndexA;  		saveB [i] = simplex.V [i].IndexB;  	}  	switch (simplex.Count) {  	case 1:  		break;  	case 2:  		simplex.Solve2 ();  		break;  	case 3:  		simplex.Solve3 ();  		break;  	default:  		Debug.Assert (false);  		break;  	}  	// If we have 3 points' then the origin is in the corresponding triangle.  	if (simplex.Count == 3) {  		break;  	}  	//FPE: This code was not used anyway.  	// Compute closest point.  	//Vector2 p = simplex.GetClosestPoint();  	//float distanceSqr2 = p.LengthSquared();  	// Ensure progress  	//if (distanceSqr2 >= distanceSqr1)  	//{  	//break;  	//}  	//distanceSqr1 = distanceSqr2;  	// Get search direction.  	Vector2 d = simplex.GetSearchDirection ();  	// Ensure the search direction is numerically fit.  	if (d.LengthSquared () < Settings.Epsilon * Settings.Epsilon) {  		// The origin is probably contained by a line segment  		// or triangle. Thus the shapes are overlapped.  		// We can't return zero here even though there may be overlap.  		// In case the simplex is a point' segment' or triangle it is difficult  		// to determine if the origin is contained in the CSO or very close to it.  		break;  	}  	// Compute a tentative new simplex vertex using support points.  	SimplexVertex vertex = simplex.V [simplex.Count];  	vertex.IndexA = input.ProxyA.GetSupport (MathUtils.MulT (input.TransformA.q' -d));  	vertex.WA = MathUtils.Mul (ref input.TransformA' input.ProxyA.Vertices [vertex.IndexA]);  	vertex.IndexB = input.ProxyB.GetSupport (MathUtils.MulT (input.TransformB.q' d));  	vertex.WB = MathUtils.Mul (ref input.TransformB' input.ProxyB.Vertices [vertex.IndexB]);  	vertex.W = vertex.WB - vertex.WA;  	simplex.V [simplex.Count] = vertex;  	// Iteration count is equated to the number of support point calls.  	++iter;  	if (Settings.EnableDiagnostics)  		//FPE: We only gather diagnostics when enabled  		++GJKIters;  	// Check for duplicate support points. This is the main termination criteria.  	bool duplicate = false;  	for (int i = 0; i < saveCount; ++i) {  		if (vertex.IndexA == saveA [i] && vertex.IndexB == saveB [i]) {  			duplicate = true;  			break;  		}  	}  	// If we found a duplicate support point we must exit to avoid cycling.  	if (duplicate) {  		break;  	}  	// New vertex is ok and needed.  	++simplex.Count;  }  
Magic Number,FarseerPhysics.Collision,Distance,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,ComputeDistance,The following statement contains a magic number: while (iter < Settings.MaxGJKIterations) {  	// Copy simplex so we can identify duplicates.  	int saveCount = simplex.Count;  	for (int i = 0; i < saveCount; ++i) {  		saveA [i] = simplex.V [i].IndexA;  		saveB [i] = simplex.V [i].IndexB;  	}  	switch (simplex.Count) {  	case 1:  		break;  	case 2:  		simplex.Solve2 ();  		break;  	case 3:  		simplex.Solve3 ();  		break;  	default:  		Debug.Assert (false);  		break;  	}  	// If we have 3 points' then the origin is in the corresponding triangle.  	if (simplex.Count == 3) {  		break;  	}  	//FPE: This code was not used anyway.  	// Compute closest point.  	//Vector2 p = simplex.GetClosestPoint();  	//float distanceSqr2 = p.LengthSquared();  	// Ensure progress  	//if (distanceSqr2 >= distanceSqr1)  	//{  	//break;  	//}  	//distanceSqr1 = distanceSqr2;  	// Get search direction.  	Vector2 d = simplex.GetSearchDirection ();  	// Ensure the search direction is numerically fit.  	if (d.LengthSquared () < Settings.Epsilon * Settings.Epsilon) {  		// The origin is probably contained by a line segment  		// or triangle. Thus the shapes are overlapped.  		// We can't return zero here even though there may be overlap.  		// In case the simplex is a point' segment' or triangle it is difficult  		// to determine if the origin is contained in the CSO or very close to it.  		break;  	}  	// Compute a tentative new simplex vertex using support points.  	SimplexVertex vertex = simplex.V [simplex.Count];  	vertex.IndexA = input.ProxyA.GetSupport (MathUtils.MulT (input.TransformA.q' -d));  	vertex.WA = MathUtils.Mul (ref input.TransformA' input.ProxyA.Vertices [vertex.IndexA]);  	vertex.IndexB = input.ProxyB.GetSupport (MathUtils.MulT (input.TransformB.q' d));  	vertex.WB = MathUtils.Mul (ref input.TransformB' input.ProxyB.Vertices [vertex.IndexB]);  	vertex.W = vertex.WB - vertex.WA;  	simplex.V [simplex.Count] = vertex;  	// Iteration count is equated to the number of support point calls.  	++iter;  	if (Settings.EnableDiagnostics)  		//FPE: We only gather diagnostics when enabled  		++GJKIters;  	// Check for duplicate support points. This is the main termination criteria.  	bool duplicate = false;  	for (int i = 0; i < saveCount; ++i) {  		if (vertex.IndexA == saveA [i] && vertex.IndexB == saveB [i]) {  			duplicate = true;  			break;  		}  	}  	// If we found a duplicate support point we must exit to avoid cycling.  	if (duplicate) {  		break;  	}  	// New vertex is ok and needed.  	++simplex.Count;  }  
Magic Number,FarseerPhysics.Collision,Distance,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,ComputeDistance,The following statement contains a magic number: while (iter < Settings.MaxGJKIterations) {  	// Copy simplex so we can identify duplicates.  	int saveCount = simplex.Count;  	for (int i = 0; i < saveCount; ++i) {  		saveA [i] = simplex.V [i].IndexA;  		saveB [i] = simplex.V [i].IndexB;  	}  	switch (simplex.Count) {  	case 1:  		break;  	case 2:  		simplex.Solve2 ();  		break;  	case 3:  		simplex.Solve3 ();  		break;  	default:  		Debug.Assert (false);  		break;  	}  	// If we have 3 points' then the origin is in the corresponding triangle.  	if (simplex.Count == 3) {  		break;  	}  	//FPE: This code was not used anyway.  	// Compute closest point.  	//Vector2 p = simplex.GetClosestPoint();  	//float distanceSqr2 = p.LengthSquared();  	// Ensure progress  	//if (distanceSqr2 >= distanceSqr1)  	//{  	//break;  	//}  	//distanceSqr1 = distanceSqr2;  	// Get search direction.  	Vector2 d = simplex.GetSearchDirection ();  	// Ensure the search direction is numerically fit.  	if (d.LengthSquared () < Settings.Epsilon * Settings.Epsilon) {  		// The origin is probably contained by a line segment  		// or triangle. Thus the shapes are overlapped.  		// We can't return zero here even though there may be overlap.  		// In case the simplex is a point' segment' or triangle it is difficult  		// to determine if the origin is contained in the CSO or very close to it.  		break;  	}  	// Compute a tentative new simplex vertex using support points.  	SimplexVertex vertex = simplex.V [simplex.Count];  	vertex.IndexA = input.ProxyA.GetSupport (MathUtils.MulT (input.TransformA.q' -d));  	vertex.WA = MathUtils.Mul (ref input.TransformA' input.ProxyA.Vertices [vertex.IndexA]);  	vertex.IndexB = input.ProxyB.GetSupport (MathUtils.MulT (input.TransformB.q' d));  	vertex.WB = MathUtils.Mul (ref input.TransformB' input.ProxyB.Vertices [vertex.IndexB]);  	vertex.W = vertex.WB - vertex.WA;  	simplex.V [simplex.Count] = vertex;  	// Iteration count is equated to the number of support point calls.  	++iter;  	if (Settings.EnableDiagnostics)  		//FPE: We only gather diagnostics when enabled  		++GJKIters;  	// Check for duplicate support points. This is the main termination criteria.  	bool duplicate = false;  	for (int i = 0; i < saveCount; ++i) {  		if (vertex.IndexA == saveA [i] && vertex.IndexB == saveB [i]) {  			duplicate = true;  			break;  		}  	}  	// If we found a duplicate support point we must exit to avoid cycling.  	if (duplicate) {  		break;  	}  	// New vertex is ok and needed.  	++simplex.Count;  }  
Magic Number,FarseerPhysics.Collision,Distance,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,ComputeDistance,The following statement contains a magic number: switch (simplex.Count) {  case 1:  	break;  case 2:  	simplex.Solve2 ();  	break;  case 3:  	simplex.Solve3 ();  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,FarseerPhysics.Collision,Distance,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,ComputeDistance,The following statement contains a magic number: switch (simplex.Count) {  case 1:  	break;  case 2:  	simplex.Solve2 ();  	break;  case 3:  	simplex.Solve3 ();  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,FarseerPhysics.Collision,Distance,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Distance.cs,ComputeDistance,The following statement contains a magic number: if (simplex.Count == 3) {  	break;  }  
Magic Number,FarseerPhysics.Collision,DynamicTree,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\DynamicTree.cs,DynamicTree,The following statement contains a magic number: _nodeCapacity = 16;  
Magic Number,FarseerPhysics.Collision,DynamicTree,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\DynamicTree.cs,AllocateNode,The following statement contains a magic number: if (_freeList == NullNode) {  	Debug.Assert (_nodeCount == _nodeCapacity);  	// The free list is empty. Rebuild a bigger pool.  	TreeNode<T>[] oldNodes = _nodes;  	_nodeCapacity *= 2;  	_nodes = new TreeNode<T>[_nodeCapacity];  	Array.Copy (oldNodes' _nodes' _nodeCount);  	// Build a linked list for the free list. The parent  	// pointer becomes the "next" pointer.  	for (int i = _nodeCount; i < _nodeCapacity - 1; ++i) {  		_nodes [i] = new TreeNode<T> ();  		_nodes [i].ParentOrNext = i + 1;  		_nodes [i].Height = -1;  	}  	_nodes [_nodeCapacity - 1] = new TreeNode<T> ();  	_nodes [_nodeCapacity - 1].ParentOrNext = NullNode;  	_nodes [_nodeCapacity - 1].Height = -1;  	_freeList = _nodeCount;  }  
Magic Number,FarseerPhysics.Collision,DynamicTree,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\DynamicTree.cs,AllocateNode,The following statement contains a magic number: _nodeCapacity *= 2;  
Magic Number,FarseerPhysics.Collision,DynamicTree,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\DynamicTree.cs,Balance,The following statement contains a magic number: if (A.IsLeaf () || A.Height < 2) {  	return iA;  }  
Magic Number,FarseerPhysics.Collision,DynamicTreeBroadPhase,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\DynamicTreeBroadPhase.cs,DynamicTreeBroadPhase,The following statement contains a magic number: _pairCapacity = 16;  
Magic Number,FarseerPhysics.Collision,DynamicTreeBroadPhase,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\DynamicTreeBroadPhase.cs,DynamicTreeBroadPhase,The following statement contains a magic number: _moveCapacity = 16;  
Magic Number,FarseerPhysics.Collision,DynamicTreeBroadPhase,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\DynamicTreeBroadPhase.cs,BufferMove,The following statement contains a magic number: if (_moveCount == _moveCapacity) {  	int[] oldBuffer = _moveBuffer;  	_moveCapacity *= 2;  	_moveBuffer = new int[_moveCapacity];  	Array.Copy (oldBuffer' _moveBuffer' _moveCount);  }  
Magic Number,FarseerPhysics.Collision,DynamicTreeBroadPhase,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\DynamicTreeBroadPhase.cs,BufferMove,The following statement contains a magic number: _moveCapacity *= 2;  
Magic Number,FarseerPhysics.Collision,DynamicTreeBroadPhase,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\DynamicTreeBroadPhase.cs,QueryCallback,The following statement contains a magic number: if (_pairCount == _pairCapacity) {  	Pair[] oldBuffer = _pairBuffer;  	_pairCapacity *= 2;  	_pairBuffer = new Pair[_pairCapacity];  	Array.Copy (oldBuffer' _pairBuffer' _pairCount);  }  
Magic Number,FarseerPhysics.Collision,DynamicTreeBroadPhase,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\DynamicTreeBroadPhase.cs,QueryCallback,The following statement contains a magic number: _pairCapacity *= 2;  
Magic Number,FarseerPhysics.Collision,SeparationFunction,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\TimeOfImpact.cs,Set,The following statement contains a magic number: Debug.Assert (0 < count && count < 3);  
Magic Number,FarseerPhysics.Collision,TimeOfImpact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\TimeOfImpact.cs,CalculateTimeOfImpact,The following statement contains a magic number: for (; ;) {  	Transform xfA' xfB;  	sweepA.GetTransform (out xfA' t1);  	sweepB.GetTransform (out xfB' t1);  	// Get the distance between shapes. We can also use the results  	// to get a separating axis.  	_distanceInput.TransformA = xfA;  	_distanceInput.TransformB = xfB;  	DistanceOutput distanceOutput;  	SimplexCache cache;  	Distance.ComputeDistance (out distanceOutput' out cache' _distanceInput);  	// If the shapes are overlapped' we give up on continuous collision.  	if (distanceOutput.Distance <= 0.0f) {  		// Failure!  		output.State = TOIOutputState.Overlapped;  		output.T = 0.0f;  		break;  	}  	if (distanceOutput.Distance < target + tolerance) {  		// Victory!  		output.State = TOIOutputState.Touching;  		output.T = t1;  		break;  	}  	SeparationFunction.Set (ref cache' input.ProxyA' ref sweepA' input.ProxyB' ref sweepB' t1);  	// Compute the TOI on the separating axis. We do this by successively  	// resolving the deepest point. This loop is bounded by the number of vertices.  	bool done = false;  	float t2 = tMax;  	int pushBackIter = 0;  	for (; ;) {  		// Find the deepest point at t2. Store the witness point indices.  		int indexA' indexB;  		float s2 = SeparationFunction.FindMinSeparation (out indexA' out indexB' t2);  		// Is the final configuration separated?  		if (s2 > target + tolerance) {  			// Victory!  			output.State = TOIOutputState.Seperated;  			output.T = tMax;  			done = true;  			break;  		}  		// Has the separation reached tolerance?  		if (s2 > target - tolerance) {  			// Advance the sweeps  			t1 = t2;  			break;  		}  		// Compute the initial separation of the witness points.  		float s1 = SeparationFunction.Evaluate (indexA' indexB' t1);  		// Check for initial overlap. This might happen if the root finder  		// runs out of iterations.  		if (s1 < target - tolerance) {  			output.State = TOIOutputState.Failed;  			output.T = t1;  			done = true;  			break;  		}  		// Check for touching  		if (s1 <= target + tolerance) {  			// Victory! t1 should hold the TOI (could be 0.0).  			output.State = TOIOutputState.Touching;  			output.T = t1;  			done = true;  			break;  		}  		// Compute 1D root of: f(x) - target = 0  		int rootIterCount = 0;  		float a1 = t1' a2 = t2;  		for (; ;) {  			// Use a mix of the secant rule and bisection.  			float t;  			if ((rootIterCount & 1) != 0) {  				// Secant rule to improve convergence.  				t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);  			}  			else {  				// Bisection to guarantee progress.  				t = 0.5f * (a1 + a2);  			}  			++rootIterCount;  			if (Settings.EnableDiagnostics)  				//FPE: We only gather diagnostics when enabled  				++TOIRootIters;  			float s = SeparationFunction.Evaluate (indexA' indexB' t);  			if (Math.Abs (s - target) < tolerance) {  				// t2 holds a tentative value for t1  				t2 = t;  				break;  			}  			// Ensure we continue to bracket the root.  			if (s > target) {  				a1 = t;  				s1 = s;  			}  			else {  				a2 = t;  				s2 = s;  			}  			if (rootIterCount == 50) {  				break;  			}  		}  		if (Settings.EnableDiagnostics)  			//FPE: We only gather diagnostics when enabled  			TOIMaxRootIters = Math.Max (TOIMaxRootIters' rootIterCount);  		++pushBackIter;  		if (pushBackIter == Settings.MaxPolygonVertices) {  			break;  		}  	}  	++iter;  	if (Settings.EnableDiagnostics)  		//FPE: We only gather diagnostics when enabled  		++TOIIters;  	if (done) {  		break;  	}  	if (iter == k_maxIterations) {  		// Root finder got stuck. Semi-victory.  		output.State = TOIOutputState.Failed;  		output.T = t1;  		break;  	}  }  
Magic Number,FarseerPhysics.Collision,TimeOfImpact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\TimeOfImpact.cs,CalculateTimeOfImpact,The following statement contains a magic number: for (; ;) {  	// Find the deepest point at t2. Store the witness point indices.  	int indexA' indexB;  	float s2 = SeparationFunction.FindMinSeparation (out indexA' out indexB' t2);  	// Is the final configuration separated?  	if (s2 > target + tolerance) {  		// Victory!  		output.State = TOIOutputState.Seperated;  		output.T = tMax;  		done = true;  		break;  	}  	// Has the separation reached tolerance?  	if (s2 > target - tolerance) {  		// Advance the sweeps  		t1 = t2;  		break;  	}  	// Compute the initial separation of the witness points.  	float s1 = SeparationFunction.Evaluate (indexA' indexB' t1);  	// Check for initial overlap. This might happen if the root finder  	// runs out of iterations.  	if (s1 < target - tolerance) {  		output.State = TOIOutputState.Failed;  		output.T = t1;  		done = true;  		break;  	}  	// Check for touching  	if (s1 <= target + tolerance) {  		// Victory! t1 should hold the TOI (could be 0.0).  		output.State = TOIOutputState.Touching;  		output.T = t1;  		done = true;  		break;  	}  	// Compute 1D root of: f(x) - target = 0  	int rootIterCount = 0;  	float a1 = t1' a2 = t2;  	for (; ;) {  		// Use a mix of the secant rule and bisection.  		float t;  		if ((rootIterCount & 1) != 0) {  			// Secant rule to improve convergence.  			t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);  		}  		else {  			// Bisection to guarantee progress.  			t = 0.5f * (a1 + a2);  		}  		++rootIterCount;  		if (Settings.EnableDiagnostics)  			//FPE: We only gather diagnostics when enabled  			++TOIRootIters;  		float s = SeparationFunction.Evaluate (indexA' indexB' t);  		if (Math.Abs (s - target) < tolerance) {  			// t2 holds a tentative value for t1  			t2 = t;  			break;  		}  		// Ensure we continue to bracket the root.  		if (s > target) {  			a1 = t;  			s1 = s;  		}  		else {  			a2 = t;  			s2 = s;  		}  		if (rootIterCount == 50) {  			break;  		}  	}  	if (Settings.EnableDiagnostics)  		//FPE: We only gather diagnostics when enabled  		TOIMaxRootIters = Math.Max (TOIMaxRootIters' rootIterCount);  	++pushBackIter;  	if (pushBackIter == Settings.MaxPolygonVertices) {  		break;  	}  }  
Magic Number,FarseerPhysics.Collision,TimeOfImpact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\TimeOfImpact.cs,CalculateTimeOfImpact,The following statement contains a magic number: for (; ;) {  	// Use a mix of the secant rule and bisection.  	float t;  	if ((rootIterCount & 1) != 0) {  		// Secant rule to improve convergence.  		t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);  	}  	else {  		// Bisection to guarantee progress.  		t = 0.5f * (a1 + a2);  	}  	++rootIterCount;  	if (Settings.EnableDiagnostics)  		//FPE: We only gather diagnostics when enabled  		++TOIRootIters;  	float s = SeparationFunction.Evaluate (indexA' indexB' t);  	if (Math.Abs (s - target) < tolerance) {  		// t2 holds a tentative value for t1  		t2 = t;  		break;  	}  	// Ensure we continue to bracket the root.  	if (s > target) {  		a1 = t;  		s1 = s;  	}  	else {  		a2 = t;  		s2 = s;  	}  	if (rootIterCount == 50) {  		break;  	}  }  
Magic Number,FarseerPhysics.Collision,TimeOfImpact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\TimeOfImpact.cs,CalculateTimeOfImpact,The following statement contains a magic number: if (rootIterCount == 50) {  	break;  }  
Magic Number,FarseerPhysics.Collision.Shapes,ChainShape,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\ChainShape.cs,ChainShape,The following statement contains a magic number: Debug.Assert (vertices != null && vertices.Count >= 3);  
Magic Number,FarseerPhysics.Collision.Shapes,ChainShape,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\ChainShape.cs,ChainShape,The following statement contains a magic number: if (createLoop) {  	Vertices.Add (vertices [0]);  	PrevVertex = Vertices [Vertices.Count - 2];  	//FPE: We use the properties instead of the private fields here.  	NextVertex = Vertices [1];  	//FPE: We use the properties instead of the private fields here.  }  
Magic Number,FarseerPhysics.Collision.Shapes,ChainShape,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\ChainShape.cs,ChainShape,The following statement contains a magic number: PrevVertex = Vertices [Vertices.Count - 2];  
Magic Number,FarseerPhysics.Collision.Shapes,ChainShape,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\ChainShape.cs,GetChildEdge,The following statement contains a magic number: if (index < Vertices.Count - 2) {  	edge.Vertex3 = Vertices [index + 2];  	edge.HasVertex3 = true;  }  else {  	edge.Vertex3 = _nextVertex;  	edge.HasVertex3 = _hasNextVertex;  }  
Magic Number,FarseerPhysics.Collision.Shapes,ChainShape,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\ChainShape.cs,GetChildEdge,The following statement contains a magic number: if (index < Vertices.Count - 2) {  	edge.Vertex3 = Vertices [index + 2];  	edge.HasVertex3 = true;  }  else {  	edge.Vertex3 = _nextVertex;  	edge.HasVertex3 = _hasNextVertex;  }  
Magic Number,FarseerPhysics.Collision.Shapes,ChainShape,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\ChainShape.cs,GetChildEdge,The following statement contains a magic number: edge.Vertex3 = Vertices [index + 2];  
Magic Number,FarseerPhysics.Collision.Shapes,PolygonShape,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\PolygonShape.cs,ComputeProperties,The following statement contains a magic number: Debug.Assert (Vertices.Count >= 3);  
Magic Number,FarseerPhysics.Collision.Shapes,MassData,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\Shape.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = Area.GetHashCode ();  	result = (result * 397) ^ Centroid.GetHashCode ();  	result = (result * 397) ^ Inertia.GetHashCode ();  	result = (result * 397) ^ Mass.GetHashCode ();  	return result;  }  
Magic Number,FarseerPhysics.Collision.Shapes,MassData,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\Shape.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = Area.GetHashCode ();  	result = (result * 397) ^ Centroid.GetHashCode ();  	result = (result * 397) ^ Inertia.GetHashCode ();  	result = (result * 397) ^ Mass.GetHashCode ();  	return result;  }  
Magic Number,FarseerPhysics.Collision.Shapes,MassData,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\Shape.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = Area.GetHashCode ();  	result = (result * 397) ^ Centroid.GetHashCode ();  	result = (result * 397) ^ Inertia.GetHashCode ();  	result = (result * 397) ^ Mass.GetHashCode ();  	return result;  }  
Magic Number,FarseerPhysics.Collision.Shapes,MassData,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\Shape.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ Centroid.GetHashCode ();  
Magic Number,FarseerPhysics.Collision.Shapes,MassData,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\Shape.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ Inertia.GetHashCode ();  
Magic Number,FarseerPhysics.Collision.Shapes,MassData,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\Shape.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ Mass.GetHashCode ();  
Magic Number,FarseerPhysics.Common.ConvexHull,ChainHull,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\ChainHull.cs,GetConvexHull,The following statement contains a magic number: if (vertices.Count <= 3)  	return vertices;  
Magic Number,FarseerPhysics.Common.ConvexHull,ChainHull,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\ChainHull.cs,GetConvexHull,The following statement contains a magic number: for (i = pointSet.Count - 2; i >= 0; i--) {  	if (pointSet [i].X != xmax)  		break;  }  
Magic Number,FarseerPhysics.Common.ConvexHull,ChainHull,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\ChainHull.cs,GetConvexHull,The following statement contains a magic number: i = pointSet.Count - 2
Magic Number,FarseerPhysics.Common.ConvexHull,GiftWrap,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\GiftWrap.cs,GetConvexHull,The following statement contains a magic number: if (vertices.Count <= 3)  	return vertices;  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (vertices.Count <= 3)  	return vertices;  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0) {  	//Vertices are collinear.  	deque [0] = vertices [0];  	deque [1] = vertices [2];  	//We can skip vertex 1 because it should be between 0 and 2  	deque [2] = vertices [0];  	qf = 2;  	//Go until the end of the collinear sequence of vertices  	for (startIndex = 3; startIndex < vertices.Count; startIndex++) {  		Vector2 tmp = vertices [startIndex];  		if (MathUtils.Area (ref deque [0]' ref deque [1]' ref tmp) == 0)  			//This point is also collinear  			deque [1] = vertices [startIndex];  		else  			break;  	}  }  else {  	deque [0] = deque [3] = vertices [2];  	if (k > 0) {  		//Is Left.  Set deque = {2' 0' 1' 2}  		deque [1] = vertices [0];  		deque [2] = vertices [1];  	}  	else {  		//Is Right. Set deque = {2' 1' 0' 2}  		deque [1] = vertices [1];  		deque [2] = vertices [0];  	}  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0) {  	//Vertices are collinear.  	deque [0] = vertices [0];  	deque [1] = vertices [2];  	//We can skip vertex 1 because it should be between 0 and 2  	deque [2] = vertices [0];  	qf = 2;  	//Go until the end of the collinear sequence of vertices  	for (startIndex = 3; startIndex < vertices.Count; startIndex++) {  		Vector2 tmp = vertices [startIndex];  		if (MathUtils.Area (ref deque [0]' ref deque [1]' ref tmp) == 0)  			//This point is also collinear  			deque [1] = vertices [startIndex];  		else  			break;  	}  }  else {  	deque [0] = deque [3] = vertices [2];  	if (k > 0) {  		//Is Left.  Set deque = {2' 0' 1' 2}  		deque [1] = vertices [0];  		deque [2] = vertices [1];  	}  	else {  		//Is Right. Set deque = {2' 1' 0' 2}  		deque [1] = vertices [1];  		deque [2] = vertices [0];  	}  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0) {  	//Vertices are collinear.  	deque [0] = vertices [0];  	deque [1] = vertices [2];  	//We can skip vertex 1 because it should be between 0 and 2  	deque [2] = vertices [0];  	qf = 2;  	//Go until the end of the collinear sequence of vertices  	for (startIndex = 3; startIndex < vertices.Count; startIndex++) {  		Vector2 tmp = vertices [startIndex];  		if (MathUtils.Area (ref deque [0]' ref deque [1]' ref tmp) == 0)  			//This point is also collinear  			deque [1] = vertices [startIndex];  		else  			break;  	}  }  else {  	deque [0] = deque [3] = vertices [2];  	if (k > 0) {  		//Is Left.  Set deque = {2' 0' 1' 2}  		deque [1] = vertices [0];  		deque [2] = vertices [1];  	}  	else {  		//Is Right. Set deque = {2' 1' 0' 2}  		deque [1] = vertices [1];  		deque [2] = vertices [0];  	}  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0) {  	//Vertices are collinear.  	deque [0] = vertices [0];  	deque [1] = vertices [2];  	//We can skip vertex 1 because it should be between 0 and 2  	deque [2] = vertices [0];  	qf = 2;  	//Go until the end of the collinear sequence of vertices  	for (startIndex = 3; startIndex < vertices.Count; startIndex++) {  		Vector2 tmp = vertices [startIndex];  		if (MathUtils.Area (ref deque [0]' ref deque [1]' ref tmp) == 0)  			//This point is also collinear  			deque [1] = vertices [startIndex];  		else  			break;  	}  }  else {  	deque [0] = deque [3] = vertices [2];  	if (k > 0) {  		//Is Left.  Set deque = {2' 0' 1' 2}  		deque [1] = vertices [0];  		deque [2] = vertices [1];  	}  	else {  		//Is Right. Set deque = {2' 1' 0' 2}  		deque [1] = vertices [1];  		deque [2] = vertices [0];  	}  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0) {  	//Vertices are collinear.  	deque [0] = vertices [0];  	deque [1] = vertices [2];  	//We can skip vertex 1 because it should be between 0 and 2  	deque [2] = vertices [0];  	qf = 2;  	//Go until the end of the collinear sequence of vertices  	for (startIndex = 3; startIndex < vertices.Count; startIndex++) {  		Vector2 tmp = vertices [startIndex];  		if (MathUtils.Area (ref deque [0]' ref deque [1]' ref tmp) == 0)  			//This point is also collinear  			deque [1] = vertices [startIndex];  		else  			break;  	}  }  else {  	deque [0] = deque [3] = vertices [2];  	if (k > 0) {  		//Is Left.  Set deque = {2' 0' 1' 2}  		deque [1] = vertices [0];  		deque [2] = vertices [1];  	}  	else {  		//Is Right. Set deque = {2' 1' 0' 2}  		deque [1] = vertices [1];  		deque [2] = vertices [0];  	}  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0) {  	//Vertices are collinear.  	deque [0] = vertices [0];  	deque [1] = vertices [2];  	//We can skip vertex 1 because it should be between 0 and 2  	deque [2] = vertices [0];  	qf = 2;  	//Go until the end of the collinear sequence of vertices  	for (startIndex = 3; startIndex < vertices.Count; startIndex++) {  		Vector2 tmp = vertices [startIndex];  		if (MathUtils.Area (ref deque [0]' ref deque [1]' ref tmp) == 0)  			//This point is also collinear  			deque [1] = vertices [startIndex];  		else  			break;  	}  }  else {  	deque [0] = deque [3] = vertices [2];  	if (k > 0) {  		//Is Left.  Set deque = {2' 0' 1' 2}  		deque [1] = vertices [0];  		deque [2] = vertices [1];  	}  	else {  		//Is Right. Set deque = {2' 1' 0' 2}  		deque [1] = vertices [1];  		deque [2] = vertices [0];  	}  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0) {  	//Vertices are collinear.  	deque [0] = vertices [0];  	deque [1] = vertices [2];  	//We can skip vertex 1 because it should be between 0 and 2  	deque [2] = vertices [0];  	qf = 2;  	//Go until the end of the collinear sequence of vertices  	for (startIndex = 3; startIndex < vertices.Count; startIndex++) {  		Vector2 tmp = vertices [startIndex];  		if (MathUtils.Area (ref deque [0]' ref deque [1]' ref tmp) == 0)  			//This point is also collinear  			deque [1] = vertices [startIndex];  		else  			break;  	}  }  else {  	deque [0] = deque [3] = vertices [2];  	if (k > 0) {  		//Is Left.  Set deque = {2' 0' 1' 2}  		deque [1] = vertices [0];  		deque [2] = vertices [1];  	}  	else {  		//Is Right. Set deque = {2' 1' 0' 2}  		deque [1] = vertices [1];  		deque [2] = vertices [0];  	}  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0) {  	//Vertices are collinear.  	deque [0] = vertices [0];  	deque [1] = vertices [2];  	//We can skip vertex 1 because it should be between 0 and 2  	deque [2] = vertices [0];  	qf = 2;  	//Go until the end of the collinear sequence of vertices  	for (startIndex = 3; startIndex < vertices.Count; startIndex++) {  		Vector2 tmp = vertices [startIndex];  		if (MathUtils.Area (ref deque [0]' ref deque [1]' ref tmp) == 0)  			//This point is also collinear  			deque [1] = vertices [startIndex];  		else  			break;  	}  }  else {  	deque [0] = deque [3] = vertices [2];  	if (k > 0) {  		//Is Left.  Set deque = {2' 0' 1' 2}  		deque [1] = vertices [0];  		deque [2] = vertices [1];  	}  	else {  		//Is Right. Set deque = {2' 1' 0' 2}  		deque [1] = vertices [1];  		deque [2] = vertices [0];  	}  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: deque [1] = vertices [2];  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: deque [2] = vertices [0];  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: qf = 2;  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: for (startIndex = 3; startIndex < vertices.Count; startIndex++) {  	Vector2 tmp = vertices [startIndex];  	if (MathUtils.Area (ref deque [0]' ref deque [1]' ref tmp) == 0)  		//This point is also collinear  		deque [1] = vertices [startIndex];  	else  		break;  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: startIndex = 3
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: deque [0] = deque [3] = vertices [2];  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: deque [0] = deque [3] = vertices [2];  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k > 0) {  	//Is Left.  Set deque = {2' 0' 1' 2}  	deque [1] = vertices [0];  	deque [2] = vertices [1];  }  else {  	//Is Right. Set deque = {2' 1' 0' 2}  	deque [1] = vertices [1];  	deque [2] = vertices [0];  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k > 0) {  	//Is Left.  Set deque = {2' 0' 1' 2}  	deque [1] = vertices [0];  	deque [2] = vertices [1];  }  else {  	//Is Right. Set deque = {2' 1' 0' 2}  	deque [1] = vertices [1];  	deque [2] = vertices [0];  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: deque [2] = vertices [1];  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: deque [2] = vertices [0];  
Magic Number,Microsoft.Xna.Framework,Curve,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Curve.cs,GetCurvePosition,The following statement contains a magic number: for (int i = 1; i < keys.Count; i++) {  	next = Keys [i];  	if (next.Position >= position) {  		if (prev.Continuity == CurveContinuity.Step) {  			if (position >= 1f) {  				return next.Value;  			}  			return prev.Value;  		}  		float t = (position - prev.Position) / (next.Position - prev.Position);  		//to have t in [0'1]  		float ts = t * t;  		float tss = ts * t;  		//After a lot of search on internet I have found all about spline function  		// and bezier (phi'sss ancien) but finaly use hermite curve   		//http://en.wikipedia.org/wiki/Cubic_Hermite_spline  		//P(t) = (2*t^3 - 3t^2 + 1)*P0 + (t^3 - 2t^2 + t)m0 + (-2t^3 + 3t^2)P1 + (t^3-t^2)m1  		//with P0.value = prev.value ' m0 = prev.tangentOut' P1= next.value' m1 = next.TangentIn  		return (2 * tss - 3 * ts + 1f) * prev.Value + (tss - 2 * ts + t) * prev.TangentOut + (3 * ts - 2 * tss) * next.Value + (tss - ts) * next.TangentIn;  	}  	prev = next;  }  
Magic Number,Microsoft.Xna.Framework,Curve,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Curve.cs,GetCurvePosition,The following statement contains a magic number: for (int i = 1; i < keys.Count; i++) {  	next = Keys [i];  	if (next.Position >= position) {  		if (prev.Continuity == CurveContinuity.Step) {  			if (position >= 1f) {  				return next.Value;  			}  			return prev.Value;  		}  		float t = (position - prev.Position) / (next.Position - prev.Position);  		//to have t in [0'1]  		float ts = t * t;  		float tss = ts * t;  		//After a lot of search on internet I have found all about spline function  		// and bezier (phi'sss ancien) but finaly use hermite curve   		//http://en.wikipedia.org/wiki/Cubic_Hermite_spline  		//P(t) = (2*t^3 - 3t^2 + 1)*P0 + (t^3 - 2t^2 + t)m0 + (-2t^3 + 3t^2)P1 + (t^3-t^2)m1  		//with P0.value = prev.value ' m0 = prev.tangentOut' P1= next.value' m1 = next.TangentIn  		return (2 * tss - 3 * ts + 1f) * prev.Value + (tss - 2 * ts + t) * prev.TangentOut + (3 * ts - 2 * tss) * next.Value + (tss - ts) * next.TangentIn;  	}  	prev = next;  }  
Magic Number,Microsoft.Xna.Framework,Curve,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Curve.cs,GetCurvePosition,The following statement contains a magic number: for (int i = 1; i < keys.Count; i++) {  	next = Keys [i];  	if (next.Position >= position) {  		if (prev.Continuity == CurveContinuity.Step) {  			if (position >= 1f) {  				return next.Value;  			}  			return prev.Value;  		}  		float t = (position - prev.Position) / (next.Position - prev.Position);  		//to have t in [0'1]  		float ts = t * t;  		float tss = ts * t;  		//After a lot of search on internet I have found all about spline function  		// and bezier (phi'sss ancien) but finaly use hermite curve   		//http://en.wikipedia.org/wiki/Cubic_Hermite_spline  		//P(t) = (2*t^3 - 3t^2 + 1)*P0 + (t^3 - 2t^2 + t)m0 + (-2t^3 + 3t^2)P1 + (t^3-t^2)m1  		//with P0.value = prev.value ' m0 = prev.tangentOut' P1= next.value' m1 = next.TangentIn  		return (2 * tss - 3 * ts + 1f) * prev.Value + (tss - 2 * ts + t) * prev.TangentOut + (3 * ts - 2 * tss) * next.Value + (tss - ts) * next.TangentIn;  	}  	prev = next;  }  
Magic Number,Microsoft.Xna.Framework,Curve,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Curve.cs,GetCurvePosition,The following statement contains a magic number: for (int i = 1; i < keys.Count; i++) {  	next = Keys [i];  	if (next.Position >= position) {  		if (prev.Continuity == CurveContinuity.Step) {  			if (position >= 1f) {  				return next.Value;  			}  			return prev.Value;  		}  		float t = (position - prev.Position) / (next.Position - prev.Position);  		//to have t in [0'1]  		float ts = t * t;  		float tss = ts * t;  		//After a lot of search on internet I have found all about spline function  		// and bezier (phi'sss ancien) but finaly use hermite curve   		//http://en.wikipedia.org/wiki/Cubic_Hermite_spline  		//P(t) = (2*t^3 - 3t^2 + 1)*P0 + (t^3 - 2t^2 + t)m0 + (-2t^3 + 3t^2)P1 + (t^3-t^2)m1  		//with P0.value = prev.value ' m0 = prev.tangentOut' P1= next.value' m1 = next.TangentIn  		return (2 * tss - 3 * ts + 1f) * prev.Value + (tss - 2 * ts + t) * prev.TangentOut + (3 * ts - 2 * tss) * next.Value + (tss - ts) * next.TangentIn;  	}  	prev = next;  }  
Magic Number,Microsoft.Xna.Framework,Curve,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Curve.cs,GetCurvePosition,The following statement contains a magic number: for (int i = 1; i < keys.Count; i++) {  	next = Keys [i];  	if (next.Position >= position) {  		if (prev.Continuity == CurveContinuity.Step) {  			if (position >= 1f) {  				return next.Value;  			}  			return prev.Value;  		}  		float t = (position - prev.Position) / (next.Position - prev.Position);  		//to have t in [0'1]  		float ts = t * t;  		float tss = ts * t;  		//After a lot of search on internet I have found all about spline function  		// and bezier (phi'sss ancien) but finaly use hermite curve   		//http://en.wikipedia.org/wiki/Cubic_Hermite_spline  		//P(t) = (2*t^3 - 3t^2 + 1)*P0 + (t^3 - 2t^2 + t)m0 + (-2t^3 + 3t^2)P1 + (t^3-t^2)m1  		//with P0.value = prev.value ' m0 = prev.tangentOut' P1= next.value' m1 = next.TangentIn  		return (2 * tss - 3 * ts + 1f) * prev.Value + (tss - 2 * ts + t) * prev.TangentOut + (3 * ts - 2 * tss) * next.Value + (tss - ts) * next.TangentIn;  	}  	prev = next;  }  
Magic Number,Microsoft.Xna.Framework,Curve,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Curve.cs,GetCurvePosition,The following statement contains a magic number: if (next.Position >= position) {  	if (prev.Continuity == CurveContinuity.Step) {  		if (position >= 1f) {  			return next.Value;  		}  		return prev.Value;  	}  	float t = (position - prev.Position) / (next.Position - prev.Position);  	//to have t in [0'1]  	float ts = t * t;  	float tss = ts * t;  	//After a lot of search on internet I have found all about spline function  	// and bezier (phi'sss ancien) but finaly use hermite curve   	//http://en.wikipedia.org/wiki/Cubic_Hermite_spline  	//P(t) = (2*t^3 - 3t^2 + 1)*P0 + (t^3 - 2t^2 + t)m0 + (-2t^3 + 3t^2)P1 + (t^3-t^2)m1  	//with P0.value = prev.value ' m0 = prev.tangentOut' P1= next.value' m1 = next.TangentIn  	return (2 * tss - 3 * ts + 1f) * prev.Value + (tss - 2 * ts + t) * prev.TangentOut + (3 * ts - 2 * tss) * next.Value + (tss - ts) * next.TangentIn;  }  
Magic Number,Microsoft.Xna.Framework,Curve,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Curve.cs,GetCurvePosition,The following statement contains a magic number: if (next.Position >= position) {  	if (prev.Continuity == CurveContinuity.Step) {  		if (position >= 1f) {  			return next.Value;  		}  		return prev.Value;  	}  	float t = (position - prev.Position) / (next.Position - prev.Position);  	//to have t in [0'1]  	float ts = t * t;  	float tss = ts * t;  	//After a lot of search on internet I have found all about spline function  	// and bezier (phi'sss ancien) but finaly use hermite curve   	//http://en.wikipedia.org/wiki/Cubic_Hermite_spline  	//P(t) = (2*t^3 - 3t^2 + 1)*P0 + (t^3 - 2t^2 + t)m0 + (-2t^3 + 3t^2)P1 + (t^3-t^2)m1  	//with P0.value = prev.value ' m0 = prev.tangentOut' P1= next.value' m1 = next.TangentIn  	return (2 * tss - 3 * ts + 1f) * prev.Value + (tss - 2 * ts + t) * prev.TangentOut + (3 * ts - 2 * tss) * next.Value + (tss - ts) * next.TangentIn;  }  
Magic Number,Microsoft.Xna.Framework,Curve,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Curve.cs,GetCurvePosition,The following statement contains a magic number: if (next.Position >= position) {  	if (prev.Continuity == CurveContinuity.Step) {  		if (position >= 1f) {  			return next.Value;  		}  		return prev.Value;  	}  	float t = (position - prev.Position) / (next.Position - prev.Position);  	//to have t in [0'1]  	float ts = t * t;  	float tss = ts * t;  	//After a lot of search on internet I have found all about spline function  	// and bezier (phi'sss ancien) but finaly use hermite curve   	//http://en.wikipedia.org/wiki/Cubic_Hermite_spline  	//P(t) = (2*t^3 - 3t^2 + 1)*P0 + (t^3 - 2t^2 + t)m0 + (-2t^3 + 3t^2)P1 + (t^3-t^2)m1  	//with P0.value = prev.value ' m0 = prev.tangentOut' P1= next.value' m1 = next.TangentIn  	return (2 * tss - 3 * ts + 1f) * prev.Value + (tss - 2 * ts + t) * prev.TangentOut + (3 * ts - 2 * tss) * next.Value + (tss - ts) * next.TangentIn;  }  
Magic Number,Microsoft.Xna.Framework,Curve,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Curve.cs,GetCurvePosition,The following statement contains a magic number: if (next.Position >= position) {  	if (prev.Continuity == CurveContinuity.Step) {  		if (position >= 1f) {  			return next.Value;  		}  		return prev.Value;  	}  	float t = (position - prev.Position) / (next.Position - prev.Position);  	//to have t in [0'1]  	float ts = t * t;  	float tss = ts * t;  	//After a lot of search on internet I have found all about spline function  	// and bezier (phi'sss ancien) but finaly use hermite curve   	//http://en.wikipedia.org/wiki/Cubic_Hermite_spline  	//P(t) = (2*t^3 - 3t^2 + 1)*P0 + (t^3 - 2t^2 + t)m0 + (-2t^3 + 3t^2)P1 + (t^3-t^2)m1  	//with P0.value = prev.value ' m0 = prev.tangentOut' P1= next.value' m1 = next.TangentIn  	return (2 * tss - 3 * ts + 1f) * prev.Value + (tss - 2 * ts + t) * prev.TangentOut + (3 * ts - 2 * tss) * next.Value + (tss - ts) * next.TangentIn;  }  
Magic Number,Microsoft.Xna.Framework,Curve,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Curve.cs,GetCurvePosition,The following statement contains a magic number: if (next.Position >= position) {  	if (prev.Continuity == CurveContinuity.Step) {  		if (position >= 1f) {  			return next.Value;  		}  		return prev.Value;  	}  	float t = (position - prev.Position) / (next.Position - prev.Position);  	//to have t in [0'1]  	float ts = t * t;  	float tss = ts * t;  	//After a lot of search on internet I have found all about spline function  	// and bezier (phi'sss ancien) but finaly use hermite curve   	//http://en.wikipedia.org/wiki/Cubic_Hermite_spline  	//P(t) = (2*t^3 - 3t^2 + 1)*P0 + (t^3 - 2t^2 + t)m0 + (-2t^3 + 3t^2)P1 + (t^3-t^2)m1  	//with P0.value = prev.value ' m0 = prev.tangentOut' P1= next.value' m1 = next.TangentIn  	return (2 * tss - 3 * ts + 1f) * prev.Value + (tss - 2 * ts + t) * prev.TangentOut + (3 * ts - 2 * tss) * next.Value + (tss - ts) * next.TangentIn;  }  
Magic Number,Microsoft.Xna.Framework,Curve,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Curve.cs,GetCurvePosition,The following statement contains a magic number: return (2 * tss - 3 * ts + 1f) * prev.Value + (tss - 2 * ts + t) * prev.TangentOut + (3 * ts - 2 * tss) * next.Value + (tss - ts) * next.TangentIn;  
Magic Number,Microsoft.Xna.Framework,Curve,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Curve.cs,GetCurvePosition,The following statement contains a magic number: return (2 * tss - 3 * ts + 1f) * prev.Value + (tss - 2 * ts + t) * prev.TangentOut + (3 * ts - 2 * tss) * next.Value + (tss - ts) * next.TangentIn;  
Magic Number,Microsoft.Xna.Framework,Curve,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Curve.cs,GetCurvePosition,The following statement contains a magic number: return (2 * tss - 3 * ts + 1f) * prev.Value + (tss - 2 * ts + t) * prev.TangentOut + (3 * ts - 2 * tss) * next.Value + (tss - ts) * next.TangentIn;  
Magic Number,Microsoft.Xna.Framework,Curve,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Curve.cs,GetCurvePosition,The following statement contains a magic number: return (2 * tss - 3 * ts + 1f) * prev.Value + (tss - 2 * ts + t) * prev.TangentOut + (3 * ts - 2 * tss) * next.Value + (tss - ts) * next.TangentIn;  
Magic Number,Microsoft.Xna.Framework,Curve,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Curve.cs,GetCurvePosition,The following statement contains a magic number: return (2 * tss - 3 * ts + 1f) * prev.Value + (tss - 2 * ts + t) * prev.TangentOut + (3 * ts - 2 * tss) * next.Value + (tss - ts) * next.TangentIn;  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,CatmullRom,The following statement contains a magic number: return (float)(0.5 * (2.0 * value2 + (value3 - value1) * amount + (2.0 * value1 - 5.0 * value2 + 4.0 * value3 - value4) * amountSquared + (3.0 * value2 - value1 - 3.0 * value3 + value4) * amountCubed));  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,CatmullRom,The following statement contains a magic number: return (float)(0.5 * (2.0 * value2 + (value3 - value1) * amount + (2.0 * value1 - 5.0 * value2 + 4.0 * value3 - value4) * amountSquared + (3.0 * value2 - value1 - 3.0 * value3 + value4) * amountCubed));  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,CatmullRom,The following statement contains a magic number: return (float)(0.5 * (2.0 * value2 + (value3 - value1) * amount + (2.0 * value1 - 5.0 * value2 + 4.0 * value3 - value4) * amountSquared + (3.0 * value2 - value1 - 3.0 * value3 + value4) * amountCubed));  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,CatmullRom,The following statement contains a magic number: return (float)(0.5 * (2.0 * value2 + (value3 - value1) * amount + (2.0 * value1 - 5.0 * value2 + 4.0 * value3 - value4) * amountSquared + (3.0 * value2 - value1 - 3.0 * value3 + value4) * amountCubed));  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,CatmullRom,The following statement contains a magic number: return (float)(0.5 * (2.0 * value2 + (value3 - value1) * amount + (2.0 * value1 - 5.0 * value2 + 4.0 * value3 - value4) * amountSquared + (3.0 * value2 - value1 - 3.0 * value3 + value4) * amountCubed));  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,CatmullRom,The following statement contains a magic number: return (float)(0.5 * (2.0 * value2 + (value3 - value1) * amount + (2.0 * value1 - 5.0 * value2 + 4.0 * value3 - value4) * amountSquared + (3.0 * value2 - value1 - 3.0 * value3 + value4) * amountCubed));  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,CatmullRom,The following statement contains a magic number: return (float)(0.5 * (2.0 * value2 + (value3 - value1) * amount + (2.0 * value1 - 5.0 * value2 + 4.0 * value3 - value4) * amountSquared + (3.0 * value2 - value1 - 3.0 * value3 + value4) * amountCubed));  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,Hermite,The following statement contains a magic number: if (amount == 0f)  	result = value1;  else if (amount == 1f)  	result = value2;  else  	result = (2 * v1 - 2 * v2 + t2 + t1) * sCubed + (3 * v2 - 3 * v1 - 2 * t1 - t2) * sSquared + t1 * s + v1;  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,Hermite,The following statement contains a magic number: if (amount == 0f)  	result = value1;  else if (amount == 1f)  	result = value2;  else  	result = (2 * v1 - 2 * v2 + t2 + t1) * sCubed + (3 * v2 - 3 * v1 - 2 * t1 - t2) * sSquared + t1 * s + v1;  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,Hermite,The following statement contains a magic number: if (amount == 0f)  	result = value1;  else if (amount == 1f)  	result = value2;  else  	result = (2 * v1 - 2 * v2 + t2 + t1) * sCubed + (3 * v2 - 3 * v1 - 2 * t1 - t2) * sSquared + t1 * s + v1;  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,Hermite,The following statement contains a magic number: if (amount == 0f)  	result = value1;  else if (amount == 1f)  	result = value2;  else  	result = (2 * v1 - 2 * v2 + t2 + t1) * sCubed + (3 * v2 - 3 * v1 - 2 * t1 - t2) * sSquared + t1 * s + v1;  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,Hermite,The following statement contains a magic number: if (amount == 0f)  	result = value1;  else if (amount == 1f)  	result = value2;  else  	result = (2 * v1 - 2 * v2 + t2 + t1) * sCubed + (3 * v2 - 3 * v1 - 2 * t1 - t2) * sSquared + t1 * s + v1;  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,Hermite,The following statement contains a magic number: if (amount == 1f)  	result = value2;  else  	result = (2 * v1 - 2 * v2 + t2 + t1) * sCubed + (3 * v2 - 3 * v1 - 2 * t1 - t2) * sSquared + t1 * s + v1;  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,Hermite,The following statement contains a magic number: if (amount == 1f)  	result = value2;  else  	result = (2 * v1 - 2 * v2 + t2 + t1) * sCubed + (3 * v2 - 3 * v1 - 2 * t1 - t2) * sSquared + t1 * s + v1;  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,Hermite,The following statement contains a magic number: if (amount == 1f)  	result = value2;  else  	result = (2 * v1 - 2 * v2 + t2 + t1) * sCubed + (3 * v2 - 3 * v1 - 2 * t1 - t2) * sSquared + t1 * s + v1;  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,Hermite,The following statement contains a magic number: if (amount == 1f)  	result = value2;  else  	result = (2 * v1 - 2 * v2 + t2 + t1) * sCubed + (3 * v2 - 3 * v1 - 2 * t1 - t2) * sSquared + t1 * s + v1;  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,Hermite,The following statement contains a magic number: if (amount == 1f)  	result = value2;  else  	result = (2 * v1 - 2 * v2 + t2 + t1) * sCubed + (3 * v2 - 3 * v1 - 2 * t1 - t2) * sSquared + t1 * s + v1;  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,Hermite,The following statement contains a magic number: result = (2 * v1 - 2 * v2 + t2 + t1) * sCubed + (3 * v2 - 3 * v1 - 2 * t1 - t2) * sSquared + t1 * s + v1;  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,Hermite,The following statement contains a magic number: result = (2 * v1 - 2 * v2 + t2 + t1) * sCubed + (3 * v2 - 3 * v1 - 2 * t1 - t2) * sSquared + t1 * s + v1;  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,Hermite,The following statement contains a magic number: result = (2 * v1 - 2 * v2 + t2 + t1) * sCubed + (3 * v2 - 3 * v1 - 2 * t1 - t2) * sSquared + t1 * s + v1;  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,Hermite,The following statement contains a magic number: result = (2 * v1 - 2 * v2 + t2 + t1) * sCubed + (3 * v2 - 3 * v1 - 2 * t1 - t2) * sSquared + t1 * s + v1;  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,Hermite,The following statement contains a magic number: result = (2 * v1 - 2 * v2 + t2 + t1) * sCubed + (3 * v2 - 3 * v1 - 2 * t1 - t2) * sSquared + t1 * s + v1;  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,ToDegrees,The following statement contains a magic number: return (float)(radians * 57.295779513082320876798154814105);  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,ToRadians,The following statement contains a magic number: return (float)(degrees * 0.017453292519943295769236907684886);  
Magic Number,Microsoft.Xna.Framework,MathHelper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\MathHelper.cs,WrapAngle,The following statement contains a magic number: angle = (float)Math.IEEERemainder ((double)angle' 6.2831854820251465);  
Magic Number,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,CreateOrthographic,The following statement contains a magic number: result.M11 = 2 / width;  
Magic Number,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,CreateOrthographic,The following statement contains a magic number: result.M22 = 2 / height;  
Magic Number,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,CreateOrthographicOffCenter,The following statement contains a magic number: result.M11 = 2 / (right - left);  
Magic Number,Microsoft.Xna.Framework,Matrix,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Matrix.cs,CreateOrthographicOffCenter,The following statement contains a magic number: result.M22 = 2 / (top - bottom);  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: Debug.Assert (vertices.Count > 3);  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: for (int i = 0; i < vertices.Count; ++i) {  	if (Reflex (i' vertices)) {  		float upperDist;  		float lowerDist = upperDist = float.MaxValue;  		for (int j = 0; j < vertices.Count; ++j) {  			// if line intersects with an edge  			float d;  			Vector2 p;  			if (Left (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)) && RightOn (At (i - 1' vertices)' At (i' vertices)' At (j - 1' vertices))) {  				// find the point of intersection  				p = LineTools.LineIntersect (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)' At (j - 1' vertices));  				if (Right (At (i + 1' vertices)' At (i' vertices)' p)) {  					// make sure it's inside the poly  					d = SquareDist (At (i' vertices)' p);  					if (d < lowerDist) {  						// keep only the closest intersection  						lowerDist = d;  						lowerInt = p;  						lowerIndex = j;  					}  				}  			}  			if (Left (At (i + 1' vertices)' At (i' vertices)' At (j + 1' vertices)) && RightOn (At (i + 1' vertices)' At (i' vertices)' At (j' vertices))) {  				p = LineTools.LineIntersect (At (i + 1' vertices)' At (i' vertices)' At (j' vertices)' At (j + 1' vertices));  				if (Left (At (i - 1' vertices)' At (i' vertices)' p)) {  					d = SquareDist (At (i' vertices)' p);  					if (d < upperDist) {  						upperDist = d;  						upperIndex = j;  						upperInt = p;  					}  				}  			}  		}  		// if there are no vertices to connect to' choose a point in the middle  		if (lowerIndex == (upperIndex + 1) % vertices.Count) {  			Vector2 p = ((lowerInt + upperInt) / 2);  			lowerPoly = Copy (i' upperIndex' vertices);  			lowerPoly.Add (p);  			upperPoly = Copy (lowerIndex' i' vertices);  			upperPoly.Add (p);  		}  		else {  			double highestScore = 0' bestIndex = lowerIndex;  			while (upperIndex < lowerIndex)  				upperIndex += vertices.Count;  			for (int j = lowerIndex; j <= upperIndex; ++j) {  				if (CanSee (i' j' vertices)) {  					double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  					if (Reflex (j' vertices)) {  						if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices)))  							score += 3;  						else  							score += 2;  					}  					else {  						score += 1;  					}  					if (score > highestScore) {  						bestIndex = j;  						highestScore = score;  					}  				}  			}  			lowerPoly = Copy (i' (int)bestIndex' vertices);  			upperPoly = Copy ((int)bestIndex' i' vertices);  		}  		list.AddRange (TriangulatePolygon (lowerPoly));  		list.AddRange (TriangulatePolygon (upperPoly));  		return list;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: for (int i = 0; i < vertices.Count; ++i) {  	if (Reflex (i' vertices)) {  		float upperDist;  		float lowerDist = upperDist = float.MaxValue;  		for (int j = 0; j < vertices.Count; ++j) {  			// if line intersects with an edge  			float d;  			Vector2 p;  			if (Left (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)) && RightOn (At (i - 1' vertices)' At (i' vertices)' At (j - 1' vertices))) {  				// find the point of intersection  				p = LineTools.LineIntersect (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)' At (j - 1' vertices));  				if (Right (At (i + 1' vertices)' At (i' vertices)' p)) {  					// make sure it's inside the poly  					d = SquareDist (At (i' vertices)' p);  					if (d < lowerDist) {  						// keep only the closest intersection  						lowerDist = d;  						lowerInt = p;  						lowerIndex = j;  					}  				}  			}  			if (Left (At (i + 1' vertices)' At (i' vertices)' At (j + 1' vertices)) && RightOn (At (i + 1' vertices)' At (i' vertices)' At (j' vertices))) {  				p = LineTools.LineIntersect (At (i + 1' vertices)' At (i' vertices)' At (j' vertices)' At (j + 1' vertices));  				if (Left (At (i - 1' vertices)' At (i' vertices)' p)) {  					d = SquareDist (At (i' vertices)' p);  					if (d < upperDist) {  						upperDist = d;  						upperIndex = j;  						upperInt = p;  					}  				}  			}  		}  		// if there are no vertices to connect to' choose a point in the middle  		if (lowerIndex == (upperIndex + 1) % vertices.Count) {  			Vector2 p = ((lowerInt + upperInt) / 2);  			lowerPoly = Copy (i' upperIndex' vertices);  			lowerPoly.Add (p);  			upperPoly = Copy (lowerIndex' i' vertices);  			upperPoly.Add (p);  		}  		else {  			double highestScore = 0' bestIndex = lowerIndex;  			while (upperIndex < lowerIndex)  				upperIndex += vertices.Count;  			for (int j = lowerIndex; j <= upperIndex; ++j) {  				if (CanSee (i' j' vertices)) {  					double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  					if (Reflex (j' vertices)) {  						if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices)))  							score += 3;  						else  							score += 2;  					}  					else {  						score += 1;  					}  					if (score > highestScore) {  						bestIndex = j;  						highestScore = score;  					}  				}  			}  			lowerPoly = Copy (i' (int)bestIndex' vertices);  			upperPoly = Copy ((int)bestIndex' i' vertices);  		}  		list.AddRange (TriangulatePolygon (lowerPoly));  		list.AddRange (TriangulatePolygon (upperPoly));  		return list;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: for (int i = 0; i < vertices.Count; ++i) {  	if (Reflex (i' vertices)) {  		float upperDist;  		float lowerDist = upperDist = float.MaxValue;  		for (int j = 0; j < vertices.Count; ++j) {  			// if line intersects with an edge  			float d;  			Vector2 p;  			if (Left (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)) && RightOn (At (i - 1' vertices)' At (i' vertices)' At (j - 1' vertices))) {  				// find the point of intersection  				p = LineTools.LineIntersect (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)' At (j - 1' vertices));  				if (Right (At (i + 1' vertices)' At (i' vertices)' p)) {  					// make sure it's inside the poly  					d = SquareDist (At (i' vertices)' p);  					if (d < lowerDist) {  						// keep only the closest intersection  						lowerDist = d;  						lowerInt = p;  						lowerIndex = j;  					}  				}  			}  			if (Left (At (i + 1' vertices)' At (i' vertices)' At (j + 1' vertices)) && RightOn (At (i + 1' vertices)' At (i' vertices)' At (j' vertices))) {  				p = LineTools.LineIntersect (At (i + 1' vertices)' At (i' vertices)' At (j' vertices)' At (j + 1' vertices));  				if (Left (At (i - 1' vertices)' At (i' vertices)' p)) {  					d = SquareDist (At (i' vertices)' p);  					if (d < upperDist) {  						upperDist = d;  						upperIndex = j;  						upperInt = p;  					}  				}  			}  		}  		// if there are no vertices to connect to' choose a point in the middle  		if (lowerIndex == (upperIndex + 1) % vertices.Count) {  			Vector2 p = ((lowerInt + upperInt) / 2);  			lowerPoly = Copy (i' upperIndex' vertices);  			lowerPoly.Add (p);  			upperPoly = Copy (lowerIndex' i' vertices);  			upperPoly.Add (p);  		}  		else {  			double highestScore = 0' bestIndex = lowerIndex;  			while (upperIndex < lowerIndex)  				upperIndex += vertices.Count;  			for (int j = lowerIndex; j <= upperIndex; ++j) {  				if (CanSee (i' j' vertices)) {  					double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  					if (Reflex (j' vertices)) {  						if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices)))  							score += 3;  						else  							score += 2;  					}  					else {  						score += 1;  					}  					if (score > highestScore) {  						bestIndex = j;  						highestScore = score;  					}  				}  			}  			lowerPoly = Copy (i' (int)bestIndex' vertices);  			upperPoly = Copy ((int)bestIndex' i' vertices);  		}  		list.AddRange (TriangulatePolygon (lowerPoly));  		list.AddRange (TriangulatePolygon (upperPoly));  		return list;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: if (Reflex (i' vertices)) {  	float upperDist;  	float lowerDist = upperDist = float.MaxValue;  	for (int j = 0; j < vertices.Count; ++j) {  		// if line intersects with an edge  		float d;  		Vector2 p;  		if (Left (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)) && RightOn (At (i - 1' vertices)' At (i' vertices)' At (j - 1' vertices))) {  			// find the point of intersection  			p = LineTools.LineIntersect (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)' At (j - 1' vertices));  			if (Right (At (i + 1' vertices)' At (i' vertices)' p)) {  				// make sure it's inside the poly  				d = SquareDist (At (i' vertices)' p);  				if (d < lowerDist) {  					// keep only the closest intersection  					lowerDist = d;  					lowerInt = p;  					lowerIndex = j;  				}  			}  		}  		if (Left (At (i + 1' vertices)' At (i' vertices)' At (j + 1' vertices)) && RightOn (At (i + 1' vertices)' At (i' vertices)' At (j' vertices))) {  			p = LineTools.LineIntersect (At (i + 1' vertices)' At (i' vertices)' At (j' vertices)' At (j + 1' vertices));  			if (Left (At (i - 1' vertices)' At (i' vertices)' p)) {  				d = SquareDist (At (i' vertices)' p);  				if (d < upperDist) {  					upperDist = d;  					upperIndex = j;  					upperInt = p;  				}  			}  		}  	}  	// if there are no vertices to connect to' choose a point in the middle  	if (lowerIndex == (upperIndex + 1) % vertices.Count) {  		Vector2 p = ((lowerInt + upperInt) / 2);  		lowerPoly = Copy (i' upperIndex' vertices);  		lowerPoly.Add (p);  		upperPoly = Copy (lowerIndex' i' vertices);  		upperPoly.Add (p);  	}  	else {  		double highestScore = 0' bestIndex = lowerIndex;  		while (upperIndex < lowerIndex)  			upperIndex += vertices.Count;  		for (int j = lowerIndex; j <= upperIndex; ++j) {  			if (CanSee (i' j' vertices)) {  				double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  				if (Reflex (j' vertices)) {  					if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices)))  						score += 3;  					else  						score += 2;  				}  				else {  					score += 1;  				}  				if (score > highestScore) {  					bestIndex = j;  					highestScore = score;  				}  			}  		}  		lowerPoly = Copy (i' (int)bestIndex' vertices);  		upperPoly = Copy ((int)bestIndex' i' vertices);  	}  	list.AddRange (TriangulatePolygon (lowerPoly));  	list.AddRange (TriangulatePolygon (upperPoly));  	return list;  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: if (Reflex (i' vertices)) {  	float upperDist;  	float lowerDist = upperDist = float.MaxValue;  	for (int j = 0; j < vertices.Count; ++j) {  		// if line intersects with an edge  		float d;  		Vector2 p;  		if (Left (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)) && RightOn (At (i - 1' vertices)' At (i' vertices)' At (j - 1' vertices))) {  			// find the point of intersection  			p = LineTools.LineIntersect (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)' At (j - 1' vertices));  			if (Right (At (i + 1' vertices)' At (i' vertices)' p)) {  				// make sure it's inside the poly  				d = SquareDist (At (i' vertices)' p);  				if (d < lowerDist) {  					// keep only the closest intersection  					lowerDist = d;  					lowerInt = p;  					lowerIndex = j;  				}  			}  		}  		if (Left (At (i + 1' vertices)' At (i' vertices)' At (j + 1' vertices)) && RightOn (At (i + 1' vertices)' At (i' vertices)' At (j' vertices))) {  			p = LineTools.LineIntersect (At (i + 1' vertices)' At (i' vertices)' At (j' vertices)' At (j + 1' vertices));  			if (Left (At (i - 1' vertices)' At (i' vertices)' p)) {  				d = SquareDist (At (i' vertices)' p);  				if (d < upperDist) {  					upperDist = d;  					upperIndex = j;  					upperInt = p;  				}  			}  		}  	}  	// if there are no vertices to connect to' choose a point in the middle  	if (lowerIndex == (upperIndex + 1) % vertices.Count) {  		Vector2 p = ((lowerInt + upperInt) / 2);  		lowerPoly = Copy (i' upperIndex' vertices);  		lowerPoly.Add (p);  		upperPoly = Copy (lowerIndex' i' vertices);  		upperPoly.Add (p);  	}  	else {  		double highestScore = 0' bestIndex = lowerIndex;  		while (upperIndex < lowerIndex)  			upperIndex += vertices.Count;  		for (int j = lowerIndex; j <= upperIndex; ++j) {  			if (CanSee (i' j' vertices)) {  				double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  				if (Reflex (j' vertices)) {  					if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices)))  						score += 3;  					else  						score += 2;  				}  				else {  					score += 1;  				}  				if (score > highestScore) {  					bestIndex = j;  					highestScore = score;  				}  			}  		}  		lowerPoly = Copy (i' (int)bestIndex' vertices);  		upperPoly = Copy ((int)bestIndex' i' vertices);  	}  	list.AddRange (TriangulatePolygon (lowerPoly));  	list.AddRange (TriangulatePolygon (upperPoly));  	return list;  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: if (Reflex (i' vertices)) {  	float upperDist;  	float lowerDist = upperDist = float.MaxValue;  	for (int j = 0; j < vertices.Count; ++j) {  		// if line intersects with an edge  		float d;  		Vector2 p;  		if (Left (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)) && RightOn (At (i - 1' vertices)' At (i' vertices)' At (j - 1' vertices))) {  			// find the point of intersection  			p = LineTools.LineIntersect (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)' At (j - 1' vertices));  			if (Right (At (i + 1' vertices)' At (i' vertices)' p)) {  				// make sure it's inside the poly  				d = SquareDist (At (i' vertices)' p);  				if (d < lowerDist) {  					// keep only the closest intersection  					lowerDist = d;  					lowerInt = p;  					lowerIndex = j;  				}  			}  		}  		if (Left (At (i + 1' vertices)' At (i' vertices)' At (j + 1' vertices)) && RightOn (At (i + 1' vertices)' At (i' vertices)' At (j' vertices))) {  			p = LineTools.LineIntersect (At (i + 1' vertices)' At (i' vertices)' At (j' vertices)' At (j + 1' vertices));  			if (Left (At (i - 1' vertices)' At (i' vertices)' p)) {  				d = SquareDist (At (i' vertices)' p);  				if (d < upperDist) {  					upperDist = d;  					upperIndex = j;  					upperInt = p;  				}  			}  		}  	}  	// if there are no vertices to connect to' choose a point in the middle  	if (lowerIndex == (upperIndex + 1) % vertices.Count) {  		Vector2 p = ((lowerInt + upperInt) / 2);  		lowerPoly = Copy (i' upperIndex' vertices);  		lowerPoly.Add (p);  		upperPoly = Copy (lowerIndex' i' vertices);  		upperPoly.Add (p);  	}  	else {  		double highestScore = 0' bestIndex = lowerIndex;  		while (upperIndex < lowerIndex)  			upperIndex += vertices.Count;  		for (int j = lowerIndex; j <= upperIndex; ++j) {  			if (CanSee (i' j' vertices)) {  				double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  				if (Reflex (j' vertices)) {  					if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices)))  						score += 3;  					else  						score += 2;  				}  				else {  					score += 1;  				}  				if (score > highestScore) {  					bestIndex = j;  					highestScore = score;  				}  			}  		}  		lowerPoly = Copy (i' (int)bestIndex' vertices);  		upperPoly = Copy ((int)bestIndex' i' vertices);  	}  	list.AddRange (TriangulatePolygon (lowerPoly));  	list.AddRange (TriangulatePolygon (upperPoly));  	return list;  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: if (lowerIndex == (upperIndex + 1) % vertices.Count) {  	Vector2 p = ((lowerInt + upperInt) / 2);  	lowerPoly = Copy (i' upperIndex' vertices);  	lowerPoly.Add (p);  	upperPoly = Copy (lowerIndex' i' vertices);  	upperPoly.Add (p);  }  else {  	double highestScore = 0' bestIndex = lowerIndex;  	while (upperIndex < lowerIndex)  		upperIndex += vertices.Count;  	for (int j = lowerIndex; j <= upperIndex; ++j) {  		if (CanSee (i' j' vertices)) {  			double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  			if (Reflex (j' vertices)) {  				if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices)))  					score += 3;  				else  					score += 2;  			}  			else {  				score += 1;  			}  			if (score > highestScore) {  				bestIndex = j;  				highestScore = score;  			}  		}  	}  	lowerPoly = Copy (i' (int)bestIndex' vertices);  	upperPoly = Copy ((int)bestIndex' i' vertices);  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: if (lowerIndex == (upperIndex + 1) % vertices.Count) {  	Vector2 p = ((lowerInt + upperInt) / 2);  	lowerPoly = Copy (i' upperIndex' vertices);  	lowerPoly.Add (p);  	upperPoly = Copy (lowerIndex' i' vertices);  	upperPoly.Add (p);  }  else {  	double highestScore = 0' bestIndex = lowerIndex;  	while (upperIndex < lowerIndex)  		upperIndex += vertices.Count;  	for (int j = lowerIndex; j <= upperIndex; ++j) {  		if (CanSee (i' j' vertices)) {  			double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  			if (Reflex (j' vertices)) {  				if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices)))  					score += 3;  				else  					score += 2;  			}  			else {  				score += 1;  			}  			if (score > highestScore) {  				bestIndex = j;  				highestScore = score;  			}  		}  	}  	lowerPoly = Copy (i' (int)bestIndex' vertices);  	upperPoly = Copy ((int)bestIndex' i' vertices);  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: if (lowerIndex == (upperIndex + 1) % vertices.Count) {  	Vector2 p = ((lowerInt + upperInt) / 2);  	lowerPoly = Copy (i' upperIndex' vertices);  	lowerPoly.Add (p);  	upperPoly = Copy (lowerIndex' i' vertices);  	upperPoly.Add (p);  }  else {  	double highestScore = 0' bestIndex = lowerIndex;  	while (upperIndex < lowerIndex)  		upperIndex += vertices.Count;  	for (int j = lowerIndex; j <= upperIndex; ++j) {  		if (CanSee (i' j' vertices)) {  			double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  			if (Reflex (j' vertices)) {  				if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices)))  					score += 3;  				else  					score += 2;  			}  			else {  				score += 1;  			}  			if (score > highestScore) {  				bestIndex = j;  				highestScore = score;  			}  		}  	}  	lowerPoly = Copy (i' (int)bestIndex' vertices);  	upperPoly = Copy ((int)bestIndex' i' vertices);  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: for (int j = lowerIndex; j <= upperIndex; ++j) {  	if (CanSee (i' j' vertices)) {  		double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  		if (Reflex (j' vertices)) {  			if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices)))  				score += 3;  			else  				score += 2;  		}  		else {  			score += 1;  		}  		if (score > highestScore) {  			bestIndex = j;  			highestScore = score;  		}  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: for (int j = lowerIndex; j <= upperIndex; ++j) {  	if (CanSee (i' j' vertices)) {  		double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  		if (Reflex (j' vertices)) {  			if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices)))  				score += 3;  			else  				score += 2;  		}  		else {  			score += 1;  		}  		if (score > highestScore) {  			bestIndex = j;  			highestScore = score;  		}  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: if (CanSee (i' j' vertices)) {  	double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  	if (Reflex (j' vertices)) {  		if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices)))  			score += 3;  		else  			score += 2;  	}  	else {  		score += 1;  	}  	if (score > highestScore) {  		bestIndex = j;  		highestScore = score;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: if (CanSee (i' j' vertices)) {  	double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  	if (Reflex (j' vertices)) {  		if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices)))  			score += 3;  		else  			score += 2;  	}  	else {  		score += 1;  	}  	if (score > highestScore) {  		bestIndex = j;  		highestScore = score;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: if (Reflex (j' vertices)) {  	if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices)))  		score += 3;  	else  		score += 2;  }  else {  	score += 1;  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: if (Reflex (j' vertices)) {  	if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices)))  		score += 3;  	else  		score += 2;  }  else {  	score += 1;  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices)))  	score += 3;  else  	score += 2;  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices)))  	score += 3;  else  	score += 2;  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: score += 3;  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: score += 2;  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: if (vertices.Count > Settings.MaxPolygonVertices) {  	lowerPoly = Copy (0' vertices.Count / 2' vertices);  	upperPoly = Copy (vertices.Count / 2' 0' vertices);  	list.AddRange (TriangulatePolygon (lowerPoly));  	list.AddRange (TriangulatePolygon (upperPoly));  }  else  	list.Add (vertices);  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: if (vertices.Count > Settings.MaxPolygonVertices) {  	lowerPoly = Copy (0' vertices.Count / 2' vertices);  	upperPoly = Copy (vertices.Count / 2' 0' vertices);  	list.AddRange (TriangulatePolygon (lowerPoly));  	list.AddRange (TriangulatePolygon (upperPoly));  }  else  	list.Add (vertices);  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: lowerPoly = Copy (0' vertices.Count / 2' vertices);  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\BayazitDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: upperPoly = Copy (vertices.Count / 2' 0' vertices);  
Magic Number,FarseerPhysics.Common.Decomposition,CDTDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDTDecomposer.cs,ConvexPartition,The following statement contains a magic number: Debug.Assert (vertices.Count > 3);  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\EarclipDecomposer.cs,ConvexPartition,The following statement contains a magic number: Debug.Assert (vertices.Count > 3);  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\EarclipDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: if (vertices.Count < 3)  	return new List<Vertices> ();  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\EarclipDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: while (vNum > 3) {  	// Find an ear  	int earIndex = -1;  	float earMaxMinCross = -10.0f;  	for (int i = 0; i < vNum; ++i) {  		if (IsEar (i' xrem' yrem' vNum)) {  			int lower = Remainder (i - 1' vNum);  			int upper = Remainder (i + 1' vNum);  			Vector2 d1 = new Vector2 (xrem [upper] - xrem [i]' yrem [upper] - yrem [i]);  			Vector2 d2 = new Vector2 (xrem [i] - xrem [lower]' yrem [i] - yrem [lower]);  			Vector2 d3 = new Vector2 (xrem [lower] - xrem [upper]' yrem [lower] - yrem [upper]);  			d1.Normalize ();  			d2.Normalize ();  			d3.Normalize ();  			float cross12;  			MathUtils.Cross (ref d1' ref d2' out cross12);  			cross12 = Math.Abs (cross12);  			float cross23;  			MathUtils.Cross (ref d2' ref d3' out cross23);  			cross23 = Math.Abs (cross23);  			float cross31;  			MathUtils.Cross (ref d3' ref d1' out cross31);  			cross31 = Math.Abs (cross31);  			//Find the maximum minimum angle  			float minCross = Math.Min (cross12' Math.Min (cross23' cross31));  			if (minCross > earMaxMinCross) {  				earIndex = i;  				earMaxMinCross = minCross;  			}  		}  	}  	// If we still haven't found an ear' we're screwed.  	// Note: sometimes this is happening because the  	// remaining points are collinear.  Really these  	// should just be thrown out without halting triangulation.  	if (earIndex == -1) {  		for (int i = 0; i < bufferSize; i++) {  			results.Add (buffer [i]);  		}  		return results;  	}  	// Clip off the ear:  	// - remove the ear tip from the list  	--vNum;  	float[] newx = new float[vNum];  	float[] newy = new float[vNum];  	int currDest = 0;  	for (int i = 0; i < vNum; ++i) {  		if (currDest == earIndex)  			++currDest;  		newx [i] = xrem [currDest];  		newy [i] = yrem [currDest];  		++currDest;  	}  	// - add the clipped triangle to the triangle list  	int under = (earIndex == 0) ? (vNum) : (earIndex - 1);  	int over = (earIndex == vNum) ? 0 : (earIndex + 1);  	Triangle toAdd = new Triangle (xrem [earIndex]' yrem [earIndex]' xrem [over]' yrem [over]' xrem [under]' yrem [under]);  	buffer [bufferSize] = toAdd;  	++bufferSize;  	// - replace the old list with the new one  	xrem = newx;  	yrem = newy;  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\EarclipDecomposer.cs,ResolvePinchPoint,The following statement contains a magic number: if (pin.Count < 3)  	return false;  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\EarclipDecomposer.cs,IsEar,The following statement contains a magic number: if (i >= xvLength || i < 0 || xvLength < 3) {  	return false;  }  
Magic Number,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,The following statement contains a magic number: Debug.Assert (vertices.Count > 3);  
Magic Number,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,The following statement contains a magic number: for (int v = nv - 1; nv > 2;) {  	// If we loop' it is probably a non-simple polygon   	if (0 >= (count--)) {  		// Triangulate: ERROR - probable bad polygon!  		return new List<Vertices> ();  	}  	// Three consecutive vertices in current polygon' <u'v'w>  	int u = v;  	if (nv <= u)  		u = 0;  	// Previous   	v = u + 1;  	if (nv <= v)  		v = 0;  	// New v     	int w = v + 1;  	if (nv <= w)  		w = 0;  	// Next   	_tmpA = vertices [polygon [u]];  	_tmpB = vertices [polygon [v]];  	_tmpC = vertices [polygon [w]];  	if (Snip (vertices' u' v' w' nv' polygon)) {  		int s' t;  		// Output Triangle  		Vertices triangle = new Vertices (3);  		triangle.Add (_tmpA);  		triangle.Add (_tmpB);  		triangle.Add (_tmpC);  		result.Add (triangle);  		// Remove v from remaining polygon   		for (s = v' t = v + 1; t < nv; s++' t++) {  			polygon [s] = polygon [t];  		}  		nv--;  		// Reset error detection counter  		count = 2 * nv;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,The following statement contains a magic number: for (int v = nv - 1; nv > 2;) {  	// If we loop' it is probably a non-simple polygon   	if (0 >= (count--)) {  		// Triangulate: ERROR - probable bad polygon!  		return new List<Vertices> ();  	}  	// Three consecutive vertices in current polygon' <u'v'w>  	int u = v;  	if (nv <= u)  		u = 0;  	// Previous   	v = u + 1;  	if (nv <= v)  		v = 0;  	// New v     	int w = v + 1;  	if (nv <= w)  		w = 0;  	// Next   	_tmpA = vertices [polygon [u]];  	_tmpB = vertices [polygon [v]];  	_tmpC = vertices [polygon [w]];  	if (Snip (vertices' u' v' w' nv' polygon)) {  		int s' t;  		// Output Triangle  		Vertices triangle = new Vertices (3);  		triangle.Add (_tmpA);  		triangle.Add (_tmpB);  		triangle.Add (_tmpC);  		result.Add (triangle);  		// Remove v from remaining polygon   		for (s = v' t = v + 1; t < nv; s++' t++) {  			polygon [s] = polygon [t];  		}  		nv--;  		// Reset error detection counter  		count = 2 * nv;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,The following statement contains a magic number: for (int v = nv - 1; nv > 2;) {  	// If we loop' it is probably a non-simple polygon   	if (0 >= (count--)) {  		// Triangulate: ERROR - probable bad polygon!  		return new List<Vertices> ();  	}  	// Three consecutive vertices in current polygon' <u'v'w>  	int u = v;  	if (nv <= u)  		u = 0;  	// Previous   	v = u + 1;  	if (nv <= v)  		v = 0;  	// New v     	int w = v + 1;  	if (nv <= w)  		w = 0;  	// Next   	_tmpA = vertices [polygon [u]];  	_tmpB = vertices [polygon [v]];  	_tmpC = vertices [polygon [w]];  	if (Snip (vertices' u' v' w' nv' polygon)) {  		int s' t;  		// Output Triangle  		Vertices triangle = new Vertices (3);  		triangle.Add (_tmpA);  		triangle.Add (_tmpB);  		triangle.Add (_tmpC);  		result.Add (triangle);  		// Remove v from remaining polygon   		for (s = v' t = v + 1; t < nv; s++' t++) {  			polygon [s] = polygon [t];  		}  		nv--;  		// Reset error detection counter  		count = 2 * nv;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (Snip (vertices' u' v' w' nv' polygon)) {  	int s' t;  	// Output Triangle  	Vertices triangle = new Vertices (3);  	triangle.Add (_tmpA);  	triangle.Add (_tmpB);  	triangle.Add (_tmpC);  	result.Add (triangle);  	// Remove v from remaining polygon   	for (s = v' t = v + 1; t < nv; s++' t++) {  		polygon [s] = polygon [t];  	}  	nv--;  	// Reset error detection counter  	count = 2 * nv;  }  
Magic Number,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (Snip (vertices' u' v' w' nv' polygon)) {  	int s' t;  	// Output Triangle  	Vertices triangle = new Vertices (3);  	triangle.Add (_tmpA);  	triangle.Add (_tmpB);  	triangle.Add (_tmpC);  	result.Add (triangle);  	// Remove v from remaining polygon   	for (s = v' t = v + 1; t < nv; s++' t++) {  		polygon [s] = polygon [t];  	}  	nv--;  	// Reset error detection counter  	count = 2 * nv;  }  
Magic Number,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,The following statement contains a magic number: count = 2 * nv;  
Magic Number,FarseerPhysics.Common.Decomposition,SeidelDecomposer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\SeidelDecomposer.cs,ConvexPartition,The following statement contains a magic number: Debug.Assert (vertices.Count > 3);  
Magic Number,FarseerPhysics.Common.Decomposition,Triangulate,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Triangulate.cs,ConvexPartition,The following statement contains a magic number: if (vertices.Count <= 3)  	return new List<Vertices> {  		vertices  	};  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,DelaunayTriangle,The following statement contains a magic number: Points [2] = p3;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,IndexCW,The following statement contains a magic number: switch (index) {  case 0:  	return 2;  case 1:  	return 0;  default:  	return 1;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,IndexCW,The following statement contains a magic number: return 2;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,IndexCCW,The following statement contains a magic number: switch (index) {  case 0:  	return 1;  case 1:  	return 2;  default:  	return 0;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,IndexCCW,The following statement contains a magic number: return 2;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,Contains,The following statement contains a magic number: return (p == Points [0] || p == Points [1] || p == Points [2]);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points [2] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [2])) {  	Neighbors [0] = t;  }  else if ((p1 == Points [0] && p2 == Points [2]) || (p1 == Points [2] && p2 == Points [0])) {  	Neighbors [1] = t;  }  else if ((p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])) {  	Neighbors [2] = t;  }  else {  	Debug.WriteLine ("Neighbor error' please report!");  	// throw new Exception("Neighbor error' please report!");  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points [2] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [2])) {  	Neighbors [0] = t;  }  else if ((p1 == Points [0] && p2 == Points [2]) || (p1 == Points [2] && p2 == Points [0])) {  	Neighbors [1] = t;  }  else if ((p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])) {  	Neighbors [2] = t;  }  else {  	Debug.WriteLine ("Neighbor error' please report!");  	// throw new Exception("Neighbor error' please report!");  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points [2] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [2])) {  	Neighbors [0] = t;  }  else if ((p1 == Points [0] && p2 == Points [2]) || (p1 == Points [2] && p2 == Points [0])) {  	Neighbors [1] = t;  }  else if ((p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])) {  	Neighbors [2] = t;  }  else {  	Debug.WriteLine ("Neighbor error' please report!");  	// throw new Exception("Neighbor error' please report!");  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points [2] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [2])) {  	Neighbors [0] = t;  }  else if ((p1 == Points [0] && p2 == Points [2]) || (p1 == Points [2] && p2 == Points [0])) {  	Neighbors [1] = t;  }  else if ((p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])) {  	Neighbors [2] = t;  }  else {  	Debug.WriteLine ("Neighbor error' please report!");  	// throw new Exception("Neighbor error' please report!");  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points [2] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [2])) {  	Neighbors [0] = t;  }  else if ((p1 == Points [0] && p2 == Points [2]) || (p1 == Points [2] && p2 == Points [0])) {  	Neighbors [1] = t;  }  else if ((p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])) {  	Neighbors [2] = t;  }  else {  	Debug.WriteLine ("Neighbor error' please report!");  	// throw new Exception("Neighbor error' please report!");  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points [0] && p2 == Points [2]) || (p1 == Points [2] && p2 == Points [0])) {  	Neighbors [1] = t;  }  else if ((p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])) {  	Neighbors [2] = t;  }  else {  	Debug.WriteLine ("Neighbor error' please report!");  	// throw new Exception("Neighbor error' please report!");  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points [0] && p2 == Points [2]) || (p1 == Points [2] && p2 == Points [0])) {  	Neighbors [1] = t;  }  else if ((p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])) {  	Neighbors [2] = t;  }  else {  	Debug.WriteLine ("Neighbor error' please report!");  	// throw new Exception("Neighbor error' please report!");  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points [0] && p2 == Points [2]) || (p1 == Points [2] && p2 == Points [0])) {  	Neighbors [1] = t;  }  else if ((p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])) {  	Neighbors [2] = t;  }  else {  	Debug.WriteLine ("Neighbor error' please report!");  	// throw new Exception("Neighbor error' please report!");  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])) {  	Neighbors [2] = t;  }  else {  	Debug.WriteLine ("Neighbor error' please report!");  	// throw new Exception("Neighbor error' please report!");  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: Neighbors [2] = t;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains (Points [1]' Points [2])) {  	Neighbors [0] = t;  	t.MarkNeighbor (Points [1]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [2])) {  	Neighbors [1] = t;  	t.MarkNeighbor (Points [0]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [1])) {  	Neighbors [2] = t;  	t.MarkNeighbor (Points [0]' Points [1]' this);  }  else {  	Debug.WriteLine ("markNeighbor failed");  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains (Points [1]' Points [2])) {  	Neighbors [0] = t;  	t.MarkNeighbor (Points [1]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [2])) {  	Neighbors [1] = t;  	t.MarkNeighbor (Points [0]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [1])) {  	Neighbors [2] = t;  	t.MarkNeighbor (Points [0]' Points [1]' this);  }  else {  	Debug.WriteLine ("markNeighbor failed");  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains (Points [1]' Points [2])) {  	Neighbors [0] = t;  	t.MarkNeighbor (Points [1]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [2])) {  	Neighbors [1] = t;  	t.MarkNeighbor (Points [0]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [1])) {  	Neighbors [2] = t;  	t.MarkNeighbor (Points [0]' Points [1]' this);  }  else {  	Debug.WriteLine ("markNeighbor failed");  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains (Points [1]' Points [2])) {  	Neighbors [0] = t;  	t.MarkNeighbor (Points [1]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [2])) {  	Neighbors [1] = t;  	t.MarkNeighbor (Points [0]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [1])) {  	Neighbors [2] = t;  	t.MarkNeighbor (Points [0]' Points [1]' this);  }  else {  	Debug.WriteLine ("markNeighbor failed");  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains (Points [1]' Points [2])) {  	Neighbors [0] = t;  	t.MarkNeighbor (Points [1]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [2])) {  	Neighbors [1] = t;  	t.MarkNeighbor (Points [0]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [1])) {  	Neighbors [2] = t;  	t.MarkNeighbor (Points [0]' Points [1]' this);  }  else {  	Debug.WriteLine ("markNeighbor failed");  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: t.MarkNeighbor (Points [1]' Points [2]' this);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains (Points [0]' Points [2])) {  	Neighbors [1] = t;  	t.MarkNeighbor (Points [0]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [1])) {  	Neighbors [2] = t;  	t.MarkNeighbor (Points [0]' Points [1]' this);  }  else {  	Debug.WriteLine ("markNeighbor failed");  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains (Points [0]' Points [2])) {  	Neighbors [1] = t;  	t.MarkNeighbor (Points [0]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [1])) {  	Neighbors [2] = t;  	t.MarkNeighbor (Points [0]' Points [1]' this);  }  else {  	Debug.WriteLine ("markNeighbor failed");  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains (Points [0]' Points [2])) {  	Neighbors [1] = t;  	t.MarkNeighbor (Points [0]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [1])) {  	Neighbors [2] = t;  	t.MarkNeighbor (Points [0]' Points [1]' this);  }  else {  	Debug.WriteLine ("markNeighbor failed");  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: t.MarkNeighbor (Points [0]' Points [2]' this);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains (Points [0]' Points [1])) {  	Neighbors [2] = t;  	t.MarkNeighbor (Points [0]' Points [1]' this);  }  else {  	Debug.WriteLine ("markNeighbor failed");  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: Neighbors [2] = t;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,ClearNeighbors,The following statement contains a magic number: Neighbors [0] = Neighbors [1] = Neighbors [2] = null;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,ClearNeighbor,The following statement contains a magic number: if (Neighbors [0] == triangle) {  	Neighbors [0] = null;  }  else if (Neighbors [1] == triangle) {  	Neighbors [1] = null;  }  else {  	Neighbors [2] = null;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,ClearNeighbor,The following statement contains a magic number: if (Neighbors [1] == triangle) {  	Neighbors [1] = null;  }  else {  	Neighbors [2] = null;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,ClearNeighbor,The following statement contains a magic number: Neighbors [2] = null;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,Clear,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	t = Neighbors [i];  	if (t != null) {  		t.ClearNeighbor (this);  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,Clear,The following statement contains a magic number: Points [0] = Points [1] = Points [2] = null;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,NeighborCW,The following statement contains a magic number: return Neighbors [(Points.IndexOf (point) + 1) % 3];  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,NeighborCCW,The following statement contains a magic number: return Neighbors [(Points.IndexOf (point) + 2) % 3];  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,NeighborCCW,The following statement contains a magic number: return Neighbors [(Points.IndexOf (point) + 2) % 3];  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,PointCCW,The following statement contains a magic number: return Points [(IndexOf (point) + 1) % 3];  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,PointCW,The following statement contains a magic number: return Points [(IndexOf (point) + 2) % 3];  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,PointCW,The following statement contains a magic number: return Points [(IndexOf (point) + 2) % 3];  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,RotateCW,The following statement contains a magic number: Points [2] = Points [1];  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,ToString,The following statement contains a magic number: return Points [0] + "'" + Points [1] + "'" + Points [2];  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (EdgeIsConstrained [i] && Neighbors [i] != null) {  		Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  	}  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (EdgeIsConstrained [i] && Neighbors [i] != null) {  		Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  	}  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (EdgeIsConstrained [i] && Neighbors [i] != null) {  		Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  	}  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (EdgeIsConstrained [i] && Neighbors [i] != null) {  		Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  	}  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: if (EdgeIsConstrained [i] && Neighbors [i] != null) {  	Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: if (EdgeIsConstrained [i] && Neighbors [i] != null) {  	Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: if (EdgeIsConstrained [i] && Neighbors [i] != null) {  	Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (EdgeIsConstrained [i]) {  		triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  	}  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (EdgeIsConstrained [i]) {  		triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  	}  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (EdgeIsConstrained [i]) {  		triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  	}  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (EdgeIsConstrained [i]) {  		triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  	}  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: if (EdgeIsConstrained [i]) {  	triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: if (EdgeIsConstrained [i]) {  	triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: if (EdgeIsConstrained [i]) {  	triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: foreach (DelaunayTriangle t in tList)  	for (int i = 0; i < 3; i++)  		if (t.EdgeIsConstrained [i]) {  			MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  		}  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: foreach (DelaunayTriangle t in tList)  	for (int i = 0; i < 3; i++)  		if (t.EdgeIsConstrained [i]) {  			MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  		}  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: foreach (DelaunayTriangle t in tList)  	for (int i = 0; i < 3; i++)  		if (t.EdgeIsConstrained [i]) {  			MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  		}  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: foreach (DelaunayTriangle t in tList)  	for (int i = 0; i < 3; i++)  		if (t.EdgeIsConstrained [i]) {  			MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  		}  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (t.EdgeIsConstrained [i]) {  		MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  	}  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (t.EdgeIsConstrained [i]) {  		MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  	}  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (t.EdgeIsConstrained [i]) {  		MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  	}  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (t.EdgeIsConstrained [i]) {  		MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  	}  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: if (t.EdgeIsConstrained [i]) {  	MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: if (t.EdgeIsConstrained [i]) {  	MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: if (t.EdgeIsConstrained [i]) {  	MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,EdgeIndex,The following statement contains a magic number: if (a && b)  	return 2;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,EdgeIndex,The following statement contains a magic number: return 2;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,GetConstrainedEdgeCCW,The following statement contains a magic number: return EdgeIsConstrained [(IndexOf (p) + 2) % 3];  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,GetConstrainedEdgeCCW,The following statement contains a magic number: return EdgeIsConstrained [(IndexOf (p) + 2) % 3];  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,GetConstrainedEdgeCW,The following statement contains a magic number: return EdgeIsConstrained [(IndexOf (p) + 1) % 3];  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,SetConstrainedEdgeCCW,The following statement contains a magic number: EdgeIsConstrained [(IndexOf (p) + 2) % 3] = ce;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,SetConstrainedEdgeCCW,The following statement contains a magic number: EdgeIsConstrained [(IndexOf (p) + 2) % 3] = ce;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,SetConstrainedEdgeCW,The following statement contains a magic number: EdgeIsConstrained [(IndexOf (p) + 1) % 3] = ce;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,GetDelaunayEdgeCCW,The following statement contains a magic number: return EdgeIsDelaunay [(IndexOf (p) + 2) % 3];  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,GetDelaunayEdgeCCW,The following statement contains a magic number: return EdgeIsDelaunay [(IndexOf (p) + 2) % 3];  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,GetDelaunayEdgeCW,The following statement contains a magic number: return EdgeIsDelaunay [(IndexOf (p) + 1) % 3];  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,SetDelaunayEdgeCCW,The following statement contains a magic number: EdgeIsDelaunay [(IndexOf (p) + 2) % 3] = ce;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,SetDelaunayEdgeCCW,The following statement contains a magic number: EdgeIsDelaunay [(IndexOf (p) + 2) % 3] = ce;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay,DelaunayTriangle,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,SetDelaunayEdgeCW,The following statement contains a magic number: EdgeIsDelaunay [(IndexOf (p) + 1) % 3] = ce;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep,DTSweep,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,Legalize,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	// TODO: fix so that cEdge is always valid when creating new triangles then we can check it here  	//       instead of below with ot  	if (t.EdgeIsDelaunay [i]) {  		continue;  	}  	DelaunayTriangle ot = t.Neighbors [i];  	if (ot != null) {  		TriangulationPoint p = t.Points [i];  		TriangulationPoint op = ot.OppositePoint (t' p);  		int oi = ot.IndexOf (op);  		// If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)  		// then we should not try to legalize  		if (ot.EdgeIsConstrained [oi] || ot.EdgeIsDelaunay [oi]) {  			t.EdgeIsConstrained [i] = ot.EdgeIsConstrained [oi];  			// XXX: have no good way of setting this property when creating new triangles so lets set it here  			continue;  		}  		bool inside = TriangulationUtil.SmartIncircle (p' t.PointCCW (p)' t.PointCW (p)' op);  		if (inside) {  			// Lets mark this shared edge as Delaunay   			t.EdgeIsDelaunay [i] = true;  			ot.EdgeIsDelaunay [oi] = true;  			// Lets rotate shared edge one vertex CW to legalize it  			RotateTrianglePair (t' p' ot' op);  			// We now got one valid Delaunay Edge shared by two triangles  			// This gives us 4 new edges to check for Delaunay  			// Make sure that triangle to node mapping is done only one time for a specific triangle  			bool notLegalized = !Legalize (tcx' t);  			if (notLegalized) {  				tcx.MapTriangleToNodes (t);  			}  			notLegalized = !Legalize (tcx' ot);  			if (notLegalized) {  				tcx.MapTriangleToNodes (ot);  			}  			// Reset the Delaunay edges' since they only are valid Delaunay edges  			// until we add a new triangle or point.  			// XXX: need to think about this. Can these edges be tried after we   			//      return to previous recursive level?  			t.EdgeIsDelaunay [i] = false;  			ot.EdgeIsDelaunay [oi] = false;  			// If triangle have been legalized no need to check the other edges since  			// the recursive legalization will handles those so we can end here.  			return true;  		}  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep,DTSweepContext,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\Sweep\DTSweepContext.cs,MeshCleanReq,The following statement contains a magic number: if (triangle != null && !triangle.IsInterior) {  	triangle.IsInterior = true;  	Triangulatable.AddTriangle (triangle);  	for (int i = 0; i < 3; i++) {  		if (!triangle.EdgeIsConstrained [i]) {  			MeshCleanReq (triangle.Neighbors [i]);  		}  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep,DTSweepContext,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\Sweep\DTSweepContext.cs,MeshCleanReq,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	if (!triangle.EdgeIsConstrained [i]) {  		MeshCleanReq (triangle.Neighbors [i]);  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep,DTSweepContext,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\Sweep\DTSweepContext.cs,CreateAdvancingFront,The following statement contains a magic number: tail = new AdvancingFrontNode (iTriangle.Points [2]);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Delaunay.Sweep,DTSweepContext,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Delaunay\Sweep\DTSweepContext.cs,MapTriangleToNodes,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	if (t.Neighbors [i] == null) {  		n = aFront.LocatePoint (t.PointCW (t.Points [i]));  		if (n != null) {  			n.Triangle = t;  		}  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Polygon,Polygon,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Polygon\Polygon.cs,Polygon,The following statement contains a magic number: if (points.Count < 3)  	throw new ArgumentException ("List has fewer than 3 points"' "points");  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Sets,ConstrainedPointSet,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Sets\ConstrainedPointSet.cs,PrepareTriangulation,The following statement contains a magic number: if (_constrainedPointList != null) {  	TriangulationPoint p1' p2;  	List<TriangulationPoint>.Enumerator iterator = _constrainedPointList.GetEnumerator ();  	while (iterator.MoveNext ()) {  		p1 = iterator.Current;  		iterator.MoveNext ();  		p2 = iterator.Current;  		tcx.NewConstraint (p1' p2);  	}  }  else {  	for (int i = 0; i < EdgeIndex.Length; i += 2) {  		// XXX: must change!!  		tcx.NewConstraint (Points [EdgeIndex [i]]' Points [EdgeIndex [i + 1]]);  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Sets,ConstrainedPointSet,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Sets\ConstrainedPointSet.cs,PrepareTriangulation,The following statement contains a magic number: for (int i = 0; i < EdgeIndex.Length; i += 2) {  	// XXX: must change!!  	tcx.NewConstraint (Points [EdgeIndex [i]]' Points [EdgeIndex [i + 1]]);  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Sets,ConstrainedPointSet,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Sets\ConstrainedPointSet.cs,PrepareTriangulation,The following statement contains a magic number: i += 2
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,FixedArray3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\FixedArray3.cs,Contains,The following statement contains a magic number: for (int i = 0; i < 3; ++i)  	if (this [i] == value)  		return true;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,FixedArray3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\FixedArray3.cs,IndexOf,The following statement contains a magic number: for (int i = 0; i < 3; ++i)  	if (this [i] == value)  		return i;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,FixedArray3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\FixedArray3.cs,Clear,The following statement contains a magic number: for (int i = 0; i < 3; ++i)  	if (this [i] == value)  		this [i] = null;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,FixedArray3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\FixedArray3.cs,Enumerate,The following statement contains a magic number: for (int i = 0; i < 3; ++i)  	yield return this [i];  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,FixedBitArray3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\FixedBitArray3.cs,Contains,The following statement contains a magic number: for (int i = 0; i < 3; ++i)  	if (this [i] == value)  		return true;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,FixedBitArray3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\FixedBitArray3.cs,IndexOf,The following statement contains a magic number: for (int i = 0; i < 3; ++i)  	if (this [i] == value)  		return i;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,FixedBitArray3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\FixedBitArray3.cs,Clear,The following statement contains a magic number: for (int i = 0; i < 3; ++i)  	if (this [i] == value)  		this [i] = false;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,FixedBitArray3,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\FixedBitArray3.cs,Enumerate,The following statement contains a magic number: for (int i = 0; i < 3; ++i)  	yield return this [i];  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PointGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PointGenerator.cs,UniformDistribution,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	points.Add (new TriangulationPoint (scale * (0.5 - RNG.NextDouble ())' scale * (0.5 - RNG.NextDouble ())));  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PointGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PointGenerator.cs,UniformDistribution,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	points.Add (new TriangulationPoint (scale * (0.5 - RNG.NextDouble ())' scale * (0.5 - RNG.NextDouble ())));  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PointGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PointGenerator.cs,UniformDistribution,The following statement contains a magic number: points.Add (new TriangulationPoint (scale * (0.5 - RNG.NextDouble ())' scale * (0.5 - RNG.NextDouble ())));  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PointGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PointGenerator.cs,UniformDistribution,The following statement contains a magic number: points.Add (new TriangulationPoint (scale * (0.5 - RNG.NextDouble ())' scale * (0.5 - RNG.NextDouble ())));  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 250 == 0) {  	radius += scale / 2 * (0.5 - RNG.NextDouble ());  }  else if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 250 == 0) {  	radius += scale / 2 * (0.5 - RNG.NextDouble ());  }  else if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 250 == 0) {  	radius += scale / 2 * (0.5 - RNG.NextDouble ());  }  else if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 250 == 0) {  	radius += scale / 2 * (0.5 - RNG.NextDouble ());  }  else if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 250 == 0) {  	radius += scale / 2 * (0.5 - RNG.NextDouble ());  }  else if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 250 == 0) {  	radius += scale / 2 * (0.5 - RNG.NextDouble ());  }  else if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 250 == 0) {  	radius += scale / 2 * (0.5 - RNG.NextDouble ());  }  else if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 250 == 0) {  	radius += scale / 2 * (0.5 - RNG.NextDouble ());  }  else if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius += scale / 2 * (0.5 - RNG.NextDouble ());  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius += scale / 2 * (0.5 - RNG.NextDouble ());  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius += scale / 5 * (0.5 - RNG.NextDouble ());  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius += scale / 5 * (0.5 - RNG.NextDouble ());  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius = radius > scale / 2 ? scale / 2 : radius;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius = radius > scale / 2 ? scale / 2 : radius;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius = radius < scale / 10 ? scale / 10 : radius;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius = radius < scale / 10 ? scale / 10 : radius;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: do {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: do {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: do {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: do {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: do {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: do {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: do {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: do {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: radius += scale / 5 * (0.5 - RNG.NextDouble ());  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: radius += scale / 5 * (0.5 - RNG.NextDouble ());  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: radius = radius > scale / 2 ? scale / 2 : radius;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: radius = radius > scale / 2 ? scale / 2 : radius;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: radius = radius < scale / 10 ? scale / 10 : radius;  
Magic Number,FarseerPhysics.Common.Decomposition.CDT.Util,PolygonGenerator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: radius = radius < scale / 10 ? scale / 10 : radius;  
Magic Number,FarseerPhysics.Common.Decomposition.Seidel,MonotoneMountain,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\MonotoneMountain.cs,Add,The following statement contains a magic number: if (_size == 0) {  	_head = point;  	_size = 1;  }  else if (_size == 1) {  	// Keep repeat points out of the list  	_tail = point;  	_tail.Prev = _head;  	_head.Next = _tail;  	_size = 2;  }  else {  	// Keep repeat points out of the list  	_tail.Next = point;  	point.Prev = _tail;  	_tail = point;  	_size += 1;  }  
Magic Number,FarseerPhysics.Common.Decomposition.Seidel,MonotoneMountain,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\MonotoneMountain.cs,Add,The following statement contains a magic number: if (_size == 1) {  	// Keep repeat points out of the list  	_tail = point;  	_tail.Prev = _head;  	_head.Next = _tail;  	_size = 2;  }  else {  	// Keep repeat points out of the list  	_tail.Next = point;  	point.Prev = _tail;  	_tail = point;  	_size += 1;  }  
Magic Number,FarseerPhysics.Common.Decomposition.Seidel,MonotoneMountain,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\MonotoneMountain.cs,Add,The following statement contains a magic number: _size = 2;  
Magic Number,FarseerPhysics.Common.Decomposition.Seidel,MonotoneMountain,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\MonotoneMountain.cs,Triangulate,The following statement contains a magic number: while (_convexPoints.Count != 0) {  	IEnumerator<Point> e = _convexPoints.GetEnumerator ();  	e.MoveNext ();  	Point ear = e.Current;  	_convexPoints.Remove (ear);  	Point a = ear.Prev;  	Point b = ear;  	Point c = ear.Next;  	List<Point> triangle = new List<Point> (3);  	triangle.Add (a);  	triangle.Add (b);  	triangle.Add (c);  	Triangles.Add (triangle);  	// Remove ear' update angles and convex list  	Remove (ear);  	if (Valid (a))  		_convexPoints.Add (a);  	if (Valid (c))  		_convexPoints.Add (c);  }  
Magic Number,FarseerPhysics.Common.Decomposition.Seidel,MonotoneMountain,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\MonotoneMountain.cs,Triangulate,The following statement contains a magic number: Debug.Assert (_size <= 3' "Triangulation bug' please report");  
Magic Number,FarseerPhysics.Common.Decomposition.Seidel,TrapezoidalMap,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\TrapezoidalMap.cs,Case1,The following statement contains a magic number: trapezoids [2] = new Trapezoid (e.P' e.Q' e' t.Bottom);  
Magic Number,FarseerPhysics.Common.Decomposition.Seidel,TrapezoidalMap,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\TrapezoidalMap.cs,Case1,The following statement contains a magic number: trapezoids [3] = new Trapezoid (e.Q' t.RightPoint' t.Top' t.Bottom);  
Magic Number,FarseerPhysics.Common.Decomposition.Seidel,TrapezoidalMap,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\TrapezoidalMap.cs,Case1,The following statement contains a magic number: trapezoids [1].UpdateLeftRight (trapezoids [0]' null' trapezoids [3]' null);  
Magic Number,FarseerPhysics.Common.Decomposition.Seidel,TrapezoidalMap,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\TrapezoidalMap.cs,Case1,The following statement contains a magic number: trapezoids [2].UpdateLeftRight (null' trapezoids [0]' null' trapezoids [3]);  
Magic Number,FarseerPhysics.Common.Decomposition.Seidel,TrapezoidalMap,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\TrapezoidalMap.cs,Case1,The following statement contains a magic number: trapezoids [2].UpdateLeftRight (null' trapezoids [0]' null' trapezoids [3]);  
Magic Number,FarseerPhysics.Common.Decomposition.Seidel,TrapezoidalMap,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\TrapezoidalMap.cs,Case1,The following statement contains a magic number: trapezoids [3].UpdateRight (t.UpperRight' t.LowerRight);  
Magic Number,FarseerPhysics.Common.Decomposition.Seidel,TrapezoidalMap,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\TrapezoidalMap.cs,Case2,The following statement contains a magic number: trapezoids [2] = new Trapezoid (e.P' rp' e' t.Bottom);  
Magic Number,FarseerPhysics.Common.Decomposition.Seidel,TrapezoidalMap,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\TrapezoidalMap.cs,Case2,The following statement contains a magic number: trapezoids [2].UpdateLeftRight (null' trapezoids [0]' null' t.LowerRight);  
Magic Number,FarseerPhysics.Common.Decomposition.Seidel,TrapezoidalMap,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\TrapezoidalMap.cs,Case2,The following statement contains a magic number: e.Below = trapezoids [2];  
Magic Number,FarseerPhysics.Common.Decomposition.Seidel,TrapezoidalMap,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\TrapezoidalMap.cs,Case4,The following statement contains a magic number: trapezoids [2] = new Trapezoid (e.Q' t.RightPoint' t.Top' t.Bottom);  
Magic Number,FarseerPhysics.Common.Decomposition.Seidel,TrapezoidalMap,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\TrapezoidalMap.cs,Case4,The following statement contains a magic number: trapezoids [2].UpdateLeftRight (trapezoids [0]' trapezoids [1]' t.UpperRight' t.LowerRight);  
Magic Number,FarseerPhysics.Common.Decomposition.Seidel,Triangulator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\Triangulator.cs,CreateMountains,The following statement contains a magic number: foreach (Edge edge in _edgeList) {  	if (edge.MPoints.Count > 2) {  		MonotoneMountain mountain = new MonotoneMountain ();  		// Sorting is a perfromance hit. Literature says this can be accomplised in  		// linear time' although I don't see a way around using traditional methods  		// when using a randomized incremental algorithm  		// Insertion sort is one of the fastest algorithms for sorting arrays containing   		// fewer than ten elements' or for lists that are already mostly sorted.  		List<Point> points = new List<Point> (edge.MPoints);  		points.Sort ((p1' p2) => p1.X.CompareTo (p2.X));  		foreach (Point p in points)  			mountain.Add (p);  		// Triangulate monotone mountain  		mountain.Process ();  		// Extract the triangles into a single list  		foreach (List<Point> t in mountain.Triangles) {  			Triangles.Add (t);  		}  		_xMonoPoly.Add (mountain);  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition.Seidel,Triangulator,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Decomposition\Seidel\Triangulator.cs,CreateMountains,The following statement contains a magic number: if (edge.MPoints.Count > 2) {  	MonotoneMountain mountain = new MonotoneMountain ();  	// Sorting is a perfromance hit. Literature says this can be accomplised in  	// linear time' although I don't see a way around using traditional methods  	// when using a randomized incremental algorithm  	// Insertion sort is one of the fastest algorithms for sorting arrays containing   	// fewer than ten elements' or for lists that are already mostly sorted.  	List<Point> points = new List<Point> (edge.MPoints);  	points.Sort ((p1' p2) => p1.X.CompareTo (p2.X));  	foreach (Point p in points)  		mountain.Add (p);  	// Triangulate monotone mountain  	mountain.Process ();  	// Extract the triangles into a single list  	foreach (List<Point> t in mountain.Triangles) {  		Triangles.Add (t);  	}  	_xMonoPoly.Add (mountain);  }  
Magic Number,FarseerPhysics.Common,MathUtils,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Math.cs,VectorAngle,The following statement contains a magic number: while (dtheta > Math.PI)  	dtheta -= (2 * Math.PI);  
Magic Number,FarseerPhysics.Common,MathUtils,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Math.cs,VectorAngle,The following statement contains a magic number: dtheta -= (2 * Math.PI);  
Magic Number,FarseerPhysics.Common,MathUtils,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Math.cs,VectorAngle,The following statement contains a magic number: while (dtheta < -Math.PI)  	dtheta += (2 * Math.PI);  
Magic Number,FarseerPhysics.Common,MathUtils,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Math.cs,VectorAngle,The following statement contains a magic number: dtheta += (2 * Math.PI);  
Magic Number,FarseerPhysics.Common,Path,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Path.cs,GetPosition,The following statement contains a magic number: if (ControlPoints.Count < 2)  	throw new Exception ("You need at least 2 control points to calculate a position.");  
Magic Number,FarseerPhysics.Common,Path,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Path.cs,GetPosition,The following statement contains a magic number: if (Closed) {  	Add (ControlPoints [0]);  	_deltaT = 1f / (ControlPoints.Count - 1);  	int p = (int)(time / _deltaT);  	// use a circular indexing system  	int p0 = p - 1;  	if (p0 < 0)  		p0 = p0 + (ControlPoints.Count - 1);  	else if (p0 >= ControlPoints.Count - 1)  		p0 = p0 - (ControlPoints.Count - 1);  	int p1 = p;  	if (p1 < 0)  		p1 = p1 + (ControlPoints.Count - 1);  	else if (p1 >= ControlPoints.Count - 1)  		p1 = p1 - (ControlPoints.Count - 1);  	int p2 = p + 1;  	if (p2 < 0)  		p2 = p2 + (ControlPoints.Count - 1);  	else if (p2 >= ControlPoints.Count - 1)  		p2 = p2 - (ControlPoints.Count - 1);  	int p3 = p + 2;  	if (p3 < 0)  		p3 = p3 + (ControlPoints.Count - 1);  	else if (p3 >= ControlPoints.Count - 1)  		p3 = p3 - (ControlPoints.Count - 1);  	// relative time  	float lt = (time - _deltaT * p) / _deltaT;  	temp = Vector2.CatmullRom (ControlPoints [p0]' ControlPoints [p1]' ControlPoints [p2]' ControlPoints [p3]' lt);  	RemoveAt (ControlPoints.Count - 1);  }  else {  	int p = (int)(time / _deltaT);  	//   	int p0 = p - 1;  	if (p0 < 0)  		p0 = 0;  	else if (p0 >= ControlPoints.Count - 1)  		p0 = ControlPoints.Count - 1;  	int p1 = p;  	if (p1 < 0)  		p1 = 0;  	else if (p1 >= ControlPoints.Count - 1)  		p1 = ControlPoints.Count - 1;  	int p2 = p + 1;  	if (p2 < 0)  		p2 = 0;  	else if (p2 >= ControlPoints.Count - 1)  		p2 = ControlPoints.Count - 1;  	int p3 = p + 2;  	if (p3 < 0)  		p3 = 0;  	else if (p3 >= ControlPoints.Count - 1)  		p3 = ControlPoints.Count - 1;  	// relative time  	float lt = (time - _deltaT * p) / _deltaT;  	temp = Vector2.CatmullRom (ControlPoints [p0]' ControlPoints [p1]' ControlPoints [p2]' ControlPoints [p3]' lt);  }  
Magic Number,FarseerPhysics.Common,Path,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Path.cs,GetPosition,The following statement contains a magic number: if (Closed) {  	Add (ControlPoints [0]);  	_deltaT = 1f / (ControlPoints.Count - 1);  	int p = (int)(time / _deltaT);  	// use a circular indexing system  	int p0 = p - 1;  	if (p0 < 0)  		p0 = p0 + (ControlPoints.Count - 1);  	else if (p0 >= ControlPoints.Count - 1)  		p0 = p0 - (ControlPoints.Count - 1);  	int p1 = p;  	if (p1 < 0)  		p1 = p1 + (ControlPoints.Count - 1);  	else if (p1 >= ControlPoints.Count - 1)  		p1 = p1 - (ControlPoints.Count - 1);  	int p2 = p + 1;  	if (p2 < 0)  		p2 = p2 + (ControlPoints.Count - 1);  	else if (p2 >= ControlPoints.Count - 1)  		p2 = p2 - (ControlPoints.Count - 1);  	int p3 = p + 2;  	if (p3 < 0)  		p3 = p3 + (ControlPoints.Count - 1);  	else if (p3 >= ControlPoints.Count - 1)  		p3 = p3 - (ControlPoints.Count - 1);  	// relative time  	float lt = (time - _deltaT * p) / _deltaT;  	temp = Vector2.CatmullRom (ControlPoints [p0]' ControlPoints [p1]' ControlPoints [p2]' ControlPoints [p3]' lt);  	RemoveAt (ControlPoints.Count - 1);  }  else {  	int p = (int)(time / _deltaT);  	//   	int p0 = p - 1;  	if (p0 < 0)  		p0 = 0;  	else if (p0 >= ControlPoints.Count - 1)  		p0 = ControlPoints.Count - 1;  	int p1 = p;  	if (p1 < 0)  		p1 = 0;  	else if (p1 >= ControlPoints.Count - 1)  		p1 = ControlPoints.Count - 1;  	int p2 = p + 1;  	if (p2 < 0)  		p2 = 0;  	else if (p2 >= ControlPoints.Count - 1)  		p2 = ControlPoints.Count - 1;  	int p3 = p + 2;  	if (p3 < 0)  		p3 = 0;  	else if (p3 >= ControlPoints.Count - 1)  		p3 = ControlPoints.Count - 1;  	// relative time  	float lt = (time - _deltaT * p) / _deltaT;  	temp = Vector2.CatmullRom (ControlPoints [p0]' ControlPoints [p1]' ControlPoints [p2]' ControlPoints [p3]' lt);  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateRectangle,The following statement contains a magic number: for (int i = 0; i < 4; ++i) {  	vertices [i] = MathUtils.Mul (ref xf' vertices [i]);  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (yRadius > height / 2 || xRadius > width / 2)  	throw new Exception ("Rounding amount can't be more than half the height and width respectively.");  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (yRadius > height / 2 || xRadius > width / 2)  	throw new Exception ("Rounding amount can't be more than half the height and width respectively.");  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: Debug.Assert (Settings.MaxPolygonVertices >= 8);  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0) {  	vertices.Add (new Vector2 (width * .5f - xRadius' -height * .5f));  	vertices.Add (new Vector2 (width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (width * .5f - xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f + xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (-width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (-width * .5f + xRadius' -height * .5f));  }  else {  	int numberOfEdges = (segments * 4 + 8);  	float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);  	int perPhase = numberOfEdges / 4;  	Vector2 posOffset = new Vector2 (width / 2 - xRadius' height / 2 - yRadius);  	vertices.Add (posOffset + new Vector2 (xRadius' -yRadius + yRadius));  	short phase = 0;  	for (int i = 1; i < numberOfEdges; i++) {  		if (i - perPhase == 0 || i - perPhase * 3 == 0) {  			posOffset.X *= -1;  			phase--;  		}  		else if (i - perPhase * 2 == 0) {  			posOffset.Y *= -1;  			phase--;  		}  		vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  	}  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0) {  	vertices.Add (new Vector2 (width * .5f - xRadius' -height * .5f));  	vertices.Add (new Vector2 (width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (width * .5f - xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f + xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (-width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (-width * .5f + xRadius' -height * .5f));  }  else {  	int numberOfEdges = (segments * 4 + 8);  	float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);  	int perPhase = numberOfEdges / 4;  	Vector2 posOffset = new Vector2 (width / 2 - xRadius' height / 2 - yRadius);  	vertices.Add (posOffset + new Vector2 (xRadius' -yRadius + yRadius));  	short phase = 0;  	for (int i = 1; i < numberOfEdges; i++) {  		if (i - perPhase == 0 || i - perPhase * 3 == 0) {  			posOffset.X *= -1;  			phase--;  		}  		else if (i - perPhase * 2 == 0) {  			posOffset.Y *= -1;  			phase--;  		}  		vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  	}  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0) {  	vertices.Add (new Vector2 (width * .5f - xRadius' -height * .5f));  	vertices.Add (new Vector2 (width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (width * .5f - xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f + xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (-width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (-width * .5f + xRadius' -height * .5f));  }  else {  	int numberOfEdges = (segments * 4 + 8);  	float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);  	int perPhase = numberOfEdges / 4;  	Vector2 posOffset = new Vector2 (width / 2 - xRadius' height / 2 - yRadius);  	vertices.Add (posOffset + new Vector2 (xRadius' -yRadius + yRadius));  	short phase = 0;  	for (int i = 1; i < numberOfEdges; i++) {  		if (i - perPhase == 0 || i - perPhase * 3 == 0) {  			posOffset.X *= -1;  			phase--;  		}  		else if (i - perPhase * 2 == 0) {  			posOffset.Y *= -1;  			phase--;  		}  		vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  	}  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0) {  	vertices.Add (new Vector2 (width * .5f - xRadius' -height * .5f));  	vertices.Add (new Vector2 (width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (width * .5f - xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f + xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (-width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (-width * .5f + xRadius' -height * .5f));  }  else {  	int numberOfEdges = (segments * 4 + 8);  	float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);  	int perPhase = numberOfEdges / 4;  	Vector2 posOffset = new Vector2 (width / 2 - xRadius' height / 2 - yRadius);  	vertices.Add (posOffset + new Vector2 (xRadius' -yRadius + yRadius));  	short phase = 0;  	for (int i = 1; i < numberOfEdges; i++) {  		if (i - perPhase == 0 || i - perPhase * 3 == 0) {  			posOffset.X *= -1;  			phase--;  		}  		else if (i - perPhase * 2 == 0) {  			posOffset.Y *= -1;  			phase--;  		}  		vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  	}  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0) {  	vertices.Add (new Vector2 (width * .5f - xRadius' -height * .5f));  	vertices.Add (new Vector2 (width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (width * .5f - xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f + xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (-width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (-width * .5f + xRadius' -height * .5f));  }  else {  	int numberOfEdges = (segments * 4 + 8);  	float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);  	int perPhase = numberOfEdges / 4;  	Vector2 posOffset = new Vector2 (width / 2 - xRadius' height / 2 - yRadius);  	vertices.Add (posOffset + new Vector2 (xRadius' -yRadius + yRadius));  	short phase = 0;  	for (int i = 1; i < numberOfEdges; i++) {  		if (i - perPhase == 0 || i - perPhase * 3 == 0) {  			posOffset.X *= -1;  			phase--;  		}  		else if (i - perPhase * 2 == 0) {  			posOffset.Y *= -1;  			phase--;  		}  		vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  	}  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0) {  	vertices.Add (new Vector2 (width * .5f - xRadius' -height * .5f));  	vertices.Add (new Vector2 (width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (width * .5f - xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f + xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (-width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (-width * .5f + xRadius' -height * .5f));  }  else {  	int numberOfEdges = (segments * 4 + 8);  	float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);  	int perPhase = numberOfEdges / 4;  	Vector2 posOffset = new Vector2 (width / 2 - xRadius' height / 2 - yRadius);  	vertices.Add (posOffset + new Vector2 (xRadius' -yRadius + yRadius));  	short phase = 0;  	for (int i = 1; i < numberOfEdges; i++) {  		if (i - perPhase == 0 || i - perPhase * 3 == 0) {  			posOffset.X *= -1;  			phase--;  		}  		else if (i - perPhase * 2 == 0) {  			posOffset.Y *= -1;  			phase--;  		}  		vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  	}  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0) {  	vertices.Add (new Vector2 (width * .5f - xRadius' -height * .5f));  	vertices.Add (new Vector2 (width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (width * .5f - xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f + xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (-width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (-width * .5f + xRadius' -height * .5f));  }  else {  	int numberOfEdges = (segments * 4 + 8);  	float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);  	int perPhase = numberOfEdges / 4;  	Vector2 posOffset = new Vector2 (width / 2 - xRadius' height / 2 - yRadius);  	vertices.Add (posOffset + new Vector2 (xRadius' -yRadius + yRadius));  	short phase = 0;  	for (int i = 1; i < numberOfEdges; i++) {  		if (i - perPhase == 0 || i - perPhase * 3 == 0) {  			posOffset.X *= -1;  			phase--;  		}  		else if (i - perPhase * 2 == 0) {  			posOffset.Y *= -1;  			phase--;  		}  		vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  	}  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0) {  	vertices.Add (new Vector2 (width * .5f - xRadius' -height * .5f));  	vertices.Add (new Vector2 (width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (width * .5f - xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f + xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (-width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (-width * .5f + xRadius' -height * .5f));  }  else {  	int numberOfEdges = (segments * 4 + 8);  	float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);  	int perPhase = numberOfEdges / 4;  	Vector2 posOffset = new Vector2 (width / 2 - xRadius' height / 2 - yRadius);  	vertices.Add (posOffset + new Vector2 (xRadius' -yRadius + yRadius));  	short phase = 0;  	for (int i = 1; i < numberOfEdges; i++) {  		if (i - perPhase == 0 || i - perPhase * 3 == 0) {  			posOffset.X *= -1;  			phase--;  		}  		else if (i - perPhase * 2 == 0) {  			posOffset.Y *= -1;  			phase--;  		}  		vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  	}  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: for (int i = 1; i < numberOfEdges; i++) {  	if (i - perPhase == 0 || i - perPhase * 3 == 0) {  		posOffset.X *= -1;  		phase--;  	}  	else if (i - perPhase * 2 == 0) {  		posOffset.Y *= -1;  		phase--;  	}  	vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: for (int i = 1; i < numberOfEdges; i++) {  	if (i - perPhase == 0 || i - perPhase * 3 == 0) {  		posOffset.X *= -1;  		phase--;  	}  	else if (i - perPhase * 2 == 0) {  		posOffset.Y *= -1;  		phase--;  	}  	vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (i - perPhase == 0 || i - perPhase * 3 == 0) {  	posOffset.X *= -1;  	phase--;  }  else if (i - perPhase * 2 == 0) {  	posOffset.Y *= -1;  	phase--;  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (i - perPhase == 0 || i - perPhase * 3 == 0) {  	posOffset.X *= -1;  	phase--;  }  else if (i - perPhase * 2 == 0) {  	posOffset.Y *= -1;  	phase--;  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (i - perPhase * 2 == 0) {  	posOffset.Y *= -1;  	phase--;  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateCapsule,The following statement contains a magic number: if (endRadius >= height / 2)  	throw new ArgumentException ("The radius must be lower than height / 2. Higher values of radius would create a circle' and not a half circle."' "endRadius");  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateCapsule,The following statement contains a magic number: if (topRadius >= height / 2)  	throw new ArgumentException ("The top radius must be lower than height / 2. Higher values of top radius would create a circle' and not a half circle."' "topRadius");  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonTools.cs,CreateCapsule,The following statement contains a magic number: if (bottomRadius >= height / 2)  	throw new ArgumentException ("The bottom radius must be lower than height / 2. Higher values of bottom radius would create a circle' and not a half circle."' "bottomRadius");  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vertices.cs,GetSignedArea,The following statement contains a magic number: if (Count < 3)  	return 0;  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vertices.cs,GetCentroid,The following statement contains a magic number: if (Count < 3)  	return new Vector2 (float.NaN' float.NaN);  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vertices.cs,IsConvex,The following statement contains a magic number: if (Count < 3)  	return false;  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vertices.cs,IsConvex,The following statement contains a magic number: if (Count == 3)  	return true;  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vertices.cs,IsCounterClockWise,The following statement contains a magic number: if (Count < 3)  	return false;  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vertices.cs,ForceCounterClockWise,The following statement contains a magic number: if (Count < 3)  	return;  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vertices.cs,IsSimple,The following statement contains a magic number: if (Count < 3)  	return false;  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if (Count < 3 || Count > Settings.MaxPolygonVertices)  	return PolygonError.InvalidAmountOfVertices;  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: for (int i = 0; i < shapeCount; ++i) {  	PolygonShape ps;  	CircleShape cs = shapes [i].Shape as CircleShape;  	if (cs != null) {  		// We create a "diamond" approximation of the circle  		Vertices v = new Vertices ();  		Vector2 vec = Vector2.Zero + new Vector2 (cs.Radius' 0);  		v.Add (vec);  		vec = Vector2.Zero + new Vector2 (0' cs.Radius);  		v.Add (vec);  		vec = Vector2.Zero + new Vector2 (-cs.Radius' cs.Radius);  		v.Add (vec);  		vec = Vector2.Zero + new Vector2 (0' -cs.Radius);  		v.Add (vec);  		ps = new PolygonShape (v' 0);  	}  	else  		ps = shapes [i].Shape as PolygonShape;  	if ((shapes [i].Body.BodyType == BodyType.Dynamic) && ps != null) {  		Vector2 toCentroid = shapes [i].Body.GetWorldPoint (ps.MassData.Centroid) - pos;  		float angleToCentroid = (float)Math.Atan2 (toCentroid.Y' toCentroid.X);  		float min = float.MaxValue;  		float max = float.MinValue;  		float minAbsolute = 0.0f;  		float maxAbsolute = 0.0f;  		for (int j = 0; j < ps.Vertices.Count; ++j) {  			Vector2 toVertex = (shapes [i].Body.GetWorldPoint (ps.Vertices [j]) - pos);  			float newAngle = (float)Math.Atan2 (toVertex.Y' toVertex.X);  			float diff = (newAngle - angleToCentroid);  			diff = (diff - MathHelper.Pi) % (2 * MathHelper.Pi);  			// the minus pi is important. It means cutoff for going other direction is at 180 deg where it needs to be  			if (diff < 0.0f)  				diff += 2 * MathHelper.Pi;  			// correction for not handling negs  			diff -= MathHelper.Pi;  			if (Math.Abs (diff) > MathHelper.Pi)  				continue;  			// Something's wrong' point not in shape but exists angle diff > 180  			if (diff > max) {  				max = diff;  				maxAbsolute = newAngle;  			}  			if (diff < min) {  				min = diff;  				minAbsolute = newAngle;  			}  		}  		vals [valIndex] = minAbsolute;  		++valIndex;  		vals [valIndex] = maxAbsolute;  		++valIndex;  	}  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: for (int i = 0; i < shapeCount; ++i) {  	PolygonShape ps;  	CircleShape cs = shapes [i].Shape as CircleShape;  	if (cs != null) {  		// We create a "diamond" approximation of the circle  		Vertices v = new Vertices ();  		Vector2 vec = Vector2.Zero + new Vector2 (cs.Radius' 0);  		v.Add (vec);  		vec = Vector2.Zero + new Vector2 (0' cs.Radius);  		v.Add (vec);  		vec = Vector2.Zero + new Vector2 (-cs.Radius' cs.Radius);  		v.Add (vec);  		vec = Vector2.Zero + new Vector2 (0' -cs.Radius);  		v.Add (vec);  		ps = new PolygonShape (v' 0);  	}  	else  		ps = shapes [i].Shape as PolygonShape;  	if ((shapes [i].Body.BodyType == BodyType.Dynamic) && ps != null) {  		Vector2 toCentroid = shapes [i].Body.GetWorldPoint (ps.MassData.Centroid) - pos;  		float angleToCentroid = (float)Math.Atan2 (toCentroid.Y' toCentroid.X);  		float min = float.MaxValue;  		float max = float.MinValue;  		float minAbsolute = 0.0f;  		float maxAbsolute = 0.0f;  		for (int j = 0; j < ps.Vertices.Count; ++j) {  			Vector2 toVertex = (shapes [i].Body.GetWorldPoint (ps.Vertices [j]) - pos);  			float newAngle = (float)Math.Atan2 (toVertex.Y' toVertex.X);  			float diff = (newAngle - angleToCentroid);  			diff = (diff - MathHelper.Pi) % (2 * MathHelper.Pi);  			// the minus pi is important. It means cutoff for going other direction is at 180 deg where it needs to be  			if (diff < 0.0f)  				diff += 2 * MathHelper.Pi;  			// correction for not handling negs  			diff -= MathHelper.Pi;  			if (Math.Abs (diff) > MathHelper.Pi)  				continue;  			// Something's wrong' point not in shape but exists angle diff > 180  			if (diff > max) {  				max = diff;  				maxAbsolute = newAngle;  			}  			if (diff < min) {  				min = diff;  				minAbsolute = newAngle;  			}  		}  		vals [valIndex] = minAbsolute;  		++valIndex;  		vals [valIndex] = maxAbsolute;  		++valIndex;  	}  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: if ((shapes [i].Body.BodyType == BodyType.Dynamic) && ps != null) {  	Vector2 toCentroid = shapes [i].Body.GetWorldPoint (ps.MassData.Centroid) - pos;  	float angleToCentroid = (float)Math.Atan2 (toCentroid.Y' toCentroid.X);  	float min = float.MaxValue;  	float max = float.MinValue;  	float minAbsolute = 0.0f;  	float maxAbsolute = 0.0f;  	for (int j = 0; j < ps.Vertices.Count; ++j) {  		Vector2 toVertex = (shapes [i].Body.GetWorldPoint (ps.Vertices [j]) - pos);  		float newAngle = (float)Math.Atan2 (toVertex.Y' toVertex.X);  		float diff = (newAngle - angleToCentroid);  		diff = (diff - MathHelper.Pi) % (2 * MathHelper.Pi);  		// the minus pi is important. It means cutoff for going other direction is at 180 deg where it needs to be  		if (diff < 0.0f)  			diff += 2 * MathHelper.Pi;  		// correction for not handling negs  		diff -= MathHelper.Pi;  		if (Math.Abs (diff) > MathHelper.Pi)  			continue;  		// Something's wrong' point not in shape but exists angle diff > 180  		if (diff > max) {  			max = diff;  			maxAbsolute = newAngle;  		}  		if (diff < min) {  			min = diff;  			minAbsolute = newAngle;  		}  	}  	vals [valIndex] = minAbsolute;  	++valIndex;  	vals [valIndex] = maxAbsolute;  	++valIndex;  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: if ((shapes [i].Body.BodyType == BodyType.Dynamic) && ps != null) {  	Vector2 toCentroid = shapes [i].Body.GetWorldPoint (ps.MassData.Centroid) - pos;  	float angleToCentroid = (float)Math.Atan2 (toCentroid.Y' toCentroid.X);  	float min = float.MaxValue;  	float max = float.MinValue;  	float minAbsolute = 0.0f;  	float maxAbsolute = 0.0f;  	for (int j = 0; j < ps.Vertices.Count; ++j) {  		Vector2 toVertex = (shapes [i].Body.GetWorldPoint (ps.Vertices [j]) - pos);  		float newAngle = (float)Math.Atan2 (toVertex.Y' toVertex.X);  		float diff = (newAngle - angleToCentroid);  		diff = (diff - MathHelper.Pi) % (2 * MathHelper.Pi);  		// the minus pi is important. It means cutoff for going other direction is at 180 deg where it needs to be  		if (diff < 0.0f)  			diff += 2 * MathHelper.Pi;  		// correction for not handling negs  		diff -= MathHelper.Pi;  		if (Math.Abs (diff) > MathHelper.Pi)  			continue;  		// Something's wrong' point not in shape but exists angle diff > 180  		if (diff > max) {  			max = diff;  			maxAbsolute = newAngle;  		}  		if (diff < min) {  			min = diff;  			minAbsolute = newAngle;  		}  	}  	vals [valIndex] = minAbsolute;  	++valIndex;  	vals [valIndex] = maxAbsolute;  	++valIndex;  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: for (int j = 0; j < ps.Vertices.Count; ++j) {  	Vector2 toVertex = (shapes [i].Body.GetWorldPoint (ps.Vertices [j]) - pos);  	float newAngle = (float)Math.Atan2 (toVertex.Y' toVertex.X);  	float diff = (newAngle - angleToCentroid);  	diff = (diff - MathHelper.Pi) % (2 * MathHelper.Pi);  	// the minus pi is important. It means cutoff for going other direction is at 180 deg where it needs to be  	if (diff < 0.0f)  		diff += 2 * MathHelper.Pi;  	// correction for not handling negs  	diff -= MathHelper.Pi;  	if (Math.Abs (diff) > MathHelper.Pi)  		continue;  	// Something's wrong' point not in shape but exists angle diff > 180  	if (diff > max) {  		max = diff;  		maxAbsolute = newAngle;  	}  	if (diff < min) {  		min = diff;  		minAbsolute = newAngle;  	}  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: for (int j = 0; j < ps.Vertices.Count; ++j) {  	Vector2 toVertex = (shapes [i].Body.GetWorldPoint (ps.Vertices [j]) - pos);  	float newAngle = (float)Math.Atan2 (toVertex.Y' toVertex.X);  	float diff = (newAngle - angleToCentroid);  	diff = (diff - MathHelper.Pi) % (2 * MathHelper.Pi);  	// the minus pi is important. It means cutoff for going other direction is at 180 deg where it needs to be  	if (diff < 0.0f)  		diff += 2 * MathHelper.Pi;  	// correction for not handling negs  	diff -= MathHelper.Pi;  	if (Math.Abs (diff) > MathHelper.Pi)  		continue;  	// Something's wrong' point not in shape but exists angle diff > 180  	if (diff > max) {  		max = diff;  		maxAbsolute = newAngle;  	}  	if (diff < min) {  		min = diff;  		minAbsolute = newAngle;  	}  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: diff = (diff - MathHelper.Pi) % (2 * MathHelper.Pi);  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: if (diff < 0.0f)  	diff += 2 * MathHelper.Pi;  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: diff += 2 * MathHelper.Pi;  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: for (int i = 0; i < valIndex; ++i) {  	Fixture fixture = null;  	float midpt;  	int iplus = (i == valIndex - 1 ? 0 : i + 1);  	if (vals [i] == vals [iplus])  		continue;  	if (i == valIndex - 1) {  		// the single edgecase  		midpt = (vals [0] + MathHelper.Pi * 2 + vals [i]);  	}  	else {  		midpt = (vals [i + 1] + vals [i]);  	}  	midpt = midpt / 2;  	Vector2 p1 = pos;  	Vector2 p2 = radius * new Vector2 ((float)Math.Cos (midpt)' (float)Math.Sin (midpt)) + pos;  	// RaycastOne  	bool hitClosest = false;  	World.RayCast ((f' p' n' fr) =>  {  		Body body = f.Body;  		if (!IsActiveOn (body))  			return 0;  		hitClosest = true;  		fixture = f;  		return fr;  	}' p1' p2);  	//draws radius points  	if ((hitClosest) && (fixture.Body.BodyType == BodyType.Dynamic)) {  		if ((_data.Any ()) && (_data.Last ().Body == fixture.Body) && (!rayMissed)) {  			int laPos = _data.Count - 1;  			ShapeData la = _data [laPos];  			la.Max = vals [iplus];  			_data [laPos] = la;  		}  		else {  			// make new  			ShapeData d;  			d.Body = fixture.Body;  			d.Min = vals [i];  			d.Max = vals [iplus];  			_data.Add (d);  		}  		if ((_data.Count > 1) && (i == valIndex - 1) && (_data.Last ().Body == _data.First ().Body) && (_data.Last ().Max == _data.First ().Min)) {  			ShapeData fi = _data [0];  			fi.Min = _data.Last ().Min;  			_data.RemoveAt (_data.Count - 1);  			_data [0] = fi;  			while (_data.First ().Min >= _data.First ().Max) {  				fi.Min -= MathHelper.Pi * 2;  				_data [0] = fi;  			}  		}  		int lastPos = _data.Count - 1;  		ShapeData last = _data [lastPos];  		while ((_data.Count > 0) && (_data.Last ().Min >= _data.Last ().Max))// just making sure min<max  		 {  			last.Min = _data.Last ().Min - 2 * MathHelper.Pi;  			_data [lastPos] = last;  		}  		rayMissed = false;  	}  	else {  		rayMissed = true;  		// raycast did not find a shape  	}  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: for (int i = 0; i < valIndex; ++i) {  	Fixture fixture = null;  	float midpt;  	int iplus = (i == valIndex - 1 ? 0 : i + 1);  	if (vals [i] == vals [iplus])  		continue;  	if (i == valIndex - 1) {  		// the single edgecase  		midpt = (vals [0] + MathHelper.Pi * 2 + vals [i]);  	}  	else {  		midpt = (vals [i + 1] + vals [i]);  	}  	midpt = midpt / 2;  	Vector2 p1 = pos;  	Vector2 p2 = radius * new Vector2 ((float)Math.Cos (midpt)' (float)Math.Sin (midpt)) + pos;  	// RaycastOne  	bool hitClosest = false;  	World.RayCast ((f' p' n' fr) =>  {  		Body body = f.Body;  		if (!IsActiveOn (body))  			return 0;  		hitClosest = true;  		fixture = f;  		return fr;  	}' p1' p2);  	//draws radius points  	if ((hitClosest) && (fixture.Body.BodyType == BodyType.Dynamic)) {  		if ((_data.Any ()) && (_data.Last ().Body == fixture.Body) && (!rayMissed)) {  			int laPos = _data.Count - 1;  			ShapeData la = _data [laPos];  			la.Max = vals [iplus];  			_data [laPos] = la;  		}  		else {  			// make new  			ShapeData d;  			d.Body = fixture.Body;  			d.Min = vals [i];  			d.Max = vals [iplus];  			_data.Add (d);  		}  		if ((_data.Count > 1) && (i == valIndex - 1) && (_data.Last ().Body == _data.First ().Body) && (_data.Last ().Max == _data.First ().Min)) {  			ShapeData fi = _data [0];  			fi.Min = _data.Last ().Min;  			_data.RemoveAt (_data.Count - 1);  			_data [0] = fi;  			while (_data.First ().Min >= _data.First ().Max) {  				fi.Min -= MathHelper.Pi * 2;  				_data [0] = fi;  			}  		}  		int lastPos = _data.Count - 1;  		ShapeData last = _data [lastPos];  		while ((_data.Count > 0) && (_data.Last ().Min >= _data.Last ().Max))// just making sure min<max  		 {  			last.Min = _data.Last ().Min - 2 * MathHelper.Pi;  			_data [lastPos] = last;  		}  		rayMissed = false;  	}  	else {  		rayMissed = true;  		// raycast did not find a shape  	}  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: for (int i = 0; i < valIndex; ++i) {  	Fixture fixture = null;  	float midpt;  	int iplus = (i == valIndex - 1 ? 0 : i + 1);  	if (vals [i] == vals [iplus])  		continue;  	if (i == valIndex - 1) {  		// the single edgecase  		midpt = (vals [0] + MathHelper.Pi * 2 + vals [i]);  	}  	else {  		midpt = (vals [i + 1] + vals [i]);  	}  	midpt = midpt / 2;  	Vector2 p1 = pos;  	Vector2 p2 = radius * new Vector2 ((float)Math.Cos (midpt)' (float)Math.Sin (midpt)) + pos;  	// RaycastOne  	bool hitClosest = false;  	World.RayCast ((f' p' n' fr) =>  {  		Body body = f.Body;  		if (!IsActiveOn (body))  			return 0;  		hitClosest = true;  		fixture = f;  		return fr;  	}' p1' p2);  	//draws radius points  	if ((hitClosest) && (fixture.Body.BodyType == BodyType.Dynamic)) {  		if ((_data.Any ()) && (_data.Last ().Body == fixture.Body) && (!rayMissed)) {  			int laPos = _data.Count - 1;  			ShapeData la = _data [laPos];  			la.Max = vals [iplus];  			_data [laPos] = la;  		}  		else {  			// make new  			ShapeData d;  			d.Body = fixture.Body;  			d.Min = vals [i];  			d.Max = vals [iplus];  			_data.Add (d);  		}  		if ((_data.Count > 1) && (i == valIndex - 1) && (_data.Last ().Body == _data.First ().Body) && (_data.Last ().Max == _data.First ().Min)) {  			ShapeData fi = _data [0];  			fi.Min = _data.Last ().Min;  			_data.RemoveAt (_data.Count - 1);  			_data [0] = fi;  			while (_data.First ().Min >= _data.First ().Max) {  				fi.Min -= MathHelper.Pi * 2;  				_data [0] = fi;  			}  		}  		int lastPos = _data.Count - 1;  		ShapeData last = _data [lastPos];  		while ((_data.Count > 0) && (_data.Last ().Min >= _data.Last ().Max))// just making sure min<max  		 {  			last.Min = _data.Last ().Min - 2 * MathHelper.Pi;  			_data [lastPos] = last;  		}  		rayMissed = false;  	}  	else {  		rayMissed = true;  		// raycast did not find a shape  	}  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: for (int i = 0; i < valIndex; ++i) {  	Fixture fixture = null;  	float midpt;  	int iplus = (i == valIndex - 1 ? 0 : i + 1);  	if (vals [i] == vals [iplus])  		continue;  	if (i == valIndex - 1) {  		// the single edgecase  		midpt = (vals [0] + MathHelper.Pi * 2 + vals [i]);  	}  	else {  		midpt = (vals [i + 1] + vals [i]);  	}  	midpt = midpt / 2;  	Vector2 p1 = pos;  	Vector2 p2 = radius * new Vector2 ((float)Math.Cos (midpt)' (float)Math.Sin (midpt)) + pos;  	// RaycastOne  	bool hitClosest = false;  	World.RayCast ((f' p' n' fr) =>  {  		Body body = f.Body;  		if (!IsActiveOn (body))  			return 0;  		hitClosest = true;  		fixture = f;  		return fr;  	}' p1' p2);  	//draws radius points  	if ((hitClosest) && (fixture.Body.BodyType == BodyType.Dynamic)) {  		if ((_data.Any ()) && (_data.Last ().Body == fixture.Body) && (!rayMissed)) {  			int laPos = _data.Count - 1;  			ShapeData la = _data [laPos];  			la.Max = vals [iplus];  			_data [laPos] = la;  		}  		else {  			// make new  			ShapeData d;  			d.Body = fixture.Body;  			d.Min = vals [i];  			d.Max = vals [iplus];  			_data.Add (d);  		}  		if ((_data.Count > 1) && (i == valIndex - 1) && (_data.Last ().Body == _data.First ().Body) && (_data.Last ().Max == _data.First ().Min)) {  			ShapeData fi = _data [0];  			fi.Min = _data.Last ().Min;  			_data.RemoveAt (_data.Count - 1);  			_data [0] = fi;  			while (_data.First ().Min >= _data.First ().Max) {  				fi.Min -= MathHelper.Pi * 2;  				_data [0] = fi;  			}  		}  		int lastPos = _data.Count - 1;  		ShapeData last = _data [lastPos];  		while ((_data.Count > 0) && (_data.Last ().Min >= _data.Last ().Max))// just making sure min<max  		 {  			last.Min = _data.Last ().Min - 2 * MathHelper.Pi;  			_data [lastPos] = last;  		}  		rayMissed = false;  	}  	else {  		rayMissed = true;  		// raycast did not find a shape  	}  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: if (i == valIndex - 1) {  	// the single edgecase  	midpt = (vals [0] + MathHelper.Pi * 2 + vals [i]);  }  else {  	midpt = (vals [i + 1] + vals [i]);  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: midpt = (vals [0] + MathHelper.Pi * 2 + vals [i]);  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: midpt = midpt / 2;  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: if ((hitClosest) && (fixture.Body.BodyType == BodyType.Dynamic)) {  	if ((_data.Any ()) && (_data.Last ().Body == fixture.Body) && (!rayMissed)) {  		int laPos = _data.Count - 1;  		ShapeData la = _data [laPos];  		la.Max = vals [iplus];  		_data [laPos] = la;  	}  	else {  		// make new  		ShapeData d;  		d.Body = fixture.Body;  		d.Min = vals [i];  		d.Max = vals [iplus];  		_data.Add (d);  	}  	if ((_data.Count > 1) && (i == valIndex - 1) && (_data.Last ().Body == _data.First ().Body) && (_data.Last ().Max == _data.First ().Min)) {  		ShapeData fi = _data [0];  		fi.Min = _data.Last ().Min;  		_data.RemoveAt (_data.Count - 1);  		_data [0] = fi;  		while (_data.First ().Min >= _data.First ().Max) {  			fi.Min -= MathHelper.Pi * 2;  			_data [0] = fi;  		}  	}  	int lastPos = _data.Count - 1;  	ShapeData last = _data [lastPos];  	while ((_data.Count > 0) && (_data.Last ().Min >= _data.Last ().Max))// just making sure min<max  	 {  		last.Min = _data.Last ().Min - 2 * MathHelper.Pi;  		_data [lastPos] = last;  	}  	rayMissed = false;  }  else {  	rayMissed = true;  	// raycast did not find a shape  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: if ((hitClosest) && (fixture.Body.BodyType == BodyType.Dynamic)) {  	if ((_data.Any ()) && (_data.Last ().Body == fixture.Body) && (!rayMissed)) {  		int laPos = _data.Count - 1;  		ShapeData la = _data [laPos];  		la.Max = vals [iplus];  		_data [laPos] = la;  	}  	else {  		// make new  		ShapeData d;  		d.Body = fixture.Body;  		d.Min = vals [i];  		d.Max = vals [iplus];  		_data.Add (d);  	}  	if ((_data.Count > 1) && (i == valIndex - 1) && (_data.Last ().Body == _data.First ().Body) && (_data.Last ().Max == _data.First ().Min)) {  		ShapeData fi = _data [0];  		fi.Min = _data.Last ().Min;  		_data.RemoveAt (_data.Count - 1);  		_data [0] = fi;  		while (_data.First ().Min >= _data.First ().Max) {  			fi.Min -= MathHelper.Pi * 2;  			_data [0] = fi;  		}  	}  	int lastPos = _data.Count - 1;  	ShapeData last = _data [lastPos];  	while ((_data.Count > 0) && (_data.Last ().Min >= _data.Last ().Max))// just making sure min<max  	 {  		last.Min = _data.Last ().Min - 2 * MathHelper.Pi;  		_data [lastPos] = last;  	}  	rayMissed = false;  }  else {  	rayMissed = true;  	// raycast did not find a shape  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: if ((_data.Count > 1) && (i == valIndex - 1) && (_data.Last ().Body == _data.First ().Body) && (_data.Last ().Max == _data.First ().Min)) {  	ShapeData fi = _data [0];  	fi.Min = _data.Last ().Min;  	_data.RemoveAt (_data.Count - 1);  	_data [0] = fi;  	while (_data.First ().Min >= _data.First ().Max) {  		fi.Min -= MathHelper.Pi * 2;  		_data [0] = fi;  	}  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: while (_data.First ().Min >= _data.First ().Max) {  	fi.Min -= MathHelper.Pi * 2;  	_data [0] = fi;  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: fi.Min -= MathHelper.Pi * 2;  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: while ((_data.Count > 0) && (_data.Last ().Min >= _data.Last ().Max))// just making sure min<max   {  	last.Min = _data.Last ().Min - 2 * MathHelper.Pi;  	_data [lastPos] = last;  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,RealExplosion,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PhysicsLogic\RealExplosion.cs,Activate,The following statement contains a magic number: last.Min = _data.Last ().Min - 2 * MathHelper.Pi;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The following statement contains a magic number: for (int n = 0; n < 2; n++) {  	Vector2 offset;  	if (cutAdded [n] > 0) {  		offset = (newPolygon [n] [cutAdded [n] - 1] - newPolygon [n] [cutAdded [n]]);  	}  	else {  		offset = (newPolygon [n] [newPolygon [n].Count - 1] - newPolygon [n] [0]);  	}  	offset.Normalize ();  	if (!offset.IsValid ())  		offset = Vector2.One;  	newPolygon [n] [cutAdded [n]] += Settings.Epsilon * offset;  	if (cutAdded [n] < newPolygon [n].Count - 2) {  		offset = (newPolygon [n] [cutAdded [n] + 2] - newPolygon [n] [cutAdded [n] + 1]);  	}  	else {  		offset = (newPolygon [n] [0] - newPolygon [n] [newPolygon [n].Count - 1]);  	}  	offset.Normalize ();  	if (!offset.IsValid ())  		offset = Vector2.One;  	newPolygon [n] [cutAdded [n] + 1] += Settings.Epsilon * offset;  }  
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The following statement contains a magic number: for (int n = 0; n < 2; n++) {  	Vector2 offset;  	if (cutAdded [n] > 0) {  		offset = (newPolygon [n] [cutAdded [n] - 1] - newPolygon [n] [cutAdded [n]]);  	}  	else {  		offset = (newPolygon [n] [newPolygon [n].Count - 1] - newPolygon [n] [0]);  	}  	offset.Normalize ();  	if (!offset.IsValid ())  		offset = Vector2.One;  	newPolygon [n] [cutAdded [n]] += Settings.Epsilon * offset;  	if (cutAdded [n] < newPolygon [n].Count - 2) {  		offset = (newPolygon [n] [cutAdded [n] + 2] - newPolygon [n] [cutAdded [n] + 1]);  	}  	else {  		offset = (newPolygon [n] [0] - newPolygon [n] [newPolygon [n].Count - 1]);  	}  	offset.Normalize ();  	if (!offset.IsValid ())  		offset = Vector2.One;  	newPolygon [n] [cutAdded [n] + 1] += Settings.Epsilon * offset;  }  
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The following statement contains a magic number: for (int n = 0; n < 2; n++) {  	Vector2 offset;  	if (cutAdded [n] > 0) {  		offset = (newPolygon [n] [cutAdded [n] - 1] - newPolygon [n] [cutAdded [n]]);  	}  	else {  		offset = (newPolygon [n] [newPolygon [n].Count - 1] - newPolygon [n] [0]);  	}  	offset.Normalize ();  	if (!offset.IsValid ())  		offset = Vector2.One;  	newPolygon [n] [cutAdded [n]] += Settings.Epsilon * offset;  	if (cutAdded [n] < newPolygon [n].Count - 2) {  		offset = (newPolygon [n] [cutAdded [n] + 2] - newPolygon [n] [cutAdded [n] + 1]);  	}  	else {  		offset = (newPolygon [n] [0] - newPolygon [n] [newPolygon [n].Count - 1]);  	}  	offset.Normalize ();  	if (!offset.IsValid ())  		offset = Vector2.One;  	newPolygon [n] [cutAdded [n] + 1] += Settings.Epsilon * offset;  }  
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The following statement contains a magic number: if (cutAdded [n] < newPolygon [n].Count - 2) {  	offset = (newPolygon [n] [cutAdded [n] + 2] - newPolygon [n] [cutAdded [n] + 1]);  }  else {  	offset = (newPolygon [n] [0] - newPolygon [n] [newPolygon [n].Count - 1]);  }  
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The following statement contains a magic number: if (cutAdded [n] < newPolygon [n].Count - 2) {  	offset = (newPolygon [n] [cutAdded [n] + 2] - newPolygon [n] [cutAdded [n] + 1]);  }  else {  	offset = (newPolygon [n] [0] - newPolygon [n] [newPolygon [n].Count - 1]);  }  
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The following statement contains a magic number: offset = (newPolygon [n] [cutAdded [n] + 2] - newPolygon [n] [cutAdded [n] + 1]);  
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\CuttingTools.cs,Cut,The following statement contains a magic number: if (entryPoints.Count + exitPoints.Count < 2)  	return false;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\SimplifyTools.cs,CollinearSimplify,The following statement contains a magic number: if (vertices.Count <= 3)  	return vertices;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\SimplifyTools.cs,DouglasPeuckerSimplify,The following statement contains a magic number: if (vertices.Count <= 3)  	return vertices;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\SimplifyTools.cs,MergeParallelEdges,The following statement contains a magic number: if (vertices.Count <= 3)  	return vertices;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\SimplifyTools.cs,MergeParallelEdges,The following statement contains a magic number: for (int i = 0; i < vertices.Count; ++i) {  	int lower = (i == 0) ? (vertices.Count - 1) : (i - 1);  	int middle = i;  	int upper = (i == vertices.Count - 1) ? (0) : (i + 1);  	float dx0 = vertices [middle].X - vertices [lower].X;  	float dy0 = vertices [middle].Y - vertices [lower].Y;  	float dx1 = vertices [upper].Y - vertices [middle].X;  	float dy1 = vertices [upper].Y - vertices [middle].Y;  	float norm0 = (float)Math.Sqrt (dx0 * dx0 + dy0 * dy0);  	float norm1 = (float)Math.Sqrt (dx1 * dx1 + dy1 * dy1);  	if (!(norm0 > 0.0f && norm1 > 0.0f) && newNVertices > 3) {  		//Merge identical points  		mergeMe [i] = true;  		--newNVertices;  	}  	dx0 /= norm0;  	dy0 /= norm0;  	dx1 /= norm1;  	dy1 /= norm1;  	float cross = dx0 * dy1 - dx1 * dy0;  	float dot = dx0 * dx1 + dy0 * dy1;  	if (Math.Abs (cross) < tolerance && dot > 0 && newNVertices > 3) {  		mergeMe [i] = true;  		--newNVertices;  	}  	else  		mergeMe [i] = false;  }  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\SimplifyTools.cs,MergeParallelEdges,The following statement contains a magic number: for (int i = 0; i < vertices.Count; ++i) {  	int lower = (i == 0) ? (vertices.Count - 1) : (i - 1);  	int middle = i;  	int upper = (i == vertices.Count - 1) ? (0) : (i + 1);  	float dx0 = vertices [middle].X - vertices [lower].X;  	float dy0 = vertices [middle].Y - vertices [lower].Y;  	float dx1 = vertices [upper].Y - vertices [middle].X;  	float dy1 = vertices [upper].Y - vertices [middle].Y;  	float norm0 = (float)Math.Sqrt (dx0 * dx0 + dy0 * dy0);  	float norm1 = (float)Math.Sqrt (dx1 * dx1 + dy1 * dy1);  	if (!(norm0 > 0.0f && norm1 > 0.0f) && newNVertices > 3) {  		//Merge identical points  		mergeMe [i] = true;  		--newNVertices;  	}  	dx0 /= norm0;  	dy0 /= norm0;  	dx1 /= norm1;  	dy1 /= norm1;  	float cross = dx0 * dy1 - dx1 * dy0;  	float dot = dx0 * dx1 + dy0 * dy1;  	if (Math.Abs (cross) < tolerance && dot > 0 && newNVertices > 3) {  		mergeMe [i] = true;  		--newNVertices;  	}  	else  		mergeMe [i] = false;  }  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\SimplifyTools.cs,MergeParallelEdges,The following statement contains a magic number: if (!(norm0 > 0.0f && norm1 > 0.0f) && newNVertices > 3) {  	//Merge identical points  	mergeMe [i] = true;  	--newNVertices;  }  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\SimplifyTools.cs,MergeParallelEdges,The following statement contains a magic number: if (Math.Abs (cross) < tolerance && dot > 0 && newNVertices > 3) {  	mergeMe [i] = true;  	--newNVertices;  }  else  	mergeMe [i] = false;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\SimplifyTools.cs,ReduceByDistance,The following statement contains a magic number: if (vertices.Count <= 3)  	return vertices;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\SimplifyTools.cs,ReduceByNth,The following statement contains a magic number: if (vertices.Count <= 3)  	return vertices;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\SimplifyTools.cs,ReduceByArea,The following statement contains a magic number: if (vertices.Count <= 3)  	return vertices;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\SimplifyTools.cs,ReduceByArea,The following statement contains a magic number: areaTolerance *= 2;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\YuPengClipper.cs,BuildPolygonsFromChain,The following statement contains a magic number: while (simplicies.Count > 0) {  	Vertices output = new Vertices ();  	output.Add (simplicies [0].EdgeStart);  	output.Add (simplicies [0].EdgeEnd);  	simplicies.RemoveAt (0);  	bool closed = false;  	int index = 0;  	int count = simplicies.Count;  	// Needed to catch infinite loops  	while (!closed && simplicies.Count > 0) {  		if (VectorEqual (output [output.Count - 1]' simplicies [index].EdgeStart)) {  			if (VectorEqual (simplicies [index].EdgeEnd' output [0])) {  				closed = true;  			}  			else {  				output.Add (simplicies [index].EdgeEnd);  			}  			simplicies.RemoveAt (index);  			--index;  		}  		else if (VectorEqual (output [output.Count - 1]' simplicies [index].EdgeEnd)) {  			if (VectorEqual (simplicies [index].EdgeStart' output [0])) {  				closed = true;  			}  			else {  				output.Add (simplicies [index].EdgeStart);  			}  			simplicies.RemoveAt (index);  			--index;  		}  		if (!closed) {  			if (++index == simplicies.Count) {  				if (count == simplicies.Count) {  					result = new List<Vertices> ();  					Debug.WriteLine ("Undefined error while building result polygon(s).");  					return PolyClipError.BrokenResult;  				}  				index = 0;  				count = simplicies.Count;  			}  		}  	}  	if (output.Count < 3) {  		errVal = PolyClipError.DegeneratedOutput;  		Debug.WriteLine ("Degenerated output polygon produced (vertices < 3).");  	}  	result.Add (output);  }  
Magic Number,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\PolygonManipulation\YuPengClipper.cs,BuildPolygonsFromChain,The following statement contains a magic number: if (output.Count < 3) {  	errVal = PolyClipError.DegeneratedOutput;  	Debug.WriteLine ("Degenerated output polygon produced (vertices < 3).");  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: for (int y = 0; y < yn; y++) {  	float y0 = y * cellHeight + domain.LowerBound.Y;  	float y1;  	if (y == yn - 1)  		y1 = domain.UpperBound.Y;  	else  		y1 = y0 + cellHeight;  	GeomPoly pre = null;  	for (int x = 0; x < xn; x++) {  		float x0 = x * cellWidth + domain.LowerBound.X;  		float x1;  		if (x == xn - 1)  			x1 = domain.UpperBound.X;  		else  			x1 = x0 + cellWidth;  		gp = new GeomPoly ();  		int key = MarchSquare (f' fs' ref gp' x' y' x0' y0' x1' y1' lerpCount);  		if (gp.Length != 0) {  			if (combine && pre != null && (key & 9) != 0) {  				combLeft (ref pre' ref gp);  				gp = pre;  			}  			else  				ret.Add (gp);  			ps [x' y] = new GeomPolyVal (gp' key);  		}  		else  			gp = null;  		pre = gp;  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: for (int x = 0; x < xn; x++) {  	float x0 = x * cellWidth + domain.LowerBound.X;  	float x1;  	if (x == xn - 1)  		x1 = domain.UpperBound.X;  	else  		x1 = x0 + cellWidth;  	gp = new GeomPoly ();  	int key = MarchSquare (f' fs' ref gp' x' y' x0' y0' x1' y1' lerpCount);  	if (gp.Length != 0) {  		if (combine && pre != null && (key & 9) != 0) {  			combLeft (ref pre' ref gp);  			gp = pre;  		}  		else  			ret.Add (gp);  		ps [x' y] = new GeomPolyVal (gp' key);  	}  	else  		gp = null;  	pre = gp;  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: if (gp.Length != 0) {  	if (combine && pre != null && (key & 9) != 0) {  		combLeft (ref pre' ref gp);  		gp = pre;  	}  	else  		ret.Add (gp);  	ps [x' y] = new GeomPolyVal (gp' key);  }  else  	gp = null;  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: if (combine && pre != null && (key & 9) != 0) {  	combLeft (ref pre' ref gp);  	gp = pre;  }  else  	ret.Add (gp);  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: for (int y = 1; y < yn; y++) {  	int x = 0;  	while (x < xn) {  		GeomPolyVal p = ps [x' y];  		//skip along scan line if no polygon exists at this point  		if (p == null) {  			x++;  			continue;  		}  		//skip along if current polygon cannot be combined above.  		if ((p.Key & 12) == 0) {  			x++;  			continue;  		}  		//skip along if no polygon exists above.  		GeomPolyVal u = ps [x' y - 1];  		if (u == null) {  			x++;  			continue;  		}  		//skip along if polygon above cannot be combined with.  		if ((u.Key & 3) == 0) {  			x++;  			continue;  		}  		float ax = x * cellWidth + domain.LowerBound.X;  		float ay = y * cellHeight + domain.LowerBound.Y;  		CxFastList<Vector2> bp = p.GeomP.Points;  		CxFastList<Vector2> ap = u.GeomP.Points;  		//skip if it's already been combined with above polygon  		if (u.GeomP == p.GeomP) {  			x++;  			continue;  		}  		//combine above (but disallow the hole thingies  		CxFastListNode<Vector2> bi = bp.Begin ();  		while (Square (bi.Elem ().Y - ay) > Settings.Epsilon || bi.Elem ().X < ax)  			bi = bi.Next ();  		//NOTE: Unused  		//Vector2 b0 = bi.elem();  		Vector2 b1 = bi.Next ().Elem ();  		if (Square (b1.Y - ay) > Settings.Epsilon) {  			x++;  			continue;  		}  		bool brk = true;  		CxFastListNode<Vector2> ai = ap.Begin ();  		while (ai != ap.End ()) {  			if (VecDsq (ai.Elem ()' b1) < Settings.Epsilon) {  				brk = false;  				break;  			}  			ai = ai.Next ();  		}  		if (brk) {  			x++;  			continue;  		}  		CxFastListNode<Vector2> bj = bi.Next ().Next ();  		if (bj == bp.End ())  			bj = bp.Begin ();  		while (bj != bi) {  			ai = ap.Insert (ai' bj.Elem ());  			// .clone()  			bj = bj.Next ();  			if (bj == bp.End ())  				bj = bp.Begin ();  			u.GeomP.Length++;  		}  		//u.p.simplify(float.Epsilon'float.Epsilon);  		//  		ax = x + 1;  		while (ax < xn) {  			GeomPolyVal p2 = ps [(int)ax' y];  			if (p2 == null || p2.GeomP != p.GeomP) {  				ax++;  				continue;  			}  			p2.GeomP = u.GeomP;  			ax++;  		}  		ax = x - 1;  		while (ax >= 0) {  			GeomPolyVal p2 = ps [(int)ax' y];  			if (p2 == null || p2.GeomP != p.GeomP) {  				ax--;  				continue;  			}  			p2.GeomP = u.GeomP;  			ax--;  		}  		ret.Remove (p.GeomP);  		p.GeomP = u.GeomP;  		x = (int)((bi.Next ().Elem ().X - domain.LowerBound.X) / cellWidth) + 1;  		//x++; this was already commented out!  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: for (int y = 1; y < yn; y++) {  	int x = 0;  	while (x < xn) {  		GeomPolyVal p = ps [x' y];  		//skip along scan line if no polygon exists at this point  		if (p == null) {  			x++;  			continue;  		}  		//skip along if current polygon cannot be combined above.  		if ((p.Key & 12) == 0) {  			x++;  			continue;  		}  		//skip along if no polygon exists above.  		GeomPolyVal u = ps [x' y - 1];  		if (u == null) {  			x++;  			continue;  		}  		//skip along if polygon above cannot be combined with.  		if ((u.Key & 3) == 0) {  			x++;  			continue;  		}  		float ax = x * cellWidth + domain.LowerBound.X;  		float ay = y * cellHeight + domain.LowerBound.Y;  		CxFastList<Vector2> bp = p.GeomP.Points;  		CxFastList<Vector2> ap = u.GeomP.Points;  		//skip if it's already been combined with above polygon  		if (u.GeomP == p.GeomP) {  			x++;  			continue;  		}  		//combine above (but disallow the hole thingies  		CxFastListNode<Vector2> bi = bp.Begin ();  		while (Square (bi.Elem ().Y - ay) > Settings.Epsilon || bi.Elem ().X < ax)  			bi = bi.Next ();  		//NOTE: Unused  		//Vector2 b0 = bi.elem();  		Vector2 b1 = bi.Next ().Elem ();  		if (Square (b1.Y - ay) > Settings.Epsilon) {  			x++;  			continue;  		}  		bool brk = true;  		CxFastListNode<Vector2> ai = ap.Begin ();  		while (ai != ap.End ()) {  			if (VecDsq (ai.Elem ()' b1) < Settings.Epsilon) {  				brk = false;  				break;  			}  			ai = ai.Next ();  		}  		if (brk) {  			x++;  			continue;  		}  		CxFastListNode<Vector2> bj = bi.Next ().Next ();  		if (bj == bp.End ())  			bj = bp.Begin ();  		while (bj != bi) {  			ai = ap.Insert (ai' bj.Elem ());  			// .clone()  			bj = bj.Next ();  			if (bj == bp.End ())  				bj = bp.Begin ();  			u.GeomP.Length++;  		}  		//u.p.simplify(float.Epsilon'float.Epsilon);  		//  		ax = x + 1;  		while (ax < xn) {  			GeomPolyVal p2 = ps [(int)ax' y];  			if (p2 == null || p2.GeomP != p.GeomP) {  				ax++;  				continue;  			}  			p2.GeomP = u.GeomP;  			ax++;  		}  		ax = x - 1;  		while (ax >= 0) {  			GeomPolyVal p2 = ps [(int)ax' y];  			if (p2 == null || p2.GeomP != p.GeomP) {  				ax--;  				continue;  			}  			p2.GeomP = u.GeomP;  			ax--;  		}  		ret.Remove (p.GeomP);  		p.GeomP = u.GeomP;  		x = (int)((bi.Next ().Elem ().X - domain.LowerBound.X) / cellWidth) + 1;  		//x++; this was already commented out!  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: while (x < xn) {  	GeomPolyVal p = ps [x' y];  	//skip along scan line if no polygon exists at this point  	if (p == null) {  		x++;  		continue;  	}  	//skip along if current polygon cannot be combined above.  	if ((p.Key & 12) == 0) {  		x++;  		continue;  	}  	//skip along if no polygon exists above.  	GeomPolyVal u = ps [x' y - 1];  	if (u == null) {  		x++;  		continue;  	}  	//skip along if polygon above cannot be combined with.  	if ((u.Key & 3) == 0) {  		x++;  		continue;  	}  	float ax = x * cellWidth + domain.LowerBound.X;  	float ay = y * cellHeight + domain.LowerBound.Y;  	CxFastList<Vector2> bp = p.GeomP.Points;  	CxFastList<Vector2> ap = u.GeomP.Points;  	//skip if it's already been combined with above polygon  	if (u.GeomP == p.GeomP) {  		x++;  		continue;  	}  	//combine above (but disallow the hole thingies  	CxFastListNode<Vector2> bi = bp.Begin ();  	while (Square (bi.Elem ().Y - ay) > Settings.Epsilon || bi.Elem ().X < ax)  		bi = bi.Next ();  	//NOTE: Unused  	//Vector2 b0 = bi.elem();  	Vector2 b1 = bi.Next ().Elem ();  	if (Square (b1.Y - ay) > Settings.Epsilon) {  		x++;  		continue;  	}  	bool brk = true;  	CxFastListNode<Vector2> ai = ap.Begin ();  	while (ai != ap.End ()) {  		if (VecDsq (ai.Elem ()' b1) < Settings.Epsilon) {  			brk = false;  			break;  		}  		ai = ai.Next ();  	}  	if (brk) {  		x++;  		continue;  	}  	CxFastListNode<Vector2> bj = bi.Next ().Next ();  	if (bj == bp.End ())  		bj = bp.Begin ();  	while (bj != bi) {  		ai = ap.Insert (ai' bj.Elem ());  		// .clone()  		bj = bj.Next ();  		if (bj == bp.End ())  			bj = bp.Begin ();  		u.GeomP.Length++;  	}  	//u.p.simplify(float.Epsilon'float.Epsilon);  	//  	ax = x + 1;  	while (ax < xn) {  		GeomPolyVal p2 = ps [(int)ax' y];  		if (p2 == null || p2.GeomP != p.GeomP) {  			ax++;  			continue;  		}  		p2.GeomP = u.GeomP;  		ax++;  	}  	ax = x - 1;  	while (ax >= 0) {  		GeomPolyVal p2 = ps [(int)ax' y];  		if (p2 == null || p2.GeomP != p.GeomP) {  			ax--;  			continue;  		}  		p2.GeomP = u.GeomP;  		ax--;  	}  	ret.Remove (p.GeomP);  	p.GeomP = u.GeomP;  	x = (int)((bi.Next ().Elem ().X - domain.LowerBound.X) / cellWidth) + 1;  	//x++; this was already commented out!  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: while (x < xn) {  	GeomPolyVal p = ps [x' y];  	//skip along scan line if no polygon exists at this point  	if (p == null) {  		x++;  		continue;  	}  	//skip along if current polygon cannot be combined above.  	if ((p.Key & 12) == 0) {  		x++;  		continue;  	}  	//skip along if no polygon exists above.  	GeomPolyVal u = ps [x' y - 1];  	if (u == null) {  		x++;  		continue;  	}  	//skip along if polygon above cannot be combined with.  	if ((u.Key & 3) == 0) {  		x++;  		continue;  	}  	float ax = x * cellWidth + domain.LowerBound.X;  	float ay = y * cellHeight + domain.LowerBound.Y;  	CxFastList<Vector2> bp = p.GeomP.Points;  	CxFastList<Vector2> ap = u.GeomP.Points;  	//skip if it's already been combined with above polygon  	if (u.GeomP == p.GeomP) {  		x++;  		continue;  	}  	//combine above (but disallow the hole thingies  	CxFastListNode<Vector2> bi = bp.Begin ();  	while (Square (bi.Elem ().Y - ay) > Settings.Epsilon || bi.Elem ().X < ax)  		bi = bi.Next ();  	//NOTE: Unused  	//Vector2 b0 = bi.elem();  	Vector2 b1 = bi.Next ().Elem ();  	if (Square (b1.Y - ay) > Settings.Epsilon) {  		x++;  		continue;  	}  	bool brk = true;  	CxFastListNode<Vector2> ai = ap.Begin ();  	while (ai != ap.End ()) {  		if (VecDsq (ai.Elem ()' b1) < Settings.Epsilon) {  			brk = false;  			break;  		}  		ai = ai.Next ();  	}  	if (brk) {  		x++;  		continue;  	}  	CxFastListNode<Vector2> bj = bi.Next ().Next ();  	if (bj == bp.End ())  		bj = bp.Begin ();  	while (bj != bi) {  		ai = ap.Insert (ai' bj.Elem ());  		// .clone()  		bj = bj.Next ();  		if (bj == bp.End ())  			bj = bp.Begin ();  		u.GeomP.Length++;  	}  	//u.p.simplify(float.Epsilon'float.Epsilon);  	//  	ax = x + 1;  	while (ax < xn) {  		GeomPolyVal p2 = ps [(int)ax' y];  		if (p2 == null || p2.GeomP != p.GeomP) {  			ax++;  			continue;  		}  		p2.GeomP = u.GeomP;  		ax++;  	}  	ax = x - 1;  	while (ax >= 0) {  		GeomPolyVal p2 = ps [(int)ax' y];  		if (p2 == null || p2.GeomP != p.GeomP) {  			ax--;  			continue;  		}  		p2.GeomP = u.GeomP;  		ax--;  	}  	ret.Remove (p.GeomP);  	p.GeomP = u.GeomP;  	x = (int)((bi.Next ().Elem ().X - domain.LowerBound.X) / cellWidth) + 1;  	//x++; this was already commented out!  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: if ((p.Key & 12) == 0) {  	x++;  	continue;  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: if ((u.Key & 3) == 0) {  	x++;  	continue;  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (v0 < 0)  	key |= 8;  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: key |= 8;  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (v1 < 0)  	key |= 4;  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: key |= 4;  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (v2 < 0)  	key |= 2;  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: key |= 2;  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0) {  	CxFastListNode<Vector2> pi = null;  	for (int i = 0; i < 8; i++) {  		Vector2 p;  		if ((val & (1 << i)) != 0) {  			if (i == 7 && (val & 1) == 0)  				poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  			else {  				if (i == 0)  					p = new Vector2 (x0' y0);  				else if (i == 2)  					p = new Vector2 (x1' y0);  				else if (i == 4)  					p = new Vector2 (x1' y1);  				else if (i == 6)  					p = new Vector2 (x0' y1);  				else if (i == 1)  					p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  				else if (i == 5)  					p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  				else if (i == 3)  					p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  				else  					p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  				pi = poly.Points.Insert (pi' p);  			}  			poly.Length++;  		}  	}  	//poly.simplify(float.Epsilon'float.Epsilon);  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0) {  	CxFastListNode<Vector2> pi = null;  	for (int i = 0; i < 8; i++) {  		Vector2 p;  		if ((val & (1 << i)) != 0) {  			if (i == 7 && (val & 1) == 0)  				poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  			else {  				if (i == 0)  					p = new Vector2 (x0' y0);  				else if (i == 2)  					p = new Vector2 (x1' y0);  				else if (i == 4)  					p = new Vector2 (x1' y1);  				else if (i == 6)  					p = new Vector2 (x0' y1);  				else if (i == 1)  					p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  				else if (i == 5)  					p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  				else if (i == 3)  					p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  				else  					p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  				pi = poly.Points.Insert (pi' p);  			}  			poly.Length++;  		}  	}  	//poly.simplify(float.Epsilon'float.Epsilon);  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0) {  	CxFastListNode<Vector2> pi = null;  	for (int i = 0; i < 8; i++) {  		Vector2 p;  		if ((val & (1 << i)) != 0) {  			if (i == 7 && (val & 1) == 0)  				poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  			else {  				if (i == 0)  					p = new Vector2 (x0' y0);  				else if (i == 2)  					p = new Vector2 (x1' y0);  				else if (i == 4)  					p = new Vector2 (x1' y1);  				else if (i == 6)  					p = new Vector2 (x0' y1);  				else if (i == 1)  					p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  				else if (i == 5)  					p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  				else if (i == 3)  					p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  				else  					p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  				pi = poly.Points.Insert (pi' p);  			}  			poly.Length++;  		}  	}  	//poly.simplify(float.Epsilon'float.Epsilon);  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0) {  	CxFastListNode<Vector2> pi = null;  	for (int i = 0; i < 8; i++) {  		Vector2 p;  		if ((val & (1 << i)) != 0) {  			if (i == 7 && (val & 1) == 0)  				poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  			else {  				if (i == 0)  					p = new Vector2 (x0' y0);  				else if (i == 2)  					p = new Vector2 (x1' y0);  				else if (i == 4)  					p = new Vector2 (x1' y1);  				else if (i == 6)  					p = new Vector2 (x0' y1);  				else if (i == 1)  					p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  				else if (i == 5)  					p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  				else if (i == 3)  					p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  				else  					p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  				pi = poly.Points.Insert (pi' p);  			}  			poly.Length++;  		}  	}  	//poly.simplify(float.Epsilon'float.Epsilon);  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0) {  	CxFastListNode<Vector2> pi = null;  	for (int i = 0; i < 8; i++) {  		Vector2 p;  		if ((val & (1 << i)) != 0) {  			if (i == 7 && (val & 1) == 0)  				poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  			else {  				if (i == 0)  					p = new Vector2 (x0' y0);  				else if (i == 2)  					p = new Vector2 (x1' y0);  				else if (i == 4)  					p = new Vector2 (x1' y1);  				else if (i == 6)  					p = new Vector2 (x0' y1);  				else if (i == 1)  					p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  				else if (i == 5)  					p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  				else if (i == 3)  					p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  				else  					p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  				pi = poly.Points.Insert (pi' p);  			}  			poly.Length++;  		}  	}  	//poly.simplify(float.Epsilon'float.Epsilon);  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0) {  	CxFastListNode<Vector2> pi = null;  	for (int i = 0; i < 8; i++) {  		Vector2 p;  		if ((val & (1 << i)) != 0) {  			if (i == 7 && (val & 1) == 0)  				poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  			else {  				if (i == 0)  					p = new Vector2 (x0' y0);  				else if (i == 2)  					p = new Vector2 (x1' y0);  				else if (i == 4)  					p = new Vector2 (x1' y1);  				else if (i == 6)  					p = new Vector2 (x0' y1);  				else if (i == 1)  					p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  				else if (i == 5)  					p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  				else if (i == 3)  					p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  				else  					p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  				pi = poly.Points.Insert (pi' p);  			}  			poly.Length++;  		}  	}  	//poly.simplify(float.Epsilon'float.Epsilon);  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0) {  	CxFastListNode<Vector2> pi = null;  	for (int i = 0; i < 8; i++) {  		Vector2 p;  		if ((val & (1 << i)) != 0) {  			if (i == 7 && (val & 1) == 0)  				poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  			else {  				if (i == 0)  					p = new Vector2 (x0' y0);  				else if (i == 2)  					p = new Vector2 (x1' y0);  				else if (i == 4)  					p = new Vector2 (x1' y1);  				else if (i == 6)  					p = new Vector2 (x0' y1);  				else if (i == 1)  					p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  				else if (i == 5)  					p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  				else if (i == 3)  					p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  				else  					p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  				pi = poly.Points.Insert (pi' p);  			}  			poly.Length++;  		}  	}  	//poly.simplify(float.Epsilon'float.Epsilon);  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	Vector2 p;  	if ((val & (1 << i)) != 0) {  		if (i == 7 && (val & 1) == 0)  			poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  		else {  			if (i == 0)  				p = new Vector2 (x0' y0);  			else if (i == 2)  				p = new Vector2 (x1' y0);  			else if (i == 4)  				p = new Vector2 (x1' y1);  			else if (i == 6)  				p = new Vector2 (x0' y1);  			else if (i == 1)  				p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  			else if (i == 5)  				p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  			else if (i == 3)  				p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  			else  				p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  			pi = poly.Points.Insert (pi' p);  		}  		poly.Length++;  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	Vector2 p;  	if ((val & (1 << i)) != 0) {  		if (i == 7 && (val & 1) == 0)  			poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  		else {  			if (i == 0)  				p = new Vector2 (x0' y0);  			else if (i == 2)  				p = new Vector2 (x1' y0);  			else if (i == 4)  				p = new Vector2 (x1' y1);  			else if (i == 6)  				p = new Vector2 (x0' y1);  			else if (i == 1)  				p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  			else if (i == 5)  				p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  			else if (i == 3)  				p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  			else  				p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  			pi = poly.Points.Insert (pi' p);  		}  		poly.Length++;  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	Vector2 p;  	if ((val & (1 << i)) != 0) {  		if (i == 7 && (val & 1) == 0)  			poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  		else {  			if (i == 0)  				p = new Vector2 (x0' y0);  			else if (i == 2)  				p = new Vector2 (x1' y0);  			else if (i == 4)  				p = new Vector2 (x1' y1);  			else if (i == 6)  				p = new Vector2 (x0' y1);  			else if (i == 1)  				p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  			else if (i == 5)  				p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  			else if (i == 3)  				p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  			else  				p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  			pi = poly.Points.Insert (pi' p);  		}  		poly.Length++;  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	Vector2 p;  	if ((val & (1 << i)) != 0) {  		if (i == 7 && (val & 1) == 0)  			poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  		else {  			if (i == 0)  				p = new Vector2 (x0' y0);  			else if (i == 2)  				p = new Vector2 (x1' y0);  			else if (i == 4)  				p = new Vector2 (x1' y1);  			else if (i == 6)  				p = new Vector2 (x0' y1);  			else if (i == 1)  				p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  			else if (i == 5)  				p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  			else if (i == 3)  				p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  			else  				p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  			pi = poly.Points.Insert (pi' p);  		}  		poly.Length++;  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	Vector2 p;  	if ((val & (1 << i)) != 0) {  		if (i == 7 && (val & 1) == 0)  			poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  		else {  			if (i == 0)  				p = new Vector2 (x0' y0);  			else if (i == 2)  				p = new Vector2 (x1' y0);  			else if (i == 4)  				p = new Vector2 (x1' y1);  			else if (i == 6)  				p = new Vector2 (x0' y1);  			else if (i == 1)  				p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  			else if (i == 5)  				p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  			else if (i == 3)  				p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  			else  				p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  			pi = poly.Points.Insert (pi' p);  		}  		poly.Length++;  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	Vector2 p;  	if ((val & (1 << i)) != 0) {  		if (i == 7 && (val & 1) == 0)  			poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  		else {  			if (i == 0)  				p = new Vector2 (x0' y0);  			else if (i == 2)  				p = new Vector2 (x1' y0);  			else if (i == 4)  				p = new Vector2 (x1' y1);  			else if (i == 6)  				p = new Vector2 (x0' y1);  			else if (i == 1)  				p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  			else if (i == 5)  				p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  			else if (i == 3)  				p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  			else  				p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  			pi = poly.Points.Insert (pi' p);  		}  		poly.Length++;  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	Vector2 p;  	if ((val & (1 << i)) != 0) {  		if (i == 7 && (val & 1) == 0)  			poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  		else {  			if (i == 0)  				p = new Vector2 (x0' y0);  			else if (i == 2)  				p = new Vector2 (x1' y0);  			else if (i == 4)  				p = new Vector2 (x1' y1);  			else if (i == 6)  				p = new Vector2 (x0' y1);  			else if (i == 1)  				p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  			else if (i == 5)  				p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  			else if (i == 3)  				p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  			else  				p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  			pi = poly.Points.Insert (pi' p);  		}  		poly.Length++;  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if ((val & (1 << i)) != 0) {  	if (i == 7 && (val & 1) == 0)  		poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  	else {  		if (i == 0)  			p = new Vector2 (x0' y0);  		else if (i == 2)  			p = new Vector2 (x1' y0);  		else if (i == 4)  			p = new Vector2 (x1' y1);  		else if (i == 6)  			p = new Vector2 (x0' y1);  		else if (i == 1)  			p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  		else if (i == 5)  			p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  		else if (i == 3)  			p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  		else  			p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  		pi = poly.Points.Insert (pi' p);  	}  	poly.Length++;  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if ((val & (1 << i)) != 0) {  	if (i == 7 && (val & 1) == 0)  		poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  	else {  		if (i == 0)  			p = new Vector2 (x0' y0);  		else if (i == 2)  			p = new Vector2 (x1' y0);  		else if (i == 4)  			p = new Vector2 (x1' y1);  		else if (i == 6)  			p = new Vector2 (x0' y1);  		else if (i == 1)  			p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  		else if (i == 5)  			p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  		else if (i == 3)  			p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  		else  			p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  		pi = poly.Points.Insert (pi' p);  	}  	poly.Length++;  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if ((val & (1 << i)) != 0) {  	if (i == 7 && (val & 1) == 0)  		poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  	else {  		if (i == 0)  			p = new Vector2 (x0' y0);  		else if (i == 2)  			p = new Vector2 (x1' y0);  		else if (i == 4)  			p = new Vector2 (x1' y1);  		else if (i == 6)  			p = new Vector2 (x0' y1);  		else if (i == 1)  			p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  		else if (i == 5)  			p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  		else if (i == 3)  			p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  		else  			p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  		pi = poly.Points.Insert (pi' p);  	}  	poly.Length++;  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if ((val & (1 << i)) != 0) {  	if (i == 7 && (val & 1) == 0)  		poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  	else {  		if (i == 0)  			p = new Vector2 (x0' y0);  		else if (i == 2)  			p = new Vector2 (x1' y0);  		else if (i == 4)  			p = new Vector2 (x1' y1);  		else if (i == 6)  			p = new Vector2 (x0' y1);  		else if (i == 1)  			p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  		else if (i == 5)  			p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  		else if (i == 3)  			p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  		else  			p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  		pi = poly.Points.Insert (pi' p);  	}  	poly.Length++;  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if ((val & (1 << i)) != 0) {  	if (i == 7 && (val & 1) == 0)  		poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  	else {  		if (i == 0)  			p = new Vector2 (x0' y0);  		else if (i == 2)  			p = new Vector2 (x1' y0);  		else if (i == 4)  			p = new Vector2 (x1' y1);  		else if (i == 6)  			p = new Vector2 (x0' y1);  		else if (i == 1)  			p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  		else if (i == 5)  			p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  		else if (i == 3)  			p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  		else  			p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  		pi = poly.Points.Insert (pi' p);  	}  	poly.Length++;  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if ((val & (1 << i)) != 0) {  	if (i == 7 && (val & 1) == 0)  		poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  	else {  		if (i == 0)  			p = new Vector2 (x0' y0);  		else if (i == 2)  			p = new Vector2 (x1' y0);  		else if (i == 4)  			p = new Vector2 (x1' y1);  		else if (i == 6)  			p = new Vector2 (x0' y1);  		else if (i == 1)  			p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  		else if (i == 5)  			p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  		else if (i == 3)  			p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  		else  			p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  		pi = poly.Points.Insert (pi' p);  	}  	poly.Length++;  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 7 && (val & 1) == 0)  	poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  else {  	if (i == 0)  		p = new Vector2 (x0' y0);  	else if (i == 2)  		p = new Vector2 (x1' y0);  	else if (i == 4)  		p = new Vector2 (x1' y1);  	else if (i == 6)  		p = new Vector2 (x0' y1);  	else if (i == 1)  		p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  	else if (i == 5)  		p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  	else if (i == 3)  		p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  	else  		p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  	pi = poly.Points.Insert (pi' p);  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 7 && (val & 1) == 0)  	poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  else {  	if (i == 0)  		p = new Vector2 (x0' y0);  	else if (i == 2)  		p = new Vector2 (x1' y0);  	else if (i == 4)  		p = new Vector2 (x1' y1);  	else if (i == 6)  		p = new Vector2 (x0' y1);  	else if (i == 1)  		p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  	else if (i == 5)  		p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  	else if (i == 3)  		p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  	else  		p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  	pi = poly.Points.Insert (pi' p);  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 7 && (val & 1) == 0)  	poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  else {  	if (i == 0)  		p = new Vector2 (x0' y0);  	else if (i == 2)  		p = new Vector2 (x1' y0);  	else if (i == 4)  		p = new Vector2 (x1' y1);  	else if (i == 6)  		p = new Vector2 (x0' y1);  	else if (i == 1)  		p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  	else if (i == 5)  		p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  	else if (i == 3)  		p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  	else  		p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  	pi = poly.Points.Insert (pi' p);  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 7 && (val & 1) == 0)  	poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  else {  	if (i == 0)  		p = new Vector2 (x0' y0);  	else if (i == 2)  		p = new Vector2 (x1' y0);  	else if (i == 4)  		p = new Vector2 (x1' y1);  	else if (i == 6)  		p = new Vector2 (x0' y1);  	else if (i == 1)  		p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  	else if (i == 5)  		p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  	else if (i == 3)  		p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  	else  		p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  	pi = poly.Points.Insert (pi' p);  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 7 && (val & 1) == 0)  	poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  else {  	if (i == 0)  		p = new Vector2 (x0' y0);  	else if (i == 2)  		p = new Vector2 (x1' y0);  	else if (i == 4)  		p = new Vector2 (x1' y1);  	else if (i == 6)  		p = new Vector2 (x0' y1);  	else if (i == 1)  		p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  	else if (i == 5)  		p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  	else if (i == 3)  		p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  	else  		p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  	pi = poly.Points.Insert (pi' p);  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 7 && (val & 1) == 0)  	poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  else {  	if (i == 0)  		p = new Vector2 (x0' y0);  	else if (i == 2)  		p = new Vector2 (x1' y0);  	else if (i == 4)  		p = new Vector2 (x1' y1);  	else if (i == 6)  		p = new Vector2 (x0' y1);  	else if (i == 1)  		p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  	else if (i == 5)  		p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  	else if (i == 3)  		p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  	else  		p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  	pi = poly.Points.Insert (pi' p);  }  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 0)  	p = new Vector2 (x0' y0);  else if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 0)  	p = new Vector2 (x0' y0);  else if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 0)  	p = new Vector2 (x0' y0);  else if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 0)  	p = new Vector2 (x0' y0);  else if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 0)  	p = new Vector2 (x0' y0);  else if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,MarchingSquares,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common.TextureTools,Terrain,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\Terrain.cs,GenerateTerrain,The following statement contains a magic number: foreach (Vertices item in polys) {  	// does this need to be negative?  	item.Scale (ref scale);  	item.Translate (ref _topLeft);  	Vertices simplified = SimplifyTools.CollinearSimplify (item);  	List<Vertices> decompPolys = Triangulate.ConvexPartition (simplified' Decomposer);  	foreach (Vertices poly in decompPolys) {  		if (poly.Count > 2)  			_bodyMap [gx' gy].Add (BodyFactory.CreatePolygon (World' poly' 1));  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,Terrain,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\Terrain.cs,GenerateTerrain,The following statement contains a magic number: foreach (Vertices poly in decompPolys) {  	if (poly.Count > 2)  		_bodyMap [gx' gy].Add (BodyFactory.CreatePolygon (World' poly' 1));  }  
Magic Number,FarseerPhysics.Common.TextureTools,Terrain,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\Terrain.cs,GenerateTerrain,The following statement contains a magic number: if (poly.Count > 2)  	_bodyMap [gx' gy].Add (BodyFactory.CreatePolygon (World' poly' 1));  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,Initialize,The following statement contains a magic number: if (alphaTolerance.HasValue)  	AlphaTolerance = alphaTolerance.Value;  else  	AlphaTolerance = 20;  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,Initialize,The following statement contains a magic number: AlphaTolerance = 20;  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SetTextureData,The following statement contains a magic number: if (data.Length < 4)  	throw new ArgumentOutOfRangeException ("data"' "'data' length can't be less then 4. Your texture must be at least 2 x 2 pixels in size.");  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SetTextureData,The following statement contains a magic number: if (width < 2)  	throw new ArgumentOutOfRangeException ("width"' "'width' can't be less then 2. Your texture must be at least 2 x 2 pixels in size.");  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (_data.Length < 4)  	throw new Exception ("'_data' length can't be less then 4. Your texture must be at least 2 x 2 pixels in size. " + "You have to use SetTextureData(uint[] data' int width) before calling this method.");  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (_width < 2)  	throw new Exception ("'_width' can't be less then 2. Your texture must be at least 2 x 2 pixels in size. " + "You have to use SetTextureData(uint[] data' int width) before calling this method.");  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: do {  	Vertices polygon;  	if (detectedPolygons.Count == 0) {  		// First pass / single polygon  		polygon = new Vertices (CreateSimplePolygon (Vector2.Zero' Vector2.Zero));  		if (polygon.Count > 2)  			polygonEntrance = GetTopMostVertex (polygon);  	}  	else if (polygonEntrance.HasValue) {  		// Multi pass / multiple polygons  		polygon = new Vertices (CreateSimplePolygon (polygonEntrance.Value' new Vector2 (polygonEntrance.Value.X - 1f' polygonEntrance.Value.Y)));  	}  	else  		break;  	searchOn = false;  	if (polygon.Count > 2) {  		if (_holeDetection) {  			do {  				holeEntrance = SearchHoleEntrance (polygon' holeEntrance);  				if (holeEntrance.HasValue) {  					if (!blackList.Contains (holeEntrance.Value)) {  						blackList.Add (holeEntrance.Value);  						Vertices holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  						if (holePolygon != null && holePolygon.Count > 2) {  							switch (_polygonDetectionType) {  							case VerticesDetectionType.Integrated:  								// Add first hole polygon vertex to close the hole polygon.  								holePolygon.Add (holePolygon [0]);  								int vertex1Index' vertex2Index;  								if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  									polygon.InsertRange (vertex2Index' holePolygon);  								break;  							case VerticesDetectionType.Separated:  								if (polygon.Holes == null)  									polygon.Holes = new List<Vertices> ();  								polygon.Holes.Add (holePolygon);  								break;  							}  						}  					}  					else  						break;  				}  				else  					break;  			}  			while (true);  		}  		detectedPolygons.Add (polygon);  	}  	if (_multipartDetection || polygon.Count <= 2) {  		if (SearchNextHullEntrance (detectedPolygons' polygonEntrance.Value' out polygonEntrance))  			searchOn = true;  	}  }  while (searchOn);  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: do {  	Vertices polygon;  	if (detectedPolygons.Count == 0) {  		// First pass / single polygon  		polygon = new Vertices (CreateSimplePolygon (Vector2.Zero' Vector2.Zero));  		if (polygon.Count > 2)  			polygonEntrance = GetTopMostVertex (polygon);  	}  	else if (polygonEntrance.HasValue) {  		// Multi pass / multiple polygons  		polygon = new Vertices (CreateSimplePolygon (polygonEntrance.Value' new Vector2 (polygonEntrance.Value.X - 1f' polygonEntrance.Value.Y)));  	}  	else  		break;  	searchOn = false;  	if (polygon.Count > 2) {  		if (_holeDetection) {  			do {  				holeEntrance = SearchHoleEntrance (polygon' holeEntrance);  				if (holeEntrance.HasValue) {  					if (!blackList.Contains (holeEntrance.Value)) {  						blackList.Add (holeEntrance.Value);  						Vertices holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  						if (holePolygon != null && holePolygon.Count > 2) {  							switch (_polygonDetectionType) {  							case VerticesDetectionType.Integrated:  								// Add first hole polygon vertex to close the hole polygon.  								holePolygon.Add (holePolygon [0]);  								int vertex1Index' vertex2Index;  								if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  									polygon.InsertRange (vertex2Index' holePolygon);  								break;  							case VerticesDetectionType.Separated:  								if (polygon.Holes == null)  									polygon.Holes = new List<Vertices> ();  								polygon.Holes.Add (holePolygon);  								break;  							}  						}  					}  					else  						break;  				}  				else  					break;  			}  			while (true);  		}  		detectedPolygons.Add (polygon);  	}  	if (_multipartDetection || polygon.Count <= 2) {  		if (SearchNextHullEntrance (detectedPolygons' polygonEntrance.Value' out polygonEntrance))  			searchOn = true;  	}  }  while (searchOn);  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: do {  	Vertices polygon;  	if (detectedPolygons.Count == 0) {  		// First pass / single polygon  		polygon = new Vertices (CreateSimplePolygon (Vector2.Zero' Vector2.Zero));  		if (polygon.Count > 2)  			polygonEntrance = GetTopMostVertex (polygon);  	}  	else if (polygonEntrance.HasValue) {  		// Multi pass / multiple polygons  		polygon = new Vertices (CreateSimplePolygon (polygonEntrance.Value' new Vector2 (polygonEntrance.Value.X - 1f' polygonEntrance.Value.Y)));  	}  	else  		break;  	searchOn = false;  	if (polygon.Count > 2) {  		if (_holeDetection) {  			do {  				holeEntrance = SearchHoleEntrance (polygon' holeEntrance);  				if (holeEntrance.HasValue) {  					if (!blackList.Contains (holeEntrance.Value)) {  						blackList.Add (holeEntrance.Value);  						Vertices holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  						if (holePolygon != null && holePolygon.Count > 2) {  							switch (_polygonDetectionType) {  							case VerticesDetectionType.Integrated:  								// Add first hole polygon vertex to close the hole polygon.  								holePolygon.Add (holePolygon [0]);  								int vertex1Index' vertex2Index;  								if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  									polygon.InsertRange (vertex2Index' holePolygon);  								break;  							case VerticesDetectionType.Separated:  								if (polygon.Holes == null)  									polygon.Holes = new List<Vertices> ();  								polygon.Holes.Add (holePolygon);  								break;  							}  						}  					}  					else  						break;  				}  				else  					break;  			}  			while (true);  		}  		detectedPolygons.Add (polygon);  	}  	if (_multipartDetection || polygon.Count <= 2) {  		if (SearchNextHullEntrance (detectedPolygons' polygonEntrance.Value' out polygonEntrance))  			searchOn = true;  	}  }  while (searchOn);  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: do {  	Vertices polygon;  	if (detectedPolygons.Count == 0) {  		// First pass / single polygon  		polygon = new Vertices (CreateSimplePolygon (Vector2.Zero' Vector2.Zero));  		if (polygon.Count > 2)  			polygonEntrance = GetTopMostVertex (polygon);  	}  	else if (polygonEntrance.HasValue) {  		// Multi pass / multiple polygons  		polygon = new Vertices (CreateSimplePolygon (polygonEntrance.Value' new Vector2 (polygonEntrance.Value.X - 1f' polygonEntrance.Value.Y)));  	}  	else  		break;  	searchOn = false;  	if (polygon.Count > 2) {  		if (_holeDetection) {  			do {  				holeEntrance = SearchHoleEntrance (polygon' holeEntrance);  				if (holeEntrance.HasValue) {  					if (!blackList.Contains (holeEntrance.Value)) {  						blackList.Add (holeEntrance.Value);  						Vertices holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  						if (holePolygon != null && holePolygon.Count > 2) {  							switch (_polygonDetectionType) {  							case VerticesDetectionType.Integrated:  								// Add first hole polygon vertex to close the hole polygon.  								holePolygon.Add (holePolygon [0]);  								int vertex1Index' vertex2Index;  								if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  									polygon.InsertRange (vertex2Index' holePolygon);  								break;  							case VerticesDetectionType.Separated:  								if (polygon.Holes == null)  									polygon.Holes = new List<Vertices> ();  								polygon.Holes.Add (holePolygon);  								break;  							}  						}  					}  					else  						break;  				}  				else  					break;  			}  			while (true);  		}  		detectedPolygons.Add (polygon);  	}  	if (_multipartDetection || polygon.Count <= 2) {  		if (SearchNextHullEntrance (detectedPolygons' polygonEntrance.Value' out polygonEntrance))  			searchOn = true;  	}  }  while (searchOn);  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (detectedPolygons.Count == 0) {  	// First pass / single polygon  	polygon = new Vertices (CreateSimplePolygon (Vector2.Zero' Vector2.Zero));  	if (polygon.Count > 2)  		polygonEntrance = GetTopMostVertex (polygon);  }  else if (polygonEntrance.HasValue) {  	// Multi pass / multiple polygons  	polygon = new Vertices (CreateSimplePolygon (polygonEntrance.Value' new Vector2 (polygonEntrance.Value.X - 1f' polygonEntrance.Value.Y)));  }  else  	break;  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (polygon.Count > 2)  	polygonEntrance = GetTopMostVertex (polygon);  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (polygon.Count > 2) {  	if (_holeDetection) {  		do {  			holeEntrance = SearchHoleEntrance (polygon' holeEntrance);  			if (holeEntrance.HasValue) {  				if (!blackList.Contains (holeEntrance.Value)) {  					blackList.Add (holeEntrance.Value);  					Vertices holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  					if (holePolygon != null && holePolygon.Count > 2) {  						switch (_polygonDetectionType) {  						case VerticesDetectionType.Integrated:  							// Add first hole polygon vertex to close the hole polygon.  							holePolygon.Add (holePolygon [0]);  							int vertex1Index' vertex2Index;  							if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  								polygon.InsertRange (vertex2Index' holePolygon);  							break;  						case VerticesDetectionType.Separated:  							if (polygon.Holes == null)  								polygon.Holes = new List<Vertices> ();  							polygon.Holes.Add (holePolygon);  							break;  						}  					}  				}  				else  					break;  			}  			else  				break;  		}  		while (true);  	}  	detectedPolygons.Add (polygon);  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (polygon.Count > 2) {  	if (_holeDetection) {  		do {  			holeEntrance = SearchHoleEntrance (polygon' holeEntrance);  			if (holeEntrance.HasValue) {  				if (!blackList.Contains (holeEntrance.Value)) {  					blackList.Add (holeEntrance.Value);  					Vertices holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  					if (holePolygon != null && holePolygon.Count > 2) {  						switch (_polygonDetectionType) {  						case VerticesDetectionType.Integrated:  							// Add first hole polygon vertex to close the hole polygon.  							holePolygon.Add (holePolygon [0]);  							int vertex1Index' vertex2Index;  							if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  								polygon.InsertRange (vertex2Index' holePolygon);  							break;  						case VerticesDetectionType.Separated:  							if (polygon.Holes == null)  								polygon.Holes = new List<Vertices> ();  							polygon.Holes.Add (holePolygon);  							break;  						}  					}  				}  				else  					break;  			}  			else  				break;  		}  		while (true);  	}  	detectedPolygons.Add (polygon);  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (_holeDetection) {  	do {  		holeEntrance = SearchHoleEntrance (polygon' holeEntrance);  		if (holeEntrance.HasValue) {  			if (!blackList.Contains (holeEntrance.Value)) {  				blackList.Add (holeEntrance.Value);  				Vertices holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  				if (holePolygon != null && holePolygon.Count > 2) {  					switch (_polygonDetectionType) {  					case VerticesDetectionType.Integrated:  						// Add first hole polygon vertex to close the hole polygon.  						holePolygon.Add (holePolygon [0]);  						int vertex1Index' vertex2Index;  						if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  							polygon.InsertRange (vertex2Index' holePolygon);  						break;  					case VerticesDetectionType.Separated:  						if (polygon.Holes == null)  							polygon.Holes = new List<Vertices> ();  						polygon.Holes.Add (holePolygon);  						break;  					}  				}  			}  			else  				break;  		}  		else  			break;  	}  	while (true);  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: do {  	holeEntrance = SearchHoleEntrance (polygon' holeEntrance);  	if (holeEntrance.HasValue) {  		if (!blackList.Contains (holeEntrance.Value)) {  			blackList.Add (holeEntrance.Value);  			Vertices holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  			if (holePolygon != null && holePolygon.Count > 2) {  				switch (_polygonDetectionType) {  				case VerticesDetectionType.Integrated:  					// Add first hole polygon vertex to close the hole polygon.  					holePolygon.Add (holePolygon [0]);  					int vertex1Index' vertex2Index;  					if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  						polygon.InsertRange (vertex2Index' holePolygon);  					break;  				case VerticesDetectionType.Separated:  					if (polygon.Holes == null)  						polygon.Holes = new List<Vertices> ();  					polygon.Holes.Add (holePolygon);  					break;  				}  			}  		}  		else  			break;  	}  	else  		break;  }  while (true);  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (holeEntrance.HasValue) {  	if (!blackList.Contains (holeEntrance.Value)) {  		blackList.Add (holeEntrance.Value);  		Vertices holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  		if (holePolygon != null && holePolygon.Count > 2) {  			switch (_polygonDetectionType) {  			case VerticesDetectionType.Integrated:  				// Add first hole polygon vertex to close the hole polygon.  				holePolygon.Add (holePolygon [0]);  				int vertex1Index' vertex2Index;  				if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  					polygon.InsertRange (vertex2Index' holePolygon);  				break;  			case VerticesDetectionType.Separated:  				if (polygon.Holes == null)  					polygon.Holes = new List<Vertices> ();  				polygon.Holes.Add (holePolygon);  				break;  			}  		}  	}  	else  		break;  }  else  	break;  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (!blackList.Contains (holeEntrance.Value)) {  	blackList.Add (holeEntrance.Value);  	Vertices holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  	if (holePolygon != null && holePolygon.Count > 2) {  		switch (_polygonDetectionType) {  		case VerticesDetectionType.Integrated:  			// Add first hole polygon vertex to close the hole polygon.  			holePolygon.Add (holePolygon [0]);  			int vertex1Index' vertex2Index;  			if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  				polygon.InsertRange (vertex2Index' holePolygon);  			break;  		case VerticesDetectionType.Separated:  			if (polygon.Holes == null)  				polygon.Holes = new List<Vertices> ();  			polygon.Holes.Add (holePolygon);  			break;  		}  	}  }  else  	break;  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (holePolygon != null && holePolygon.Count > 2) {  	switch (_polygonDetectionType) {  	case VerticesDetectionType.Integrated:  		// Add first hole polygon vertex to close the hole polygon.  		holePolygon.Add (holePolygon [0]);  		int vertex1Index' vertex2Index;  		if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  			polygon.InsertRange (vertex2Index' holePolygon);  		break;  	case VerticesDetectionType.Separated:  		if (polygon.Holes == null)  			polygon.Holes = new List<Vertices> ();  		polygon.Holes.Add (holePolygon);  		break;  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (_multipartDetection || polygon.Count <= 2) {  	if (SearchNextHullEntrance (detectedPolygons' polygonEntrance.Value' out polygonEntrance))  		searchOn = true;  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (polygon.Count < 3)  	throw new ArgumentException ("'polygon.MainPolygon.Count' can't be less then 3.");  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (startY > 0 && startY < _height && endY > 0 && endY < _height) {  	// go from top to bottom of the polygon  	for (int y = startY; y <= endY; y++) {  		// get x-coord of every polygon edge which crosses y  		xCoords = SearchCrossingEdges (polygon' y);  		// We need an even number of crossing edges.   		// It's always a pair of start and end edge: nothing | polygon | hole | polygon | nothing ...  		// If it's not then don't bother' it's probably a peak ...  		// ...which should be filtered out by SearchCrossingEdges() anyway.  		if (xCoords.Count > 1 && xCoords.Count % 2 == 0) {  			// Ok' this is short' but probably a little bit confusing.  			// This part searches from left to right between the edges inside the polygon.  			// The problem: We are using the polygon data to search in the texture data.  			// That's simply not accurate' but necessary because of performance.  			for (int i = 0; i < xCoords.Count; i += 2) {  				foundSolid = false;  				foundTransparent = false;  				// We search between the edges inside the polygon.  				for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  					// First pass: IsSolid might return false.  					// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  					// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  					// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   					// after it has found a solid pixel.  					// After we've found a solid and a transparent pixel (a hole's left edge)   					// we search for a solid pixel again (a hole's right edge).  					// When found the distance of that coodrinate has to be greater then the hull tolerance.  					if (IsSolid (ref x' ref y)) {  						if (!foundTransparent) {  							foundSolid = true;  							lastSolid = x;  						}  						if (foundSolid && foundTransparent) {  							entrance = new Vector2 (lastSolid' y);  							if (DistanceToHullAcceptable (polygon' entrance.Value' true))  								return entrance;  							entrance = null;  							break;  						}  					}  					else {  						if (foundSolid)  							foundTransparent = true;  					}  				}  			}  		}  		else {  			if (xCoords.Count % 2 == 0)  				Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  		}  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (startY > 0 && startY < _height && endY > 0 && endY < _height) {  	// go from top to bottom of the polygon  	for (int y = startY; y <= endY; y++) {  		// get x-coord of every polygon edge which crosses y  		xCoords = SearchCrossingEdges (polygon' y);  		// We need an even number of crossing edges.   		// It's always a pair of start and end edge: nothing | polygon | hole | polygon | nothing ...  		// If it's not then don't bother' it's probably a peak ...  		// ...which should be filtered out by SearchCrossingEdges() anyway.  		if (xCoords.Count > 1 && xCoords.Count % 2 == 0) {  			// Ok' this is short' but probably a little bit confusing.  			// This part searches from left to right between the edges inside the polygon.  			// The problem: We are using the polygon data to search in the texture data.  			// That's simply not accurate' but necessary because of performance.  			for (int i = 0; i < xCoords.Count; i += 2) {  				foundSolid = false;  				foundTransparent = false;  				// We search between the edges inside the polygon.  				for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  					// First pass: IsSolid might return false.  					// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  					// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  					// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   					// after it has found a solid pixel.  					// After we've found a solid and a transparent pixel (a hole's left edge)   					// we search for a solid pixel again (a hole's right edge).  					// When found the distance of that coodrinate has to be greater then the hull tolerance.  					if (IsSolid (ref x' ref y)) {  						if (!foundTransparent) {  							foundSolid = true;  							lastSolid = x;  						}  						if (foundSolid && foundTransparent) {  							entrance = new Vector2 (lastSolid' y);  							if (DistanceToHullAcceptable (polygon' entrance.Value' true))  								return entrance;  							entrance = null;  							break;  						}  					}  					else {  						if (foundSolid)  							foundTransparent = true;  					}  				}  			}  		}  		else {  			if (xCoords.Count % 2 == 0)  				Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  		}  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (startY > 0 && startY < _height && endY > 0 && endY < _height) {  	// go from top to bottom of the polygon  	for (int y = startY; y <= endY; y++) {  		// get x-coord of every polygon edge which crosses y  		xCoords = SearchCrossingEdges (polygon' y);  		// We need an even number of crossing edges.   		// It's always a pair of start and end edge: nothing | polygon | hole | polygon | nothing ...  		// If it's not then don't bother' it's probably a peak ...  		// ...which should be filtered out by SearchCrossingEdges() anyway.  		if (xCoords.Count > 1 && xCoords.Count % 2 == 0) {  			// Ok' this is short' but probably a little bit confusing.  			// This part searches from left to right between the edges inside the polygon.  			// The problem: We are using the polygon data to search in the texture data.  			// That's simply not accurate' but necessary because of performance.  			for (int i = 0; i < xCoords.Count; i += 2) {  				foundSolid = false;  				foundTransparent = false;  				// We search between the edges inside the polygon.  				for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  					// First pass: IsSolid might return false.  					// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  					// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  					// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   					// after it has found a solid pixel.  					// After we've found a solid and a transparent pixel (a hole's left edge)   					// we search for a solid pixel again (a hole's right edge).  					// When found the distance of that coodrinate has to be greater then the hull tolerance.  					if (IsSolid (ref x' ref y)) {  						if (!foundTransparent) {  							foundSolid = true;  							lastSolid = x;  						}  						if (foundSolid && foundTransparent) {  							entrance = new Vector2 (lastSolid' y);  							if (DistanceToHullAcceptable (polygon' entrance.Value' true))  								return entrance;  							entrance = null;  							break;  						}  					}  					else {  						if (foundSolid)  							foundTransparent = true;  					}  				}  			}  		}  		else {  			if (xCoords.Count % 2 == 0)  				Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  		}  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: for (int y = startY; y <= endY; y++) {  	// get x-coord of every polygon edge which crosses y  	xCoords = SearchCrossingEdges (polygon' y);  	// We need an even number of crossing edges.   	// It's always a pair of start and end edge: nothing | polygon | hole | polygon | nothing ...  	// If it's not then don't bother' it's probably a peak ...  	// ...which should be filtered out by SearchCrossingEdges() anyway.  	if (xCoords.Count > 1 && xCoords.Count % 2 == 0) {  		// Ok' this is short' but probably a little bit confusing.  		// This part searches from left to right between the edges inside the polygon.  		// The problem: We are using the polygon data to search in the texture data.  		// That's simply not accurate' but necessary because of performance.  		for (int i = 0; i < xCoords.Count; i += 2) {  			foundSolid = false;  			foundTransparent = false;  			// We search between the edges inside the polygon.  			for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  				// First pass: IsSolid might return false.  				// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  				// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  				// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   				// after it has found a solid pixel.  				// After we've found a solid and a transparent pixel (a hole's left edge)   				// we search for a solid pixel again (a hole's right edge).  				// When found the distance of that coodrinate has to be greater then the hull tolerance.  				if (IsSolid (ref x' ref y)) {  					if (!foundTransparent) {  						foundSolid = true;  						lastSolid = x;  					}  					if (foundSolid && foundTransparent) {  						entrance = new Vector2 (lastSolid' y);  						if (DistanceToHullAcceptable (polygon' entrance.Value' true))  							return entrance;  						entrance = null;  						break;  					}  				}  				else {  					if (foundSolid)  						foundTransparent = true;  				}  			}  		}  	}  	else {  		if (xCoords.Count % 2 == 0)  			Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: for (int y = startY; y <= endY; y++) {  	// get x-coord of every polygon edge which crosses y  	xCoords = SearchCrossingEdges (polygon' y);  	// We need an even number of crossing edges.   	// It's always a pair of start and end edge: nothing | polygon | hole | polygon | nothing ...  	// If it's not then don't bother' it's probably a peak ...  	// ...which should be filtered out by SearchCrossingEdges() anyway.  	if (xCoords.Count > 1 && xCoords.Count % 2 == 0) {  		// Ok' this is short' but probably a little bit confusing.  		// This part searches from left to right between the edges inside the polygon.  		// The problem: We are using the polygon data to search in the texture data.  		// That's simply not accurate' but necessary because of performance.  		for (int i = 0; i < xCoords.Count; i += 2) {  			foundSolid = false;  			foundTransparent = false;  			// We search between the edges inside the polygon.  			for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  				// First pass: IsSolid might return false.  				// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  				// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  				// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   				// after it has found a solid pixel.  				// After we've found a solid and a transparent pixel (a hole's left edge)   				// we search for a solid pixel again (a hole's right edge).  				// When found the distance of that coodrinate has to be greater then the hull tolerance.  				if (IsSolid (ref x' ref y)) {  					if (!foundTransparent) {  						foundSolid = true;  						lastSolid = x;  					}  					if (foundSolid && foundTransparent) {  						entrance = new Vector2 (lastSolid' y);  						if (DistanceToHullAcceptable (polygon' entrance.Value' true))  							return entrance;  						entrance = null;  						break;  					}  				}  				else {  					if (foundSolid)  						foundTransparent = true;  				}  			}  		}  	}  	else {  		if (xCoords.Count % 2 == 0)  			Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: for (int y = startY; y <= endY; y++) {  	// get x-coord of every polygon edge which crosses y  	xCoords = SearchCrossingEdges (polygon' y);  	// We need an even number of crossing edges.   	// It's always a pair of start and end edge: nothing | polygon | hole | polygon | nothing ...  	// If it's not then don't bother' it's probably a peak ...  	// ...which should be filtered out by SearchCrossingEdges() anyway.  	if (xCoords.Count > 1 && xCoords.Count % 2 == 0) {  		// Ok' this is short' but probably a little bit confusing.  		// This part searches from left to right between the edges inside the polygon.  		// The problem: We are using the polygon data to search in the texture data.  		// That's simply not accurate' but necessary because of performance.  		for (int i = 0; i < xCoords.Count; i += 2) {  			foundSolid = false;  			foundTransparent = false;  			// We search between the edges inside the polygon.  			for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  				// First pass: IsSolid might return false.  				// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  				// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  				// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   				// after it has found a solid pixel.  				// After we've found a solid and a transparent pixel (a hole's left edge)   				// we search for a solid pixel again (a hole's right edge).  				// When found the distance of that coodrinate has to be greater then the hull tolerance.  				if (IsSolid (ref x' ref y)) {  					if (!foundTransparent) {  						foundSolid = true;  						lastSolid = x;  					}  					if (foundSolid && foundTransparent) {  						entrance = new Vector2 (lastSolid' y);  						if (DistanceToHullAcceptable (polygon' entrance.Value' true))  							return entrance;  						entrance = null;  						break;  					}  				}  				else {  					if (foundSolid)  						foundTransparent = true;  				}  			}  		}  	}  	else {  		if (xCoords.Count % 2 == 0)  			Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (xCoords.Count > 1 && xCoords.Count % 2 == 0) {  	// Ok' this is short' but probably a little bit confusing.  	// This part searches from left to right between the edges inside the polygon.  	// The problem: We are using the polygon data to search in the texture data.  	// That's simply not accurate' but necessary because of performance.  	for (int i = 0; i < xCoords.Count; i += 2) {  		foundSolid = false;  		foundTransparent = false;  		// We search between the edges inside the polygon.  		for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  			// First pass: IsSolid might return false.  			// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  			// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  			// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   			// after it has found a solid pixel.  			// After we've found a solid and a transparent pixel (a hole's left edge)   			// we search for a solid pixel again (a hole's right edge).  			// When found the distance of that coodrinate has to be greater then the hull tolerance.  			if (IsSolid (ref x' ref y)) {  				if (!foundTransparent) {  					foundSolid = true;  					lastSolid = x;  				}  				if (foundSolid && foundTransparent) {  					entrance = new Vector2 (lastSolid' y);  					if (DistanceToHullAcceptable (polygon' entrance.Value' true))  						return entrance;  					entrance = null;  					break;  				}  			}  			else {  				if (foundSolid)  					foundTransparent = true;  			}  		}  	}  }  else {  	if (xCoords.Count % 2 == 0)  		Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (xCoords.Count > 1 && xCoords.Count % 2 == 0) {  	// Ok' this is short' but probably a little bit confusing.  	// This part searches from left to right between the edges inside the polygon.  	// The problem: We are using the polygon data to search in the texture data.  	// That's simply not accurate' but necessary because of performance.  	for (int i = 0; i < xCoords.Count; i += 2) {  		foundSolid = false;  		foundTransparent = false;  		// We search between the edges inside the polygon.  		for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  			// First pass: IsSolid might return false.  			// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  			// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  			// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   			// after it has found a solid pixel.  			// After we've found a solid and a transparent pixel (a hole's left edge)   			// we search for a solid pixel again (a hole's right edge).  			// When found the distance of that coodrinate has to be greater then the hull tolerance.  			if (IsSolid (ref x' ref y)) {  				if (!foundTransparent) {  					foundSolid = true;  					lastSolid = x;  				}  				if (foundSolid && foundTransparent) {  					entrance = new Vector2 (lastSolid' y);  					if (DistanceToHullAcceptable (polygon' entrance.Value' true))  						return entrance;  					entrance = null;  					break;  				}  			}  			else {  				if (foundSolid)  					foundTransparent = true;  			}  		}  	}  }  else {  	if (xCoords.Count % 2 == 0)  		Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (xCoords.Count > 1 && xCoords.Count % 2 == 0) {  	// Ok' this is short' but probably a little bit confusing.  	// This part searches from left to right between the edges inside the polygon.  	// The problem: We are using the polygon data to search in the texture data.  	// That's simply not accurate' but necessary because of performance.  	for (int i = 0; i < xCoords.Count; i += 2) {  		foundSolid = false;  		foundTransparent = false;  		// We search between the edges inside the polygon.  		for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  			// First pass: IsSolid might return false.  			// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  			// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  			// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   			// after it has found a solid pixel.  			// After we've found a solid and a transparent pixel (a hole's left edge)   			// we search for a solid pixel again (a hole's right edge).  			// When found the distance of that coodrinate has to be greater then the hull tolerance.  			if (IsSolid (ref x' ref y)) {  				if (!foundTransparent) {  					foundSolid = true;  					lastSolid = x;  				}  				if (foundSolid && foundTransparent) {  					entrance = new Vector2 (lastSolid' y);  					if (DistanceToHullAcceptable (polygon' entrance.Value' true))  						return entrance;  					entrance = null;  					break;  				}  			}  			else {  				if (foundSolid)  					foundTransparent = true;  			}  		}  	}  }  else {  	if (xCoords.Count % 2 == 0)  		Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: for (int i = 0; i < xCoords.Count; i += 2) {  	foundSolid = false;  	foundTransparent = false;  	// We search between the edges inside the polygon.  	for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  		// First pass: IsSolid might return false.  		// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  		// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  		// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   		// after it has found a solid pixel.  		// After we've found a solid and a transparent pixel (a hole's left edge)   		// we search for a solid pixel again (a hole's right edge).  		// When found the distance of that coodrinate has to be greater then the hull tolerance.  		if (IsSolid (ref x' ref y)) {  			if (!foundTransparent) {  				foundSolid = true;  				lastSolid = x;  			}  			if (foundSolid && foundTransparent) {  				entrance = new Vector2 (lastSolid' y);  				if (DistanceToHullAcceptable (polygon' entrance.Value' true))  					return entrance;  				entrance = null;  				break;  			}  		}  		else {  			if (foundSolid)  				foundTransparent = true;  		}  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: i += 2
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (xCoords.Count % 2 == 0)  	Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DistanceToHullAcceptableHoles,The following statement contains a magic number: if (polygon.Count < 3)  	throw new ArgumentException ("'polygon.MainPolygon.Count' can't be less then 3.");  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DistanceToHullAcceptable,The following statement contains a magic number: if (polygon.Count < 3)  	throw new ArgumentException ("'polygon.Count' can't be less then 3.");  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,InPolygon,The following statement contains a magic number: if (!inPolygon) {  	List<float> xCoords = SearchCrossingEdgesHoles (polygon' (int)point.Y);  	if (xCoords.Count > 0 && xCoords.Count % 2 == 0) {  		for (int i = 0; i < xCoords.Count; i += 2) {  			if (xCoords [i] <= point.X && xCoords [i + 1] >= point.X)  				return true;  		}  	}  	return false;  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,InPolygon,The following statement contains a magic number: if (!inPolygon) {  	List<float> xCoords = SearchCrossingEdgesHoles (polygon' (int)point.Y);  	if (xCoords.Count > 0 && xCoords.Count % 2 == 0) {  		for (int i = 0; i < xCoords.Count; i += 2) {  			if (xCoords [i] <= point.X && xCoords [i + 1] >= point.X)  				return true;  		}  	}  	return false;  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,InPolygon,The following statement contains a magic number: if (xCoords.Count > 0 && xCoords.Count % 2 == 0) {  	for (int i = 0; i < xCoords.Count; i += 2) {  		if (xCoords [i] <= point.X && xCoords [i + 1] >= point.X)  			return true;  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,InPolygon,The following statement contains a magic number: if (xCoords.Count > 0 && xCoords.Count % 2 == 0) {  	for (int i = 0; i < xCoords.Count; i += 2) {  		if (xCoords [i] <= point.X && xCoords [i + 1] >= point.X)  			return true;  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,InPolygon,The following statement contains a magic number: for (int i = 0; i < xCoords.Count; i += 2) {  	if (xCoords [i] <= point.X && xCoords [i + 1] >= point.X)  		return true;  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,InPolygon,The following statement contains a magic number: i += 2
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchCrossingEdgesHoles,The following statement contains a magic number: if (polygon.Count < 3)  	throw new ArgumentException ("'polygon.MainPolygon.Count' can't be less then 3.");  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchCrossingEdges,The following statement contains a magic number: if (polygon.Count > 2) {  	// There is a gap between the last and the first vertex in the vertex list.  	// We will bridge that by setting the last vertex (vertex2) to the last   	// vertex in the list.  	vertex2 = polygon [polygon.Count - 1];  	// We are moving along the polygon edges.  	for (int i = 0; i < polygon.Count; i++) {  		vertex1 = polygon [i];  		// Approx. check if the edge crosses our y coord.  		if ((vertex1.Y >= y && vertex2.Y <= y) || (vertex1.Y <= y && vertex2.Y >= y)) {  			// Ignore edges that are parallel to y.  			if (vertex1.Y != vertex2.Y) {  				addFind = true;  				slope = vertex2 - vertex1;  				// Special threatment for edges that end at the y coord.  				if (vertex1.Y == y) {  					// Create preview of the next edge.  					nextVertex = polygon [(i + 1) % polygon.Count];  					nextSlope = vertex1 - nextVertex;  					// Ignore peaks.   					// If thwo edges are aligned like this: /\ and the y coordinate lies on the top'  					// then we get the same x coord twice and we don't need that.  					if (slope.Y > 0)  						addFind = (nextSlope.Y <= 0);  					else  						addFind = (nextSlope.Y >= 0);  				}  				if (addFind)  					edges.Add ((y - vertex1.Y) / slope.Y * slope.X + vertex1.X);  				// Calculate and add the x coord.  			}  		}  		// vertex1 becomes vertex2 :).  		vertex2 = vertex1;  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SplitPolygonEdge,The following statement contains a magic number: if (xCoords != null && xCoords.Count > 1 && xCoords.Count % 2 == 0) {  	float distance;  	for (int i = 0; i < xCoords.Count; i++) {  		if (xCoords [i] < coordInsideThePolygon.X) {  			distance = coordInsideThePolygon.X - xCoords [i];  			if (distance < shortestDistance) {  				shortestDistance = distance;  				foundEdgeCoord.X = xCoords [i];  				edgeCoordFound = true;  			}  		}  	}  	if (edgeCoordFound) {  		shortestDistance = float.MaxValue;  		int edgeVertex2Index = polygon.Count - 1;  		int edgeVertex1Index;  		for (edgeVertex1Index = 0; edgeVertex1Index < polygon.Count; edgeVertex1Index++) {  			Vector2 tempVector1 = polygon [edgeVertex1Index];  			Vector2 tempVector2 = polygon [edgeVertex2Index];  			distance = LineTools.DistanceBetweenPointAndLineSegment (ref foundEdgeCoord' ref tempVector1' ref tempVector2);  			if (distance < shortestDistance) {  				shortestDistance = distance;  				nearestEdgeVertex1Index = edgeVertex1Index;  				nearestEdgeVertex2Index = edgeVertex2Index;  				edgeFound = true;  			}  			edgeVertex2Index = edgeVertex1Index;  		}  		if (edgeFound) {  			slope = polygon [nearestEdgeVertex2Index] - polygon [nearestEdgeVertex1Index];  			slope.Normalize ();  			Vector2 tempVector = polygon [nearestEdgeVertex1Index];  			distance = Vector2.Distance (tempVector' foundEdgeCoord);  			vertex1Index = nearestEdgeVertex1Index;  			vertex2Index = nearestEdgeVertex1Index + 1;  			polygon.Insert (nearestEdgeVertex1Index' distance * slope + polygon [vertex1Index]);  			polygon.Insert (nearestEdgeVertex1Index' distance * slope + polygon [vertex2Index]);  			return true;  		}  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,SearchForOutstandingVertex,The following statement contains a magic number: if (hullArea.Count > 2) {  	int hullAreaLastPoint = hullArea.Count - 1;  	Vector2 tempVector1;  	Vector2 tempVector2 = hullArea [0];  	Vector2 tempVector3 = hullArea [hullAreaLastPoint];  	// Search between the first and last hull point.  	for (int i = 1; i < hullAreaLastPoint; i++) {  		tempVector1 = hullArea [i];  		// Check if the distance is over the one that's tolerable.  		if (LineTools.DistanceBetweenPointAndLineSegment (ref tempVector1' ref tempVector2' ref tempVector3) >= _hullTolerance) {  			outstandingResult = hullArea [i];  			found = true;  			break;  		}  	}  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.X - last.X)) {  case 1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 1;  	case 0:  		return 0;  	case -1:  		return 7;  	}  	break;  case 0:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 2;  	case -1:  		return 6;  	}  	break;  case -1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 3;  	case 0:  		return 4;  	case -1:  		return 5;  	}  	break;  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.X - last.X)) {  case 1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 1;  	case 0:  		return 0;  	case -1:  		return 7;  	}  	break;  case 0:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 2;  	case -1:  		return 6;  	}  	break;  case -1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 3;  	case 0:  		return 4;  	case -1:  		return 5;  	}  	break;  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.X - last.X)) {  case 1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 1;  	case 0:  		return 0;  	case -1:  		return 7;  	}  	break;  case 0:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 2;  	case -1:  		return 6;  	}  	break;  case -1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 3;  	case 0:  		return 4;  	case -1:  		return 5;  	}  	break;  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.X - last.X)) {  case 1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 1;  	case 0:  		return 0;  	case -1:  		return 7;  	}  	break;  case 0:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 2;  	case -1:  		return 6;  	}  	break;  case -1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 3;  	case 0:  		return 4;  	case -1:  		return 5;  	}  	break;  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.X - last.X)) {  case 1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 1;  	case 0:  		return 0;  	case -1:  		return 7;  	}  	break;  case 0:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 2;  	case -1:  		return 6;  	}  	break;  case -1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 3;  	case 0:  		return 4;  	case -1:  		return 5;  	}  	break;  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.X - last.X)) {  case 1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 1;  	case 0:  		return 0;  	case -1:  		return 7;  	}  	break;  case 0:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 2;  	case -1:  		return 6;  	}  	break;  case -1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 3;  	case 0:  		return 4;  	case -1:  		return 5;  	}  	break;  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.Y - last.Y)) {  case 1:  	return 1;  case 0:  	return 0;  case -1:  	return 7;  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: return 7;  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.Y - last.Y)) {  case 1:  	return 2;  case -1:  	return 6;  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.Y - last.Y)) {  case 1:  	return 2;  case -1:  	return 6;  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: return 2;  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: return 6;  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.Y - last.Y)) {  case 1:  	return 3;  case 0:  	return 4;  case -1:  	return 5;  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.Y - last.Y)) {  case 1:  	return 3;  case 0:  	return 4;  case -1:  	return 5;  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.Y - last.Y)) {  case 1:  	return 3;  case 0:  	return 4;  case -1:  	return 5;  }  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: return 3;  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: return 4;  
Magic Number,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: return 5;  
Magic Number,FarseerPhysics.Controllers,AbstractForceController,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Controllers\AbstractForceController.cs,AbstractForceController,The following statement contains a magic number: Randomize = new Random (1234);  
Magic Number,FarseerPhysics.Controllers,AbstractForceController,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Controllers\AbstractForceController.cs,AbstractForceController,The following statement contains a magic number: StrengthCurve.Keys.Add (new CurveKey (0' 5));  
Magic Number,FarseerPhysics.Controllers,AbstractForceController,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Controllers\AbstractForceController.cs,AbstractForceController,The following statement contains a magic number: StrengthCurve.Keys.Add (new CurveKey (0.1f' 5));  
Magic Number,FarseerPhysics.Controllers,AbstractForceController,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Controllers\AbstractForceController.cs,AbstractForceController,The following statement contains a magic number: StrengthCurve.Keys.Add (new CurveKey (0.2f' -4));  
Magic Number,FarseerPhysics.Dynamics,Island,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Island.cs,Reset,The following statement contains a magic number: if (_contacts == null || _contacts.Length < contactCapacity) {  	_contacts = new Contact[contactCapacity * 2];  }  
Magic Number,FarseerPhysics.Dynamics,Island,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Island.cs,Reset,The following statement contains a magic number: _contacts = new Contact[contactCapacity * 2];  
Magic Number,FarseerPhysics.Dynamics,Island,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Island.cs,Reset,The following statement contains a magic number: if (_joints == null || _joints.Length < jointCapacity) {  	_joints = new Joint[jointCapacity * 2];  }  
Magic Number,FarseerPhysics.Dynamics,Island,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Island.cs,Reset,The following statement contains a magic number: _joints = new Joint[jointCapacity * 2];  
Magic Number,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,World,The following statement contains a magic number: BodyList = new List<Body> (32);  
Magic Number,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,World,The following statement contains a magic number: JointList = new List<Joint> (32);  
Magic Number,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,Solve,The following statement contains a magic number: if (stackSize > _stack.Length)  	_stack = new Body[Math.Max (_stack.Length * 2' stackSize)];  
Magic Number,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,Solve,The following statement contains a magic number: _stack = new Body[Math.Max (_stack.Length * 2' stackSize)];  
Magic Number,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,SolveTOI,The following statement contains a magic number: Island.Reset (2 * Settings.MaxTOIContacts' Settings.MaxTOIContacts' 0' ContactManager);  
Magic Number,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,SolveTOI,The following statement contains a magic number: for (; ;) {  	// Find the first TOI.  	Contact minContact = null;  	float minAlpha = 1.0f;  	#if USE_ACTIVE_CONTACT_SET  	                foreach (var c in ContactManager.ActiveContacts)                 { #else  	for (int i = 0; i < ContactManager.ContactList.Count; i++) {  		Contact c = ContactManager.ContactList [i];  		#endif  		// Is this contact disabled?  		if (c.Enabled == false) {  			continue;  		}  		// Prevent excessive sub-stepping.  		if (c._toiCount > Settings.MaxSubSteps) {  			continue;  		}  		float alpha;  		if (c.TOIFlag) {  			// This contact has a valid cached TOI.  			alpha = c._toi;  		}  		else {  			Fixture fA = c.FixtureA;  			Fixture fB = c.FixtureB;  			// Is there a sensor?  			if (fA.IsSensor || fB.IsSensor) {  				continue;  			}  			Body bA = fA.Body;  			Body bB = fB.Body;  			BodyType typeA = bA.BodyType;  			BodyType typeB = bB.BodyType;  			Debug.Assert (typeA == BodyType.Dynamic || typeB == BodyType.Dynamic);  			bool activeA = bA.Awake && typeA != BodyType.Static;  			bool activeB = bB.Awake && typeB != BodyType.Static;  			// Is at least one body active (awake and dynamic or kinematic)?  			if (activeA == false && activeB == false) {  				continue;  			}  			bool collideA = (bA.IsBullet || typeA != BodyType.Dynamic) && ((fA.IgnoreCCDWith & fB.CollisionCategories) == 0) && !bA.IgnoreCCD;  			bool collideB = (bB.IsBullet || typeB != BodyType.Dynamic) && ((fB.IgnoreCCDWith & fA.CollisionCategories) == 0) && !bB.IgnoreCCD;  			// Are these two non-bullet dynamic bodies?  			if (collideA == false && collideB == false) {  				continue;  			}  			#if OPTIMIZE_TOI  			                        if (_stepComplete)                         {                             if (!TOISet.Contains(bA))                             {                                 TOISet.Add(bA);                                 bA.Flags &= ~BodyFlags.Island;                                 bA.Sweep.Alpha0 = 0.0f;                             }                             if (!TOISet.Contains(bB))                             {                                 TOISet.Add(bB);                                 bB.Flags &= ~BodyFlags.Island;                                 bB.Sweep.Alpha0 = 0.0f;                             }                         } #endif  			// Compute the TOI for this contact.  			// Put the sweeps onto the same time interval.  			float alpha0 = bA._sweep.Alpha0;  			if (bA._sweep.Alpha0 < bB._sweep.Alpha0) {  				alpha0 = bB._sweep.Alpha0;  				bA._sweep.Advance (alpha0);  			}  			else if (bB._sweep.Alpha0 < bA._sweep.Alpha0) {  				alpha0 = bA._sweep.Alpha0;  				bB._sweep.Advance (alpha0);  			}  			Debug.Assert (alpha0 < 1.0f);  			// Compute the time of impact in interval [0' minTOI]  			_input.ProxyA.Set (fA.Shape' c.ChildIndexA);  			_input.ProxyB.Set (fB.Shape' c.ChildIndexB);  			_input.SweepA = bA._sweep;  			_input.SweepB = bB._sweep;  			_input.TMax = 1.0f;  			TOIOutput output;  			TimeOfImpact.CalculateTimeOfImpact (out output' _input);  			// Beta is the fraction of the remaining portion of the .  			float beta = output.T;  			if (output.State == TOIOutputState.Touching) {  				alpha = Math.Min (alpha0 + (1.0f - alpha0) * beta' 1.0f);  			}  			else {  				alpha = 1.0f;  			}  			c._toi = alpha;  			c.TOIFlag = true;  		}  		if (alpha < minAlpha) {  			// This is the minimum TOI found so far.  			minContact = c;  			minAlpha = alpha;  		}  	}  	if (minContact == null || 1.0f - 10.0f * Settings.Epsilon < minAlpha) {  		// No more TOI events. Done!  		_stepComplete = true;  		break;  	}  	// Advance the bodies to the TOI.  	Fixture fA1 = minContact.FixtureA;  	Fixture fB1 = minContact.FixtureB;  	Body bA0 = fA1.Body;  	Body bB0 = fB1.Body;  	Sweep backup1 = bA0._sweep;  	Sweep backup2 = bB0._sweep;  	bA0.Advance (minAlpha);  	bB0.Advance (minAlpha);  	// The TOI contact likely has some new contact points.  	minContact.Update (ContactManager);  	minContact.TOIFlag = false;  	++minContact._toiCount;  	// Is the contact solid?  	if (minContact.Enabled == false || minContact.IsTouching == false) {  		// Restore the sweeps.  		minContact.Enabled = false;  		bA0._sweep = backup1;  		bB0._sweep = backup2;  		bA0.SynchronizeTransform ();  		bB0.SynchronizeTransform ();  		continue;  	}  	bA0.Awake = true;  	bB0.Awake = true;  	// Build the island  	Island.Clear ();  	Island.Add (bA0);  	Island.Add (bB0);  	Island.Add (minContact);  	bA0._island = true;  	bB0._island = true;  	minContact.IslandFlag = true;  	// Get contacts on bodyA and bodyB.  	Body[] bodies =  {  		bA0'  		bB0  	};  	for (int i = 0; i < 2; ++i) {  		Body body = bodies [i];  		if (body.BodyType == BodyType.Dynamic) {  			for (ContactEdge ce = body.ContactList; ce != null; ce = ce.Next) {  				Contact contact = ce.Contact;  				if (Island.BodyCount == Island.BodyCapacity) {  					break;  				}  				if (Island.ContactCount == Island.ContactCapacity) {  					break;  				}  				// Has this contact already been added to the island?  				if (contact.IslandFlag) {  					continue;  				}  				// Only add static' kinematic' or bullet bodies.  				Body other = ce.Other;  				if (other.BodyType == BodyType.Dynamic && body.IsBullet == false && other.IsBullet == false) {  					continue;  				}  				// Skip sensors.  				if (contact.FixtureA.IsSensor || contact.FixtureB.IsSensor) {  					continue;  				}  				// Tentatively advance the body to the TOI.  				Sweep backup = other._sweep;  				if (!other._island) {  					other.Advance (minAlpha);  				}  				// Update the contact points  				contact.Update (ContactManager);  				// Was the contact disabled by the user?  				if (contact.Enabled == false) {  					other._sweep = backup;  					other.SynchronizeTransform ();  					continue;  				}  				// Are there contact points?  				if (contact.IsTouching == false) {  					other._sweep = backup;  					other.SynchronizeTransform ();  					continue;  				}  				// Add the contact to the island  				contact.IslandFlag = true;  				Island.Add (contact);  				// Has the other body already been added to the island?  				if (other._island) {  					continue;  				}  				// Add the other body to the island.  				other._island = true;  				if (other.BodyType != BodyType.Static) {  					other.Awake = true;  				}  				#if OPTIMIZE_TOI  				                            if (_stepComplete)                             {                                 if (!TOISet.Contains(other))                                 {                                     TOISet.Add(other);                                     other.Sweep.Alpha0 = 0.0f;                                 }                             } #endif  				Island.Add (other);  			}  		}  	}  	TimeStep subStep;  	subStep.dt = (1.0f - minAlpha) * step.dt;  	subStep.inv_dt = 1.0f / subStep.dt;  	subStep.dtRatio = 1.0f;  	Island.SolveTOI (ref subStep' bA0.IslandIndex' bB0.IslandIndex' false);  	// Reset island flags and synchronize broad-phase proxies.  	for (int i = 0; i < Island.BodyCount; ++i) {  		Body body = Island.Bodies [i];  		body._island = false;  		if (body.BodyType != BodyType.Dynamic) {  			continue;  		}  		body.SynchronizeFixtures ();  		// Invalidate all contact TOIs on this displaced body.  		for (ContactEdge ce = body.ContactList; ce != null; ce = ce.Next) {  			ce.Contact.TOIFlag = false;  			ce.Contact.IslandFlag = false;  		}  	}  	// Commit fixture proxy movements to the broad-phase so that new contacts are created.  	// Also' some contacts can be destroyed.  	ContactManager.FindNewContacts ();  	if (Settings.EnableSubStepping) {  		_stepComplete = false;  		break;  	}  }  
Magic Number,FarseerPhysics.Dynamics,World,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\World.cs,SolveTOI,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {  	Body body = bodies [i];  	if (body.BodyType == BodyType.Dynamic) {  		for (ContactEdge ce = body.ContactList; ce != null; ce = ce.Next) {  			Contact contact = ce.Contact;  			if (Island.BodyCount == Island.BodyCapacity) {  				break;  			}  			if (Island.ContactCount == Island.ContactCapacity) {  				break;  			}  			// Has this contact already been added to the island?  			if (contact.IslandFlag) {  				continue;  			}  			// Only add static' kinematic' or bullet bodies.  			Body other = ce.Other;  			if (other.BodyType == BodyType.Dynamic && body.IsBullet == false && other.IsBullet == false) {  				continue;  			}  			// Skip sensors.  			if (contact.FixtureA.IsSensor || contact.FixtureB.IsSensor) {  				continue;  			}  			// Tentatively advance the body to the TOI.  			Sweep backup = other._sweep;  			if (!other._island) {  				other.Advance (minAlpha);  			}  			// Update the contact points  			contact.Update (ContactManager);  			// Was the contact disabled by the user?  			if (contact.Enabled == false) {  				other._sweep = backup;  				other.SynchronizeTransform ();  				continue;  			}  			// Are there contact points?  			if (contact.IsTouching == false) {  				other._sweep = backup;  				other.SynchronizeTransform ();  				continue;  			}  			// Add the contact to the island  			contact.IslandFlag = true;  			Island.Add (contact);  			// Has the other body already been added to the island?  			if (other._island) {  				continue;  			}  			// Add the other body to the island.  			other._island = true;  			if (other.BodyType != BodyType.Static) {  				other.Awake = true;  			}  			#if OPTIMIZE_TOI  			                            if (_stepComplete)                             {                                 if (!TOISet.Contains(other))                                 {                                     TOISet.Add(other);                                     other.Sweep.Alpha0 = 0.0f;                                 }                             } #endif  			Island.Add (other);  		}  	}  }  
Magic Number,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\ContactSolver.cs,Reset,The following statement contains a magic number: if (_velocityConstraints == null || _velocityConstraints.Length < count) {  	_velocityConstraints = new ContactVelocityConstraint[count * 2];  	_positionConstraints = new ContactPositionConstraint[count * 2];  	for (int i = 0; i < _velocityConstraints.Length; i++) {  		_velocityConstraints [i] = new ContactVelocityConstraint ();  	}  	for (int i = 0; i < _positionConstraints.Length; i++) {  		_positionConstraints [i] = new ContactPositionConstraint ();  	}  }  
Magic Number,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\ContactSolver.cs,Reset,The following statement contains a magic number: if (_velocityConstraints == null || _velocityConstraints.Length < count) {  	_velocityConstraints = new ContactVelocityConstraint[count * 2];  	_positionConstraints = new ContactPositionConstraint[count * 2];  	for (int i = 0; i < _velocityConstraints.Length; i++) {  		_velocityConstraints [i] = new ContactVelocityConstraint ();  	}  	for (int i = 0; i < _positionConstraints.Length; i++) {  		_positionConstraints [i] = new ContactPositionConstraint ();  	}  }  
Magic Number,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\ContactSolver.cs,Reset,The following statement contains a magic number: _velocityConstraints = new ContactVelocityConstraint[count * 2];  
Magic Number,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\ContactSolver.cs,Reset,The following statement contains a magic number: _positionConstraints = new ContactPositionConstraint[count * 2];  
Magic Number,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\ContactSolver.cs,InitializeVelocityConstraints,The following statement contains a magic number: for (int i = 0; i < _count; ++i) {  	ContactVelocityConstraint vc = _velocityConstraints [i];  	ContactPositionConstraint pc = _positionConstraints [i];  	float radiusA = pc.radiusA;  	float radiusB = pc.radiusB;  	Manifold manifold = _contacts [vc.contactIndex].Manifold;  	int indexA = vc.indexA;  	int indexB = vc.indexB;  	float mA = vc.invMassA;  	float mB = vc.invMassB;  	float iA = vc.invIA;  	float iB = vc.invIB;  	Vector2 localCenterA = pc.localCenterA;  	Vector2 localCenterB = pc.localCenterB;  	Vector2 cA = _positions [indexA].c;  	float aA = _positions [indexA].a;  	Vector2 vA = _velocities [indexA].v;  	float wA = _velocities [indexA].w;  	Vector2 cB = _positions [indexB].c;  	float aB = _positions [indexB].a;  	Vector2 vB = _velocities [indexB].v;  	float wB = _velocities [indexB].w;  	Debug.Assert (manifold.PointCount > 0);  	Transform xfA = new Transform ();  	Transform xfB = new Transform ();  	xfA.q.Set (aA);  	xfB.q.Set (aB);  	xfA.p = cA - MathUtils.Mul (xfA.q' localCenterA);  	xfB.p = cB - MathUtils.Mul (xfB.q' localCenterB);  	Vector2 normal;  	FixedArray2<Vector2> points;  	WorldManifold.Initialize (ref manifold' ref xfA' radiusA' ref xfB' radiusB' out normal' out points);  	vc.normal = normal;  	int pointCount = vc.pointCount;  	for (int j = 0; j < pointCount; ++j) {  		VelocityConstraintPoint vcp = vc.points [j];  		vcp.rA = points [j] - cA;  		vcp.rB = points [j] - cB;  		float rnA = MathUtils.Cross (vcp.rA' vc.normal);  		float rnB = MathUtils.Cross (vcp.rB' vc.normal);  		float kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;  		vcp.normalMass = kNormal > 0.0f ? 1.0f / kNormal : 0.0f;  		Vector2 tangent = MathUtils.Cross (vc.normal' 1.0f);  		float rtA = MathUtils.Cross (vcp.rA' tangent);  		float rtB = MathUtils.Cross (vcp.rB' tangent);  		float kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;  		vcp.tangentMass = kTangent > 0.0f ? 1.0f / kTangent : 0.0f;  		// Setup a velocity bias for restitution.  		vcp.velocityBias = 0.0f;  		float vRel = Vector2.Dot (vc.normal' vB + MathUtils.Cross (wB' vcp.rB) - vA - MathUtils.Cross (wA' vcp.rA));  		if (vRel < -Settings.VelocityThreshold) {  			vcp.velocityBias = -vc.restitution * vRel;  		}  	}  	// If we have two points' then prepare the block solver.  	if (vc.pointCount == 2) {  		VelocityConstraintPoint vcp1 = vc.points [0];  		VelocityConstraintPoint vcp2 = vc.points [1];  		float rn1A = MathUtils.Cross (vcp1.rA' vc.normal);  		float rn1B = MathUtils.Cross (vcp1.rB' vc.normal);  		float rn2A = MathUtils.Cross (vcp2.rA' vc.normal);  		float rn2B = MathUtils.Cross (vcp2.rB' vc.normal);  		float k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;  		float k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;  		float k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;  		// Ensure a reasonable condition number.  		const float k_maxConditionNumber = 1000.0f;  		if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {  			// K is safe to invert.  			vc.K.ex = new Vector2 (k11' k12);  			vc.K.ey = new Vector2 (k12' k22);  			vc.normalMass = vc.K.Inverse;  		}  		else {  			// The constraints are redundant' just use one.  			// TODO_ERIN use deepest?  			vc.pointCount = 1;  		}  	}  }  
Magic Number,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\ContactSolver.cs,InitializeVelocityConstraints,The following statement contains a magic number: if (vc.pointCount == 2) {  	VelocityConstraintPoint vcp1 = vc.points [0];  	VelocityConstraintPoint vcp2 = vc.points [1];  	float rn1A = MathUtils.Cross (vcp1.rA' vc.normal);  	float rn1B = MathUtils.Cross (vcp1.rB' vc.normal);  	float rn2A = MathUtils.Cross (vcp2.rA' vc.normal);  	float rn2B = MathUtils.Cross (vcp2.rB' vc.normal);  	float k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;  	float k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;  	float k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;  	// Ensure a reasonable condition number.  	const float k_maxConditionNumber = 1000.0f;  	if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {  		// K is safe to invert.  		vc.K.ex = new Vector2 (k11' k12);  		vc.K.ey = new Vector2 (k12' k22);  		vc.normalMass = vc.K.Inverse;  	}  	else {  		// The constraints are redundant' just use one.  		// TODO_ERIN use deepest?  		vc.pointCount = 1;  	}  }  
Magic Number,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The following statement contains a magic number: for (int i = 0; i < _count; ++i) {  	ContactVelocityConstraint vc = _velocityConstraints [i];  	int indexA = vc.indexA;  	int indexB = vc.indexB;  	float mA = vc.invMassA;  	float iA = vc.invIA;  	float mB = vc.invMassB;  	float iB = vc.invIB;  	int pointCount = vc.pointCount;  	Vector2 vA = _velocities [indexA].v;  	float wA = _velocities [indexA].w;  	Vector2 vB = _velocities [indexB].v;  	float wB = _velocities [indexB].w;  	Vector2 normal = vc.normal;  	Vector2 tangent = MathUtils.Cross (normal' 1.0f);  	float friction = vc.friction;  	Debug.Assert (pointCount == 1 || pointCount == 2);  	// Solve tangent constraints first because non-penetration is more important  	// than friction.  	for (int j = 0; j < pointCount; ++j) {  		VelocityConstraintPoint vcp = vc.points [j];  		// Relative velocity at contact  		Vector2 dv = vB + MathUtils.Cross (wB' vcp.rB) - vA - MathUtils.Cross (wA' vcp.rA);  		// Compute tangent force  		float vt = Vector2.Dot (dv' tangent) - vc.tangentSpeed;  		float lambda = vcp.tangentMass * (-vt);  		// b2Clamp the accumulated force  		float maxFriction = friction * vcp.normalImpulse;  		float newImpulse = MathUtils.Clamp (vcp.tangentImpulse + lambda' -maxFriction' maxFriction);  		lambda = newImpulse - vcp.tangentImpulse;  		vcp.tangentImpulse = newImpulse;  		// Apply contact impulse  		Vector2 P = lambda * tangent;  		vA -= mA * P;  		wA -= iA * MathUtils.Cross (vcp.rA' P);  		vB += mB * P;  		wB += iB * MathUtils.Cross (vcp.rB' P);  	}  	// Solve normal constraints  	if (vc.pointCount == 1) {  		VelocityConstraintPoint vcp = vc.points [0];  		// Relative velocity at contact  		Vector2 dv = vB + MathUtils.Cross (wB' vcp.rB) - vA - MathUtils.Cross (wA' vcp.rA);  		// Compute normal impulse  		float vn = Vector2.Dot (dv' normal);  		float lambda = -vcp.normalMass * (vn - vcp.velocityBias);  		// b2Clamp the accumulated impulse  		float newImpulse = Math.Max (vcp.normalImpulse + lambda' 0.0f);  		lambda = newImpulse - vcp.normalImpulse;  		vcp.normalImpulse = newImpulse;  		// Apply contact impulse  		Vector2 P = lambda * normal;  		vA -= mA * P;  		wA -= iA * MathUtils.Cross (vcp.rA' P);  		vB += mB * P;  		wB += iB * MathUtils.Cross (vcp.rB' P);  	}  	else {  		// Block solver developed in collaboration with Dirk Gregorius (back in 01/07 on Box2D_Lite).  		// Build the mini LCP for this contact patch  		//  		// vn = A * x + b' vn >= 0' ' vn >= 0' x >= 0 and vn_i * x_i = 0 with i = 1..2  		//  		// A = J * W * JT and J = ( -n' -r1 x n' n' r2 x n )  		// b = vn0 - velocityBias  		//  		// The system is solved using the "Total enumeration method" (s. Murty). The complementary constraint vn_i * x_i  		// implies that we must have in any solution either vn_i = 0 or x_i = 0. So for the 2D contact problem the cases  		// vn1 = 0 and vn2 = 0' x1 = 0 and x2 = 0' x1 = 0 and vn2 = 0' x2 = 0 and vn1 = 0 need to be tested. The first valid  		// solution that satisfies the problem is chosen.  		//   		// In order to account of the accumulated impulse 'a' (because of the iterative nature of the solver which only requires  		// that the accumulated impulse is clamped and not the incremental impulse) we change the impulse variable (x_i).  		//  		// Substitute:  		//   		// x = a + d  		//   		// a := old total impulse  		// x := new total impulse  		// d := incremental impulse   		//  		// For the current iteration we extend the formula for the incremental impulse  		// to compute the new total impulse:  		//  		// vn = A * d + b  		//    = A * (x - a) + b  		//    = A * x + b - A * a  		//    = A * x + b'  		// b' = b - A * a;  		VelocityConstraintPoint cp1 = vc.points [0];  		VelocityConstraintPoint cp2 = vc.points [1];  		Vector2 a = new Vector2 (cp1.normalImpulse' cp2.normalImpulse);  		Debug.Assert (a.X >= 0.0f && a.Y >= 0.0f);  		// Relative velocity at contact  		Vector2 dv1 = vB + MathUtils.Cross (wB' cp1.rB) - vA - MathUtils.Cross (wA' cp1.rA);  		Vector2 dv2 = vB + MathUtils.Cross (wB' cp2.rB) - vA - MathUtils.Cross (wA' cp2.rA);  		// Compute normal velocity  		float vn1 = Vector2.Dot (dv1' normal);  		float vn2 = Vector2.Dot (dv2' normal);  		Vector2 b = new Vector2 ();  		b.X = vn1 - cp1.velocityBias;  		b.Y = vn2 - cp2.velocityBias;  		// Compute b'  		b -= MathUtils.Mul (ref vc.K' a);  		const float k_errorTol = 1e-3f;  		//B2_NOT_USED(k_errorTol);  		for (; ;) {  			//  			// Case 1: vn = 0  			//  			// 0 = A * x + b'  			//  			// Solve for x:  			//  			// x = - inv(A) * b'  			//  			Vector2 x = -MathUtils.Mul (ref vc.normalMass' b);  			if (x.X >= 0.0f && x.Y >= 0.0f) {  				// Get the incremental impulse  				Vector2 d = x - a;  				// Apply incremental impulse  				Vector2 P1 = d.X * normal;  				Vector2 P2 = d.Y * normal;  				vA -= mA * (P1 + P2);  				wA -= iA * (MathUtils.Cross (cp1.rA' P1) + MathUtils.Cross (cp2.rA' P2));  				vB += mB * (P1 + P2);  				wB += iB * (MathUtils.Cross (cp1.rB' P1) + MathUtils.Cross (cp2.rB' P2));  				// Accumulate  				cp1.normalImpulse = x.X;  				cp2.normalImpulse = x.Y;  				#if B2_DEBUG_SOLVER  									// Postconditions 					dv1 = vB + MathUtils.Cross(wB' cp1.rB) - vA - MathUtils.Cross(wA' cp1.rA); 					dv2 = vB + MathUtils.Cross(wB' cp2.rB) - vA - MathUtils.Cross(wA' cp2.rA);  					// Compute normal velocity 					vn1 = Vector2.Dot(dv1' normal); 					vn2 = Vector2.Dot(dv2' normal);  					b2Assert(b2Abs(vn1 - cp1.velocityBias) < k_errorTol); 					b2Assert(b2Abs(vn2 - cp2.velocityBias) < k_errorTol); #endif  				break;  			}  			//  			// Case 2: vn1 = 0 and x2 = 0  			//  			//   0 = a11 * x1 + a12 * 0 + b1'   			// vn2 = a21 * x1 + a22 * 0 + b2'  			//  			x.X = -cp1.normalMass * b.X;  			x.Y = 0.0f;  			vn1 = 0.0f;  			vn2 = vc.K.ex.Y * x.X + b.Y;  			if (x.X >= 0.0f && vn2 >= 0.0f) {  				// Get the incremental impulse  				Vector2 d = x - a;  				// Apply incremental impulse  				Vector2 P1 = d.X * normal;  				Vector2 P2 = d.Y * normal;  				vA -= mA * (P1 + P2);  				wA -= iA * (MathUtils.Cross (cp1.rA' P1) + MathUtils.Cross (cp2.rA' P2));  				vB += mB * (P1 + P2);  				wB += iB * (MathUtils.Cross (cp1.rB' P1) + MathUtils.Cross (cp2.rB' P2));  				// Accumulate  				cp1.normalImpulse = x.X;  				cp2.normalImpulse = x.Y;  				#if B2_DEBUG_SOLVER  									// Postconditions 					dv1 = vB + MathUtils.Cross(wB' cp1.rB) - vA - MathUtils.Cross(wA' cp1.rA);  					// Compute normal velocity 					vn1 = Vector2.Dot(dv1' normal);  					b2Assert(b2Abs(vn1 - cp1.velocityBias) < k_errorTol); #endif  				break;  			}  			//  			// Case 3: vn2 = 0 and x1 = 0  			//  			// vn1 = a11 * 0 + a12 * x2 + b1'   			//   0 = a21 * 0 + a22 * x2 + b2'  			//  			x.X = 0.0f;  			x.Y = -cp2.normalMass * b.Y;  			vn1 = vc.K.ey.X * x.Y + b.X;  			vn2 = 0.0f;  			if (x.Y >= 0.0f && vn1 >= 0.0f) {  				// Resubstitute for the incremental impulse  				Vector2 d = x - a;  				// Apply incremental impulse  				Vector2 P1 = d.X * normal;  				Vector2 P2 = d.Y * normal;  				vA -= mA * (P1 + P2);  				wA -= iA * (MathUtils.Cross (cp1.rA' P1) + MathUtils.Cross (cp2.rA' P2));  				vB += mB * (P1 + P2);  				wB += iB * (MathUtils.Cross (cp1.rB' P1) + MathUtils.Cross (cp2.rB' P2));  				// Accumulate  				cp1.normalImpulse = x.X;  				cp2.normalImpulse = x.Y;  				#if B2_DEBUG_SOLVER  									// Postconditions 					dv2 = vB + MathUtils.Cross(wB' cp2.rB) - vA - MathUtils.Cross(wA' cp2.rA);  					// Compute normal velocity 					vn2 = Vector2.Dot(dv2' normal);  					b2Assert(b2Abs(vn2 - cp2.velocityBias) < k_errorTol); #endif  				break;  			}  			//  			// Case 4: x1 = 0 and x2 = 0  			//   			// vn1 = b1  			// vn2 = b2;  			x.X = 0.0f;  			x.Y = 0.0f;  			vn1 = b.X;  			vn2 = b.Y;  			if (vn1 >= 0.0f && vn2 >= 0.0f) {  				// Resubstitute for the incremental impulse  				Vector2 d = x - a;  				// Apply incremental impulse  				Vector2 P1 = d.X * normal;  				Vector2 P2 = d.Y * normal;  				vA -= mA * (P1 + P2);  				wA -= iA * (MathUtils.Cross (cp1.rA' P1) + MathUtils.Cross (cp2.rA' P2));  				vB += mB * (P1 + P2);  				wB += iB * (MathUtils.Cross (cp1.rB' P1) + MathUtils.Cross (cp2.rB' P2));  				// Accumulate  				cp1.normalImpulse = x.X;  				cp2.normalImpulse = x.Y;  				break;  			}  			// No solution' give up. This is hit sometimes' but it doesn't seem to matter.  			break;  		}  	}  	_velocities [indexA].v = vA;  	_velocities [indexA].w = wA;  	_velocities [indexB].v = vB;  	_velocities [indexB].w = wB;  }  
Magic Number,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The following statement contains a magic number: Debug.Assert (pointCount == 1 || pointCount == 2);  
Magic Number,FarseerPhysics.Dynamics.Joints,FixedMouseJoint,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Joints\FixedMouseJoint.cs,FixedMouseJoint,The following statement contains a magic number: MaxForce = 1000 * body.Mass;  
Magic Number,FarseerPhysics.Factories,BodyFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\BodyFactory.cs,CreateCapsule,The following statement contains a magic number: topCircle.Position = new Vector2 (0' height / 2);  
Magic Number,FarseerPhysics.Factories,BodyFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\BodyFactory.cs,CreateCapsule,The following statement contains a magic number: bottomCircle.Position = new Vector2 (0' -(height / 2));  
Magic Number,FarseerPhysics.Factories,FixtureFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\FixtureFactory.cs,AttachCompoundPolygon,The following statement contains a magic number: foreach (Vertices vertices in list) {  	if (vertices.Count == 2) {  		EdgeShape shape = new EdgeShape (vertices [0]' vertices [1]);  		res.Add (body.CreateFixture (shape' userData));  	}  	else {  		PolygonShape shape = new PolygonShape (vertices' density);  		res.Add (body.CreateFixture (shape' userData));  	}  }  
Magic Number,FarseerPhysics.Factories,FixtureFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\FixtureFactory.cs,AttachCompoundPolygon,The following statement contains a magic number: if (vertices.Count == 2) {  	EdgeShape shape = new EdgeShape (vertices [0]' vertices [1]);  	res.Add (body.CreateFixture (shape' userData));  }  else {  	PolygonShape shape = new PolygonShape (vertices' density);  	res.Add (body.CreateFixture (shape' userData));  }  
Magic Number,FarseerPhysics.Factories,FixtureFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\FixtureFactory.cs,AttachLineArc,The following statement contains a magic number: arc.Rotate ((MathHelper.Pi - radians) / 2 + angle);  
Magic Number,FarseerPhysics.Factories,FixtureFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\FixtureFactory.cs,AttachSolidArc,The following statement contains a magic number: arc.Rotate ((MathHelper.Pi - radians) / 2 + angle);  
Magic Number,FarseerPhysics.Factories,LinkFactory,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Factories\LinkFactory.cs,CreateChain,The following statement contains a magic number: Debug.Assert (numberOfLinks >= 2);  
Missing Default,FarseerPhysics.Collision.Shapes,PolygonShape,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Collision\Shapes\PolygonShape.cs,ComputeSubmergedArea,The following switch statement is missing a default case: switch (diveCount) {  case 0:  	if (lastSubmerged) {  		//Completely submerged  		sc = MathUtils.Mul (ref xf' MassData.Centroid);  		return MassData.Mass / Density;  	}  	//Completely dry  	return 0;  case 1:  	if (intoIndex == -1) {  		intoIndex = Vertices.Count - 1;  	}  	else {  		outoIndex = Vertices.Count - 1;  	}  	break;  }  
Missing Default,Microsoft.Xna.Framework,Curve,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Curve.cs,Evaluate,The following switch statement is missing a default case: switch (PreLoop) {  case CurveLoopType.Constant:  	//constant  	return first.Value;  case CurveLoopType.Linear:  	// linear y = a*x +b with a tangeant of last point  	return first.Value - first.TangentIn * (first.Position - position);  case CurveLoopType.Cycle:  	//start -> end / start -> end  	int cycle = GetNumberOfCycle (position);  	float virtualPos = position - (cycle * (last.Position - first.Position));  	return GetCurvePosition (virtualPos);  case CurveLoopType.CycleOffset:  	//make the curve continue (with no step) so must up the curve each cycle of delta(value)  	cycle = GetNumberOfCycle (position);  	virtualPos = position - (cycle * (last.Position - first.Position));  	return (GetCurvePosition (virtualPos) + cycle * (last.Value - first.Value));  case CurveLoopType.Oscillate:  	//go back on curve from end and target start   	// start-> end / end -> start  	cycle = GetNumberOfCycle (position);  	if (0 == cycle % 2f)  		//if pair  		virtualPos = position - (cycle * (last.Position - first.Position));  	else  		virtualPos = last.Position - position + first.Position + (cycle * (last.Position - first.Position));  	return GetCurvePosition (virtualPos);  }  
Missing Default,Microsoft.Xna.Framework,Curve,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Curve.cs,Evaluate,The following switch statement is missing a default case: switch (PostLoop) {  case CurveLoopType.Constant:  	//constant  	return last.Value;  case CurveLoopType.Linear:  	// linear y = a*x +b with a tangeant of last point  	return last.Value + first.TangentOut * (position - last.Position);  case CurveLoopType.Cycle:  	//start -> end / start -> end  	cycle = GetNumberOfCycle (position);  	float virtualPos = position - (cycle * (last.Position - first.Position));  	return GetCurvePosition (virtualPos);  case CurveLoopType.CycleOffset:  	//make the curve continue (with no step) so must up the curve each cycle of delta(value)  	cycle = GetNumberOfCycle (position);  	virtualPos = position - (cycle * (last.Position - first.Position));  	return (GetCurvePosition (virtualPos) + cycle * (last.Value - first.Value));  case CurveLoopType.Oscillate:  	//go back on curve from end and target start   	// start-> end / end -> start  	cycle = GetNumberOfCycle (position);  	virtualPos = position - (cycle * (last.Position - first.Position));  	if (0 == cycle % 2f)  		//if pair  		virtualPos = position - (cycle * (last.Position - first.Position));  	else  		virtualPos = last.Position - position + first.Position + (cycle * (last.Position - first.Position));  	return GetCurvePosition (virtualPos);  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "vertices":  	{  		List<Vector2> verts = new List<Vector2> (sn.Elements.Count);  		foreach (XMLFragmentElement vert in sn.Elements)  			verts.Add (ReadVector (vert));  		shape.Vertices = new Vertices (verts);  	}  	break;  case "centroid":  	shape.MassData.Centroid = ReadVector (sn);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "filterdata":  	foreach (XMLFragmentElement ssn in sn.Elements) {  		switch (ssn.Name.ToLower ()) {  		case "categorybits":  			fixture._collisionCategories = (Category)int.Parse (ssn.Value);  			break;  		case "maskbits":  			fixture._collidesWith = (Category)int.Parse (ssn.Value);  			break;  		case "groupindex":  			fixture._collisionGroup = short.Parse (ssn.Value);  			break;  		case "CollisionIgnores":  			string[] split = ssn.Value.Split ('|');  			foreach (string s in split) {  				fixture._collisionIgnores.Add (int.Parse (s));  			}  			break;  		}  	}  	break;  case "friction":  	fixture.Friction = float.Parse (sn.Value);  	break;  case "issensor":  	fixture.IsSensor = bool.Parse (sn.Value);  	break;  case "restitution":  	fixture.Restitution = float.Parse (sn.Value);  	break;  case "userdata":  	fixture.UserData = ReadSimpleType (sn' null' false);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (ssn.Name.ToLower ()) {  case "categorybits":  	fixture._collisionCategories = (Category)int.Parse (ssn.Value);  	break;  case "maskbits":  	fixture._collidesWith = (Category)int.Parse (ssn.Value);  	break;  case "groupindex":  	fixture._collisionGroup = short.Parse (ssn.Value);  	break;  case "CollisionIgnores":  	string[] split = ssn.Value.Split ('|');  	foreach (string s in split) {  		fixture._collisionIgnores.Add (int.Parse (s));  	}  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "active":  	body._enabled = bool.Parse (sn.Value);  	break;  case "allowsleep":  	body.SleepingAllowed = bool.Parse (sn.Value);  	break;  case "angle":  	{  		Vector2 position = body.Position;  		body.SetTransformIgnoreContacts (ref position' float.Parse (sn.Value));  	}  	break;  case "angulardamping":  	body.AngularDamping = float.Parse (sn.Value);  	break;  case "angularvelocity":  	body.AngularVelocity = float.Parse (sn.Value);  	break;  case "awake":  	body.Awake = bool.Parse (sn.Value);  	break;  case "bullet":  	body.IsBullet = bool.Parse (sn.Value);  	break;  case "fixedrotation":  	body.FixedRotation = bool.Parse (sn.Value);  	break;  case "lineardamping":  	body.LinearDamping = float.Parse (sn.Value);  	break;  case "linearvelocity":  	body.LinearVelocity = ReadVector (sn);  	break;  case "position":  	{  		float rotation = body.Rotation;  		Vector2 position = ReadVector (sn);  		body.SetTransformIgnoreContacts (ref position' rotation);  	}  	break;  case "userdata":  	body.UserData = ReadSimpleType (sn' null' false);  	break;  case "bindings": {  	foreach (XMLFragmentElement pair in sn.Elements) {  		Fixture fix = fixtures [int.Parse (pair.Attributes [0].Value)];  		fix.Shape = shapes [int.Parse (pair.Attributes [1].Value)].Clone ();  		fix.CloneOnto (body);  	}  	break;  }  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "bodya":  	bodyAIndex = int.Parse (sn.Value);  	break;  case "bodyb":  	bodyBIndex = int.Parse (sn.Value);  	break;  case "collideconnected":  	collideConnected = bool.Parse (sn.Value);  	break;  case "userdata":  	userData = ReadSimpleType (sn' null' false);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (type) {  case JointType.Distance:  	{  		switch (sn.Name.ToLower ()) {  		case "dampingratio":  			((DistanceJoint)joint).DampingRatio = float.Parse (sn.Value);  			break;  		case "frequencyhz":  			((DistanceJoint)joint).Frequency = float.Parse (sn.Value);  			break;  		case "length":  			((DistanceJoint)joint).Length = float.Parse (sn.Value);  			break;  		case "localanchora":  			((DistanceJoint)joint).LocalAnchorA = ReadVector (sn);  			break;  		case "localanchorb":  			((DistanceJoint)joint).LocalAnchorB = ReadVector (sn);  			break;  		}  	}  	break;  case JointType.Friction:  	{  		switch (sn.Name.ToLower ()) {  		case "localanchora":  			((FrictionJoint)joint).LocalAnchorA = ReadVector (sn);  			break;  		case "localanchorb":  			((FrictionJoint)joint).LocalAnchorB = ReadVector (sn);  			break;  		case "maxforce":  			((FrictionJoint)joint).MaxForce = float.Parse (sn.Value);  			break;  		case "maxtorque":  			((FrictionJoint)joint).MaxTorque = float.Parse (sn.Value);  			break;  		}  	}  	break;  case JointType.Wheel:  	{  		switch (sn.Name.ToLower ()) {  		case "enablemotor":  			((WheelJoint)joint).MotorEnabled = bool.Parse (sn.Value);  			break;  		case "localanchora":  			((WheelJoint)joint).LocalAnchorA = ReadVector (sn);  			break;  		case "localanchorb":  			((WheelJoint)joint).LocalAnchorB = ReadVector (sn);  			break;  		case "motorspeed":  			((WheelJoint)joint).MotorSpeed = float.Parse (sn.Value);  			break;  		case "dampingratio":  			((WheelJoint)joint).DampingRatio = float.Parse (sn.Value);  			break;  		case "maxmotortorque":  			((WheelJoint)joint).MaxMotorTorque = float.Parse (sn.Value);  			break;  		case "frequencyhz":  			((WheelJoint)joint).Frequency = float.Parse (sn.Value);  			break;  		case "axis":  			((WheelJoint)joint).Axis = ReadVector (sn);  			break;  		}  	}  	break;  case JointType.Prismatic:  	{  		switch (sn.Name.ToLower ()) {  		case "enablelimit":  			((PrismaticJoint)joint).LimitEnabled = bool.Parse (sn.Value);  			break;  		case "enablemotor":  			((PrismaticJoint)joint).MotorEnabled = bool.Parse (sn.Value);  			break;  		case "localanchora":  			((PrismaticJoint)joint).LocalAnchorA = ReadVector (sn);  			break;  		case "localanchorb":  			((PrismaticJoint)joint).LocalAnchorB = ReadVector (sn);  			break;  		case "axis":  			((PrismaticJoint)joint).Axis = ReadVector (sn);  			break;  		case "maxmotorforce":  			((PrismaticJoint)joint).MaxMotorForce = float.Parse (sn.Value);  			break;  		case "motorspeed":  			((PrismaticJoint)joint).MotorSpeed = float.Parse (sn.Value);  			break;  		case "lowertranslation":  			((PrismaticJoint)joint).LowerLimit = float.Parse (sn.Value);  			break;  		case "uppertranslation":  			((PrismaticJoint)joint).UpperLimit = float.Parse (sn.Value);  			break;  		case "referenceangle":  			((PrismaticJoint)joint).ReferenceAngle = float.Parse (sn.Value);  			break;  		}  	}  	break;  case JointType.Pulley:  	{  		switch (sn.Name.ToLower ()) {  		case "worldanchora":  			((PulleyJoint)joint).WorldAnchorA = ReadVector (sn);  			break;  		case "worldanchorb":  			((PulleyJoint)joint).WorldAnchorB = ReadVector (sn);  			break;  		case "lengtha":  			((PulleyJoint)joint).LengthA = float.Parse (sn.Value);  			break;  		case "lengthb":  			((PulleyJoint)joint).LengthB = float.Parse (sn.Value);  			break;  		case "localanchora":  			((PulleyJoint)joint).LocalAnchorA = ReadVector (sn);  			break;  		case "localanchorb":  			((PulleyJoint)joint).LocalAnchorB = ReadVector (sn);  			break;  		case "ratio":  			((PulleyJoint)joint).Ratio = float.Parse (sn.Value);  			break;  		case "constant":  			((PulleyJoint)joint).Constant = float.Parse (sn.Value);  			break;  		}  	}  	break;  case JointType.Revolute:  	{  		switch (sn.Name.ToLower ()) {  		case "enablelimit":  			((RevoluteJoint)joint).LimitEnabled = bool.Parse (sn.Value);  			break;  		case "enablemotor":  			((RevoluteJoint)joint).MotorEnabled = bool.Parse (sn.Value);  			break;  		case "localanchora":  			((RevoluteJoint)joint).LocalAnchorA = ReadVector (sn);  			break;  		case "localanchorb":  			((RevoluteJoint)joint).LocalAnchorB = ReadVector (sn);  			break;  		case "maxmotortorque":  			((RevoluteJoint)joint).MaxMotorTorque = float.Parse (sn.Value);  			break;  		case "motorspeed":  			((RevoluteJoint)joint).MotorSpeed = float.Parse (sn.Value);  			break;  		case "lowerangle":  			((RevoluteJoint)joint).LowerLimit = float.Parse (sn.Value);  			break;  		case "upperangle":  			((RevoluteJoint)joint).UpperLimit = float.Parse (sn.Value);  			break;  		case "referenceangle":  			((RevoluteJoint)joint).ReferenceAngle = float.Parse (sn.Value);  			break;  		}  	}  	break;  case JointType.Weld:  	{  		switch (sn.Name.ToLower ()) {  		case "localanchora":  			((WeldJoint)joint).LocalAnchorA = ReadVector (sn);  			break;  		case "localanchorb":  			((WeldJoint)joint).LocalAnchorB = ReadVector (sn);  			break;  		}  	}  	break;  case JointType.Rope:  	{  		switch (sn.Name.ToLower ()) {  		case "localanchora":  			((RopeJoint)joint).LocalAnchorA = ReadVector (sn);  			break;  		case "localanchorb":  			((RopeJoint)joint).LocalAnchorB = ReadVector (sn);  			break;  		case "maxlength":  			((RopeJoint)joint).MaxLength = float.Parse (sn.Value);  			break;  		}  	}  	break;  case JointType.Gear:  	throw new Exception ("Gear joint is unsupported");  case JointType.Angle:  	{  		switch (sn.Name.ToLower ()) {  		case "biasfactor":  			((AngleJoint)joint).BiasFactor = float.Parse (sn.Value);  			break;  		case "maximpulse":  			((AngleJoint)joint).MaxImpulse = float.Parse (sn.Value);  			break;  		case "softness":  			((AngleJoint)joint).Softness = float.Parse (sn.Value);  			break;  		case "targetangle":  			((AngleJoint)joint).TargetAngle = float.Parse (sn.Value);  			break;  		}  	}  	break;  case JointType.Motor:  	switch (sn.Name.ToLower ()) {  	case "angularoffset":  		((MotorJoint)joint).AngularOffset = float.Parse (sn.Value);  		break;  	case "linearoffset":  		((MotorJoint)joint).LinearOffset = ReadVector (sn);  		break;  	case "maxforce":  		((MotorJoint)joint).MaxForce = float.Parse (sn.Value);  		break;  	case "maxtorque":  		((MotorJoint)joint).MaxTorque = float.Parse (sn.Value);  		break;  	case "correctionfactor":  		((MotorJoint)joint).CorrectionFactor = float.Parse (sn.Value);  		break;  	}  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "dampingratio":  	((DistanceJoint)joint).DampingRatio = float.Parse (sn.Value);  	break;  case "frequencyhz":  	((DistanceJoint)joint).Frequency = float.Parse (sn.Value);  	break;  case "length":  	((DistanceJoint)joint).Length = float.Parse (sn.Value);  	break;  case "localanchora":  	((DistanceJoint)joint).LocalAnchorA = ReadVector (sn);  	break;  case "localanchorb":  	((DistanceJoint)joint).LocalAnchorB = ReadVector (sn);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "localanchora":  	((FrictionJoint)joint).LocalAnchorA = ReadVector (sn);  	break;  case "localanchorb":  	((FrictionJoint)joint).LocalAnchorB = ReadVector (sn);  	break;  case "maxforce":  	((FrictionJoint)joint).MaxForce = float.Parse (sn.Value);  	break;  case "maxtorque":  	((FrictionJoint)joint).MaxTorque = float.Parse (sn.Value);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "enablemotor":  	((WheelJoint)joint).MotorEnabled = bool.Parse (sn.Value);  	break;  case "localanchora":  	((WheelJoint)joint).LocalAnchorA = ReadVector (sn);  	break;  case "localanchorb":  	((WheelJoint)joint).LocalAnchorB = ReadVector (sn);  	break;  case "motorspeed":  	((WheelJoint)joint).MotorSpeed = float.Parse (sn.Value);  	break;  case "dampingratio":  	((WheelJoint)joint).DampingRatio = float.Parse (sn.Value);  	break;  case "maxmotortorque":  	((WheelJoint)joint).MaxMotorTorque = float.Parse (sn.Value);  	break;  case "frequencyhz":  	((WheelJoint)joint).Frequency = float.Parse (sn.Value);  	break;  case "axis":  	((WheelJoint)joint).Axis = ReadVector (sn);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "enablelimit":  	((PrismaticJoint)joint).LimitEnabled = bool.Parse (sn.Value);  	break;  case "enablemotor":  	((PrismaticJoint)joint).MotorEnabled = bool.Parse (sn.Value);  	break;  case "localanchora":  	((PrismaticJoint)joint).LocalAnchorA = ReadVector (sn);  	break;  case "localanchorb":  	((PrismaticJoint)joint).LocalAnchorB = ReadVector (sn);  	break;  case "axis":  	((PrismaticJoint)joint).Axis = ReadVector (sn);  	break;  case "maxmotorforce":  	((PrismaticJoint)joint).MaxMotorForce = float.Parse (sn.Value);  	break;  case "motorspeed":  	((PrismaticJoint)joint).MotorSpeed = float.Parse (sn.Value);  	break;  case "lowertranslation":  	((PrismaticJoint)joint).LowerLimit = float.Parse (sn.Value);  	break;  case "uppertranslation":  	((PrismaticJoint)joint).UpperLimit = float.Parse (sn.Value);  	break;  case "referenceangle":  	((PrismaticJoint)joint).ReferenceAngle = float.Parse (sn.Value);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "worldanchora":  	((PulleyJoint)joint).WorldAnchorA = ReadVector (sn);  	break;  case "worldanchorb":  	((PulleyJoint)joint).WorldAnchorB = ReadVector (sn);  	break;  case "lengtha":  	((PulleyJoint)joint).LengthA = float.Parse (sn.Value);  	break;  case "lengthb":  	((PulleyJoint)joint).LengthB = float.Parse (sn.Value);  	break;  case "localanchora":  	((PulleyJoint)joint).LocalAnchorA = ReadVector (sn);  	break;  case "localanchorb":  	((PulleyJoint)joint).LocalAnchorB = ReadVector (sn);  	break;  case "ratio":  	((PulleyJoint)joint).Ratio = float.Parse (sn.Value);  	break;  case "constant":  	((PulleyJoint)joint).Constant = float.Parse (sn.Value);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "enablelimit":  	((RevoluteJoint)joint).LimitEnabled = bool.Parse (sn.Value);  	break;  case "enablemotor":  	((RevoluteJoint)joint).MotorEnabled = bool.Parse (sn.Value);  	break;  case "localanchora":  	((RevoluteJoint)joint).LocalAnchorA = ReadVector (sn);  	break;  case "localanchorb":  	((RevoluteJoint)joint).LocalAnchorB = ReadVector (sn);  	break;  case "maxmotortorque":  	((RevoluteJoint)joint).MaxMotorTorque = float.Parse (sn.Value);  	break;  case "motorspeed":  	((RevoluteJoint)joint).MotorSpeed = float.Parse (sn.Value);  	break;  case "lowerangle":  	((RevoluteJoint)joint).LowerLimit = float.Parse (sn.Value);  	break;  case "upperangle":  	((RevoluteJoint)joint).UpperLimit = float.Parse (sn.Value);  	break;  case "referenceangle":  	((RevoluteJoint)joint).ReferenceAngle = float.Parse (sn.Value);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "localanchora":  	((WeldJoint)joint).LocalAnchorA = ReadVector (sn);  	break;  case "localanchorb":  	((WeldJoint)joint).LocalAnchorB = ReadVector (sn);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "localanchora":  	((RopeJoint)joint).LocalAnchorA = ReadVector (sn);  	break;  case "localanchorb":  	((RopeJoint)joint).LocalAnchorB = ReadVector (sn);  	break;  case "maxlength":  	((RopeJoint)joint).MaxLength = float.Parse (sn.Value);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "biasfactor":  	((AngleJoint)joint).BiasFactor = float.Parse (sn.Value);  	break;  case "maximpulse":  	((AngleJoint)joint).MaxImpulse = float.Parse (sn.Value);  	break;  case "softness":  	((AngleJoint)joint).Softness = float.Parse (sn.Value);  	break;  case "targetangle":  	((AngleJoint)joint).TargetAngle = float.Parse (sn.Value);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "angularoffset":  	((MotorJoint)joint).AngularOffset = float.Parse (sn.Value);  	break;  case "linearoffset":  	((MotorJoint)joint).LinearOffset = ReadVector (sn);  	break;  case "maxforce":  	((MotorJoint)joint).MaxForce = float.Parse (sn.Value);  	break;  case "maxtorque":  	((MotorJoint)joint).MaxTorque = float.Parse (sn.Value);  	break;  case "correctionfactor":  	((MotorJoint)joint).CorrectionFactor = float.Parse (sn.Value);  	break;  }  
Missing Default,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,DetectVertices,The following switch statement is missing a default case: switch (_polygonDetectionType) {  case VerticesDetectionType.Integrated:  	// Add first hole polygon vertex to close the hole polygon.  	holePolygon.Add (holePolygon [0]);  	int vertex1Index' vertex2Index;  	if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  		polygon.InsertRange (vertex2Index' holePolygon);  	break;  case VerticesDetectionType.Separated:  	if (polygon.Holes == null)  		polygon.Holes = new List<Vertices> ();  	polygon.Holes.Add (holePolygon);  	break;  }  
Missing Default,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following switch statement is missing a default case: switch ((int)(current.X - last.X)) {  case 1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 1;  	case 0:  		return 0;  	case -1:  		return 7;  	}  	break;  case 0:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 2;  	case -1:  		return 6;  	}  	break;  case -1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 3;  	case 0:  		return 4;  	case -1:  		return 5;  	}  	break;  }  
Missing Default,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following switch statement is missing a default case: switch ((int)(current.Y - last.Y)) {  case 1:  	return 1;  case 0:  	return 0;  case -1:  	return 7;  }  
Missing Default,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following switch statement is missing a default case: switch ((int)(current.Y - last.Y)) {  case 1:  	return 2;  case -1:  	return 6;  }  
Missing Default,FarseerPhysics.Common.TextureTools,TextureConverter,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following switch statement is missing a default case: switch ((int)(current.Y - last.Y)) {  case 1:  	return 3;  case 0:  	return 4;  case -1:  	return 5;  }  
Missing Default,FarseerPhysics.Controllers,AbstractForceController,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Controllers\AbstractForceController.cs,AbstractForceController,The following switch statement is missing a default case: switch (mode) {  case TimingModes.Switched:  	Enabled = true;  	break;  case TimingModes.Triggered:  	Enabled = false;  	break;  case TimingModes.Curve:  	Enabled = false;  	break;  }  
Missing Default,FarseerPhysics.Controllers,AbstractForceController,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Controllers\AbstractForceController.cs,Update,The following switch statement is missing a default case: switch (TimingMode) {  case TimingModes.Switched: {  	if (Enabled) {  		ApplyForce (dt' Strength);  	}  	break;  }  case TimingModes.Triggered: {  	if (Enabled && Triggered) {  		if (ImpulseTime < ImpulseLength) {  			ApplyForce (dt' Strength);  			ImpulseTime += dt;  		}  		else {  			Triggered = false;  		}  	}  	break;  }  case TimingModes.Curve: {  	if (Enabled && Triggered) {  		if (ImpulseTime < ImpulseLength) {  			ApplyForce (dt' Strength * StrengthCurve.Evaluate (ImpulseTime));  			ImpulseTime += dt;  		}  		else {  			Triggered = false;  		}  	}  	break;  }  }  
Missing Default,FarseerPhysics.Controllers,GravityController,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Controllers\GravityController.cs,Update,The following switch statement is missing a default case: switch (GravityType) {  case GravityType.DistanceSquared:  	f = Strength / r2 * worldBody.Mass * controllerBody.Mass * d;  	break;  case GravityType.Linear:  	f = Strength / (float)Math.Sqrt (r2) * worldBody.Mass * controllerBody.Mass * d;  	break;  }  
Missing Default,FarseerPhysics.Controllers,GravityController,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Controllers\GravityController.cs,Update,The following switch statement is missing a default case: switch (GravityType) {  case GravityType.DistanceSquared:  	f = Strength / r2 * worldBody.Mass * d;  	break;  case GravityType.Linear:  	f = Strength / (float)Math.Sqrt (r2) * worldBody.Mass * d;  	break;  }  
Missing Default,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\SitanaTeam_Farseer-Physics-Engine\Farseer Physics Engine 3.5\Dynamics\Contacts\Contact.cs,Evaluate,The following switch statement is missing a default case: switch (_type) {  case ContactType.Polygon:  	Collision.Collision.CollidePolygons (ref manifold' (PolygonShape)FixtureA.Shape' ref transformA' (PolygonShape)FixtureB.Shape' ref transformB);  	break;  case ContactType.PolygonAndCircle:  	Collision.Collision.CollidePolygonAndCircle (ref manifold' (PolygonShape)FixtureA.Shape' ref transformA' (CircleShape)FixtureB.Shape' ref transformB);  	break;  case ContactType.EdgeAndCircle:  	Collision.Collision.CollideEdgeAndCircle (ref manifold' (EdgeShape)FixtureA.Shape' ref transformA' (CircleShape)FixtureB.Shape' ref transformB);  	break;  case ContactType.EdgeAndPolygon:  	Collision.Collision.CollideEdgeAndPolygon (ref manifold' (EdgeShape)FixtureA.Shape' ref transformA' (PolygonShape)FixtureB.Shape' ref transformB);  	break;  case ContactType.ChainAndCircle:  	ChainShape chain = (ChainShape)FixtureA.Shape;  	chain.GetChildEdge (_edge' ChildIndexA);  	Collision.Collision.CollideEdgeAndCircle (ref manifold' _edge' ref transformA' (CircleShape)FixtureB.Shape' ref transformB);  	break;  case ContactType.ChainAndPolygon:  	ChainShape loop2 = (ChainShape)FixtureA.Shape;  	loop2.GetChildEdge (_edge' ChildIndexA);  	Collision.Collision.CollideEdgeAndPolygon (ref manifold' _edge' ref transformA' (PolygonShape)FixtureB.Shape' ref transformB);  	break;  case ContactType.Circle:  	Collision.Collision.CollideCircles (ref manifold' (CircleShape)FixtureA.Shape' ref transformA' (CircleShape)FixtureB.Shape' ref transformB);  	break;  }  
