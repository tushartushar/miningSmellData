Implementation smell,Namespace,Class,File,Method,Description
Complex Method,DistributedLockingPerMethod,MethodMutexWithFrequency,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\MethodMutexWithFrequency.cs,OnInvoke,Cyclomatic complexity of the method is 12
Complex Method,DistributedLockingPerMethod,Program,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\Program.cs,Main,Cyclomatic complexity of the method is 8
Long Statement,DistributedLockingPerMethod,MethodMutex,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\MethodMutex.cs,CompileTimeInitialize,The length of the statement  "		throw new ArgumentException ("MethodMutex only works on methods that return a bool. Method " + method.Name + " return type " + info.ReturnType); " is 144.
Long Statement,DistributedLockingPerMethod,MethodMutexWithFrequency,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\MethodMutexWithFrequency.cs,OnInvoke,The length of the statement  "		if (trackerFromLocalCache != null && trackerFromLocalCache.LastExecuted.HasValue && trackerFromLocalCache.LastExecuted.Value.Add (_maxMethodFrequencyTime) > DateTime.UtcNow) { " is 175.
Long Statement,DistributedLockingPerMethod,MethodMutexWithFrequency,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\MethodMutexWithFrequency.cs,OnInvoke,The length of the statement  "				MemoryCache.Default.Set (key' trackerFromDistributedCache' trackerFromDistributedCache.LastExecuted.Value.Add (_maxMethodFrequencyTime)); " is 137.
Magic Number,DistributedLockingPerMethod,MethodMutex,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\MethodMutex.cs,OnInvoke,The following statement contains a magic number: try {  	using (var client = new RedisClient (_redisConnStr)) {  		lockResult = TryGetLock<MethodTrackerDto> (client' key' _maxMethodLockTime' TimeSpan.FromSeconds (2));  		if (!lockResult.Acquired) {  			ReturnWithoutRunning (args);  		}  		else {  			RunMethod (args);  		}  		//clear the lock  		if (lockResult.Handle != null) {  			lockResult.Handle.Handle.Dispose ();  		}  	}  }  catch (Exception ex) {  	Debug.WriteLine (ex.ToString ());  	ReturnWithoutRunning (args);  }  
Magic Number,DistributedLockingPerMethod,MethodMutex,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\MethodMutex.cs,OnInvoke,The following statement contains a magic number: using (var client = new RedisClient (_redisConnStr)) {  	lockResult = TryGetLock<MethodTrackerDto> (client' key' _maxMethodLockTime' TimeSpan.FromSeconds (2));  	if (!lockResult.Acquired) {  		ReturnWithoutRunning (args);  	}  	else {  		RunMethod (args);  	}  	//clear the lock  	if (lockResult.Handle != null) {  		lockResult.Handle.Handle.Dispose ();  	}  }  
Magic Number,DistributedLockingPerMethod,MethodMutex,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\MethodMutex.cs,OnInvoke,The following statement contains a magic number: lockResult = TryGetLock<MethodTrackerDto> (client' key' _maxMethodLockTime' TimeSpan.FromSeconds (2));  
Magic Number,DistributedLockingPerMethod,MethodMutexWithFrequency,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\MethodMutexWithFrequency.cs,OnInvoke,The following statement contains a magic number: try {  	MethodTrackerDto trackerFromLocalCache = MemoryCache.Default.Get (key) as MethodTrackerDto;  	//local cache says we can't run this again for a while still due to frequency limits  	if (trackerFromLocalCache != null && trackerFromLocalCache.LastExecuted.HasValue && trackerFromLocalCache.LastExecuted.Value.Add (_maxMethodFrequencyTime) > DateTime.UtcNow) {  		ReturnWithoutRunning (args);  		return;  	}  	using (var client = new RedisClient (_redisConnStr)) {  		lockResult = TryGetLock<MethodTrackerDto> (client' key' _maxMethodLockTime' TimeSpan.FromSeconds (2));  		if (!lockResult.Acquired || _maxMethodFrequencyTime == TimeSpan.Zero) {  			ReturnWithoutRunning (args);  		}  		else {  			trackerFromDistributedCache = lockResult.Result;  			if (trackerFromDistributedCache == null || trackerFromDistributedCache.LastExecuted == null) {  				trackerFromDistributedCache = new MethodTrackerDto () {  					LastExecuted = DateTime.UtcNow  				};  				RunMethod (args);  			}  			//is the last time plus the interval in the future? If so we can't run it and we can cache that knowledge locally  			else if (trackerFromDistributedCache.LastExecuted.Value.Add (_maxMethodLockTime) > DateTime.UtcNow) {  				//cache local since there is a max run. We should have found this locally  				ReturnWithoutRunning (args);  			}  			else {  				trackerFromDistributedCache = new MethodTrackerDto () {  					LastExecuted = DateTime.UtcNow  				};  				RunMethod (args);  			}  			//update local cache in case the method is called again we don't have to hit redis to know we can't run it again yet  			MemoryCache.Default.Set (key' trackerFromDistributedCache' trackerFromDistributedCache.LastExecuted.Value.Add (_maxMethodFrequencyTime));  		}  		if (trackerFromDistributedCache == null) {  			trackerFromDistributedCache = new MethodTrackerDto ();  		}  		trackerFromDistributedCache.LastExecuted = DateTime.UtcNow;  		//set back to the cache so we track the last time it ran  		using (var tx = client.CreateTransaction ()) {  			tx.QueueCommand (c => c.Set (key' trackerFromDistributedCache' DateTime.UtcNow.Add (_maxMethodFrequencyTime)));  		}  		//clear the lock  		if (lockResult.Handle != null) {  			//put to the cache the last run time  			lockResult.Handle.Handle.Dispose ();  		}  	}  }  catch (Exception ex) {  	Debug.WriteLine (ex.ToString ());  	ReturnWithoutRunning (args);  }  
Magic Number,DistributedLockingPerMethod,MethodMutexWithFrequency,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\MethodMutexWithFrequency.cs,OnInvoke,The following statement contains a magic number: using (var client = new RedisClient (_redisConnStr)) {  	lockResult = TryGetLock<MethodTrackerDto> (client' key' _maxMethodLockTime' TimeSpan.FromSeconds (2));  	if (!lockResult.Acquired || _maxMethodFrequencyTime == TimeSpan.Zero) {  		ReturnWithoutRunning (args);  	}  	else {  		trackerFromDistributedCache = lockResult.Result;  		if (trackerFromDistributedCache == null || trackerFromDistributedCache.LastExecuted == null) {  			trackerFromDistributedCache = new MethodTrackerDto () {  				LastExecuted = DateTime.UtcNow  			};  			RunMethod (args);  		}  		//is the last time plus the interval in the future? If so we can't run it and we can cache that knowledge locally  		else if (trackerFromDistributedCache.LastExecuted.Value.Add (_maxMethodLockTime) > DateTime.UtcNow) {  			//cache local since there is a max run. We should have found this locally  			ReturnWithoutRunning (args);  		}  		else {  			trackerFromDistributedCache = new MethodTrackerDto () {  				LastExecuted = DateTime.UtcNow  			};  			RunMethod (args);  		}  		//update local cache in case the method is called again we don't have to hit redis to know we can't run it again yet  		MemoryCache.Default.Set (key' trackerFromDistributedCache' trackerFromDistributedCache.LastExecuted.Value.Add (_maxMethodFrequencyTime));  	}  	if (trackerFromDistributedCache == null) {  		trackerFromDistributedCache = new MethodTrackerDto ();  	}  	trackerFromDistributedCache.LastExecuted = DateTime.UtcNow;  	//set back to the cache so we track the last time it ran  	using (var tx = client.CreateTransaction ()) {  		tx.QueueCommand (c => c.Set (key' trackerFromDistributedCache' DateTime.UtcNow.Add (_maxMethodFrequencyTime)));  	}  	//clear the lock  	if (lockResult.Handle != null) {  		//put to the cache the last run time  		lockResult.Handle.Handle.Dispose ();  	}  }  
Magic Number,DistributedLockingPerMethod,MethodMutexWithFrequency,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\MethodMutexWithFrequency.cs,OnInvoke,The following statement contains a magic number: lockResult = TryGetLock<MethodTrackerDto> (client' key' _maxMethodLockTime' TimeSpan.FromSeconds (2));  
Magic Number,DistributedLockingPerMethod,Program,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\Program.cs,Main,The following statement contains a magic number: while (true) {  	Console.WriteLine (worker2.DoWork ());  	System.Threading.Thread.Sleep (1000);  }  
Magic Number,DistributedLockingPerMethod,Program,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\Program.cs,Main,The following statement contains a magic number: System.Threading.Thread.Sleep (1000);  
Magic Number,DistributedLockingPerMethod,Program,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\Program.cs,Main,The following statement contains a magic number: Thread.Sleep (200);  
Magic Number,DistributedLockingPerMethod,Program,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\Program.cs,Main,The following statement contains a magic number: while (allInstances.Length == 1) {  	Console.Clear ();  	Console.WriteLine ("Redis Distributed Locking Example\r\n");  	Console.WriteLine ("Launch a 2nd instance of this app to start...");  	Thread.Sleep (400);  	allInstances = Process.GetProcessesByName (thisInstance.ProcessName);  }  
Magic Number,DistributedLockingPerMethod,Program,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\Program.cs,Main,The following statement contains a magic number: Thread.Sleep (400);  
Magic Number,DistributedLockingPerMethod,Program,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\Program.cs,Main,The following statement contains a magic number: if (!gotWorkDone) {  	Console.WriteLine ("{0:T} - Method was locked' waiting..."' DateTime.Now);  	// whether to retry or continue depends on your specific scenario  	// for demo' we'll retry. In cases where workers might receive  	// duplicate payloads near-instantaneously and only one should  	// succeed' you might just choose to continue.  	Stopwatch time = Stopwatch.StartNew ();  	do {  		Thread.Sleep (500);  		gotWorkDone = worker.DoWork ();  		Console.WriteLine ("gotWorkDone: " + gotWorkDone);  	}  	while (!gotWorkDone && time.Elapsed < TimeSpan.FromMinutes (1));  	time.Stop ();  	if (!gotWorkDone) {  		Console.WriteLine ("Timed out after 1 minute...");  	}  }  
Magic Number,DistributedLockingPerMethod,Program,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\Program.cs,Main,The following statement contains a magic number: do {  	Thread.Sleep (500);  	gotWorkDone = worker.DoWork ();  	Console.WriteLine ("gotWorkDone: " + gotWorkDone);  }  while (!gotWorkDone && time.Elapsed < TimeSpan.FromMinutes (1));  
Magic Number,DistributedLockingPerMethod,Program,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\Program.cs,Main,The following statement contains a magic number: Thread.Sleep (500);  
Magic Number,DistributedLockingPerMethod,WorkerInstance,C:\repos\stackify_redis-tagging-locking-sample\src\DistributedLockingPerMethod\WorkerInstance.cs,DoWork,The following statement contains a magic number: Thread.Sleep (workDurationSeconds * 1000);  
